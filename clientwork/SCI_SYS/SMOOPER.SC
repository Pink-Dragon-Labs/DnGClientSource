;;;;
;;;;	SMOOPER.SC
;;;;
;;;;	(c) Sierra On-Line, Inc, 1989
;;;;
;;;;	Author: 	J. Mark Hood
;;;;	Updated:
;;;;
;;;;	The SmoothLooper class loops its client smoothly through transition
;;;;	cels on a direction change.
;;;;
;;;;	Usage: set property vChangeDir to a view containing transition loops
;;;;	in the order listed in the enum below, and set the client's looper
;;;;	property.
;;;;
;;;;	Classes:
;;;;		SmoothLooper


(module# SMOOPER)


(public
	SmoothLooper	0
)

(enum
	lEastToSouth	
	lWestToSouth	
	lSouthToEast
	lSouthToWest
	lNorthToEast	
	lNorthToWest	
	lEastToNorth
	lWestToNorth
)

(define TwoStep	+ 16)

(define HEADINGNORTH 	(or (<= theHeading 45	) (> theHeading 315)))
(define HEADINGEAST 	(<= theHeading 135	))
(define HEADINGSOUTH 	(<= theHeading 225	))
(define HEADINGWEST 	(<= theHeading 315	))

(class SmoothLooper of Code
	(properties
		int nextLoop	 	0
		id  client			0
		int oldCycler		0
		id  oldMover		0
		id  newMover		0
		int oldCycleSpeed	0
		int cycleSpeed		0
		int inProgress		0
		int vNormal			0
		int vChangeDir		0
	)

	(methods
		cue
	)

	(method (doit cl theHeading &tmp theLoop changedTheLoop)
		(if (& (cl signal) fixedLoop) (return))
		(= changedTheLoop FALSE)
		(if inProgress
			(if newMover 	(newMover dispose:))
			(= newMover 	(cl mover?))
			(cl mover:0)
			(return)
		else
			(if (not vNormal)
				(= vNormal (cl view?))
			)
			(= client 	cl)
			(= inProgress	TRUE)
		)
		(if (and 
				(>  (client loop?)	3) 
				(== (client view?) vNormal)
			) ;abnormal loops
			;;ie hero's quest cat
			(if inProgress
				(if oldMover (oldMover dispose:))
			else
				(client 
					view:vNormal,
				)
				(DirLoop client theHeading)
			)
		)
		(= theLoop (client loop?))
		(switch theLoop  ; clients Loop
			(facingNorth
				(cond
					(HEADINGNORTH		  ; new Headings
					)
					(HEADINGEAST
						(= theLoop 	lNorthToEast) 
						(= nextLoop facingEast)
						(=	changedTheLoop TRUE)
					)
					(HEADINGSOUTH
						(= theLoop  lNorthToEast)
						(= nextLoop (TwoStep lEastToSouth))
						(=	changedTheLoop TRUE)
					)
					(HEADINGWEST
						(= theLoop  lNorthToWest)
						(= nextLoop facingWest)
						(=	changedTheLoop TRUE)
					)
				)
			)
			(facingEast
				(cond
					(HEADINGNORTH
						(= theLoop	lEastToNorth)
						(= nextLoop facingNorth )
						(=	changedTheLoop TRUE)
					)
					(HEADINGEAST
					)
					(HEADINGSOUTH
						(= theLoop 	lEastToSouth)
						(= nextLoop facingSouth)
						(=	changedTheLoop TRUE)
					)
					(HEADINGWEST							
						(= theLoop	lEastToNorth)
						(= nextLoop (TwoStep lNorthToWest))
						(=	changedTheLoop TRUE)
					)
				)
			)
			(facingWest
				(cond
					(HEADINGNORTH
						(= theLoop 	lWestToNorth) 
						(= nextLoop facingNorth)
						(=	changedTheLoop TRUE)
					)
					(HEADINGEAST
						(= theLoop 	lWestToSouth)
						(= nextLoop (TwoStep lSouthToEast))
						(=	changedTheLoop TRUE)
					)
					(HEADINGSOUTH
						(= theLoop 	lWestToSouth)
						(= nextLoop facingSouth)
						(=	changedTheLoop TRUE)
					)
					(HEADINGWEST
					)
				)
			)
			(facingSouth
				(cond
					(HEADINGNORTH
						(= theLoop 	lSouthToWest) 
						(= nextLoop (TwoStep lWestToNorth))
						(=	changedTheLoop TRUE)
					)
					(HEADINGEAST
						(= theLoop 	lSouthToEast)
						(= nextLoop facingEast)
						(=	changedTheLoop TRUE)
					)
					(HEADINGSOUTH
					)
					(HEADINGWEST
						(= theLoop	lSouthToWest)
						(= nextLoop facingWest)
						(=	changedTheLoop TRUE)
					)
				)
			)
		)
		(if changedTheLoop
			(= oldCycler 		(client cycler?))
			(= oldMover 		(client mover?))
			(= oldCycleSpeed 	(client cycleSpeed?))
			(client 
				view:			vChangeDir,
				cycleSpeed:	cycleSpeed,
				mover:		0,
				cycler:		0,
				loop:			theLoop,
				cel:			0,
				setCycle:	EndLoop self
			)
		else
			(= inProgress FALSE)
		)
	); doit

	(method (cue)
		(if (< nextLoop 15) ; single step transition
			(client 
				view:			vNormal,
				loop:			nextLoop,
				mover:		oldMover,			; setMotion would be recursive
				cycler:		oldCycler,
				cycleSpeed:	oldCycleSpeed
			)
			(= oldMover 	0)
			(= oldCycler 	0)
			(= inProgress FALSE)
			(if newMover
				(client setMotion:newMover)
				(= newMover 0)
			)
		else					  ; two step transition
			(-= nextLoop 16)
			(client
				loop:			nextLoop,
				cel:			0,
				setCycle:	EndLoop self,
			)
			(= nextLoop
				(switch nextLoop
					(lEastToSouth
						facingSouth
					)
					(lNorthToWest
						facingWest
					)
					(lSouthToEast
						facingEast
					)
					(lWestToNorth
						facingNorth
					)
				)
			)
		); if
	);cue

	(method (dispose)
		(if oldMover	(oldMover 	dispose:))
		(if newMover	(newMover 	dispose:))
		(if oldCycler	(oldCycler	dispose:))
		(= inProgress (= oldMover (= newMover (= oldCycler 0))))
		(client			view:vNormal, looper:0)
		(DirLoop client (client heading?))
		(super 			dispose:)
	); dispose

); SmoothLooper
