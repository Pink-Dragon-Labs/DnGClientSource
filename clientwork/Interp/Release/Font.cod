	TITLE	\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Font.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BM@LHED@Instructed?5to?5scale?5to?5zero?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07CCG@ResView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KCEF@?4v56?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06IAEF@ResPic?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04EODC@?4p56?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08OCKJ@ResChunk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PIPI@?4chk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07ICMB@ResHunk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GG@?4scr?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08BLBP@ResSound?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KPDA@?4snd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NNMB@ResVocab?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PGDD@?4voc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FLKK@ResPatch?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CEHK@?4pat?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07MKGC@ResFont?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04IDCK@?4fon?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06DEEM@ResPal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NJLC@?4pal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07HFNL@ResHeap?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GFFD@?4hep?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06HDCC@ResMsg?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JONM@?4msg?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NFDN@ResAudio?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MOHF@?4aud?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BKMJ@ResWave?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MPDF@?4wav?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@IMEI@ResAudio36?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BONB@ResSync?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KFFK@?4syn?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09CBJE@ResSync36?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06MIEL@ResMap?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CFLF@?4map?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@LIAH@ResMsgTranslation?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JFJA@?4trn?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08JLOL@ResRobot?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04LLKI@?4rbt?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06OEMP@ResVMD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04IOID@?4vmd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MemoryMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@MemoryMgr@@QAEIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckValid@MemoryMgr@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GMemoryMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@V1@III@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AMemID@@QBEAADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8MemID@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??7MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeArrayID@@QBEPAUArrayHeader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ArrayID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ArrayID@@QAE@HW4ArrayType@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@ArrayID@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Data@ArrayID@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAE?AVMemID@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAEXVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@NN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SOL_Point@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Rgb24@@QAE@EEE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Rgb24@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Rgb24F@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Ratio@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Ratio@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@HHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@VMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Type@Bitmap@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?View@Bitmap@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Loop@Bitmap@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Cel@Bitmap@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObj@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Width@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Height@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResX@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResY@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Skip@CelObj@@QBEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemapState@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Mirrored@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObj@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjView@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjView@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjView@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjView@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjMem@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjMem@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjMem@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjMem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjColor@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjColor@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjColor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjColor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@HHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@AAVSOL_Point@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Set@SOL_Rect@@QAEXHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEmpty@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeEmpty@SOL_Rect@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Xlen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ylen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8SOL_Rect@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clip@SOL_Rect@@QAEXABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Inset@SOL_Rect@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Scale@SOL_Rect@@QAEXHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Draw@ScreenItem@@QAEXABVBuffer@@ABVSOL_Rect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SOL_Rect@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TopPlane@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TopSCIPlane@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Xdim@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ydim@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FontMgr@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PointSize@FontMgr@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetRes@FontMgr@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetText@FontMgr@@QAEXVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetExtension@SOL_ResType@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSupported@SOL_ResType@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAttrs@SOL_ResType@@UBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResView@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPic@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResChunk@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResScript@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSound@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResVocab@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPatch@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResFont@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPal@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResHeap@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMsg@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResAudio@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResWave@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResAudio36@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSync@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSync36@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMap@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMsgTranslation@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileType@ResMsgTranslation@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResRobot@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResVMD@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_List@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@SOL_List@@QAEAAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildHeader@@YAXVMemID@@HHHHHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeDispatchTblID@@QBEPAUDispatchTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeScriptEntryID@@QBEPAUScriptEntry@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntry@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeVariableID@@QBEPAUVariable@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Script@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Object@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGraphicsUpdate@Object@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?selectorDict@Object@@QAEPAVSelectorDict@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AObject@@QAEAAFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddr@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedPropAddr@Object@@QAEPBFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedProperty@Object@@QAEFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddrCheck@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@Object@@QAEFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropOffset@Object@@QAEIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetIndexedProperty@Object@@QAEXHF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetProperty@Object@@QAEXGF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssureValid@ObjectID@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsObject@ObjectID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeClassTblID@@QBEPAUClassTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DTextID@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TextID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7ResPic@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResView@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResPal@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObj@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResHeap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResWave@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResRobot@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResPatch@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMsgTranslation@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7Buffer@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResScript@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjColor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSync36@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMsg@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjView@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResAudio36@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResAudio@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResFont@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7MemoryMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResVMD@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResChunk@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSync@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjMem@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResVocab@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?fontMgr@@3PAVFontMgr@@A			; fontMgr
PUBLIC	?gFontTable@@3PAPAXA				; gFontTable
PUBLIC	?systemFont@@3GA				; systemFont
PUBLIC	?xRes@FontMgr@@1HA				; FontMgr::xRes
PUBLIC	?yRes@FontMgr@@1HA				; FontMgr::yRes
_BSS	SEGMENT
?fontMgr@@3PAVFontMgr@@A DD 01H DUP (?)			; fontMgr
?gFontTable@@3PAPAXA DD 02710H DUP (?)			; gFontTable
_BSS	ENDS
_DATA	SEGMENT
?xRes@FontMgr@@1HA DD 0280H				; FontMgr::xRes
?yRes@FontMgr@@1HA DD 01e0H				; FontMgr::yRes
?systemFont@@3GA DW 0ffffH				; systemFont
_DATA	ENDS
PUBLIC	??0Ratio@@QAE@HH@Z				; Ratio::Ratio
PUBLIC	?GetAddr@MemoryMgr@@QAEPAXG@Z			; MemoryMgr::GetAddr
PUBLIC	?BuildHeader@@YAXVMemID@@HHHHHHHHH@Z		; BuildHeader
PUBLIC	??0MemID@@QAE@ABV0@@Z				; MemID::MemID
PUBLIC	?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get
PUBLIC	??BMemID@@QBEGXZ				; MemID::operator unsigned short
PUBLIC	??7MemID@@QBEHXZ				; MemID::operator!
PUBLIC	?View@Bitmap@@QBEHXZ				; Bitmap::View
PUBLIC	?Loop@Bitmap@@QBEHXZ				; Bitmap::Loop
PUBLIC	?Cel@Bitmap@@QBEHXZ				; Bitmap::Cel
PUBLIC	?Width@CelObj@@QBEHXZ				; CelObj::Width
PUBLIC	?Height@CelObj@@QBEHXZ				; CelObj::Height
PUBLIC	?ResX@CelObj@@QBEHXZ				; CelObj::ResX
PUBLIC	?ResY@CelObj@@QBEHXZ				; CelObj::ResY
PUBLIC	?Skip@CelObj@@QBEEXZ				; CelObj::Skip
PUBLIC	??0SOL_Point@@QAE@HH@Z				; SOL_Point::SOL_Point
PUBLIC	??0SOL_Point@@QAE@ABV0@@Z			; SOL_Point::SOL_Point
PUBLIC	??1CelObjView@@UAE@XZ				; CelObjView::~CelObjView
PUBLIC	??0FontMgr@@QAE@G@Z				; FontMgr::FontMgr
PUBLIC	?BuildFBM@FontMgr@@QAE?AVMemID@@AAVBitmap@@AAVSOL_Rect@@V2@HHHHHH@Z ; FontMgr::BuildFBM
PUBLIC	?BuildFBM@FontMgr@@QAE?AVMemID@@HHAAVSOL_Rect@@V2@HHHHHHHH@Z ; FontMgr::BuildFBM
PUBLIC	?DrawTextBox@FontMgr@@QAEXXZ			; FontMgr::DrawTextBox
PUBLIC	?Erase@FontMgr@@QAEXAAVSOL_Rect@@H@Z		; FontMgr::Erase
PUBLIC	?Frame@FontMgr@@QAEXAAVSOL_Rect@@HEH@Z		; FontMgr::Frame
PUBLIC	??0SOL_Rect@@QAE@HHHH@Z				; SOL_Rect::SOL_Rect
PUBLIC	?Xlen@SOL_Rect@@QBEHXZ				; SOL_Rect::Xlen
PUBLIC	?Ylen@SOL_Rect@@QBEHXZ				; SOL_Rect::Ylen
PUBLIC	?Clip@SOL_Rect@@QAEXABV1@@Z			; SOL_Rect::Clip
PUBLIC	?BuildFontTable@FontMgr@@IAEXH@Z		; FontMgr::BuildFontTable
PUBLIC	?Scale@SOL_Rect@@QAEXHHHH@Z			; SOL_Rect::Scale
PUBLIC	??4SOL_Rect@@QAEAAV0@ABV0@@Z			; SOL_Rect::operator=
EXTRN	?Free@MemoryMgr@@QAEXG@Z:NEAR			; MemoryMgr::Free
EXTRN	??0Ratio@@QAE@ABV0@@Z:NEAR			; Ratio::Ratio
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	_memMgr:DWORD
EXTRN	_memset:NEAR
EXTRN	??0BufferStd@@QAE@HHPAE@Z:NEAR			; BufferStd::BufferStd
EXTRN	??0CelObjView@@QAE@HHH@Z:NEAR			; CelObjView::CelObjView
EXTRN	?Draw@CelObjView@@QAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@HVRatio@@3@Z:NEAR ; CelObjView::Draw
EXTRN	?resMgr@@3PAVResourceMgr@@A:DWORD		; resMgr
xdata$x	SEGMENT
$T63563	DD	019930520H
	DD	01H
	DD	FLAT:$T63566
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T63566	DD	0ffffffffH
	DD	FLAT:$L63559
xdata$x	ENDS
_TEXT	SEGMENT
$T63550 = -792
$T63551 = -796
$T63552 = -800
$T63553 = -808
$T63554 = -812
$T63555 = -820
$T63556 = -824
$T63557 = -828
$T63558 = -832
__$EHRec$ = -12
_bitmap$ = 12
_theTextBox$ = 16
_theText$ = 20
_theFore$ = 24
_theBack$ = 28
_theFont$ = 32
_theSkip$ = 36
_theBorderColor$ = 40
_dimIt$ = 44
___$ReturnUdt$ = 8
_this$ = -836
_frameSize$ = -112
_celObj$ = -92
_rect$ = -108
_pt$ = -136
_buffer$ = -128
_overlayWidth$62664 = -776
_overlayHeight$62665 = -772
_overlayTextBox$62666 = -764
_fntMgr$62667 = -748
_overlay$62668 = -140
_drawTo$62671 = -780
_drawFrom$62673 = -768
_skipToNextRow$62675 = -148
_row$62676 = -144
_col$62680 = -784
_color$62684 = -788
?BuildFBM@FontMgr@@QAE?AVMemID@@AAVBitmap@@AAVSOL_Rect@@V2@HHHHHH@Z PROC NEAR ; FontMgr::BuildFBM

; 42   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 $L63564
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	81 ec 38 03 00
	00		 sub	 esp, 824		; 00000338H
  0001e	56		 push	 esi
  0001f	89 8d bc fc ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 43   : #ifdef MACINTOSH
; 44   : 	if (theFore == 255)
; 45   : 		theFore = 0;
; 46   : 	else if (theFore == 0)
; 47   : 		theFore = 236;
; 48   : 
; 49   : 	if (theBack == 255)
; 50   : 		theBack = 0;
; 51   : 	else if (theBack == 0)
; 52   : 		theBack = 236;
; 53   : 
; 54   : 	if (theBorderColor == 255)
; 55   : 		theBorderColor = 0;
; 56   : 	else if (theBorderColor == 0)
; 57   : 		theBorderColor = 236;
; 58   : 
; 59   : #endif	//MACINTOSH
; 60   : 
; 61   : 	int frameSize = 1;

  00025	c7 45 90 01 00
	00 00		 mov	 DWORD PTR _frameSize$[ebp], 1

; 62   : 
; 63   : 	// No title
; 64   : 	titleSize = 0;

  0002c	8b 85 bc fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00032	66 c7 40 26 00
	00		 mov	 WORD PTR [eax+38], 0

; 65   :    borderColor = theBorderColor;

  00038	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	66 8b 55 28	 mov	 dx, WORD PTR _theBorderColor$[ebp]
  00042	66 89 51 2c	 mov	 WORD PTR [ecx+44], dx

; 66   : 
; 67   : 	textBox = theTextBox;

  00046	8b 45 10	 mov	 eax, DWORD PTR _theTextBox$[ebp]
  00049	50		 push	 eax
  0004a	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00050	83 c1 14	 add	 ecx, 20			; 00000014H
  00053	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 68   :    textBox.Scale(xRes,SCIRESX,yRes,SCIRESY);

  00058	68 e0 01 00 00	 push	 480			; 000001e0H
  0005d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?yRes@FontMgr@@1HA ; FontMgr::yRes
  00063	51		 push	 ecx
  00064	68 80 02 00 00	 push	 640			; 00000280H
  00069	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes
  0006f	52		 push	 edx
  00070	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00076	83 c1 14	 add	 ecx, 20			; 00000014H
  00079	e8 00 00 00 00	 call	 ?Scale@SOL_Rect@@QAEXHHHH@Z ; SOL_Rect::Scale

; 69   : 	text = theText;

  0007e	8b 85 bc fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00084	66 8b 4d 14	 mov	 cx, WORD PTR _theText$[ebp]
  00088	66 89 48 0e	 mov	 WORD PTR [eax+14], cx

; 70   : 	fore = theFore;

  0008c	8b 95 bc fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00092	66 8b 45 18	 mov	 ax, WORD PTR _theFore$[ebp]
  00096	66 89 42 06	 mov	 WORD PTR [edx+6], ax

; 71   : 	dim = dimIt;

  0009a	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000a0	66 8b 55 2c	 mov	 dx, WORD PTR _dimIt$[ebp]
  000a4	66 89 51 44	 mov	 WORD PTR [ecx+68], dx

; 72   : 	// Build the font table containing the font widths
; 73   : 	BuildFontTable(theFont);

  000a8	8b 45 20	 mov	 eax, DWORD PTR _theFont$[ebp]
  000ab	50		 push	 eax
  000ac	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000b2	e8 00 00 00 00	 call	 ?BuildFontTable@FontMgr@@IAEXH@Z ; FontMgr::BuildFontTable

; 74   : 
; 75   : 	// create a cel object
; 76   : 	CelObjView celObj(bitmap.View(),bitmap.Loop(),bitmap.Cel());

  000b7	8b 4d 0c	 mov	 ecx, DWORD PTR _bitmap$[ebp]
  000ba	e8 00 00 00 00	 call	 ?Cel@Bitmap@@QBEHXZ	; Bitmap::Cel
  000bf	50		 push	 eax
  000c0	8b 4d 0c	 mov	 ecx, DWORD PTR _bitmap$[ebp]
  000c3	e8 00 00 00 00	 call	 ?Loop@Bitmap@@QBEHXZ	; Bitmap::Loop
  000c8	50		 push	 eax
  000c9	8b 4d 0c	 mov	 ecx, DWORD PTR _bitmap$[ebp]
  000cc	e8 00 00 00 00	 call	 ?View@Bitmap@@QBEHXZ	; Bitmap::View
  000d1	50		 push	 eax
  000d2	8d 4d a4	 lea	 ecx, DWORD PTR _celObj$[ebp]
  000d5	e8 00 00 00 00	 call	 ??0CelObjView@@QAE@HHH@Z ; CelObjView::CelObjView
  000da	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 77   :    skip = celObj.Skip();

  000e1	8d 4d a4	 lea	 ecx, DWORD PTR _celObj$[ebp]
  000e4	e8 00 00 00 00	 call	 ?Skip@CelObj@@QBEEXZ	; CelObj::Skip
  000e9	66 33 c9	 xor	 cx, cx
  000ec	8a c8		 mov	 cl, al
  000ee	8b 95 bc fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  000f4	66 89 4a 10	 mov	 WORD PTR [edx+16], cx

; 78   : 
; 79   : 	// the cel object should have the dimension
; 80   : 	BMWidth = celObj.Width() * xRes / celObj.ResX();

  000f8	8d 4d a4	 lea	 ecx, DWORD PTR _celObj$[ebp]
  000fb	e8 00 00 00 00	 call	 ?Width@CelObj@@QBEHXZ	; CelObj::Width
  00100	8b f0		 mov	 esi, eax
  00102	0f af 35 00 00
	00 00		 imul	 esi, DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes
  00109	8d 4d a4	 lea	 ecx, DWORD PTR _celObj$[ebp]
  0010c	e8 00 00 00 00	 call	 ?ResX@CelObj@@QBEHXZ	; CelObj::ResX
  00111	8b c8		 mov	 ecx, eax
  00113	8b c6		 mov	 eax, esi
  00115	99		 cdq
  00116	f7 f9		 idiv	 ecx
  00118	8b 95 bc fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0011e	66 89 42 02	 mov	 WORD PTR [edx+2], ax

; 81   : 	BMHeight = celObj.Height() * yRes / celObj.ResY();

  00122	8d 4d a4	 lea	 ecx, DWORD PTR _celObj$[ebp]
  00125	e8 00 00 00 00	 call	 ?Height@CelObj@@QBEHXZ	; CelObj::Height
  0012a	8b f0		 mov	 esi, eax
  0012c	0f af 35 00 00
	00 00		 imul	 esi, DWORD PTR ?yRes@FontMgr@@1HA ; FontMgr::yRes
  00133	8d 4d a4	 lea	 ecx, DWORD PTR _celObj$[ebp]
  00136	e8 00 00 00 00	 call	 ?ResY@CelObj@@QBEHXZ	; CelObj::ResY
  0013b	8b c8		 mov	 ecx, eax
  0013d	8b c6		 mov	 eax, esi
  0013f	99		 cdq
  00140	f7 f9		 idiv	 ecx
  00142	8b 95 bc fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00148	66 89 42 04	 mov	 WORD PTR [edx+4], ax

; 82   : 
; 83   : 	// clip the textbox by the FBM
; 84   : 	SOL_Rect rect(0,0,BMWidth - 1,BMHeight - 1);

  0014c	8b 85 bc fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00152	33 c9		 xor	 ecx, ecx
  00154	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  00158	83 e9 01	 sub	 ecx, 1
  0015b	51		 push	 ecx
  0015c	8b 95 bc fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00162	33 c0		 xor	 eax, eax
  00164	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  00168	83 e8 01	 sub	 eax, 1
  0016b	50		 push	 eax
  0016c	6a 00		 push	 0
  0016e	6a 00		 push	 0
  00170	8d 4d 94	 lea	 ecx, DWORD PTR _rect$[ebp]
  00173	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@HHHH@Z	; SOL_Rect::SOL_Rect

; 85   : 	textBox.Clip(rect);

  00178	8d 4d 94	 lea	 ecx, DWORD PTR _rect$[ebp]
  0017b	51		 push	 ecx
  0017c	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00182	83 c1 14	 add	 ecx, 20			; 00000014H
  00185	e8 00 00 00 00	 call	 ?Clip@SOL_Rect@@QAEXABV1@@Z ; SOL_Rect::Clip

; 86   : 
; 87   : 	// allocate memory for the bitmap
; 88   : 	BM.Get(MemBitmap,BMWidth*BMHeight+CELHEADERSIZE);

  0018a	6a 00		 push	 0
  0018c	6a 00		 push	 0
  0018e	6a 00		 push	 0
  00190	6a 00		 push	 0
  00192	68 00 02 00 00	 push	 512			; 00000200H
  00197	8b 95 bc fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0019d	33 c0		 xor	 eax, eax
  0019f	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  001a3	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001a9	33 d2		 xor	 edx, edx
  001ab	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  001af	0f af c2	 imul	 eax, edx
  001b2	83 c0 2e	 add	 eax, 46			; 0000002eH
  001b5	50		 push	 eax
  001b6	6a 4b		 push	 75			; 0000004bH
  001b8	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001be	83 c1 4e	 add	 ecx, 78			; 0000004eH
  001c1	e8 00 00 00 00	 call	 ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get

; 89   : 
; 90   : 	// build the header for the BM
; 91   : 	BuildHeader(BM,BMWidth,BMHeight,skip,0,0,xRes,yRes);

  001c6	6a 00		 push	 0
  001c8	6a 00		 push	 0
  001ca	a1 00 00 00 00	 mov	 eax, DWORD PTR ?yRes@FontMgr@@1HA ; FontMgr::yRes
  001cf	50		 push	 eax
  001d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes
  001d6	51		 push	 ecx
  001d7	6a 00		 push	 0
  001d9	6a 00		 push	 0
  001db	8b 95 bc fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001e1	33 c0		 xor	 eax, eax
  001e3	66 8b 42 10	 mov	 ax, WORD PTR [edx+16]
  001e7	50		 push	 eax
  001e8	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001ee	33 d2		 xor	 edx, edx
  001f0	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  001f4	52		 push	 edx
  001f5	8b 85 bc fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001fb	33 c9		 xor	 ecx, ecx
  001fd	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  00201	51		 push	 ecx
  00202	8b 95 bc fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00208	83 c2 4e	 add	 edx, 78			; 0000004eH
  0020b	51		 push	 ecx
  0020c	8b cc		 mov	 ecx, esp
  0020e	89 a5 e8 fc ff
	ff		 mov	 DWORD PTR $T63550[ebp], esp
  00214	52		 push	 edx
  00215	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  0021a	e8 00 00 00 00	 call	 ?BuildHeader@@YAXVMemID@@HHHHHHHHH@Z ; BuildHeader
  0021f	83 c4 28	 add	 esp, 40			; 00000028H

; 92   : 
; 93   : 	// draw the cel into the bitmap
; 94   : 	SOL_Point pt(0,0);

  00222	6a 00		 push	 0
  00224	6a 00		 push	 0
  00226	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _pt$[ebp]
  0022c	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@HH@Z	; SOL_Point::SOL_Point

; 95   : 
; 96   :    memset((char*)memMgr->GetAddr(BM) + CELHEADERSIZE,11,BMWidth*BMHeight);

  00231	8b 85 bc fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00237	33 c9		 xor	 ecx, ecx
  00239	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  0023d	8b 95 bc fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00243	33 c0		 xor	 eax, eax
  00245	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  00249	0f af c8	 imul	 ecx, eax
  0024c	51		 push	 ecx
  0024d	6a 0b		 push	 11			; 0000000bH
  0024f	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00255	83 c1 4e	 add	 ecx, 78			; 0000004eH
  00258	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  0025d	50		 push	 eax
  0025e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00264	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr
  00269	83 c0 2e	 add	 eax, 46			; 0000002eH
  0026c	50		 push	 eax
  0026d	e8 00 00 00 00	 call	 _memset
  00272	83 c4 0c	 add	 esp, 12			; 0000000cH

; 97   : 
; 98   : 	resMgr->Get ( MemResView, bitmap.View() );

  00275	6a 00		 push	 0
  00277	8b 4d 0c	 mov	 ecx, DWORD PTR _bitmap$[ebp]
  0027a	e8 00 00 00 00	 call	 ?View@Bitmap@@QBEHXZ	; Bitmap::View
  0027f	50		 push	 eax
  00280	6a 00		 push	 0
  00282	8d 8d e4 fc ff
	ff		 lea	 ecx, DWORD PTR $T63551[ebp]
  00288	51		 push	 ecx
  00289	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?resMgr@@3PAVResourceMgr@@A ; resMgr
  0028f	8b 02		 mov	 eax, DWORD PTR [edx]
  00291	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMgr@@3PAVResourceMgr@@A ; resMgr
  00297	ff 50 20	 call	 DWORD PTR [eax+32]

; 99   : 	BufferStd buffer(BMWidth,BMHeight,(uchar*) memMgr->GetAddr(BM) + CELHEADERSIZE);

  0029a	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002a0	83 c1 4e	 add	 ecx, 78			; 0000004eH
  002a3	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  002a8	50		 push	 eax
  002a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  002af	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr
  002b4	83 c0 2e	 add	 eax, 46			; 0000002eH
  002b7	50		 push	 eax
  002b8	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002be	33 d2		 xor	 edx, edx
  002c0	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  002c4	52		 push	 edx
  002c5	8b 85 bc fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  002cb	33 c9		 xor	 ecx, ecx
  002cd	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  002d1	51		 push	 ecx
  002d2	8d 4d 80	 lea	 ecx, DWORD PTR _buffer$[ebp]
  002d5	e8 00 00 00 00	 call	 ??0BufferStd@@QAE@HHPAE@Z ; BufferStd::BufferStd

; 100  : 
; 101  : 	// fill the back ground with skip
; 102  : 	back = skip;

  002da	8b 95 bc fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  002e0	8b 85 bc fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  002e6	66 8b 48 10	 mov	 cx, WORD PTR [eax+16]
  002ea	66 89 4a 08	 mov	 WORD PTR [edx+8], cx

; 103  : 	Erase(rect,False);

  002ee	6a 00		 push	 0
  002f0	8d 55 94	 lea	 edx, DWORD PTR _rect$[ebp]
  002f3	52		 push	 edx
  002f4	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002fa	e8 00 00 00 00	 call	 ?Erase@FontMgr@@QAEXAAVSOL_Rect@@H@Z ; FontMgr::Erase

; 104  : 	back = theBack;

  002ff	8b 85 bc fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00305	66 8b 4d 1c	 mov	 cx, WORD PTR _theBack$[ebp]
  00309	66 89 48 08	 mov	 WORD PTR [eax+8], cx

; 105  : 
; 106  : 	celObj.Draw(buffer,rect,pt,False,Ratio(xRes,celObj.ResX()),Ratio(yRes,celObj.ResY()));

  0030d	8d 4d a4	 lea	 ecx, DWORD PTR _celObj$[ebp]
  00310	e8 00 00 00 00	 call	 ?ResY@CelObj@@QBEHXZ	; CelObj::ResY
  00315	50		 push	 eax
  00316	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?yRes@FontMgr@@1HA ; FontMgr::yRes
  0031c	52		 push	 edx
  0031d	8d 8d d8 fc ff
	ff		 lea	 ecx, DWORD PTR $T63553[ebp]
  00323	e8 00 00 00 00	 call	 ??0Ratio@@QAE@HH@Z	; Ratio::Ratio
  00328	83 ec 08	 sub	 esp, 8
  0032b	8b cc		 mov	 ecx, esp
  0032d	89 a5 e0 fc ff
	ff		 mov	 DWORD PTR $T63552[ebp], esp
  00333	50		 push	 eax
  00334	e8 00 00 00 00	 call	 ??0Ratio@@QAE@ABV0@@Z	; Ratio::Ratio
  00339	8d 4d a4	 lea	 ecx, DWORD PTR _celObj$[ebp]
  0033c	e8 00 00 00 00	 call	 ?ResX@CelObj@@QBEHXZ	; CelObj::ResX
  00341	50		 push	 eax
  00342	a1 00 00 00 00	 mov	 eax, DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes
  00347	50		 push	 eax
  00348	8d 8d cc fc ff
	ff		 lea	 ecx, DWORD PTR $T63555[ebp]
  0034e	e8 00 00 00 00	 call	 ??0Ratio@@QAE@HH@Z	; Ratio::Ratio
  00353	83 ec 08	 sub	 esp, 8
  00356	8b cc		 mov	 ecx, esp
  00358	89 a5 d4 fc ff
	ff		 mov	 DWORD PTR $T63554[ebp], esp
  0035e	50		 push	 eax
  0035f	e8 00 00 00 00	 call	 ??0Ratio@@QAE@ABV0@@Z	; Ratio::Ratio
  00364	6a 00		 push	 0
  00366	83 ec 08	 sub	 esp, 8
  00369	8b cc		 mov	 ecx, esp
  0036b	89 a5 c8 fc ff
	ff		 mov	 DWORD PTR $T63556[ebp], esp
  00371	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR _pt$[ebp]
  00377	52		 push	 edx
  00378	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  0037d	8d 45 94	 lea	 eax, DWORD PTR _rect$[ebp]
  00380	50		 push	 eax
  00381	8d 4d 80	 lea	 ecx, DWORD PTR _buffer$[ebp]
  00384	51		 push	 ecx
  00385	8d 4d a4	 lea	 ecx, DWORD PTR _celObj$[ebp]
  00388	e8 00 00 00 00	 call	 ?Draw@CelObjView@@QAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@HVRatio@@3@Z ; CelObjView::Draw

; 107  : 
; 108  : 	// fill the textBox with the back ground color (unless it's skip)
; 109  :    if ((back != theSkip)        && (fore != theSkip))

  0038d	8b 95 bc fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00393	33 c0		 xor	 eax, eax
  00395	66 8b 42 08	 mov	 ax, WORD PTR [edx+8]
  00399	3b 45 24	 cmp	 eax, DWORD PTR _theSkip$[ebp]
  0039c	74 28		 je	 SHORT $L62661
  0039e	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003a4	33 d2		 xor	 edx, edx
  003a6	66 8b 51 06	 mov	 dx, WORD PTR [ecx+6]
  003aa	3b 55 24	 cmp	 edx, DWORD PTR _theSkip$[ebp]
  003ad	74 17		 je	 SHORT $L62661

; 110  : 	   Erase(textBox,False);

  003af	6a 00		 push	 0
  003b1	8b 85 bc fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  003b7	83 c0 14	 add	 eax, 20			; 00000014H
  003ba	50		 push	 eax
  003bb	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003c1	e8 00 00 00 00	 call	 ?Erase@FontMgr@@QAEXAAVSOL_Rect@@H@Z ; FontMgr::Erase
$L62661:

; 111  : 
; 112  : 	if (!text)

  003c6	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003cc	83 c1 0e	 add	 ecx, 14			; 0000000eH
  003cf	e8 00 00 00 00	 call	 ??7MemID@@QBEHXZ	; MemID::operator!
  003d4	85 c0		 test	 eax, eax
  003d6	74 29		 je	 SHORT $L62662

; 113  : 		return BM;

  003d8	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003de	83 c1 4e	 add	 ecx, 78			; 0000004eH
  003e1	51		 push	 ecx
  003e2	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  003e5	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  003ea	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003f1	8d 4d a4	 lea	 ecx, DWORD PTR _celObj$[ebp]
  003f4	e8 00 00 00 00	 call	 ??1CelObjView@@UAE@XZ	; CelObjView::~CelObjView
  003f9	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  003fc	e9 e8 02 00 00	 jmp	 $L62646
$L62662:

; 114  : 
; 115  :    if (fore == theSkip) {

  00401	8b 95 bc fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00407	33 c0		 xor	 eax, eax
  00409	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  0040d	3b 45 24	 cmp	 eax, DWORD PTR _theSkip$[ebp]
  00410	0f 85 68 02 00
	00		 jne	 $L62663

; 116  : 		// Build a FBM with the textBox as the rectangle
; 117  : 		int overlayWidth = textBox.Xlen();

  00416	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0041c	83 c1 14	 add	 ecx, 20			; 00000014H
  0041f	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  00424	89 85 f8 fc ff
	ff		 mov	 DWORD PTR _overlayWidth$62664[ebp], eax

; 118  : 		int overlayHeight = textBox.Ylen();

  0042a	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00430	83 c1 14	 add	 ecx, 20			; 00000014H
  00433	e8 00 00 00 00	 call	 ?Ylen@SOL_Rect@@QBEHXZ	; SOL_Rect::Ylen
  00438	89 85 fc fc ff
	ff		 mov	 DWORD PTR _overlayHeight$62665[ebp], eax

; 119  : 		SOL_Rect overlayTextBox(0,0,overlayWidth - 1,overlayHeight - 1);

  0043e	8b 8d fc fc ff
	ff		 mov	 ecx, DWORD PTR _overlayHeight$62665[ebp]
  00444	83 e9 01	 sub	 ecx, 1
  00447	51		 push	 ecx
  00448	8b 95 f8 fc ff
	ff		 mov	 edx, DWORD PTR _overlayWidth$62664[ebp]
  0044e	83 ea 01	 sub	 edx, 1
  00451	52		 push	 edx
  00452	6a 00		 push	 0
  00454	6a 00		 push	 0
  00456	8d 8d 04 fd ff
	ff		 lea	 ecx, DWORD PTR _overlayTextBox$62666[ebp]
  0045c	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@HHHH@Z	; SOL_Rect::SOL_Rect

; 120  : 		FontMgr fntMgr;

  00461	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?systemFont@@3GA ; systemFont
  00467	50		 push	 eax
  00468	8d 8d 14 fd ff
	ff		 lea	 ecx, DWORD PTR _fntMgr$62667[ebp]
  0046e	e8 00 00 00 00	 call	 ??0FontMgr@@QAE@G@Z	; FontMgr::FontMgr

; 121  : 		MemID overlay = fntMgr.BuildFBM(overlayWidth,
; 122  : 												  overlayHeight,
; 123  : 												  overlayTextBox,
; 124  : 												  text,
; 125  : 												  fore,
; 126  : 												  back,
; 127  : 												  skip,
; 128  : 												  font,
; 129  : 												  mode,
; 130  : 												  borderColor,
; 131  : 												  0,
; 132  : 												  False);

  00473	6a 00		 push	 0
  00475	6a 00		 push	 0
  00477	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0047d	33 d2		 xor	 edx, edx
  0047f	66 8b 51 2c	 mov	 dx, WORD PTR [ecx+44]
  00483	52		 push	 edx
  00484	8b 85 bc fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0048a	0f bf 48 46	 movsx	 ecx, WORD PTR [eax+70]
  0048e	51		 push	 ecx
  0048f	8b 95 bc fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00495	33 c0		 xor	 eax, eax
  00497	66 8b 42 28	 mov	 ax, WORD PTR [edx+40]
  0049b	50		 push	 eax
  0049c	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004a2	33 d2		 xor	 edx, edx
  004a4	66 8b 51 10	 mov	 dx, WORD PTR [ecx+16]
  004a8	52		 push	 edx
  004a9	8b 85 bc fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  004af	33 c9		 xor	 ecx, ecx
  004b1	66 8b 48 08	 mov	 cx, WORD PTR [eax+8]
  004b5	51		 push	 ecx
  004b6	8b 95 bc fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  004bc	33 c0		 xor	 eax, eax
  004be	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  004c2	50		 push	 eax
  004c3	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004c9	83 c1 0e	 add	 ecx, 14			; 0000000eH
  004cc	51		 push	 ecx
  004cd	8b d4		 mov	 edx, esp
  004cf	89 a5 c4 fc ff
	ff		 mov	 DWORD PTR $T63557[ebp], esp
  004d5	51		 push	 ecx
  004d6	8b ca		 mov	 ecx, edx
  004d8	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  004dd	8d 85 04 fd ff
	ff		 lea	 eax, DWORD PTR _overlayTextBox$62666[ebp]
  004e3	50		 push	 eax
  004e4	8b 8d fc fc ff
	ff		 mov	 ecx, DWORD PTR _overlayHeight$62665[ebp]
  004ea	51		 push	 ecx
  004eb	8b 95 f8 fc ff
	ff		 mov	 edx, DWORD PTR _overlayWidth$62664[ebp]
  004f1	52		 push	 edx
  004f2	8d 85 c0 fc ff
	ff		 lea	 eax, DWORD PTR $T63558[ebp]
  004f8	50		 push	 eax
  004f9	8d 8d 14 fd ff
	ff		 lea	 ecx, DWORD PTR _fntMgr$62667[ebp]
  004ff	e8 00 00 00 00	 call	 ?BuildFBM@FontMgr@@QAE?AVMemID@@HHAAVSOL_Rect@@V2@HHHHHHHH@Z ; FontMgr::BuildFBM
  00504	50		 push	 eax
  00505	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _overlay$62668[ebp]
  0050b	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID

; 133  : 		// Now copy this into the other bitmap treating skip as skip
; 134  : 		uchar* drawTo = (uchar*) memMgr->GetAddr(BM) + 
; 135  : 												 BMWidth*textBox.A.y + 
; 136  : 												 textBox.A.x +
; 137  : 												 CELHEADERSIZE;

  00510	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00516	83 c1 4e	 add	 ecx, 78			; 0000004eH
  00519	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  0051e	50		 push	 eax
  0051f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00525	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr
  0052a	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00530	33 d2		 xor	 edx, edx
  00532	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  00536	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0053c	0f af 51 18	 imul	 edx, DWORD PTR [ecx+24]
  00540	03 c2		 add	 eax, edx
  00542	8b 95 bc fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00548	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  0054b	8d 54 08 2e	 lea	 edx, DWORD PTR [eax+ecx+46]
  0054f	89 95 f4 fc ff
	ff		 mov	 DWORD PTR _drawTo$62671[ebp], edx

; 138  : 		uchar* drawFrom = (uchar*) memMgr->GetAddr(overlay) + CELHEADERSIZE;

  00555	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _overlay$62668[ebp]
  0055b	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00560	50		 push	 eax
  00561	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00567	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr
  0056c	83 c0 2e	 add	 eax, 46			; 0000002eH
  0056f	89 85 00 fd ff
	ff		 mov	 DWORD PTR _drawFrom$62673[ebp], eax

; 139  : 		int skipToNextRow = BMWidth - overlayWidth;

  00575	8b 85 bc fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0057b	33 c9		 xor	 ecx, ecx
  0057d	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  00581	2b 8d f8 fc ff
	ff		 sub	 ecx, DWORD PTR _overlayWidth$62664[ebp]
  00587	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _skipToNextRow$62675[ebp], ecx

; 140  : 		for (int row = 0;row < overlayHeight;++row) {

  0058d	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _row$62676[ebp], 0
  00597	eb 0f		 jmp	 SHORT $L62677
$L62678:
  00599	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _row$62676[ebp]
  0059f	83 c2 01	 add	 edx, 1
  005a2	89 95 70 ff ff
	ff		 mov	 DWORD PTR _row$62676[ebp], edx
$L62677:
  005a8	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _row$62676[ebp]
  005ae	3b 85 fc fc ff
	ff		 cmp	 eax, DWORD PTR _overlayHeight$62665[ebp]
  005b4	0f 8d ab 00 00
	00		 jge	 $L62679

; 141  : 			for (int col = 0;col < overlayWidth;++col) {

  005ba	c7 85 f0 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _col$62680[ebp], 0
  005c4	eb 0f		 jmp	 SHORT $L62681
$L62682:
  005c6	8b 8d f0 fc ff
	ff		 mov	 ecx, DWORD PTR _col$62680[ebp]
  005cc	83 c1 01	 add	 ecx, 1
  005cf	89 8d f0 fc ff
	ff		 mov	 DWORD PTR _col$62680[ebp], ecx
$L62681:
  005d5	8b 95 f0 fc ff
	ff		 mov	 edx, DWORD PTR _col$62680[ebp]
  005db	3b 95 f8 fc ff
	ff		 cmp	 edx, DWORD PTR _overlayWidth$62664[ebp]
  005e1	7d 6b		 jge	 SHORT $L62683

; 142  : 				uchar color = *drawFrom++;

  005e3	8b 85 00 fd ff
	ff		 mov	 eax, DWORD PTR _drawFrom$62673[ebp]
  005e9	8a 08		 mov	 cl, BYTE PTR [eax]
  005eb	88 8d ec fc ff
	ff		 mov	 BYTE PTR _color$62684[ebp], cl
  005f1	8b 95 00 fd ff
	ff		 mov	 edx, DWORD PTR _drawFrom$62673[ebp]
  005f7	83 c2 01	 add	 edx, 1
  005fa	89 95 00 fd ff
	ff		 mov	 DWORD PTR _drawFrom$62673[ebp], edx

; 143  : 				if (color == fore)

  00600	8b 85 ec fc ff
	ff		 mov	 eax, DWORD PTR _color$62684[ebp]
  00606	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0060b	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00611	33 d2		 xor	 edx, edx
  00613	66 8b 51 06	 mov	 dx, WORD PTR [ecx+6]
  00617	3b c2		 cmp	 eax, edx
  00619	75 11		 jne	 SHORT $L62685

; 144  : 					++drawTo;

  0061b	8b 85 f4 fc ff
	ff		 mov	 eax, DWORD PTR _drawTo$62671[ebp]
  00621	83 c0 01	 add	 eax, 1
  00624	89 85 f4 fc ff
	ff		 mov	 DWORD PTR _drawTo$62671[ebp], eax

; 145  : 				else

  0062a	eb 1d		 jmp	 SHORT $L62686
$L62685:

; 146  : 					*drawTo++ = color;

  0062c	8b 8d f4 fc ff
	ff		 mov	 ecx, DWORD PTR _drawTo$62671[ebp]
  00632	8a 95 ec fc ff
	ff		 mov	 dl, BYTE PTR _color$62684[ebp]
  00638	88 11		 mov	 BYTE PTR [ecx], dl
  0063a	8b 85 f4 fc ff
	ff		 mov	 eax, DWORD PTR _drawTo$62671[ebp]
  00640	83 c0 01	 add	 eax, 1
  00643	89 85 f4 fc ff
	ff		 mov	 DWORD PTR _drawTo$62671[ebp], eax
$L62686:

; 147  : 			}

  00649	e9 78 ff ff ff	 jmp	 $L62682
$L62683:

; 148  : 			drawTo += skipToNextRow;

  0064e	8b 8d f4 fc ff
	ff		 mov	 ecx, DWORD PTR _drawTo$62671[ebp]
  00654	03 8d 6c ff ff
	ff		 add	 ecx, DWORD PTR _skipToNextRow$62675[ebp]
  0065a	89 8d f4 fc ff
	ff		 mov	 DWORD PTR _drawTo$62671[ebp], ecx

; 149  : 		}

  00660	e9 34 ff ff ff	 jmp	 $L62678
$L62679:

; 150  : 		memMgr->Free(overlay);

  00665	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _overlay$62668[ebp]
  0066b	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00670	50		 push	 eax
  00671	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00677	e8 00 00 00 00	 call	 ?Free@MemoryMgr@@QAEXG@Z ; MemoryMgr::Free

; 152  : 	else {

  0067c	eb 47		 jmp	 SHORT $L62690
$L62663:

; 153  : 
; 154  :       if (theBorderColor != -1) {

  0067e	83 7d 28 ff	 cmp	 DWORD PTR _theBorderColor$[ebp], -1
  00682	74 1f		 je	 SHORT $L62688

; 155  : 	      // frame the title box
; 156  : 	      Frame(rect,frameSize,borderColor,False);

  00684	6a 00		 push	 0
  00686	8b 95 bc fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0068c	8a 42 2c	 mov	 al, BYTE PTR [edx+44]
  0068f	50		 push	 eax
  00690	8b 4d 90	 mov	 ecx, DWORD PTR _frameSize$[ebp]
  00693	51		 push	 ecx
  00694	8d 55 94	 lea	 edx, DWORD PTR _rect$[ebp]
  00697	52		 push	 edx
  00698	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0069e	e8 00 00 00 00	 call	 ?Frame@FontMgr@@QAEXAAVSOL_Rect@@HEH@Z ; FontMgr::Frame
$L62688:

; 158  : 		// put the text into the bitmap
; 159  : 		if ((int)text)

  006a3	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  006a9	83 c1 0e	 add	 ecx, 14			; 0000000eH
  006ac	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  006b1	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  006b6	85 c0		 test	 eax, eax
  006b8	74 0b		 je	 SHORT $L62690

; 160  : 		   DrawTextBox();

  006ba	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  006c0	e8 00 00 00 00	 call	 ?DrawTextBox@FontMgr@@QAEXXZ ; FontMgr::DrawTextBox
$L62690:

; 162  : 	// return the handle to the BM
; 163  : 	return BM;

  006c5	8b 85 bc fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  006cb	83 c0 4e	 add	 eax, 78			; 0000004eH
  006ce	50		 push	 eax
  006cf	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  006d2	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  006d7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  006de	8d 4d a4	 lea	 ecx, DWORD PTR _celObj$[ebp]
  006e1	e8 00 00 00 00	 call	 ??1CelObjView@@UAE@XZ	; CelObjView::~CelObjView
  006e6	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$L62646:

; 164  : }

  006e9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  006ec	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  006f3	5e		 pop	 esi
  006f4	8b e5		 mov	 esp, ebp
  006f6	5d		 pop	 ebp
  006f7	c2 28 00	 ret	 40			; 00000028H
_TEXT	ENDS
text$x	SEGMENT
$L63559:
  00000	8d 4d a4	 lea	 ecx, DWORD PTR _celObj$[ebp]
  00003	e8 00 00 00 00	 call	 ??1CelObjView@@UAE@XZ	; CelObjView::~CelObjView
  00008	c3		 ret	 0
$L63564:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T63563
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?BuildFBM@FontMgr@@QAE?AVMemID@@AAVBitmap@@AAVSOL_Rect@@V2@HHHHHH@Z ENDP ; FontMgr::BuildFBM
PUBLIC	??DTextID@@QAEPADXZ				; TextID::operator*
PUBLIC	?SetFont@FontMgr@@QAEXH@Z			; FontMgr::SetFont
EXTRN	?AddPalShift@@YAHH@Z:NEAR			; AddPalShift
EXTRN	??0TextID@@QAE@ABVMemID@@@Z:NEAR		; TextID::TextID
EXTRN	_strlen:NEAR
_TEXT	SEGMENT
$T63569 = -28
_theWidth$ = 12
_theHeight$ = 16
_theTextBox$ = 20
_theText$ = 24
_theFore$ = 28
_theBack$ = 32
_theSkip$ = 36
_theFont$ = 40
_theMode$ = 44
_theBorderColor$ = 48
_dimIt$ = 52
_scale$ = 56
___$ReturnUdt$ = 8
_this$ = -36
_frameSize$ = -24
_textSize$ = -20
_rect$ = -16
?BuildFBM@FontMgr@@QAE?AVMemID@@HHAAVSOL_Rect@@V2@HHHHHHHH@Z PROC NEAR ; FontMgr::BuildFBM

; 183  : {

  006fa	55		 push	 ebp
  006fb	8b ec		 mov	 ebp, esp
  006fd	83 ec 24	 sub	 esp, 36			; 00000024H
  00700	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 184  : 
; 185  : #ifdef MACINTOSH
; 186  : 
; 187  : 	if	(theFore == 255)						// MAC 4/28
; 188  : 		theFore = 0;
; 189  : 	else if	(theFore == 0)
; 190  : 		theFore = 236;							//255;
; 191  : 
; 192  : 	if	(theBack == 255)
; 193  : 		theBack = 0;
; 194  : 	else if	(theBack == 0)
; 195  : 		theBack = 236;							//255;
; 196  : 
; 197  : 	if	(theBorderColor == 255)
; 198  : 		theBorderColor = 0;
; 199  : 	else if	(theBorderColor == 0)
; 200  : 		theBorderColor = 236;				//255;
; 201  : 
; 202  : 
; 203  : #endif
; 204  : 
; 205  : #ifdef WIN32S
; 206  : 	theFore = AddPalShift(theFore);

  00703	8b 45 1c	 mov	 eax, DWORD PTR _theFore$[ebp]
  00706	50		 push	 eax
  00707	e8 00 00 00 00	 call	 ?AddPalShift@@YAHH@Z	; AddPalShift
  0070c	83 c4 04	 add	 esp, 4
  0070f	89 45 1c	 mov	 DWORD PTR _theFore$[ebp], eax

; 207  : 	theBack = AddPalShift(theBack);

  00712	8b 4d 20	 mov	 ecx, DWORD PTR _theBack$[ebp]
  00715	51		 push	 ecx
  00716	e8 00 00 00 00	 call	 ?AddPalShift@@YAHH@Z	; AddPalShift
  0071b	83 c4 04	 add	 esp, 4
  0071e	89 45 20	 mov	 DWORD PTR _theBack$[ebp], eax

; 208  : 	if (theBorderColor != -1)

  00721	83 7d 30 ff	 cmp	 DWORD PTR _theBorderColor$[ebp], -1
  00725	74 0f		 je	 SHORT $L62707

; 209  : 		theBorderColor = AddPalShift(theBorderColor);

  00727	8b 55 30	 mov	 edx, DWORD PTR _theBorderColor$[ebp]
  0072a	52		 push	 edx
  0072b	e8 00 00 00 00	 call	 ?AddPalShift@@YAHH@Z	; AddPalShift
  00730	83 c4 04	 add	 esp, 4
  00733	89 45 30	 mov	 DWORD PTR _theBorderColor$[ebp], eax
$L62707:

; 210  : #endif
; 211  : 
; 212  : 	int frameSize = 1;

  00736	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _frameSize$[ebp], 1

; 213  : 
; 214  : 	// No title
; 215  : 	titleSize = 0;

  0073d	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00740	66 c7 40 26 00
	00		 mov	 WORD PTR [eax+38], 0

; 216  :    borderColor = theBorderColor;

  00746	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00749	66 8b 55 30	 mov	 dx, WORD PTR _theBorderColor$[ebp]
  0074d	66 89 51 2c	 mov	 WORD PTR [ecx+44], dx

; 217  : 
; 218  : 	SetFont(theFont);

  00751	8b 45 28	 mov	 eax, DWORD PTR _theFont$[ebp]
  00754	50		 push	 eax
  00755	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00758	e8 00 00 00 00	 call	 ?SetFont@FontMgr@@QAEXH@Z ; FontMgr::SetFont

; 219  : 
; 220  : 	int textSize = strlen(*(TextID)theText);

  0075d	8d 4d 18	 lea	 ecx, DWORD PTR _theText$[ebp]
  00760	51		 push	 ecx
  00761	8d 4d e4	 lea	 ecx, DWORD PTR $T63569[ebp]
  00764	e8 00 00 00 00	 call	 ??0TextID@@QAE@ABVMemID@@@Z ; TextID::TextID
  00769	8b c8		 mov	 ecx, eax
  0076b	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  00770	50		 push	 eax
  00771	e8 00 00 00 00	 call	 _strlen
  00776	83 c4 04	 add	 esp, 4
  00779	89 45 ec	 mov	 DWORD PTR _textSize$[ebp], eax

; 221  : 
; 222  :    // talk to LARRY on this stuff note TextSize is a scale call
; 223  : 	/*SOL_Rect textRect;
; 224  : 	TextSize(theText,theWidth,textRect);
; 225  : 	if ((textRect.Xlen() > theTextBox.Xlen()) || (textRect.Ylen() > theTextBox.Ylen()))
; 226  : 		msgMgr->Fatal ( "BuildFBM textRect too big: (%d, %d)  (%d, %d)", 
; 227  : 			textRect.Xlen(), theTextBox.Xlen(),
; 228  : 			textRect.Ylen(), theTextBox.Ylen()
; 229  : 			)
; 230  : //		msgMgr->Fatal(SrcLoc,Msg_WindowTextTooBig);
; 231  : 	*/
; 232  : 	BMWidth = theWidth;

  0077c	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  0077f	66 8b 45 0c	 mov	 ax, WORD PTR _theWidth$[ebp]
  00783	66 89 42 02	 mov	 WORD PTR [edx+2], ax

; 233  : 	BMHeight = theHeight;

  00787	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0078a	66 8b 55 10	 mov	 dx, WORD PTR _theHeight$[ebp]
  0078e	66 89 51 04	 mov	 WORD PTR [ecx+4], dx

; 234  : 	textBox = theTextBox;

  00792	8b 45 14	 mov	 eax, DWORD PTR _theTextBox$[ebp]
  00795	50		 push	 eax
  00796	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00799	83 c1 14	 add	 ecx, 20			; 00000014H
  0079c	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 235  : 	if (scale) {

  007a1	83 7d 38 00	 cmp	 DWORD PTR _scale$[ebp], 0
  007a5	74 64		 je	 SHORT $L62712

; 236  : 		BMWidth = BMWidth * xRes / SCIRESX;

  007a7	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  007aa	33 d2		 xor	 edx, edx
  007ac	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  007b0	8b c2		 mov	 eax, edx
  007b2	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes
  007b9	99		 cdq
  007ba	b9 80 02 00 00	 mov	 ecx, 640		; 00000280H
  007bf	f7 f9		 idiv	 ecx
  007c1	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  007c4	66 89 42 02	 mov	 WORD PTR [edx+2], ax

; 237  : 		BMHeight = BMHeight * yRes /SCIRESY;

  007c8	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  007cb	33 c9		 xor	 ecx, ecx
  007cd	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  007d1	8b c1		 mov	 eax, ecx
  007d3	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR ?yRes@FontMgr@@1HA ; FontMgr::yRes
  007da	99		 cdq
  007db	b9 e0 01 00 00	 mov	 ecx, 480		; 000001e0H
  007e0	f7 f9		 idiv	 ecx
  007e2	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  007e5	66 89 42 04	 mov	 WORD PTR [edx+4], ax

; 238  : 		textBox.Scale(xRes,SCIRESX,yRes,SCIRESY);

  007e9	68 e0 01 00 00	 push	 480			; 000001e0H
  007ee	a1 00 00 00 00	 mov	 eax, DWORD PTR ?yRes@FontMgr@@1HA ; FontMgr::yRes
  007f3	50		 push	 eax
  007f4	68 80 02 00 00	 push	 640			; 00000280H
  007f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes
  007ff	51		 push	 ecx
  00800	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00803	83 c1 14	 add	 ecx, 20			; 00000014H
  00806	e8 00 00 00 00	 call	 ?Scale@SOL_Rect@@QAEXHHHH@Z ; SOL_Rect::Scale
$L62712:

; 240  : 	text = theText;

  0080b	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  0080e	66 8b 45 18	 mov	 ax, WORD PTR _theText$[ebp]
  00812	66 89 42 0e	 mov	 WORD PTR [edx+14], ax

; 241  : 	fore = theFore;

  00816	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00819	66 8b 55 1c	 mov	 dx, WORD PTR _theFore$[ebp]
  0081d	66 89 51 06	 mov	 WORD PTR [ecx+6], dx

; 242  : 	back = theBack;

  00821	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00824	66 8b 4d 20	 mov	 cx, WORD PTR _theBack$[ebp]
  00828	66 89 48 08	 mov	 WORD PTR [eax+8], cx

; 243  : 	skip = theSkip;

  0082c	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  0082f	66 8b 45 24	 mov	 ax, WORD PTR _theSkip$[ebp]
  00833	66 89 42 10	 mov	 WORD PTR [edx+16], ax

; 244  : 	mode = theMode;

  00837	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0083a	66 8b 55 2c	 mov	 dx, WORD PTR _theMode$[ebp]
  0083e	66 89 51 46	 mov	 WORD PTR [ecx+70], dx

; 245  : 	dim = dimIt;

  00842	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00845	66 8b 4d 34	 mov	 cx, WORD PTR _dimIt$[ebp]
  00849	66 89 48 44	 mov	 WORD PTR [eax+68], cx

; 246  : 
; 247  : 	// clip the textbox by the FBM
; 248  : 	SOL_Rect rect(0,0,BMWidth-1,BMHeight-1);

  0084d	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00850	33 c0		 xor	 eax, eax
  00852	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  00856	83 e8 01	 sub	 eax, 1
  00859	50		 push	 eax
  0085a	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0085d	33 d2		 xor	 edx, edx
  0085f	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  00863	83 ea 01	 sub	 edx, 1
  00866	52		 push	 edx
  00867	6a 00		 push	 0
  00869	6a 00		 push	 0
  0086b	8d 4d f0	 lea	 ecx, DWORD PTR _rect$[ebp]
  0086e	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@HHHH@Z	; SOL_Rect::SOL_Rect

; 249  : 	textBox.Clip(rect);

  00873	8d 45 f0	 lea	 eax, DWORD PTR _rect$[ebp]
  00876	50		 push	 eax
  00877	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0087a	83 c1 14	 add	 ecx, 20			; 00000014H
  0087d	e8 00 00 00 00	 call	 ?Clip@SOL_Rect@@QAEXABV1@@Z ; SOL_Rect::Clip

; 250  : 	// allocate memory for the bitmap
; 251  : 	BM.Get(MemBitmap,BMWidth*BMHeight+CELHEADERSIZE);

  00882	6a 00		 push	 0
  00884	6a 00		 push	 0
  00886	6a 00		 push	 0
  00888	6a 00		 push	 0
  0088a	68 00 02 00 00	 push	 512			; 00000200H
  0088f	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00892	33 d2		 xor	 edx, edx
  00894	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  00898	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  0089b	33 c9		 xor	 ecx, ecx
  0089d	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  008a1	0f af d1	 imul	 edx, ecx
  008a4	83 c2 2e	 add	 edx, 46			; 0000002eH
  008a7	52		 push	 edx
  008a8	6a 4b		 push	 75			; 0000004bH
  008aa	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  008ad	83 c1 4e	 add	 ecx, 78			; 0000004eH
  008b0	e8 00 00 00 00	 call	 ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get

; 252  : 
; 253  : 	// build the header for the BM
; 254  : 	BuildHeader(BM,BMWidth,BMHeight,skip,0,0,xRes,yRes);

  008b5	6a 00		 push	 0
  008b7	6a 00		 push	 0
  008b9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?yRes@FontMgr@@1HA ; FontMgr::yRes
  008bf	52		 push	 edx
  008c0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes
  008c5	50		 push	 eax
  008c6	6a 00		 push	 0
  008c8	6a 00		 push	 0
  008ca	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  008cd	33 d2		 xor	 edx, edx
  008cf	66 8b 51 10	 mov	 dx, WORD PTR [ecx+16]
  008d3	52		 push	 edx
  008d4	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  008d7	33 c9		 xor	 ecx, ecx
  008d9	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  008dd	51		 push	 ecx
  008de	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  008e1	33 c0		 xor	 eax, eax
  008e3	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  008e7	50		 push	 eax
  008e8	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  008eb	83 c1 4e	 add	 ecx, 78			; 0000004eH
  008ee	51		 push	 ecx
  008ef	8b d4		 mov	 edx, esp
  008f1	51		 push	 ecx
  008f2	8b ca		 mov	 ecx, edx
  008f4	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  008f9	e8 00 00 00 00	 call	 ?BuildHeader@@YAXVMemID@@HHHHHHHHH@Z ; BuildHeader
  008fe	83 c4 28	 add	 esp, 40			; 00000028H

; 255  : 
; 256  : 	// fill the bitmap with the background color
; 257  : 	Erase(rect,False);

  00901	6a 00		 push	 0
  00903	8d 45 f0	 lea	 eax, DWORD PTR _rect$[ebp]
  00906	50		 push	 eax
  00907	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0090a	e8 00 00 00 00	 call	 ?Erase@FontMgr@@QAEXAAVSOL_Rect@@H@Z ; FontMgr::Erase

; 258  : 
; 259  :    if (theBorderColor != -1) {

  0090f	83 7d 30 ff	 cmp	 DWORD PTR _theBorderColor$[ebp], -1
  00913	74 19		 je	 SHORT $L62715

; 260  : 	   // frame the title box
; 261  : 	   Frame(rect,frameSize,borderColor,False);

  00915	6a 00		 push	 0
  00917	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0091a	8a 51 2c	 mov	 dl, BYTE PTR [ecx+44]
  0091d	52		 push	 edx
  0091e	8b 45 e8	 mov	 eax, DWORD PTR _frameSize$[ebp]
  00921	50		 push	 eax
  00922	8d 4d f0	 lea	 ecx, DWORD PTR _rect$[ebp]
  00925	51		 push	 ecx
  00926	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00929	e8 00 00 00 00	 call	 ?Frame@FontMgr@@QAEXAAVSOL_Rect@@HEH@Z ; FontMgr::Frame
$L62715:

; 263  : 	
; 264  : 	// put the text into the bitmap
; 265  : 	DrawTextBox();

  0092e	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00931	e8 00 00 00 00	 call	 ?DrawTextBox@FontMgr@@QAEXXZ ; FontMgr::DrawTextBox

; 266  : 
; 267  : 	// return the handle to the BM
; 268  : 	return BM;

  00936	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00939	83 c2 4e	 add	 edx, 78			; 0000004eH
  0093c	52		 push	 edx
  0093d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00940	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00945	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 269  : }

  00948	8b e5		 mov	 esp, ebp
  0094a	5d		 pop	 ebp
  0094b	c2 34 00	 ret	 52			; 00000034H
?BuildFBM@FontMgr@@QAE?AVMemID@@HHAAVSOL_Rect@@V2@HHHHHHHH@Z ENDP ; FontMgr::BuildFBM
_TEXT	ENDS
PUBLIC	?TitledFBM@FontMgr@@QAE?AVMemID@@HHAAVSOL_Rect@@V2@HHHHHH1HHHH@Z ; FontMgr::TitledFBM
PUBLIC	?Inset@SOL_Rect@@QAEXHH@Z			; SOL_Rect::Inset
PUBLIC	?TextDimensions@FontMgr@@IAEXHHAAH0@Z		; FontMgr::TextDimensions
EXTRN	?Fatal@MsgMgr@@QAAXPADZZ:NEAR			; MsgMgr::Fatal
EXTRN	?Fatal@MsgMgr@@QAAXDPADHHZZ:NEAR		; MsgMgr::Fatal
EXTRN	?msgMgr@@3PAVMsgMgr@@A:DWORD			; msgMgr
_DATA	SEGMENT
	ORG $+2
$SG62740 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Font'
	DB	'.cpp', 00H
	ORG $+3
$SG62746 DB	'Title too big for window: (%d, %d)  (%d, %d)', 00H
_DATA	ENDS
_TEXT	SEGMENT
_theWidth$ = 12
_theHeight$ = 16
_theTextBox$ = 20
_theText$ = 24
_theFore$ = 28
_theBack$ = 32
_theSkip$ = 36
_theFont$ = 40
_theMode$ = 44
_theBorderColor$ = 48
_theTitleText$ = 52
_theTitleFore$ = 56
_theTitleBack$ = 60
_theTitleFont$ = 64
_scale$ = 68
___$ReturnUdt$ = 8
_this$ = -36
_frameSize$ = -28
_titleWidth$ = -24
_titleHeight$ = -20
_rect$ = -16
?TitledFBM@FontMgr@@QAE?AVMemID@@HHAAVSOL_Rect@@V2@HHHHHH1HHHH@Z PROC NEAR ; FontMgr::TitledFBM

; 292  : {

  0094e	55		 push	 ebp
  0094f	8b ec		 mov	 ebp, esp
  00951	83 ec 24	 sub	 esp, 36			; 00000024H
  00954	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 293  : #ifdef WIN32S
; 294  : 	theFore = AddPalShift(theFore);

  00957	8b 45 1c	 mov	 eax, DWORD PTR _theFore$[ebp]
  0095a	50		 push	 eax
  0095b	e8 00 00 00 00	 call	 ?AddPalShift@@YAHH@Z	; AddPalShift
  00960	83 c4 04	 add	 esp, 4
  00963	89 45 1c	 mov	 DWORD PTR _theFore$[ebp], eax

; 295  : 	theBack = AddPalShift(theBack);

  00966	8b 4d 20	 mov	 ecx, DWORD PTR _theBack$[ebp]
  00969	51		 push	 ecx
  0096a	e8 00 00 00 00	 call	 ?AddPalShift@@YAHH@Z	; AddPalShift
  0096f	83 c4 04	 add	 esp, 4
  00972	89 45 20	 mov	 DWORD PTR _theBack$[ebp], eax

; 296  : 	if (theBorderColor != -1)

  00975	83 7d 30 ff	 cmp	 DWORD PTR _theBorderColor$[ebp], -1
  00979	74 0f		 je	 SHORT $L62735

; 297  : 		theBorderColor = AddPalShift(theBorderColor);

  0097b	8b 55 30	 mov	 edx, DWORD PTR _theBorderColor$[ebp]
  0097e	52		 push	 edx
  0097f	e8 00 00 00 00	 call	 ?AddPalShift@@YAHH@Z	; AddPalShift
  00984	83 c4 04	 add	 esp, 4
  00987	89 45 30	 mov	 DWORD PTR _theBorderColor$[ebp], eax
$L62735:

; 298  : #endif
; 299  : 
; 300  : 	int frameSize = 1;

  0098a	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _frameSize$[ebp], 1

; 301  : 
; 302  :    if (scale) {

  00991	83 7d 44 00	 cmp	 DWORD PTR _scale$[ebp], 0
  00995	74 34		 je	 SHORT $L62737

; 303  : 		BMWidth = theWidth * xRes / SCIRESX;

  00997	8b 45 0c	 mov	 eax, DWORD PTR _theWidth$[ebp]
  0099a	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes
  009a1	99		 cdq
  009a2	b9 80 02 00 00	 mov	 ecx, 640		; 00000280H
  009a7	f7 f9		 idiv	 ecx
  009a9	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  009ac	66 89 42 02	 mov	 WORD PTR [edx+2], ax

; 304  : 		BMHeight = theHeight * yRes / SCIRESY;

  009b0	8b 45 10	 mov	 eax, DWORD PTR _theHeight$[ebp]
  009b3	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR ?yRes@FontMgr@@1HA ; FontMgr::yRes
  009ba	99		 cdq
  009bb	b9 e0 01 00 00	 mov	 ecx, 480		; 000001e0H
  009c0	f7 f9		 idiv	 ecx
  009c2	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  009c5	66 89 42 04	 mov	 WORD PTR [edx+4], ax

; 305  : 	} else {  

  009c9	eb 16		 jmp	 SHORT $L62738
$L62737:

; 306  : 		BMWidth = theWidth;

  009cb	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  009ce	66 8b 4d 0c	 mov	 cx, WORD PTR _theWidth$[ebp]
  009d2	66 89 48 02	 mov	 WORD PTR [eax+2], cx

; 307  : 		BMHeight = theHeight;

  009d6	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  009d9	66 8b 45 10	 mov	 ax, WORD PTR _theHeight$[ebp]
  009dd	66 89 42 04	 mov	 WORD PTR [edx+4], ax
$L62738:

; 309  : 	skip = theSkip;

  009e1	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  009e4	66 8b 55 24	 mov	 dx, WORD PTR _theSkip$[ebp]
  009e8	66 89 51 10	 mov	 WORD PTR [ecx+16], dx

; 310  :    borderColor = theBorderColor;

  009ec	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  009ef	66 8b 4d 30	 mov	 cx, WORD PTR _theBorderColor$[ebp]
  009f3	66 89 48 2c	 mov	 WORD PTR [eax+44], cx

; 311  : 
; 312  :    if (!theTitleText)

  009f7	8d 4d 34	 lea	 ecx, DWORD PTR _theTitleText$[ebp]
  009fa	e8 00 00 00 00	 call	 ??7MemID@@QBEHXZ	; MemID::operator!
  009ff	85 c0		 test	 eax, eax
  00a01	74 1d		 je	 SHORT $L62739

; 313  : 		msgMgr->Fatal(SrcLoc,Msg_NoWindowTitle);

  00a03	6a 5d		 push	 93			; 0000005dH
  00a05	68 39 01 00 00	 push	 313			; 00000139H
  00a0a	68 00 00 00 00	 push	 OFFSET FLAT:$SG62740
  00a0f	6a 61		 push	 97			; 00000061H
  00a11	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00a17	52		 push	 edx
  00a18	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXDPADHHZZ ; MsgMgr::Fatal
  00a1d	83 c4 14	 add	 esp, 20			; 00000014H
$L62739:

; 314  :    // calculate the title size
; 315  :    SetFont(theTitleFont);

  00a20	8b 45 40	 mov	 eax, DWORD PTR _theTitleFont$[ebp]
  00a23	50		 push	 eax
  00a24	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a27	e8 00 00 00 00	 call	 ?SetFont@FontMgr@@QAEXH@Z ; FontMgr::SetFont

; 316  : 	// check title will fit in the given size (adjust for border)
; 317  :    text = theTitleText;

  00a2c	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a2f	66 8b 55 34	 mov	 dx, WORD PTR _theTitleText$[ebp]
  00a33	66 89 51 0e	 mov	 WORD PTR [ecx+14], dx

; 318  : 	int titleWidth;
; 319  : 	int titleHeight;
; 320  : 	TextDimensions(0,10000,titleWidth,titleHeight);

  00a37	8d 45 ec	 lea	 eax, DWORD PTR _titleHeight$[ebp]
  00a3a	50		 push	 eax
  00a3b	8d 4d e8	 lea	 ecx, DWORD PTR _titleWidth$[ebp]
  00a3e	51		 push	 ecx
  00a3f	68 10 27 00 00	 push	 10000			; 00002710H
  00a44	6a 00		 push	 0
  00a46	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a49	e8 00 00 00 00	 call	 ?TextDimensions@FontMgr@@IAEXHHAAH0@Z ; FontMgr::TextDimensions

; 321  : 	titleWidth += 2;

  00a4e	8b 55 e8	 mov	 edx, DWORD PTR _titleWidth$[ebp]
  00a51	83 c2 02	 add	 edx, 2
  00a54	89 55 e8	 mov	 DWORD PTR _titleWidth$[ebp], edx

; 322  : 	titleHeight += 1;

  00a57	8b 45 ec	 mov	 eax, DWORD PTR _titleHeight$[ebp]
  00a5a	83 c0 01	 add	 eax, 1
  00a5d	89 45 ec	 mov	 DWORD PTR _titleHeight$[ebp], eax

; 323  :    if (theBorderColor != -1) {

  00a60	83 7d 30 ff	 cmp	 DWORD PTR _theBorderColor$[ebp], -1
  00a64	74 12		 je	 SHORT $L62743

; 324  :       titleWidth += 2;

  00a66	8b 4d e8	 mov	 ecx, DWORD PTR _titleWidth$[ebp]
  00a69	83 c1 02	 add	 ecx, 2
  00a6c	89 4d e8	 mov	 DWORD PTR _titleWidth$[ebp], ecx

; 325  :       titleHeight += 2;

  00a6f	8b 55 ec	 mov	 edx, DWORD PTR _titleHeight$[ebp]
  00a72	83 c2 02	 add	 edx, 2
  00a75	89 55 ec	 mov	 DWORD PTR _titleHeight$[ebp], edx
$L62743:

; 327  : 
; 328  : 	if (titleWidth > BMWidth || titleHeight > BMHeight)

  00a78	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00a7b	33 c9		 xor	 ecx, ecx
  00a7d	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  00a81	39 4d e8	 cmp	 DWORD PTR _titleWidth$[ebp], ecx
  00a84	7f 0e		 jg	 SHORT $L62745
  00a86	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00a89	33 c0		 xor	 eax, eax
  00a8b	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  00a8f	39 45 ec	 cmp	 DWORD PTR _titleHeight$[ebp], eax
  00a92	7e 30		 jle	 SHORT $L62744
$L62745:

; 330  : 							titleWidth,
; 331  : 							titleHeight,
; 332  : 							BMWidth,
; 333  : 							BMHeight);

  00a94	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a97	33 d2		 xor	 edx, edx
  00a99	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  00a9d	52		 push	 edx
  00a9e	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00aa1	33 c9		 xor	 ecx, ecx
  00aa3	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  00aa7	51		 push	 ecx
  00aa8	8b 55 ec	 mov	 edx, DWORD PTR _titleHeight$[ebp]
  00aab	52		 push	 edx
  00aac	8b 45 e8	 mov	 eax, DWORD PTR _titleWidth$[ebp]
  00aaf	50		 push	 eax
  00ab0	68 00 00 00 00	 push	 OFFSET FLAT:$SG62746
  00ab5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00abb	51		 push	 ecx
  00abc	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00ac1	83 c4 18	 add	 esp, 24			; 00000018H
$L62744:

; 334  : 
; 335  : 	title = theTitleText;

  00ac4	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00ac7	66 8b 45 34	 mov	 ax, WORD PTR _theTitleText$[ebp]
  00acb	66 89 42 24	 mov	 WORD PTR [edx+36], ax

; 336  : 	titleSize = titleHeight;

  00acf	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ad2	66 8b 55 ec	 mov	 dx, WORD PTR _titleHeight$[ebp]
  00ad6	66 89 51 26	 mov	 WORD PTR [ecx+38], dx

; 337  : 	titleFont = theTitleFont;

  00ada	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00add	66 8b 4d 40	 mov	 cx, WORD PTR _theTitleFont$[ebp]
  00ae1	66 89 48 2a	 mov	 WORD PTR [eax+42], cx

; 338  : 	titleFore = theTitleFore;

  00ae5	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00ae8	66 8b 45 38	 mov	 ax, WORD PTR _theTitleFore$[ebp]
  00aec	66 89 42 0a	 mov	 WORD PTR [edx+10], ax

; 339  : 	titleBack = theTitleBack;

  00af0	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00af3	66 8b 55 3c	 mov	 dx, WORD PTR _theTitleBack$[ebp]
  00af7	66 89 51 0c	 mov	 WORD PTR [ecx+12], dx

; 340  : 
; 341  : 	// Draw the title
; 342  : 	text = title;

  00afb	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00afe	66 8b 48 24	 mov	 cx, WORD PTR [eax+36]
  00b02	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00b05	66 89 4a 0e	 mov	 WORD PTR [edx+14], cx

; 343  : 	fore = titleFore;

  00b09	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00b0c	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b0f	66 8b 51 0a	 mov	 dx, WORD PTR [ecx+10]
  00b13	66 89 50 06	 mov	 WORD PTR [eax+6], dx

; 344  : 	back = theBack;

  00b17	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00b1a	66 8b 4d 20	 mov	 cx, WORD PTR _theBack$[ebp]
  00b1e	66 89 48 08	 mov	 WORD PTR [eax+8], cx

; 345  : 	mode = TEJUSTCENTER;

  00b22	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00b25	66 c7 42 46 01
	00		 mov	 WORD PTR [edx+70], 1

; 346  : 	dim = False;

  00b2b	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00b2e	66 c7 40 44 00
	00		 mov	 WORD PTR [eax+68], 0

; 347  : 
; 348  : 	// allocate memory for the bitmap
; 349  : 	BM.Get(MemBitmap,BMWidth*BMHeight+CELHEADERSIZE);

  00b34	6a 00		 push	 0
  00b36	6a 00		 push	 0
  00b38	6a 00		 push	 0
  00b3a	6a 00		 push	 0
  00b3c	68 00 02 00 00	 push	 512			; 00000200H
  00b41	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b44	33 d2		 xor	 edx, edx
  00b46	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  00b4a	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00b4d	33 c9		 xor	 ecx, ecx
  00b4f	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  00b53	0f af d1	 imul	 edx, ecx
  00b56	83 c2 2e	 add	 edx, 46			; 0000002eH
  00b59	52		 push	 edx
  00b5a	6a 4b		 push	 75			; 0000004bH
  00b5c	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b5f	83 c1 4e	 add	 ecx, 78			; 0000004eH
  00b62	e8 00 00 00 00	 call	 ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get

; 350  : 
; 351  : 	// build the header for the BM
; 352  : 	BuildHeader(BM,BMWidth,BMHeight,skip,0,0,xRes,yRes);

  00b67	6a 00		 push	 0
  00b69	6a 00		 push	 0
  00b6b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?yRes@FontMgr@@1HA ; FontMgr::yRes
  00b71	52		 push	 edx
  00b72	a1 00 00 00 00	 mov	 eax, DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes
  00b77	50		 push	 eax
  00b78	6a 00		 push	 0
  00b7a	6a 00		 push	 0
  00b7c	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b7f	33 d2		 xor	 edx, edx
  00b81	66 8b 51 10	 mov	 dx, WORD PTR [ecx+16]
  00b85	52		 push	 edx
  00b86	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00b89	33 c9		 xor	 ecx, ecx
  00b8b	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  00b8f	51		 push	 ecx
  00b90	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00b93	33 c0		 xor	 eax, eax
  00b95	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  00b99	50		 push	 eax
  00b9a	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b9d	83 c1 4e	 add	 ecx, 78			; 0000004eH
  00ba0	51		 push	 ecx
  00ba1	8b d4		 mov	 edx, esp
  00ba3	51		 push	 ecx
  00ba4	8b ca		 mov	 ecx, edx
  00ba6	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00bab	e8 00 00 00 00	 call	 ?BuildHeader@@YAXVMemID@@HHHHHHHHH@Z ; BuildHeader
  00bb0	83 c4 28	 add	 esp, 40			; 00000028H

; 353  : 
; 354  : 	// fill the bitmap with the back ground color
; 355  : 	textBox.A.x = 0;

  00bb3	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00bb6	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 356  : 	textBox.A.y = 0;

  00bbd	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00bc0	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 357  : 	textBox.B.x = BMWidth - 1;

  00bc7	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00bca	33 c0		 xor	 eax, eax
  00bcc	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  00bd0	83 e8 01	 sub	 eax, 1
  00bd3	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00bd6	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 358  : 	textBox.B.y = BMHeight - 1;

  00bd9	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00bdc	33 c0		 xor	 eax, eax
  00bde	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  00be2	83 e8 01	 sub	 eax, 1
  00be5	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00be8	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 359  : 
; 360  : 	Erase(textBox,False);

  00beb	6a 00		 push	 0
  00bed	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00bf0	83 c2 14	 add	 edx, 20			; 00000014H
  00bf3	52		 push	 edx
  00bf4	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00bf7	e8 00 00 00 00	 call	 ?Erase@FontMgr@@QAEXAAVSOL_Rect@@H@Z ; FontMgr::Erase

; 361  : 
; 362  : 	back = titleBack;

  00bfc	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00bff	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c02	66 8b 51 0c	 mov	 dx, WORD PTR [ecx+12]
  00c06	66 89 50 08	 mov	 WORD PTR [eax+8], dx

; 363  : 	textBox.B.y = titleSize - 1;

  00c0a	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00c0d	33 c9		 xor	 ecx, ecx
  00c0f	66 8b 48 26	 mov	 cx, WORD PTR [eax+38]
  00c13	83 e9 01	 sub	 ecx, 1
  00c16	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00c19	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 364  : 	Erase(textBox,False);

  00c1c	6a 00		 push	 0
  00c1e	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00c21	83 c0 14	 add	 eax, 20			; 00000014H
  00c24	50		 push	 eax
  00c25	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c28	e8 00 00 00 00	 call	 ?Erase@FontMgr@@QAEXAAVSOL_Rect@@H@Z ; FontMgr::Erase

; 365  : 
; 366  :    if (theBorderColor != -1) {

  00c2d	83 7d 30 ff	 cmp	 DWORD PTR _theBorderColor$[ebp], -1
  00c31	74 35		 je	 SHORT $L62748

; 367  : 	   // frame the title box
; 368  : 	   Frame(textBox,frameSize,borderColor,False);

  00c33	6a 00		 push	 0
  00c35	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c38	8a 51 2c	 mov	 dl, BYTE PTR [ecx+44]
  00c3b	52		 push	 edx
  00c3c	8b 45 e4	 mov	 eax, DWORD PTR _frameSize$[ebp]
  00c3f	50		 push	 eax
  00c40	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c43	83 c1 14	 add	 ecx, 20			; 00000014H
  00c46	51		 push	 ecx
  00c47	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c4a	e8 00 00 00 00	 call	 ?Frame@FontMgr@@QAEXAAVSOL_Rect@@HEH@Z ; FontMgr::Frame

; 369  : 	   // reduce the title box by the frame
; 370  : 	   textBox.Inset(frameSize+1,frameSize+1);

  00c4f	8b 55 e4	 mov	 edx, DWORD PTR _frameSize$[ebp]
  00c52	83 c2 01	 add	 edx, 1
  00c55	52		 push	 edx
  00c56	8b 45 e4	 mov	 eax, DWORD PTR _frameSize$[ebp]
  00c59	83 c0 01	 add	 eax, 1
  00c5c	50		 push	 eax
  00c5d	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c60	83 c1 14	 add	 ecx, 20			; 00000014H
  00c63	e8 00 00 00 00	 call	 ?Inset@SOL_Rect@@QAEXHH@Z ; SOL_Rect::Inset
$L62748:

; 372  : 
; 373  : 	// put the text into the bitmap
; 374  : 	DrawTextBox();

  00c68	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c6b	e8 00 00 00 00	 call	 ?DrawTextBox@FontMgr@@QAEXXZ ; FontMgr::DrawTextBox

; 375  : 
; 376  : 	text = theText;

  00c70	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c73	66 8b 55 18	 mov	 dx, WORD PTR _theText$[ebp]
  00c77	66 89 51 0e	 mov	 WORD PTR [ecx+14], dx

; 377  : 	back = theBack;

  00c7b	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00c7e	66 8b 4d 20	 mov	 cx, WORD PTR _theBack$[ebp]
  00c82	66 89 48 08	 mov	 WORD PTR [eax+8], cx

; 378  : 	fore = theFore;

  00c86	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00c89	66 8b 45 1c	 mov	 ax, WORD PTR _theFore$[ebp]
  00c8d	66 89 42 06	 mov	 WORD PTR [edx+6], ax

; 379  : 	mode = theMode;

  00c91	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c94	66 8b 55 2c	 mov	 dx, WORD PTR _theMode$[ebp]
  00c98	66 89 51 46	 mov	 WORD PTR [ecx+70], dx

; 380  : 	textBox = theTextBox;

  00c9c	8b 45 14	 mov	 eax, DWORD PTR _theTextBox$[ebp]
  00c9f	50		 push	 eax
  00ca0	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ca3	83 c1 14	 add	 ecx, 20			; 00000014H
  00ca6	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 381  :    if(scale)

  00cab	83 7d 44 00	 cmp	 DWORD PTR _scale$[ebp], 0
  00caf	74 23		 je	 SHORT $L62749

; 382  : 		textBox.Scale(xRes,SCIRESX,yRes,SCIRESY);

  00cb1	68 e0 01 00 00	 push	 480			; 000001e0H
  00cb6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?yRes@FontMgr@@1HA ; FontMgr::yRes
  00cbc	51		 push	 ecx
  00cbd	68 80 02 00 00	 push	 640			; 00000280H
  00cc2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes
  00cc8	52		 push	 edx
  00cc9	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ccc	83 c1 14	 add	 ecx, 20			; 00000014H
  00ccf	e8 00 00 00 00	 call	 ?Scale@SOL_Rect@@QAEXHHHH@Z ; SOL_Rect::Scale
$L62749:

; 383  : 
; 384  : 	SetFont(theFont);

  00cd4	8b 45 28	 mov	 eax, DWORD PTR _theFont$[ebp]
  00cd7	50		 push	 eax
  00cd8	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00cdb	e8 00 00 00 00	 call	 ?SetFont@FontMgr@@QAEXH@Z ; FontMgr::SetFont

; 385  : 
; 386  : 	// clip the textbox by the non title area
; 387  : 	SOL_Rect rect(0,titleSize-1,BMWidth-1,BMHeight-1);

  00ce0	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ce3	33 d2		 xor	 edx, edx
  00ce5	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  00ce9	83 ea 01	 sub	 edx, 1
  00cec	52		 push	 edx
  00ced	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00cf0	33 c9		 xor	 ecx, ecx
  00cf2	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  00cf6	83 e9 01	 sub	 ecx, 1
  00cf9	51		 push	 ecx
  00cfa	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00cfd	33 c0		 xor	 eax, eax
  00cff	66 8b 42 26	 mov	 ax, WORD PTR [edx+38]
  00d03	83 e8 01	 sub	 eax, 1
  00d06	50		 push	 eax
  00d07	6a 00		 push	 0
  00d09	8d 4d f0	 lea	 ecx, DWORD PTR _rect$[ebp]
  00d0c	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@HHHH@Z	; SOL_Rect::SOL_Rect

; 388  : 	textBox.Clip(rect);

  00d11	8d 4d f0	 lea	 ecx, DWORD PTR _rect$[ebp]
  00d14	51		 push	 ecx
  00d15	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d18	83 c1 14	 add	 ecx, 20			; 00000014H
  00d1b	e8 00 00 00 00	 call	 ?Clip@SOL_Rect@@QAEXABV1@@Z ; SOL_Rect::Clip

; 389  : 
; 390  :    if (theBorderColor != -1) {

  00d20	83 7d 30 ff	 cmp	 DWORD PTR _theBorderColor$[ebp], -1
  00d24	74 17		 je	 SHORT $L62751

; 391  : 	   // frame the main box
; 392  : 	   Frame(rect,1,borderColor,False);

  00d26	6a 00		 push	 0
  00d28	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00d2b	8a 42 2c	 mov	 al, BYTE PTR [edx+44]
  00d2e	50		 push	 eax
  00d2f	6a 01		 push	 1
  00d31	8d 4d f0	 lea	 ecx, DWORD PTR _rect$[ebp]
  00d34	51		 push	 ecx
  00d35	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d38	e8 00 00 00 00	 call	 ?Frame@FontMgr@@QAEXAAVSOL_Rect@@HEH@Z ; FontMgr::Frame
$L62751:

; 394  : 
; 395  : 	if (textBox.Ylen() >= pointSize) {

  00d3d	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d40	83 c1 14	 add	 ecx, 20			; 00000014H
  00d43	e8 00 00 00 00	 call	 ?Ylen@SOL_Rect@@QBEHXZ	; SOL_Rect::Ylen
  00d48	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00d4b	33 c9		 xor	 ecx, ecx
  00d4d	66 8b 4a 4c	 mov	 cx, WORD PTR [edx+76]
  00d51	3b c1		 cmp	 eax, ecx
  00d53	7c 08		 jl	 SHORT $L62752

; 396  : 		// put the text into the bitmap
; 397  : 		DrawTextBox();

  00d55	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d58	e8 00 00 00 00	 call	 ?DrawTextBox@FontMgr@@QAEXXZ ; FontMgr::DrawTextBox
$L62752:

; 399  : 
; 400  : 	// return the handle to the BM
; 401  : 	return BM;

  00d5d	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00d60	83 c2 4e	 add	 edx, 78			; 0000004eH
  00d63	52		 push	 edx
  00d64	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00d67	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00d6c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 402  : }

  00d6f	8b e5		 mov	 esp, ebp
  00d71	5d		 pop	 ebp
  00d72	c2 40 00	 ret	 64			; 00000040H
?TitledFBM@FontMgr@@QAE?AVMemID@@HHAAVSOL_Rect@@V2@HHHHHH1HHHH@Z ENDP ; FontMgr::TitledFBM
_TEXT	ENDS
EXTRN	__descPtrTable:BYTE
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -4
?GetAddr@MemoryMgr@@QAEPAXG@Z PROC NEAR			; MemoryMgr::GetAddr, COMDAT

; 462  : 	inline void* MemoryMgr::GetAddr(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : //		CheckValid(theID);
; 464  : 		return _descPtrTable[(unsigned int)((unsigned short)theID)];

  00007	8b 45 08	 mov	 eax, DWORD PTR _theID$[ebp]
  0000a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0000f	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR __descPtrTable[eax*4]

; 465  : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?GetAddr@MemoryMgr@@QAEPAXG@Z ENDP			; MemoryMgr::GetAddr
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0MemID@@QAE@ABV0@@Z PROC NEAR				; MemID::MemID, COMDAT

; 19   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  0000d	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00010	66 89 10	 mov	 WORD PTR [eax], dx

; 20   : 	}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0MemID@@QAE@ABV0@@Z ENDP				; MemID::MemID
_TEXT	ENDS
EXTRN	?Alloc@MemoryMgr@@QAEGIIIPAUMemClient@@DW4ReservedHandle@@@Z:NEAR ; MemoryMgr::Alloc
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT
_type$ = 8
_size$ = 12
_a$ = 16
_num$ = 20
_client$ = 24
_initChar$ = 28
_h$ = 32
_this$ = -4
?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z PROC NEAR ; MemID::Get, COMDAT

; 42   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 43   : 		handle = memMgr->Alloc(type | a, size, num, client, initChar, h);

  00007	8b 45 20	 mov	 eax, DWORD PTR _h$[ebp]
  0000a	50		 push	 eax
  0000b	8a 4d 1c	 mov	 cl, BYTE PTR _initChar$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 18	 mov	 edx, DWORD PTR _client$[ebp]
  00012	52		 push	 edx
  00013	8b 45 14	 mov	 eax, DWORD PTR _num$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 55 08	 mov	 edx, DWORD PTR _type$[ebp]
  0001e	0b 55 10	 or	 edx, DWORD PTR _a$[ebp]
  00021	52		 push	 edx
  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00028	e8 00 00 00 00	 call	 ?Alloc@MemoryMgr@@QAEGIIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemoryMgr::Alloc
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	66 89 01	 mov	 WORD PTR [ecx], ax

; 44   : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 1c 00	 ret	 28			; 0000001cH
?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ENDP ; MemID::Get
_TEXT	ENDS
PUBLIC	?DeleteFBM@FontMgr@@QAEXVMemID@@@Z		; FontMgr::DeleteFBM
_TEXT	SEGMENT
_theBM$ = 8
_this$ = -4
?DeleteFBM@FontMgr@@QAEXVMemID@@@Z PROC NEAR		; FontMgr::DeleteFBM

; 406  : {

  00d75	55		 push	 ebp
  00d76	8b ec		 mov	 ebp, esp
  00d78	51		 push	 ecx
  00d79	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 407  : 	memMgr->Free(theBM);

  00d7c	8d 4d 08	 lea	 ecx, DWORD PTR _theBM$[ebp]
  00d7f	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00d84	50		 push	 eax
  00d85	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00d8b	e8 00 00 00 00	 call	 ?Free@MemoryMgr@@QAEXG@Z ; MemoryMgr::Free

; 408  : }

  00d90	8b e5		 mov	 esp, ebp
  00d92	5d		 pop	 ebp
  00d93	c2 04 00	 ret	 4
?DeleteFBM@FontMgr@@QAEXVMemID@@@Z ENDP			; FontMgr::DeleteFBM
_TEXT	ENDS
PUBLIC	??DMemID@@QBEPAXXZ				; MemID::operator*
PUBLIC	?ResizeBitMap@FontMgr@@QAEXVSOL_Rect@@H@Z	; FontMgr::ResizeBitMap
PUBLIC	?IsEmpty@SOL_Rect@@QBEHXZ			; SOL_Rect::IsEmpty
EXTRN	?Realloc@MemoryMgr@@QAEXGI@Z:NEAR		; MemoryMgr::Realloc
_DATA	SEGMENT
	ORG $+3
$SG62766 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Font'
	DB	'.cpp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_newRect$ = 8
_scale$ = 24
_this$ = -36
_frameSize$ = -4
_celPtr$62768 = -8
_saveText$62771 = -24
_saveFont$62772 = -20
_saveFore$62773 = -28
_saveBack$62774 = -16
_saveMode$62775 = -12
?ResizeBitMap@FontMgr@@QAEXVSOL_Rect@@H@Z PROC NEAR	; FontMgr::ResizeBitMap

; 412  : {

  00d96	55		 push	 ebp
  00d97	8b ec		 mov	 ebp, esp
  00d99	83 ec 24	 sub	 esp, 36			; 00000024H
  00d9c	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 413  : 	int frameSize = 1;

  00d9f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _frameSize$[ebp], 1

; 414  : 
; 415  :    if (scale)

  00da6	83 7d 18 00	 cmp	 DWORD PTR _scale$[ebp], 0
  00daa	74 1f		 je	 SHORT $L62763

; 416  : 		newRect.Scale(xRes,SCIRESX,yRes,SCIRESY);

  00dac	68 e0 01 00 00	 push	 480			; 000001e0H
  00db1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?yRes@FontMgr@@1HA ; FontMgr::yRes
  00db6	50		 push	 eax
  00db7	68 80 02 00 00	 push	 640			; 00000280H
  00dbc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes
  00dc2	51		 push	 ecx
  00dc3	8d 4d 08	 lea	 ecx, DWORD PTR _newRect$[ebp]
  00dc6	e8 00 00 00 00	 call	 ?Scale@SOL_Rect@@QAEXHHHH@Z ; SOL_Rect::Scale
$L62763:

; 417  : 
; 418  : 	// Assume the textBox is what's left 
; 419  : 	// after the title area is removed.
; 420  : 	// Assume dim is False.
; 421  : 	if (!newRect.IsEmpty()) {

  00dcb	8d 4d 08	 lea	 ecx, DWORD PTR _newRect$[ebp]
  00dce	e8 00 00 00 00	 call	 ?IsEmpty@SOL_Rect@@QBEHXZ ; SOL_Rect::IsEmpty
  00dd3	85 c0		 test	 eax, eax
  00dd5	0f 85 ea 02 00
	00		 jne	 $L62780

; 422  : 		// ReAlloc the memory 
; 423  : 		BMWidth = newRect.Xlen();

  00ddb	8d 4d 08	 lea	 ecx, DWORD PTR _newRect$[ebp]
  00dde	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  00de3	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00de6	66 89 42 02	 mov	 WORD PTR [edx+2], ax

; 424  : 		BMHeight = newRect.Ylen();

  00dea	8d 4d 08	 lea	 ecx, DWORD PTR _newRect$[ebp]
  00ded	e8 00 00 00 00	 call	 ?Ylen@SOL_Rect@@QBEHXZ	; SOL_Rect::Ylen
  00df2	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00df5	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 425  : 
; 426  : 		if (titleSize >= BMHeight)

  00df9	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00dfc	33 c0		 xor	 eax, eax
  00dfe	66 8b 42 26	 mov	 ax, WORD PTR [edx+38]
  00e02	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e05	33 d2		 xor	 edx, edx
  00e07	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  00e0b	3b c2		 cmp	 eax, edx
  00e0d	7c 1c		 jl	 SHORT $L62765

; 427  : 			msgMgr->Fatal(SrcLoc,Msg_WindowTitleTooBig);

  00e0f	6a 41		 push	 65			; 00000041H
  00e11	68 ab 01 00 00	 push	 427			; 000001abH
  00e16	68 00 00 00 00	 push	 OFFSET FLAT:$SG62766
  00e1b	6a 61		 push	 97			; 00000061H
  00e1d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00e22	50		 push	 eax
  00e23	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXDPADHHZZ ; MsgMgr::Fatal
  00e28	83 c4 14	 add	 esp, 20			; 00000014H
$L62765:

; 428  : 		memMgr->Realloc(BM,BMWidth*BMHeight+CELHEADERSIZE);

  00e2b	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e2e	33 d2		 xor	 edx, edx
  00e30	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  00e34	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00e37	33 c9		 xor	 ecx, ecx
  00e39	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  00e3d	0f af d1	 imul	 edx, ecx
  00e40	83 c2 2e	 add	 edx, 46			; 0000002eH
  00e43	52		 push	 edx
  00e44	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e47	83 c1 4e	 add	 ecx, 78			; 0000004eH
  00e4a	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00e4f	50		 push	 eax
  00e50	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00e56	e8 00 00 00 00	 call	 ?Realloc@MemoryMgr@@QAEXGI@Z ; MemoryMgr::Realloc

; 429  : 
; 430  : 		// build the header for the BM
; 431  : 		BuildHeader(BM,BMWidth,BMHeight,skip,0,0,xRes,yRes);

  00e5b	6a 00		 push	 0
  00e5d	6a 00		 push	 0
  00e5f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?yRes@FontMgr@@1HA ; FontMgr::yRes
  00e65	52		 push	 edx
  00e66	a1 00 00 00 00	 mov	 eax, DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes
  00e6b	50		 push	 eax
  00e6c	6a 00		 push	 0
  00e6e	6a 00		 push	 0
  00e70	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e73	33 d2		 xor	 edx, edx
  00e75	66 8b 51 10	 mov	 dx, WORD PTR [ecx+16]
  00e79	52		 push	 edx
  00e7a	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00e7d	33 c9		 xor	 ecx, ecx
  00e7f	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  00e83	51		 push	 ecx
  00e84	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00e87	33 c0		 xor	 eax, eax
  00e89	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  00e8d	50		 push	 eax
  00e8e	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e91	83 c1 4e	 add	 ecx, 78			; 0000004eH
  00e94	51		 push	 ecx
  00e95	8b d4		 mov	 edx, esp
  00e97	51		 push	 ecx
  00e98	8b ca		 mov	 ecx, edx
  00e9a	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00e9f	e8 00 00 00 00	 call	 ?BuildHeader@@YAXVMemID@@HHHHHHHHH@Z ; BuildHeader
  00ea4	83 c4 28	 add	 esp, 40			; 00000028H

; 432  : 	   CelHeader* celPtr = (CelHeader*) *BM;

  00ea7	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00eaa	83 c1 4e	 add	 ecx, 78			; 0000004eH
  00ead	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  00eb2	89 45 f8	 mov	 DWORD PTR _celPtr$62768[ebp], eax

; 433  : 
; 434  : 		// fill the bitmap with the back ground color
; 435  : 		Erase(newRect,False);

  00eb5	6a 00		 push	 0
  00eb7	8d 45 08	 lea	 eax, DWORD PTR _newRect$[ebp]
  00eba	50		 push	 eax
  00ebb	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ebe	e8 00 00 00 00	 call	 ?Erase@FontMgr@@QAEXAAVSOL_Rect@@H@Z ; FontMgr::Erase

; 436  : 
; 437  : 		// Is there a title
; 438  : 		if (titleSize) {

  00ec3	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ec6	33 d2		 xor	 edx, edx
  00ec8	66 8b 51 26	 mov	 dx, WORD PTR [ecx+38]
  00ecc	85 d2		 test	 edx, edx
  00ece	0f 84 57 01 00
	00		 je	 $L62770

; 439  : 			// Save the text info
; 440  : 			MemID saveText = text;

  00ed4	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00ed7	83 c0 0e	 add	 eax, 14			; 0000000eH
  00eda	50		 push	 eax
  00edb	8d 4d e8	 lea	 ecx, DWORD PTR _saveText$62771[ebp]
  00ede	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID

; 441  : 			ushort saveFont = font;

  00ee3	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ee6	66 8b 51 28	 mov	 dx, WORD PTR [ecx+40]
  00eea	66 89 55 ec	 mov	 WORD PTR _saveFont$62772[ebp], dx

; 442  : 			ushort saveFore = fore;

  00eee	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00ef1	66 8b 48 06	 mov	 cx, WORD PTR [eax+6]
  00ef5	66 89 4d e4	 mov	 WORD PTR _saveFore$62773[ebp], cx

; 443  : 			ushort saveBack = back;

  00ef9	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00efc	66 8b 42 08	 mov	 ax, WORD PTR [edx+8]
  00f00	66 89 45 f0	 mov	 WORD PTR _saveBack$62774[ebp], ax

; 444  : 			short saveMode = mode;

  00f04	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f07	66 8b 51 46	 mov	 dx, WORD PTR [ecx+70]
  00f0b	66 89 55 f4	 mov	 WORD PTR _saveMode$62775[ebp], dx

; 445  : 
; 446  : 			// Draw the title
; 447  : 			textBox.A.x = 0;

  00f0f	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00f12	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 448  : 			textBox.A.y = 0;

  00f19	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f1c	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 449  : 			textBox.B.x = newRect.Xlen() - 1;

  00f23	8d 4d 08	 lea	 ecx, DWORD PTR _newRect$[ebp]
  00f26	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  00f2b	83 e8 01	 sub	 eax, 1
  00f2e	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00f31	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 450  : 			textBox.B.y = titleSize - 1;

  00f34	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00f37	33 c9		 xor	 ecx, ecx
  00f39	66 8b 48 26	 mov	 cx, WORD PTR [eax+38]
  00f3d	83 e9 01	 sub	 ecx, 1
  00f40	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00f43	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 451  : 			text = title;

  00f46	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00f49	66 8b 48 24	 mov	 cx, WORD PTR [eax+36]
  00f4d	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00f50	66 89 4a 0e	 mov	 WORD PTR [edx+14], cx

; 452  : 			SetFont (titleFont);

  00f54	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00f57	33 c9		 xor	 ecx, ecx
  00f59	66 8b 48 2a	 mov	 cx, WORD PTR [eax+42]
  00f5d	51		 push	 ecx
  00f5e	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f61	e8 00 00 00 00	 call	 ?SetFont@FontMgr@@QAEXH@Z ; FontMgr::SetFont

; 453  : 			fore = titleFore;

  00f66	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00f69	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00f6c	66 8b 48 0a	 mov	 cx, WORD PTR [eax+10]
  00f70	66 89 4a 06	 mov	 WORD PTR [edx+6], cx

; 454  : 			back = titleBack;

  00f74	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00f77	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00f7a	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  00f7e	66 89 4a 08	 mov	 WORD PTR [edx+8], cx

; 455  : 			mode = TEJUSTCENTER;

  00f82	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00f85	66 c7 42 46 01
	00		 mov	 WORD PTR [edx+70], 1

; 456  : 			dim = False;

  00f8b	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00f8e	66 c7 40 44 00
	00		 mov	 WORD PTR [eax+68], 0

; 457  : 
; 458  : 			Erase(textBox,False);

  00f94	6a 00		 push	 0
  00f96	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f99	83 c1 14	 add	 ecx, 20			; 00000014H
  00f9c	51		 push	 ecx
  00f9d	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00fa0	e8 00 00 00 00	 call	 ?Erase@FontMgr@@QAEXAAVSOL_Rect@@H@Z ; FontMgr::Erase

; 459  : 
; 460  : 	 if (borderColor != (ushort)-1) {

  00fa5	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00fa8	33 c0		 xor	 eax, eax
  00faa	66 8b 42 2c	 mov	 ax, WORD PTR [edx+44]
  00fae	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00fb3	74 30		 je	 SHORT $L62777

; 461  : 			   // frame the title box
; 462  : 			   Frame(textBox,frameSize,SOL_BLACK,False);

  00fb5	6a 00		 push	 0
  00fb7	6a 00		 push	 0
  00fb9	8b 4d fc	 mov	 ecx, DWORD PTR _frameSize$[ebp]
  00fbc	51		 push	 ecx
  00fbd	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00fc0	83 c2 14	 add	 edx, 20			; 00000014H
  00fc3	52		 push	 edx
  00fc4	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00fc7	e8 00 00 00 00	 call	 ?Frame@FontMgr@@QAEXAAVSOL_Rect@@HEH@Z ; FontMgr::Frame

; 463  : 			   // reduce the title box by the frame
; 464  : 				textBox.Inset(frameSize+1,frameSize+1);

  00fcc	8b 45 fc	 mov	 eax, DWORD PTR _frameSize$[ebp]
  00fcf	83 c0 01	 add	 eax, 1
  00fd2	50		 push	 eax
  00fd3	8b 4d fc	 mov	 ecx, DWORD PTR _frameSize$[ebp]
  00fd6	83 c1 01	 add	 ecx, 1
  00fd9	51		 push	 ecx
  00fda	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00fdd	83 c1 14	 add	 ecx, 20			; 00000014H
  00fe0	e8 00 00 00 00	 call	 ?Inset@SOL_Rect@@QAEXHH@Z ; SOL_Rect::Inset
$L62777:

; 466  : 
; 467  : 			// put the title text into the bitmap
; 468  : 			DrawTextBox();

  00fe5	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00fe8	e8 00 00 00 00	 call	 ?DrawTextBox@FontMgr@@QAEXXZ ; FontMgr::DrawTextBox

; 469  : 
; 470  : 			text = saveText;

  00fed	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00ff0	66 8b 45 e8	 mov	 ax, WORD PTR _saveText$62771[ebp]
  00ff4	66 89 42 0e	 mov	 WORD PTR [edx+14], ax

; 471  : 			back = saveBack;

  00ff8	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ffb	66 8b 55 f0	 mov	 dx, WORD PTR _saveBack$62774[ebp]
  00fff	66 89 51 08	 mov	 WORD PTR [ecx+8], dx

; 472  : 			fore = saveFore;

  01003	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  01006	66 8b 4d e4	 mov	 cx, WORD PTR _saveFore$62773[ebp]
  0100a	66 89 48 06	 mov	 WORD PTR [eax+6], cx

; 473  : 			mode = saveMode;

  0100e	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  01011	66 8b 45 f4	 mov	 ax, WORD PTR _saveMode$62775[ebp]
  01015	66 89 42 46	 mov	 WORD PTR [edx+70], ax

; 474  : 			SetFont(saveFont);

  01019	8b 4d ec	 mov	 ecx, DWORD PTR _saveFont$62772[ebp]
  0101c	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  01022	51		 push	 ecx
  01023	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  01026	e8 00 00 00 00	 call	 ?SetFont@FontMgr@@QAEXH@Z ; FontMgr::SetFont
$L62770:

; 476  : 
; 477  : 		// The text box is whats left after the title area is removed
; 478  : 		textBox.A.x = 0;

  0102b	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  0102e	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 479  : 		textBox.A.y = titleSize;

  01035	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  01038	33 c9		 xor	 ecx, ecx
  0103a	66 8b 48 26	 mov	 cx, WORD PTR [eax+38]
  0103e	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  01041	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 480  : 		textBox.B.x = newRect.Xlen() - 1;

  01044	8d 4d 08	 lea	 ecx, DWORD PTR _newRect$[ebp]
  01047	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  0104c	83 e8 01	 sub	 eax, 1
  0104f	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  01052	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 481  : 		textBox.B.y = newRect.Ylen() - 1;

  01055	8d 4d 08	 lea	 ecx, DWORD PTR _newRect$[ebp]
  01058	e8 00 00 00 00	 call	 ?Ylen@SOL_Rect@@QBEHXZ	; SOL_Rect::Ylen
  0105d	83 e8 01	 sub	 eax, 1
  01060	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  01063	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 482  : 
; 483  :       if (borderColor != (ushort)-1) {

  01066	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  01069	33 c9		 xor	 ecx, ecx
  0106b	66 8b 48 2c	 mov	 cx, WORD PTR [eax+44]
  0106f	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  01075	74 2e		 je	 SHORT $L62779

; 484  : 		   // frame the main box
; 485  : 		   Frame(textBox,1,SOL_BLACK,False);

  01077	6a 00		 push	 0
  01079	6a 00		 push	 0
  0107b	6a 01		 push	 1
  0107d	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  01080	83 c2 14	 add	 edx, 20			; 00000014H
  01083	52		 push	 edx
  01084	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  01087	e8 00 00 00 00	 call	 ?Frame@FontMgr@@QAEXAAVSOL_Rect@@HEH@Z ; FontMgr::Frame

; 486  : 		   // reduce the main box by the frame
; 487  : 		   textBox.Inset(frameSize+1,frameSize+1);

  0108c	8b 45 fc	 mov	 eax, DWORD PTR _frameSize$[ebp]
  0108f	83 c0 01	 add	 eax, 1
  01092	50		 push	 eax
  01093	8b 4d fc	 mov	 ecx, DWORD PTR _frameSize$[ebp]
  01096	83 c1 01	 add	 ecx, 1
  01099	51		 push	 ecx
  0109a	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0109d	83 c1 14	 add	 ecx, 20			; 00000014H
  010a0	e8 00 00 00 00	 call	 ?Inset@SOL_Rect@@QAEXHH@Z ; SOL_Rect::Inset
$L62779:

; 489  : 
; 490  : 		if (textBox.Ylen() >= pointSize) {

  010a5	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  010a8	83 c1 14	 add	 ecx, 20			; 00000014H
  010ab	e8 00 00 00 00	 call	 ?Ylen@SOL_Rect@@QBEHXZ	; SOL_Rect::Ylen
  010b0	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  010b3	33 c9		 xor	 ecx, ecx
  010b5	66 8b 4a 4c	 mov	 cx, WORD PTR [edx+76]
  010b9	3b c1		 cmp	 eax, ecx
  010bb	7c 08		 jl	 SHORT $L62780

; 491  : 			// put the text into the bitmap
; 492  : 			DrawTextBox();

  010bd	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  010c0	e8 00 00 00 00	 call	 ?DrawTextBox@FontMgr@@QAEXXZ ; FontMgr::DrawTextBox
$L62780:

; 495  : }

  010c5	8b e5		 mov	 esp, ebp
  010c7	5d		 pop	 ebp
  010c8	c2 14 00	 ret	 20			; 00000014H
?ResizeBitMap@FontMgr@@QAEXVSOL_Rect@@H@Z ENDP		; FontMgr::ResizeBitMap
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4
??BMemID@@QBEGXZ PROC NEAR				; MemID::operator unsigned short, COMDAT

; 93   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   : 		return handle;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 00	 mov	 ax, WORD PTR [eax]

; 95   : 	}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??BMemID@@QBEGXZ ENDP					; MemID::operator unsigned short
_TEXT	ENDS
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT
_this$ = -4
??DMemID@@QBEPAXXZ PROC NEAR				; MemID::operator*, COMDAT

; 98   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 99   : 		return memMgr->GetAddr(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr

; 100  : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??DMemID@@QBEPAXXZ ENDP					; MemID::operator*
_TEXT	ENDS
;	COMDAT ??7MemID@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
??7MemID@@QBEHXZ PROC NEAR				; MemID::operator!, COMDAT

; 118  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 119  : 		return handle == 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000f	8b c1		 mov	 eax, ecx
  00011	f7 d8		 neg	 eax
  00013	1b c0		 sbb	 eax, eax
  00015	40		 inc	 eax

; 120  : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??7MemID@@QBEHXZ ENDP					; MemID::operator!
_TEXT	ENDS
_TEXT	SEGMENT
_theFont$ = 8
_this$ = -4
?SetFont@FontMgr@@QAEXH@Z PROC NEAR			; FontMgr::SetFont

; 499  : {

  010cb	55		 push	 ebp
  010cc	8b ec		 mov	 ebp, esp
  010ce	51		 push	 ecx
  010cf	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 500  : 	// Build the font table containing the font widths
; 501  : 	BuildFontTable(theFont);

  010d2	8b 45 08	 mov	 eax, DWORD PTR _theFont$[ebp]
  010d5	50		 push	 eax
  010d6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  010d9	e8 00 00 00 00	 call	 ?BuildFontTable@FontMgr@@IAEXH@Z ; FontMgr::BuildFontTable

; 502  : }

  010de	8b e5		 mov	 esp, ebp
  010e0	5d		 pop	 ebp
  010e1	c2 04 00	 ret	 4
?SetFont@FontMgr@@QAEXH@Z ENDP				; FontMgr::SetFont
_TEXT	ENDS
PUBLIC	?StringWidth@FontMgr@@QAEHVMemID@@@Z		; FontMgr::StringWidth
_TEXT	SEGMENT
_theString$ = 8
_this$ = -12
_width$ = -4
_height$ = -8
?StringWidth@FontMgr@@QAEHVMemID@@@Z PROC NEAR		; FontMgr::StringWidth

; 506  : {

  010e4	55		 push	 ebp
  010e5	8b ec		 mov	 ebp, esp
  010e7	83 ec 0c	 sub	 esp, 12			; 0000000cH
  010ea	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 507  : 	assert(theString.IsValid());
; 508  : 
; 509  : 	text = theString;

  010ed	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  010f0	66 8b 4d 08	 mov	 cx, WORD PTR _theString$[ebp]
  010f4	66 89 48 0e	 mov	 WORD PTR [eax+14], cx

; 510  : 
; 511  : 	int width;
; 512  : 	int height;
; 513  : 	TextDimensions(0,10000,width,height);

  010f8	8d 55 f8	 lea	 edx, DWORD PTR _height$[ebp]
  010fb	52		 push	 edx
  010fc	8d 45 fc	 lea	 eax, DWORD PTR _width$[ebp]
  010ff	50		 push	 eax
  01100	68 10 27 00 00	 push	 10000			; 00002710H
  01105	6a 00		 push	 0
  01107	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0110a	e8 00 00 00 00	 call	 ?TextDimensions@FontMgr@@IAEXHHAAH0@Z ; FontMgr::TextDimensions

; 514  : 
; 515  : 	return (width*SCIRESX + xRes - 1)/xRes;

  0110f	8b 4d fc	 mov	 ecx, DWORD PTR _width$[ebp]
  01112	69 c9 80 02 00
	00		 imul	 ecx, 640		; 00000280H
  01118	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes
  0111e	8d 44 11 ff	 lea	 eax, DWORD PTR [ecx+edx-1]
  01122	99		 cdq
  01123	f7 3d 00 00 00
	00		 idiv	 DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes

; 516  : }

  01129	8b e5		 mov	 esp, ebp
  0112b	5d		 pop	 ebp
  0112c	c2 04 00	 ret	 4
?StringWidth@FontMgr@@QAEHVMemID@@@Z ENDP		; FontMgr::StringWidth
_TEXT	ENDS
PUBLIC	?TextSize@FontMgr@@QAEXVMemID@@HAAVSOL_Rect@@H@Z ; FontMgr::TextSize
PUBLIC	?GetLongest@FontMgr@@QAEGPAHH@Z			; FontMgr::GetLongest
_TEXT	SEGMENT
_theString$ = 8
_maxSize$ = 12
_theRect$ = 16
_scale$ = 20
_this$ = -60
_DEFAULTWIDE$ = -8
_oldfont$ = -24
_currentfont$ = -16
_oldcolor$ = -12
_currentcolor$ = -20
_oldmode$ = -4
_currentmode$ = -28
_height$62809 = -48
_str$62811 = -32
_longest$62813 = -40
_start$62814 = -44
_end$62815 = -36
_count$62819 = -52
_length$62820 = -56
?TextSize@FontMgr@@QAEXVMemID@@HAAVSOL_Rect@@H@Z PROC NEAR ; FontMgr::TextSize

; 520  : {

  0112f	55		 push	 ebp
  01130	8b ec		 mov	 ebp, esp
  01132	83 ec 3c	 sub	 esp, 60			; 0000003cH
  01135	89 4d c4	 mov	 DWORD PTR _this$[ebp], ecx

; 521  : 	// makes the rect large enough to hold the text string
; 522  : 	assert(theString.IsValid());
; 523  : 
; 524  : 	theRect.A.x = 0;

  01138	8b 45 10	 mov	 eax, DWORD PTR _theRect$[ebp]
  0113b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 525  : 	theRect.B.x = 0;

  01141	8b 4d 10	 mov	 ecx, DWORD PTR _theRect$[ebp]
  01144	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 526  : 	theRect.A.y = 0;

  0114b	8b 55 10	 mov	 edx, DWORD PTR _theRect$[ebp]
  0114e	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 527  : 	theRect.B.y = 0;

  01155	8b 45 10	 mov	 eax, DWORD PTR _theRect$[ebp]
  01158	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 528  : 
; 529  :    maxSize = maxSize * xRes/SCIRESX;

  0115f	8b 45 0c	 mov	 eax, DWORD PTR _maxSize$[ebp]
  01162	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes
  01169	99		 cdq
  0116a	b9 80 02 00 00	 mov	 ecx, 640		; 00000280H
  0116f	f7 f9		 idiv	 ecx
  01171	89 45 0c	 mov	 DWORD PTR _maxSize$[ebp], eax

; 530  : 
; 531  : 	// change to something based on screen dimension
; 532  : 	// I use a formula that maintains compatability with older low res
; 533  : 	int DEFAULTWIDE = 3 * SCIRESX / 5;

  01174	c7 45 f8 80 01
	00 00		 mov	 DWORD PTR _DEFAULTWIDE$[ebp], 384 ; 00000180H

; 534  : 
; 535  : 	// set the width
; 536  : 	//      if maxSize = 0 use DEFAULTWIDE
; 537  : 	//      if maxSize > 0 use maxSize
; 538  : 	//    if maxSize < 0 put all the text on one line
; 539  : 	text = theString;

  0117b	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  0117e	66 8b 45 08	 mov	 ax, WORD PTR _theString$[ebp]
  01182	66 89 42 0e	 mov	 WORD PTR [edx+14], ax

; 540  :    int oldfont = font;

  01186	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  01189	33 d2		 xor	 edx, edx
  0118b	66 8b 51 28	 mov	 dx, WORD PTR [ecx+40]
  0118f	89 55 e8	 mov	 DWORD PTR _oldfont$[ebp], edx

; 541  : 	int currentfont = font;

  01192	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  01195	33 c9		 xor	 ecx, ecx
  01197	66 8b 48 28	 mov	 cx, WORD PTR [eax+40]
  0119b	89 4d f0	 mov	 DWORD PTR _currentfont$[ebp], ecx

; 542  :    int oldcolor = fore;

  0119e	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  011a1	33 c0		 xor	 eax, eax
  011a3	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  011a7	89 45 f4	 mov	 DWORD PTR _oldcolor$[ebp], eax

; 543  : 	int currentcolor = fore;

  011aa	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  011ad	33 d2		 xor	 edx, edx
  011af	66 8b 51 06	 mov	 dx, WORD PTR [ecx+6]
  011b3	89 55 ec	 mov	 DWORD PTR _currentcolor$[ebp], edx

; 544  :    int oldmode = mode;

  011b6	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  011b9	0f bf 48 46	 movsx	 ecx, WORD PTR [eax+70]
  011bd	89 4d fc	 mov	 DWORD PTR _oldmode$[ebp], ecx

; 545  : 	int currentmode = mode;

  011c0	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  011c3	0f bf 42 46	 movsx	 eax, WORD PTR [edx+70]
  011c7	89 45 e4	 mov	 DWORD PTR _currentmode$[ebp], eax

; 546  : 	if (maxSize < 0) {

  011ca	83 7d 0c 00	 cmp	 DWORD PTR _maxSize$[ebp], 0
  011ce	7d 40		 jge	 SHORT $L62807

; 547  : 		// we don't want word wrap
; 548  : 		TextDimensions(0,10000,theRect.B.x,theRect.B.y);

  011d0	8b 4d 10	 mov	 ecx, DWORD PTR _theRect$[ebp]
  011d3	83 c1 0c	 add	 ecx, 12			; 0000000cH
  011d6	51		 push	 ecx
  011d7	8b 55 10	 mov	 edx, DWORD PTR _theRect$[ebp]
  011da	83 c2 08	 add	 edx, 8
  011dd	52		 push	 edx
  011de	68 10 27 00 00	 push	 10000			; 00002710H
  011e3	6a 00		 push	 0
  011e5	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  011e8	e8 00 00 00 00	 call	 ?TextDimensions@FontMgr@@IAEXHHAAH0@Z ; FontMgr::TextDimensions

; 549  : 		theRect.B.x -= 1;

  011ed	8b 45 10	 mov	 eax, DWORD PTR _theRect$[ebp]
  011f0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  011f3	83 e9 01	 sub	 ecx, 1
  011f6	8b 55 10	 mov	 edx, DWORD PTR _theRect$[ebp]
  011f9	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 550  : 		theRect.B.y = pointSize;

  011fc	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  011ff	33 c9		 xor	 ecx, ecx
  01201	66 8b 48 4c	 mov	 cx, WORD PTR [eax+76]
  01205	8b 55 10	 mov	 edx, DWORD PTR _theRect$[ebp]
  01208	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 552  : 	else {

  0120b	e9 79 01 00 00	 jmp	 $L62824
$L62807:

; 553  : 		int height;
; 554  : 		if (!maxSize) maxSize = DEFAULTWIDE * xRes / SCIRESX;

  01210	83 7d 0c 00	 cmp	 DWORD PTR _maxSize$[ebp], 0
  01214	75 15		 jne	 SHORT $L62810
  01216	8b 45 f8	 mov	 eax, DWORD PTR _DEFAULTWIDE$[ebp]
  01219	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes
  01220	99		 cdq
  01221	b9 80 02 00 00	 mov	 ecx, 640		; 00000280H
  01226	f7 f9		 idiv	 ecx
  01228	89 45 0c	 mov	 DWORD PTR _maxSize$[ebp], eax
$L62810:

; 555  : 		theRect.B.x = maxSize - 1;

  0122b	8b 55 0c	 mov	 edx, DWORD PTR _maxSize$[ebp]
  0122e	83 ea 01	 sub	 edx, 1
  01231	8b 45 10	 mov	 eax, DWORD PTR _theRect$[ebp]
  01234	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 556  : 		// get a local pointer to text
; 557  : 		uchar* str = (uchar*) memMgr->GetAddr(text);

  01237	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  0123a	83 c1 0e	 add	 ecx, 14			; 0000000eH
  0123d	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  01242	50		 push	 eax
  01243	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  01249	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr
  0124e	89 45 e0	 mov	 DWORD PTR _str$62811[ebp], eax

; 558  : 
; 559  : 		int longest = 0;

  01251	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _longest$62813[ebp], 0

; 560  : 		int start = 0;

  01258	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _start$62814[ebp], 0

; 561  : 		int end = 0;

  0125f	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _end$62815[ebp], 0
$L62817:

; 562  : 		while (*str){

  01266	8b 4d e0	 mov	 ecx, DWORD PTR _str$62811[ebp]
  01269	33 d2		 xor	 edx, edx
  0126b	8a 11		 mov	 dl, BYTE PTR [ecx]
  0126d	85 d2		 test	 edx, edx
  0126f	0f 84 c7 00 00
	00		 je	 $L62818

; 563  : 			int count = GetLongest(&end,theRect.B.x + 1);

  01275	8b 45 10	 mov	 eax, DWORD PTR _theRect$[ebp]
  01278	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0127b	83 c1 01	 add	 ecx, 1
  0127e	51		 push	 ecx
  0127f	8d 55 dc	 lea	 edx, DWORD PTR _end$62815[ebp]
  01282	52		 push	 edx
  01283	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  01286	e8 00 00 00 00	 call	 ?GetLongest@FontMgr@@QAEGPAHH@Z ; FontMgr::GetLongest
  0128b	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  01290	89 45 cc	 mov	 DWORD PTR _count$62819[ebp], eax

; 564  : 			SetFont(currentfont);

  01293	8b 45 f0	 mov	 eax, DWORD PTR _currentfont$[ebp]
  01296	50		 push	 eax
  01297	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  0129a	e8 00 00 00 00	 call	 ?SetFont@FontMgr@@QAEXH@Z ; FontMgr::SetFont

; 565  : 			mode = currentmode;

  0129f	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  012a2	66 8b 55 e4	 mov	 dx, WORD PTR _currentmode$[ebp]
  012a6	66 89 51 46	 mov	 WORD PTR [ecx+70], dx

; 566  : 	      fore = currentcolor;

  012aa	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  012ad	66 8b 4d ec	 mov	 cx, WORD PTR _currentcolor$[ebp]
  012b1	66 89 48 06	 mov	 WORD PTR [eax+6], cx

; 567  : 			int length;
; 568  : 			TextDimensions(start,count,length,height);

  012b5	8d 55 d0	 lea	 edx, DWORD PTR _height$62809[ebp]
  012b8	52		 push	 edx
  012b9	8d 45 c8	 lea	 eax, DWORD PTR _length$62820[ebp]
  012bc	50		 push	 eax
  012bd	8b 4d cc	 mov	 ecx, DWORD PTR _count$62819[ebp]
  012c0	51		 push	 ecx
  012c1	8b 55 d4	 mov	 edx, DWORD PTR _start$62814[ebp]
  012c4	52		 push	 edx
  012c5	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  012c8	e8 00 00 00 00	 call	 ?TextDimensions@FontMgr@@IAEXHHAAH0@Z ; FontMgr::TextDimensions

; 569  : 			if (length > longest)

  012cd	8b 45 c8	 mov	 eax, DWORD PTR _length$62820[ebp]
  012d0	3b 45 d8	 cmp	 eax, DWORD PTR _longest$62813[ebp]
  012d3	7e 06		 jle	 SHORT $L62821

; 570  : 				longest = length;

  012d5	8b 4d c8	 mov	 ecx, DWORD PTR _length$62820[ebp]
  012d8	89 4d d8	 mov	 DWORD PTR _longest$62813[ebp], ecx
$L62821:

; 571  : 			currentfont = font;

  012db	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  012de	33 c0		 xor	 eax, eax
  012e0	66 8b 42 28	 mov	 ax, WORD PTR [edx+40]
  012e4	89 45 f0	 mov	 DWORD PTR _currentfont$[ebp], eax

; 572  : 			currentmode = mode;

  012e7	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  012ea	0f bf 51 46	 movsx	 edx, WORD PTR [ecx+70]
  012ee	89 55 e4	 mov	 DWORD PTR _currentmode$[ebp], edx

; 573  : 	      currentcolor = fore;

  012f1	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  012f4	33 c9		 xor	 ecx, ecx
  012f6	66 8b 48 06	 mov	 cx, WORD PTR [eax+6]
  012fa	89 4d ec	 mov	 DWORD PTR _currentcolor$[ebp], ecx

; 574  : 			start = end;

  012fd	8b 55 dc	 mov	 edx, DWORD PTR _end$62815[ebp]
  01300	89 55 d4	 mov	 DWORD PTR _start$62814[ebp], edx

; 575  : 			str = (uchar*) memMgr->GetAddr(text) + start;

  01303	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  01306	83 c1 0e	 add	 ecx, 14			; 0000000eH
  01309	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  0130e	50		 push	 eax
  0130f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  01315	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr
  0131a	03 45 d4	 add	 eax, DWORD PTR _start$62814[ebp]
  0131d	89 45 e0	 mov	 DWORD PTR _str$62811[ebp], eax

; 576  : 			theRect.B.y += pointSize;

  01320	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  01323	33 c9		 xor	 ecx, ecx
  01325	66 8b 48 4c	 mov	 cx, WORD PTR [eax+76]
  01329	8b 55 10	 mov	 edx, DWORD PTR _theRect$[ebp]
  0132c	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0132f	03 c1		 add	 eax, ecx
  01331	8b 4d 10	 mov	 ecx, DWORD PTR _theRect$[ebp]
  01334	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 577  : 		}

  01337	e9 2a ff ff ff	 jmp	 $L62817
$L62818:

; 578  : 		theRect.B.y -= 1;

  0133c	8b 55 10	 mov	 edx, DWORD PTR _theRect$[ebp]
  0133f	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  01342	83 e8 01	 sub	 eax, 1
  01345	8b 4d 10	 mov	 ecx, DWORD PTR _theRect$[ebp]
  01348	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 579  : 		if (maxSize > longest)

  0134b	8b 55 0c	 mov	 edx, DWORD PTR _maxSize$[ebp]
  0134e	3b 55 d8	 cmp	 edx, DWORD PTR _longest$62813[ebp]
  01351	7e 0c		 jle	 SHORT $L62823

; 580  : 			theRect.B.x = longest - 1;

  01353	8b 45 d8	 mov	 eax, DWORD PTR _longest$62813[ebp]
  01356	83 e8 01	 sub	 eax, 1
  01359	8b 4d 10	 mov	 ecx, DWORD PTR _theRect$[ebp]
  0135c	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L62823:

; 581  : 		if (height > pointSize)

  0135f	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  01362	33 c0		 xor	 eax, eax
  01364	66 8b 42 4c	 mov	 ax, WORD PTR [edx+76]
  01368	39 45 d0	 cmp	 DWORD PTR _height$62809[ebp], eax
  0136b	7e 1c		 jle	 SHORT $L62824

; 582  : 			theRect.B.y += height - pointSize;

  0136d	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  01370	33 d2		 xor	 edx, edx
  01372	66 8b 51 4c	 mov	 dx, WORD PTR [ecx+76]
  01376	8b 45 d0	 mov	 eax, DWORD PTR _height$62809[ebp]
  01379	2b c2		 sub	 eax, edx
  0137b	8b 4d 10	 mov	 ecx, DWORD PTR _theRect$[ebp]
  0137e	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  01381	03 d0		 add	 edx, eax
  01383	8b 45 10	 mov	 eax, DWORD PTR _theRect$[ebp]
  01386	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$L62824:

; 584  : 	if (scale) {

  01389	83 7d 14 00	 cmp	 DWORD PTR _scale$[ebp], 0
  0138d	74 76		 je	 SHORT $L62825

; 585  : 		theRect.A.x = theRect.A.x * SCIRESX / xRes;

  0138f	8b 4d 10	 mov	 ecx, DWORD PTR _theRect$[ebp]
  01392	8b 01		 mov	 eax, DWORD PTR [ecx]
  01394	69 c0 80 02 00
	00		 imul	 eax, 640		; 00000280H
  0139a	99		 cdq
  0139b	f7 3d 00 00 00
	00		 idiv	 DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes
  013a1	8b 55 10	 mov	 edx, DWORD PTR _theRect$[ebp]
  013a4	89 02		 mov	 DWORD PTR [edx], eax

; 586  : 		theRect.A.y = theRect.A.y * SCIRESY / yRes;

  013a6	8b 45 10	 mov	 eax, DWORD PTR _theRect$[ebp]
  013a9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  013ac	69 c0 e0 01 00
	00		 imul	 eax, 480		; 000001e0H
  013b2	99		 cdq
  013b3	f7 3d 00 00 00
	00		 idiv	 DWORD PTR ?yRes@FontMgr@@1HA ; FontMgr::yRes
  013b9	8b 4d 10	 mov	 ecx, DWORD PTR _theRect$[ebp]
  013bc	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 587  : 		theRect.B.x = (theRect.B.x * SCIRESX + xRes - 1) / xRes;

  013bf	8b 55 10	 mov	 edx, DWORD PTR _theRect$[ebp]
  013c2	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  013c5	69 c0 80 02 00
	00		 imul	 eax, 640		; 00000280H
  013cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes
  013d1	8d 44 08 ff	 lea	 eax, DWORD PTR [eax+ecx-1]
  013d5	99		 cdq
  013d6	f7 3d 00 00 00
	00		 idiv	 DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes
  013dc	8b 55 10	 mov	 edx, DWORD PTR _theRect$[ebp]
  013df	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 588  : 		theRect.B.y = (theRect.B.y * SCIRESY + yRes - 1) / yRes;

  013e2	8b 45 10	 mov	 eax, DWORD PTR _theRect$[ebp]
  013e5	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  013e8	69 c9 e0 01 00
	00		 imul	 ecx, 480		; 000001e0H
  013ee	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?yRes@FontMgr@@1HA ; FontMgr::yRes
  013f4	8d 44 11 ff	 lea	 eax, DWORD PTR [ecx+edx-1]
  013f8	99		 cdq
  013f9	f7 3d 00 00 00
	00		 idiv	 DWORD PTR ?yRes@FontMgr@@1HA ; FontMgr::yRes
  013ff	8b 4d 10	 mov	 ecx, DWORD PTR _theRect$[ebp]
  01402	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$L62825:

; 590  : 	SetFont(oldfont);

  01405	8b 55 e8	 mov	 edx, DWORD PTR _oldfont$[ebp]
  01408	52		 push	 edx
  01409	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  0140c	e8 00 00 00 00	 call	 ?SetFont@FontMgr@@QAEXH@Z ; FontMgr::SetFont

; 591  : 	fore = oldcolor;

  01411	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  01414	66 8b 4d f4	 mov	 cx, WORD PTR _oldcolor$[ebp]
  01418	66 89 48 06	 mov	 WORD PTR [eax+6], cx

; 592  :    mode = oldmode;

  0141c	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  0141f	66 8b 45 fc	 mov	 ax, WORD PTR _oldmode$[ebp]
  01423	66 89 42 46	 mov	 WORD PTR [edx+70], ax

; 593  : }

  01427	8b e5		 mov	 esp, ebp
  01429	5d		 pop	 ebp
  0142a	c2 10 00	 ret	 16			; 00000010H
?TextSize@FontMgr@@QAEXVMemID@@HAAVSOL_Rect@@H@Z ENDP	; FontMgr::TextSize
_TEXT	ENDS
PUBLIC	?TextCount@FontMgr@@QAEHVMemID@@HHAAVSOL_Rect@@H@Z ; FontMgr::TextCount
PUBLIC	?TextCount@FontMgr@@QAEHVMemID@@HAAVSOL_Rect@@H@Z ; FontMgr::TextCount
_TEXT	SEGMENT
_theText$ = 8
_theStart$ = 12
_rect$ = 16
_scale$ = 20
_this$ = -8
?TextCount@FontMgr@@QAEHVMemID@@HAAVSOL_Rect@@H@Z PROC NEAR ; FontMgr::TextCount

; 597  : {

  0142d	55		 push	 ebp
  0142e	8b ec		 mov	 ebp, esp
  01430	83 ec 08	 sub	 esp, 8
  01433	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 598  : 	// The font manager already has the font
; 599  : 	return TextCount(theText,theStart,font,rect,scale);

  01436	8b 45 14	 mov	 eax, DWORD PTR _scale$[ebp]
  01439	50		 push	 eax
  0143a	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  0143d	51		 push	 ecx
  0143e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  01441	33 c0		 xor	 eax, eax
  01443	66 8b 42 28	 mov	 ax, WORD PTR [edx+40]
  01447	50		 push	 eax
  01448	8b 4d 0c	 mov	 ecx, DWORD PTR _theStart$[ebp]
  0144b	51		 push	 ecx
  0144c	51		 push	 ecx
  0144d	8b cc		 mov	 ecx, esp
  0144f	8d 55 08	 lea	 edx, DWORD PTR _theText$[ebp]
  01452	52		 push	 edx
  01453	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  01458	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0145b	e8 00 00 00 00	 call	 ?TextCount@FontMgr@@QAEHVMemID@@HHAAVSOL_Rect@@H@Z ; FontMgr::TextCount

; 600  : }

  01460	8b e5		 mov	 esp, ebp
  01462	5d		 pop	 ebp
  01463	c2 10 00	 ret	 16			; 00000010H
?TextCount@FontMgr@@QAEHVMemID@@HAAVSOL_Rect@@H@Z ENDP	; FontMgr::TextCount
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@HH@Z
_TEXT	SEGMENT
_x$ = 8
_y$ = 12
_this$ = -4
??0SOL_Point@@QAE@HH@Z PROC NEAR			; SOL_Point::SOL_Point, COMDAT

; 21   : 	SOL_Point(Coord x, Coord y) : x(x), y(y) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0SOL_Point@@QAE@HH@Z ENDP				; SOL_Point::SOL_Point
_TEXT	ENDS
PUBLIC	??0SOL_Rect@@QAE@ABV0@@Z			; SOL_Rect::SOL_Rect
_TEXT	SEGMENT
_theText$ = 8
_theStart$ = 12
_theFont$ = 16
_rect$ = 20
_scale$ = 24
_this$ = -40
_count$ = -28
_newRect$ = -16
_oldText$ = -32
_maxPixels$ = -20
_vRun$ = -24
_strOffset$ = -36
?TextCount@FontMgr@@QAEHVMemID@@HHAAVSOL_Rect@@H@Z PROC NEAR ; FontMgr::TextCount

; 604  : {

  01466	55		 push	 ebp
  01467	8b ec		 mov	 ebp, esp
  01469	83 ec 28	 sub	 esp, 40			; 00000028H
  0146c	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx

; 605  : 	// returns the number of characters that will fit into a        rectangle
; 606  : 	// starting at the given character of the text string.
; 607  : 
; 608  : 	int count;
; 609  : 
; 610  : 	SOL_Rect newRect = rect;

  0146f	8b 45 14	 mov	 eax, DWORD PTR _rect$[ebp]
  01472	50		 push	 eax
  01473	8d 4d f0	 lea	 ecx, DWORD PTR _newRect$[ebp]
  01476	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@ABV0@@Z ; SOL_Rect::SOL_Rect

; 611  : 	if (scale)

  0147b	83 7d 18 00	 cmp	 DWORD PTR _scale$[ebp], 0
  0147f	74 20		 je	 SHORT $L62844

; 612  : 		newRect.Scale(xRes,SCIRESX,yRes,SCIRESY);

  01481	68 e0 01 00 00	 push	 480			; 000001e0H
  01486	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?yRes@FontMgr@@1HA ; FontMgr::yRes
  0148c	51		 push	 ecx
  0148d	68 80 02 00 00	 push	 640			; 00000280H
  01492	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes
  01498	52		 push	 edx
  01499	8d 4d f0	 lea	 ecx, DWORD PTR _newRect$[ebp]
  0149c	e8 00 00 00 00	 call	 ?Scale@SOL_Rect@@QAEXHHHH@Z ; SOL_Rect::Scale
$L62844:

; 613  : 
; 614  : 	SetFont(theFont);

  014a1	8b 45 10	 mov	 eax, DWORD PTR _theFont$[ebp]
  014a4	50		 push	 eax
  014a5	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  014a8	e8 00 00 00 00	 call	 ?SetFont@FontMgr@@QAEXH@Z ; FontMgr::SetFont

; 615  : 
; 616  : 	// Save the original text
; 617  : 	MemID oldText = text;

  014ad	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  014b0	83 c1 0e	 add	 ecx, 14			; 0000000eH
  014b3	51		 push	 ecx
  014b4	8d 4d e0	 lea	 ecx, DWORD PTR _oldText$[ebp]
  014b7	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID

; 618  : 	text = theText;

  014bc	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  014bf	66 8b 45 08	 mov	 ax, WORD PTR _theText$[ebp]
  014c3	66 89 42 0e	 mov	 WORD PTR [edx+14], ax

; 619  : 
; 620  : 	int maxPixels = newRect.Xlen();

  014c7	8d 4d f0	 lea	 ecx, DWORD PTR _newRect$[ebp]
  014ca	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  014cf	89 45 ec	 mov	 DWORD PTR _maxPixels$[ebp], eax

; 621  : 
; 622  : 	// Adjust for frame
; 623  : 	int vRun =  (newRect.Ylen()-2)/pointSize;

  014d2	8d 4d f0	 lea	 ecx, DWORD PTR _newRect$[ebp]
  014d5	e8 00 00 00 00	 call	 ?Ylen@SOL_Rect@@QBEHXZ	; SOL_Rect::Ylen
  014da	83 e8 02	 sub	 eax, 2
  014dd	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  014e0	33 d2		 xor	 edx, edx
  014e2	66 8b 51 4c	 mov	 dx, WORD PTR [ecx+76]
  014e6	8b ca		 mov	 ecx, edx
  014e8	99		 cdq
  014e9	f7 f9		 idiv	 ecx
  014eb	89 45 e8	 mov	 DWORD PTR _vRun$[ebp], eax

; 624  : 	int strOffset = theStart;

  014ee	8b 55 0c	 mov	 edx, DWORD PTR _theStart$[ebp]
  014f1	89 55 dc	 mov	 DWORD PTR _strOffset$[ebp], edx

; 625  : 
; 626  : 	for (;vRun>0;--vRun) {

  014f4	eb 09		 jmp	 SHORT $L62849
$L62850:
  014f6	8b 45 e8	 mov	 eax, DWORD PTR _vRun$[ebp]
  014f9	83 e8 01	 sub	 eax, 1
  014fc	89 45 e8	 mov	 DWORD PTR _vRun$[ebp], eax
$L62849:
  014ff	83 7d e8 00	 cmp	 DWORD PTR _vRun$[ebp], 0
  01503	7e 12		 jle	 SHORT $L62851

; 627  : 		GetLongest(&strOffset,maxPixels);

  01505	8b 4d ec	 mov	 ecx, DWORD PTR _maxPixels$[ebp]
  01508	51		 push	 ecx
  01509	8d 55 dc	 lea	 edx, DWORD PTR _strOffset$[ebp]
  0150c	52		 push	 edx
  0150d	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01510	e8 00 00 00 00	 call	 ?GetLongest@FontMgr@@QAEGPAHH@Z ; FontMgr::GetLongest

; 628  : 	}

  01515	eb df		 jmp	 SHORT $L62850
$L62851:

; 629  : 	count = strOffset - theStart;

  01517	8b 45 dc	 mov	 eax, DWORD PTR _strOffset$[ebp]
  0151a	2b 45 0c	 sub	 eax, DWORD PTR _theStart$[ebp]
  0151d	89 45 e4	 mov	 DWORD PTR _count$[ebp], eax

; 630  : 
; 631  : 	text = oldText;

  01520	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01523	66 8b 55 e0	 mov	 dx, WORD PTR _oldText$[ebp]
  01527	66 89 51 0e	 mov	 WORD PTR [ecx+14], dx

; 632  : 
; 633  : 	return count;

  0152b	8b 45 e4	 mov	 eax, DWORD PTR _count$[ebp]

; 634  : }

  0152e	8b e5		 mov	 esp, ebp
  01530	5d		 pop	 ebp
  01531	c2 14 00	 ret	 20			; 00000014H
?TextCount@FontMgr@@QAEHVMemID@@HHAAVSOL_Rect@@H@Z ENDP	; FontMgr::TextCount
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@ABV0@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
??0SOL_Point@@QAE@ABV0@@Z PROC NEAR			; SOL_Point::SOL_Point, COMDAT

; 22   : 	SOL_Point(const SOL_Point& p) : x(p.x), y(p.y) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00017	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001a	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??0SOL_Point@@QAE@ABV0@@Z ENDP				; SOL_Point::SOL_Point
_TEXT	ENDS
_TEXT	SEGMENT
_theRect$ = 8
_scale$ = 12
_this$ = -40
_eraseRect$ = -24
_fontBM$ = -28
_hRun$ = -8
_vRun$ = -4
_drawHere$62864 = -32
_drawHere$62867 = -36
?Erase@FontMgr@@QAEXAAVSOL_Rect@@H@Z PROC NEAR		; FontMgr::Erase

; 638  : {

  01534	55		 push	 ebp
  01535	8b ec		 mov	 ebp, esp
  01537	83 ec 28	 sub	 esp, 40			; 00000028H
  0153a	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx

; 639  : 	// Erase the given rectangle of the BM using the background color
; 640  : 
; 641  : 	SOL_Rect eraseRect = theRect;

  0153d	8b 45 08	 mov	 eax, DWORD PTR _theRect$[ebp]
  01540	50		 push	 eax
  01541	8d 4d e8	 lea	 ecx, DWORD PTR _eraseRect$[ebp]
  01544	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@ABV0@@Z ; SOL_Rect::SOL_Rect

; 642  : 	if (scale)

  01549	83 7d 0c 00	 cmp	 DWORD PTR _scale$[ebp], 0
  0154d	74 20		 je	 SHORT $L62858

; 643  : 		eraseRect.Scale(xRes,SCIRESX,yRes,SCIRESY);

  0154f	68 e0 01 00 00	 push	 480			; 000001e0H
  01554	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?yRes@FontMgr@@1HA ; FontMgr::yRes
  0155a	51		 push	 ecx
  0155b	68 80 02 00 00	 push	 640			; 00000280H
  01560	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes
  01566	52		 push	 edx
  01567	8d 4d e8	 lea	 ecx, DWORD PTR _eraseRect$[ebp]
  0156a	e8 00 00 00 00	 call	 ?Scale@SOL_Rect@@QAEXHHHH@Z ; SOL_Rect::Scale
$L62858:

; 647  : 	fontBM = (CelHeader*) memMgr->GetAddr(BM);

  0156f	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01572	83 c1 4e	 add	 ecx, 78			; 0000004eH
  01575	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  0157a	50		 push	 eax
  0157b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  01581	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr
  01586	89 45 e4	 mov	 DWORD PTR _fontBM$[ebp], eax

; 648  : 	int hRun = eraseRect.Xlen();

  01589	8d 4d e8	 lea	 ecx, DWORD PTR _eraseRect$[ebp]
  0158c	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  01591	89 45 f8	 mov	 DWORD PTR _hRun$[ebp], eax

; 649  : 	int vRun = eraseRect.Ylen();

  01594	8d 4d e8	 lea	 ecx, DWORD PTR _eraseRect$[ebp]
  01597	e8 00 00 00 00	 call	 ?Ylen@SOL_Rect@@QBEHXZ	; SOL_Rect::Ylen
  0159c	89 45 fc	 mov	 DWORD PTR _vRun$[ebp], eax

; 654  : 		(hRun == BMWidth)               &&
; 655  : 		(vRun == BMHeight)
; 656  : 		) {

  0159f	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  015a2	33 c9		 xor	 ecx, ecx
  015a4	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  015a8	39 4d f8	 cmp	 DWORD PTR _hRun$[ebp], ecx
  015ab	75 3a		 jne	 SHORT $L62863
  015ad	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  015b0	33 c0		 xor	 eax, eax
  015b2	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  015b6	39 45 fc	 cmp	 DWORD PTR _vRun$[ebp], eax
  015b9	75 2c		 jne	 SHORT $L62863

; 657  : 		uchar* drawHere = (uchar*) fontBM + fontBM->colorOffset;

  015bb	8b 4d e4	 mov	 ecx, DWORD PTR _fontBM$[ebp]
  015be	8b 55 e4	 mov	 edx, DWORD PTR _fontBM$[ebp]
  015c1	03 51 1c	 add	 edx, DWORD PTR [ecx+28]
  015c4	89 55 e0	 mov	 DWORD PTR _drawHere$62864[ebp], edx

; 658  : 		memset(drawHere,back,hRun*vRun);

  015c7	8b 45 f8	 mov	 eax, DWORD PTR _hRun$[ebp]
  015ca	0f af 45 fc	 imul	 eax, DWORD PTR _vRun$[ebp]
  015ce	50		 push	 eax
  015cf	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  015d2	33 d2		 xor	 edx, edx
  015d4	66 8b 51 08	 mov	 dx, WORD PTR [ecx+8]
  015d8	52		 push	 edx
  015d9	8b 45 e0	 mov	 eax, DWORD PTR _drawHere$62864[ebp]
  015dc	50		 push	 eax
  015dd	e8 00 00 00 00	 call	 _memset
  015e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 660  : 	else {

  015e5	eb 5d		 jmp	 SHORT $L62871
$L62863:

; 661  : 		uchar * drawHere = (uchar*) fontBM + fontBM->colorOffset + BMWidth*eraseRect.A.y + eraseRect.A.x;

  015e7	8b 4d e4	 mov	 ecx, DWORD PTR _fontBM$[ebp]
  015ea	8b 55 e4	 mov	 edx, DWORD PTR _fontBM$[ebp]
  015ed	03 51 1c	 add	 edx, DWORD PTR [ecx+28]
  015f0	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  015f3	33 c9		 xor	 ecx, ecx
  015f5	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  015f9	0f af 4d ec	 imul	 ecx, DWORD PTR _eraseRect$[ebp+4]
  015fd	8b 45 e8	 mov	 eax, DWORD PTR _eraseRect$[ebp]
  01600	03 c2		 add	 eax, edx
  01602	03 c8		 add	 ecx, eax
  01604	89 4d dc	 mov	 DWORD PTR _drawHere$62867[ebp], ecx
$L62870:

; 662  : 		while (vRun--) {

  01607	8b 4d fc	 mov	 ecx, DWORD PTR _vRun$[ebp]
  0160a	8b 55 fc	 mov	 edx, DWORD PTR _vRun$[ebp]
  0160d	83 ea 01	 sub	 edx, 1
  01610	89 55 fc	 mov	 DWORD PTR _vRun$[ebp], edx
  01613	85 c9		 test	 ecx, ecx
  01615	74 2d		 je	 SHORT $L62871

; 663  : 			memset(drawHere,back,hRun);

  01617	8b 45 f8	 mov	 eax, DWORD PTR _hRun$[ebp]
  0161a	50		 push	 eax
  0161b	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0161e	33 d2		 xor	 edx, edx
  01620	66 8b 51 08	 mov	 dx, WORD PTR [ecx+8]
  01624	52		 push	 edx
  01625	8b 45 dc	 mov	 eax, DWORD PTR _drawHere$62867[ebp]
  01628	50		 push	 eax
  01629	e8 00 00 00 00	 call	 _memset
  0162e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 664  : 			drawHere += BMWidth;

  01631	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01634	33 d2		 xor	 edx, edx
  01636	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  0163a	8b 45 dc	 mov	 eax, DWORD PTR _drawHere$62867[ebp]
  0163d	03 c2		 add	 eax, edx
  0163f	89 45 dc	 mov	 DWORD PTR _drawHere$62867[ebp], eax

; 665  : 		}

  01642	eb c3		 jmp	 SHORT $L62870
$L62871:

; 667  : }

  01644	8b e5		 mov	 esp, ebp
  01646	5d		 pop	 ebp
  01647	c2 08 00	 ret	 8
?Erase@FontMgr@@QAEXAAVSOL_Rect@@H@Z ENDP		; FontMgr::Erase
_theRect$ = 8
_thickness$ = 12
_theColor$ = 16
_scale$ = 20
_this$ = -40
_frameRect$ = -24
_penAddr$ = -8
_vRun$ = -32
_hRun$ = -36
_skip1$ = -4
_skip2$ = -28
?Frame@FontMgr@@QAEXAAVSOL_Rect@@HEH@Z PROC NEAR	; FontMgr::Frame

; 672  : {

  0164a	55		 push	 ebp
  0164b	8b ec		 mov	 ebp, esp
  0164d	83 ec 28	 sub	 esp, 40			; 00000028H
  01650	56		 push	 esi
  01651	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx

; 673  : 	SOL_Rect frameRect = theRect;

  01654	8b 45 08	 mov	 eax, DWORD PTR _theRect$[ebp]
  01657	50		 push	 eax
  01658	8d 4d e8	 lea	 ecx, DWORD PTR _frameRect$[ebp]
  0165b	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@ABV0@@Z ; SOL_Rect::SOL_Rect

; 674  : 	if(scale)

  01660	83 7d 14 00	 cmp	 DWORD PTR _scale$[ebp], 0
  01664	74 20		 je	 SHORT $L62880

; 675  : 		frameRect.Scale(xRes,SCIRESX,yRes,SCIRESY);

  01666	68 e0 01 00 00	 push	 480			; 000001e0H
  0166b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?yRes@FontMgr@@1HA ; FontMgr::yRes
  01671	51		 push	 ecx
  01672	68 80 02 00 00	 push	 640			; 00000280H
  01677	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes
  0167d	52		 push	 edx
  0167e	8d 4d e8	 lea	 ecx, DWORD PTR _frameRect$[ebp]
  01681	e8 00 00 00 00	 call	 ?Scale@SOL_Rect@@QAEXHHHH@Z ; SOL_Rect::Scale
$L62880:

; 676  : 	// If the thickness is too large reduce it.
; 677  : 	if (thickness*2 > frameRect.Ylen()) {

  01686	8b 75 0c	 mov	 esi, DWORD PTR _thickness$[ebp]
  01689	d1 e6		 shl	 esi, 1
  0168b	8d 4d e8	 lea	 ecx, DWORD PTR _frameRect$[ebp]
  0168e	e8 00 00 00 00	 call	 ?Ylen@SOL_Rect@@QBEHXZ	; SOL_Rect::Ylen
  01693	3b f0		 cmp	 esi, eax
  01695	7e 10		 jle	 SHORT $L62881

; 678  : 		thickness = frameRect.Ylen()/2;

  01697	8d 4d e8	 lea	 ecx, DWORD PTR _frameRect$[ebp]
  0169a	e8 00 00 00 00	 call	 ?Ylen@SOL_Rect@@QBEHXZ	; SOL_Rect::Ylen
  0169f	99		 cdq
  016a0	2b c2		 sub	 eax, edx
  016a2	d1 f8		 sar	 eax, 1
  016a4	89 45 0c	 mov	 DWORD PTR _thickness$[ebp], eax
$L62881:

; 680  : 	if (thickness*2 > frameRect.Xlen()) {

  016a7	8b 75 0c	 mov	 esi, DWORD PTR _thickness$[ebp]
  016aa	d1 e6		 shl	 esi, 1
  016ac	8d 4d e8	 lea	 ecx, DWORD PTR _frameRect$[ebp]
  016af	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  016b4	3b f0		 cmp	 esi, eax
  016b6	7e 10		 jle	 SHORT $L62882

; 681  : 		thickness = frameRect.Xlen()/2;

  016b8	8d 4d e8	 lea	 ecx, DWORD PTR _frameRect$[ebp]
  016bb	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  016c0	99		 cdq
  016c1	2b c2		 sub	 eax, edx
  016c3	d1 f8		 sar	 eax, 1
  016c5	89 45 0c	 mov	 DWORD PTR _thickness$[ebp], eax
$L62882:

; 683  : 	// Calculate the box address
; 684  : 	uchar* penAddr = (uchar*) memMgr->GetAddr(BM);

  016c8	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  016cb	83 c1 4e	 add	 ecx, 78			; 0000004eH
  016ce	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  016d3	50		 push	 eax
  016d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  016da	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr
  016df	89 45 f8	 mov	 DWORD PTR _penAddr$[ebp], eax

; 685  : 	penAddr +=      frameRect.A.y*BMWidth + frameRect.A.x + CELHEADERSIZE;

  016e2	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  016e5	33 c9		 xor	 ecx, ecx
  016e7	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  016eb	8b 55 ec	 mov	 edx, DWORD PTR _frameRect$[ebp+4]
  016ee	0f af d1	 imul	 edx, ecx
  016f1	03 55 e8	 add	 edx, DWORD PTR _frameRect$[ebp]
  016f4	8b 45 f8	 mov	 eax, DWORD PTR _penAddr$[ebp]
  016f7	8d 4c 10 2e	 lea	 ecx, DWORD PTR [eax+edx+46]
  016fb	89 4d f8	 mov	 DWORD PTR _penAddr$[ebp], ecx

; 686  : 	// draw the top frame
; 687  : 	int vRun = thickness;

  016fe	8b 55 0c	 mov	 edx, DWORD PTR _thickness$[ebp]
  01701	89 55 e0	 mov	 DWORD PTR _vRun$[ebp], edx

; 688  : 	int hRun = frameRect.Xlen();

  01704	8d 4d e8	 lea	 ecx, DWORD PTR _frameRect$[ebp]
  01707	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  0170c	89 45 dc	 mov	 DWORD PTR _hRun$[ebp], eax
$L62888:

; 689  : 	while(vRun--) {

  0170f	8b 45 e0	 mov	 eax, DWORD PTR _vRun$[ebp]
  01712	8b 4d e0	 mov	 ecx, DWORD PTR _vRun$[ebp]
  01715	83 e9 01	 sub	 ecx, 1
  01718	89 4d e0	 mov	 DWORD PTR _vRun$[ebp], ecx
  0171b	85 c0		 test	 eax, eax
  0171d	74 2c		 je	 SHORT $L62889

; 690  : 		memset(penAddr,theColor,hRun);

  0171f	8b 55 dc	 mov	 edx, DWORD PTR _hRun$[ebp]
  01722	52		 push	 edx
  01723	8b 45 10	 mov	 eax, DWORD PTR _theColor$[ebp]
  01726	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0172b	50		 push	 eax
  0172c	8b 4d f8	 mov	 ecx, DWORD PTR _penAddr$[ebp]
  0172f	51		 push	 ecx
  01730	e8 00 00 00 00	 call	 _memset
  01735	83 c4 0c	 add	 esp, 12			; 0000000cH

; 691  : 		penAddr += BMWidth;

  01738	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  0173b	33 c0		 xor	 eax, eax
  0173d	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  01741	8b 4d f8	 mov	 ecx, DWORD PTR _penAddr$[ebp]
  01744	03 c8		 add	 ecx, eax
  01746	89 4d f8	 mov	 DWORD PTR _penAddr$[ebp], ecx

; 692  : 	}

  01749	eb c4		 jmp	 SHORT $L62888
$L62889:

; 693  : 	// draw the side frames
; 694  : 	vRun = frameRect.Ylen() - 2*thickness;

  0174b	8d 4d e8	 lea	 ecx, DWORD PTR _frameRect$[ebp]
  0174e	e8 00 00 00 00	 call	 ?Ylen@SOL_Rect@@QBEHXZ	; SOL_Rect::Ylen
  01753	8b 55 0c	 mov	 edx, DWORD PTR _thickness$[ebp]
  01756	d1 e2		 shl	 edx, 1
  01758	2b c2		 sub	 eax, edx
  0175a	89 45 e0	 mov	 DWORD PTR _vRun$[ebp], eax

; 695  : 	hRun = thickness;

  0175d	8b 45 0c	 mov	 eax, DWORD PTR _thickness$[ebp]
  01760	89 45 dc	 mov	 DWORD PTR _hRun$[ebp], eax

; 696  : 	int skip1 = frameRect.Xlen() - thickness;

  01763	8d 4d e8	 lea	 ecx, DWORD PTR _frameRect$[ebp]
  01766	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  0176b	2b 45 0c	 sub	 eax, DWORD PTR _thickness$[ebp]
  0176e	89 45 fc	 mov	 DWORD PTR _skip1$[ebp], eax

; 697  : 	int skip2 = BMWidth - frameRect.Xlen() + thickness;

  01771	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01774	33 d2		 xor	 edx, edx
  01776	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  0177a	8b f2		 mov	 esi, edx
  0177c	8d 4d e8	 lea	 ecx, DWORD PTR _frameRect$[ebp]
  0177f	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  01784	2b f0		 sub	 esi, eax
  01786	03 75 0c	 add	 esi, DWORD PTR _thickness$[ebp]
  01789	89 75 e4	 mov	 DWORD PTR _skip2$[ebp], esi
$L62893:

; 698  : 	while(vRun--) {

  0178c	8b 45 e0	 mov	 eax, DWORD PTR _vRun$[ebp]
  0178f	8b 4d e0	 mov	 ecx, DWORD PTR _vRun$[ebp]
  01792	83 e9 01	 sub	 ecx, 1
  01795	89 4d e0	 mov	 DWORD PTR _vRun$[ebp], ecx
  01798	85 c0		 test	 eax, eax
  0179a	74 47		 je	 SHORT $L62894

; 699  : 		memset(penAddr,theColor,hRun);

  0179c	8b 55 dc	 mov	 edx, DWORD PTR _hRun$[ebp]
  0179f	52		 push	 edx
  017a0	8b 45 10	 mov	 eax, DWORD PTR _theColor$[ebp]
  017a3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  017a8	50		 push	 eax
  017a9	8b 4d f8	 mov	 ecx, DWORD PTR _penAddr$[ebp]
  017ac	51		 push	 ecx
  017ad	e8 00 00 00 00	 call	 _memset
  017b2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 700  : 		penAddr += skip1;

  017b5	8b 55 f8	 mov	 edx, DWORD PTR _penAddr$[ebp]
  017b8	03 55 fc	 add	 edx, DWORD PTR _skip1$[ebp]
  017bb	89 55 f8	 mov	 DWORD PTR _penAddr$[ebp], edx

; 701  : 		memset(penAddr,theColor,hRun);

  017be	8b 45 dc	 mov	 eax, DWORD PTR _hRun$[ebp]
  017c1	50		 push	 eax
  017c2	8b 4d 10	 mov	 ecx, DWORD PTR _theColor$[ebp]
  017c5	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  017cb	51		 push	 ecx
  017cc	8b 55 f8	 mov	 edx, DWORD PTR _penAddr$[ebp]
  017cf	52		 push	 edx
  017d0	e8 00 00 00 00	 call	 _memset
  017d5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 702  : 		penAddr += skip2;

  017d8	8b 45 f8	 mov	 eax, DWORD PTR _penAddr$[ebp]
  017db	03 45 e4	 add	 eax, DWORD PTR _skip2$[ebp]
  017de	89 45 f8	 mov	 DWORD PTR _penAddr$[ebp], eax

; 703  : 	}

  017e1	eb a9		 jmp	 SHORT $L62893
$L62894:

; 704  : 	// draw the bottom frame
; 705  : 	vRun = thickness;

  017e3	8b 4d 0c	 mov	 ecx, DWORD PTR _thickness$[ebp]
  017e6	89 4d e0	 mov	 DWORD PTR _vRun$[ebp], ecx

; 706  : 	hRun = frameRect.Xlen();

  017e9	8d 4d e8	 lea	 ecx, DWORD PTR _frameRect$[ebp]
  017ec	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  017f1	89 45 dc	 mov	 DWORD PTR _hRun$[ebp], eax
$L62896:

; 707  : 	while(vRun--) {

  017f4	8b 55 e0	 mov	 edx, DWORD PTR _vRun$[ebp]
  017f7	8b 45 e0	 mov	 eax, DWORD PTR _vRun$[ebp]
  017fa	83 e8 01	 sub	 eax, 1
  017fd	89 45 e0	 mov	 DWORD PTR _vRun$[ebp], eax
  01800	85 d2		 test	 edx, edx
  01802	74 2d		 je	 SHORT $L62897

; 708  : 		memset(penAddr,theColor,hRun);

  01804	8b 4d dc	 mov	 ecx, DWORD PTR _hRun$[ebp]
  01807	51		 push	 ecx
  01808	8b 55 10	 mov	 edx, DWORD PTR _theColor$[ebp]
  0180b	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  01811	52		 push	 edx
  01812	8b 45 f8	 mov	 eax, DWORD PTR _penAddr$[ebp]
  01815	50		 push	 eax
  01816	e8 00 00 00 00	 call	 _memset
  0181b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 709  : 		penAddr += BMWidth;

  0181e	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01821	33 d2		 xor	 edx, edx
  01823	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  01827	8b 45 f8	 mov	 eax, DWORD PTR _penAddr$[ebp]
  0182a	03 c2		 add	 eax, edx
  0182c	89 45 f8	 mov	 DWORD PTR _penAddr$[ebp], eax

; 710  : 	}

  0182f	eb c3		 jmp	 SHORT $L62896
$L62897:

; 711  : }

  01831	5e		 pop	 esi
  01832	8b e5		 mov	 esp, ebp
  01834	5d		 pop	 ebp
  01835	c2 10 00	 ret	 16			; 00000010H
?Frame@FontMgr@@QAEXAAVSOL_Rect@@HEH@Z ENDP		; FontMgr::Frame
_TEXT	ENDS
PUBLIC	?GetSize@MemoryMgr@@QAEIG@Z			; MemoryMgr::GetSize
PUBLIC	?InvertRect@FontMgr@@QAEXVMemID@@HVSOL_Rect@@DDH@Z ; FontMgr::InvertRect
_DATA	SEGMENT
	ORG $+3
$SG62913 DB	'InvertRect too big: %d >= %d', 00H
_DATA	ENDS
_TEXT	SEGMENT
_theBM$ = 8
_theWidth$ = 12
_theRect$ = 16
_fore$ = 32
_back$ = 36
_scale$ = 40
_this$ = -32
_i$ = -16
_j$ = -20
_celHeader$ = -24
_penAddr$ = -4
_vRun$ = -8
_hRun$ = -12
_i$62921 = -28
?InvertRect@FontMgr@@QAEXVMemID@@HVSOL_Rect@@DDH@Z PROC NEAR ; FontMgr::InvertRect

; 715  : {

  01838	55		 push	 ebp
  01839	8b ec		 mov	 ebp, esp
  0183b	83 ec 20	 sub	 esp, 32			; 00000020H
  0183e	56		 push	 esi
  0183f	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 716  : 	
; 717  : 	// Switches the fore ground and background 
; 718  : 	// colors for the given rectangles
; 719  :    if (scale) {

  01842	83 7d 28 00	 cmp	 DWORD PTR _scale$[ebp], 0
  01846	74 34		 je	 SHORT $L62907

; 720  : 	   theWidth = theWidth * xRes / SCIRESX;

  01848	8b 45 0c	 mov	 eax, DWORD PTR _theWidth$[ebp]
  0184b	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes
  01852	99		 cdq
  01853	b9 80 02 00 00	 mov	 ecx, 640		; 00000280H
  01858	f7 f9		 idiv	 ecx
  0185a	89 45 0c	 mov	 DWORD PTR _theWidth$[ebp], eax

; 721  : 	   theRect.Scale(xRes,SCIRESX,yRes,SCIRESY);

  0185d	68 e0 01 00 00	 push	 480			; 000001e0H
  01862	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?yRes@FontMgr@@1HA ; FontMgr::yRes
  01868	52		 push	 edx
  01869	68 80 02 00 00	 push	 640			; 00000280H
  0186e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes
  01873	50		 push	 eax
  01874	8d 4d 10	 lea	 ecx, DWORD PTR _theRect$[ebp]
  01877	e8 00 00 00 00	 call	 ?Scale@SOL_Rect@@QAEXHHHH@Z ; SOL_Rect::Scale
$L62907:

; 723  : 
; 724  : 	// Sanity check
; 725  : 	int i = theRect.B.y;

  0187c	8b 4d 1c	 mov	 ecx, DWORD PTR _theRect$[ebp+12]
  0187f	89 4d f0	 mov	 DWORD PTR _i$[ebp], ecx

; 726  : 	int j = theRect.B.x;

  01882	8b 55 18	 mov	 edx, DWORD PTR _theRect$[ebp+8]
  01885	89 55 ec	 mov	 DWORD PTR _j$[ebp], edx

; 727  : 	CelHeader* celHeader = ((CelHeader*) memMgr->GetAddr(theBM));

  01888	8d 4d 08	 lea	 ecx, DWORD PTR _theBM$[ebp]
  0188b	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  01890	50		 push	 eax
  01891	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  01897	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr
  0189c	89 45 e8	 mov	 DWORD PTR _celHeader$[ebp], eax

; 728  : 	if ((theRect.B.y*theWidth + theRect.B.x + CELHEADERSIZE) >= memMgr->GetSize(theBM))

  0189f	8b 45 1c	 mov	 eax, DWORD PTR _theRect$[ebp+12]
  018a2	0f af 45 0c	 imul	 eax, DWORD PTR _theWidth$[ebp]
  018a6	8b 4d 18	 mov	 ecx, DWORD PTR _theRect$[ebp+8]
  018a9	8d 74 08 2e	 lea	 esi, DWORD PTR [eax+ecx+46]
  018ad	8d 4d 08	 lea	 ecx, DWORD PTR _theBM$[ebp]
  018b0	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  018b5	50		 push	 eax
  018b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  018bc	e8 00 00 00 00	 call	 ?GetSize@MemoryMgr@@QAEIG@Z ; MemoryMgr::GetSize
  018c1	3b f0		 cmp	 esi, eax
  018c3	72 38		 jb	 SHORT $L62912

; 731  : 			theRect.B.y*theWidth + theRect.B.x + CELHEADERSIZE, 
; 732  : 			memMgr->GetSize(theBM)
; 733  : 			);

  018c5	8d 4d 08	 lea	 ecx, DWORD PTR _theBM$[ebp]
  018c8	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  018cd	50		 push	 eax
  018ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  018d4	e8 00 00 00 00	 call	 ?GetSize@MemoryMgr@@QAEIG@Z ; MemoryMgr::GetSize
  018d9	50		 push	 eax
  018da	8b 55 1c	 mov	 edx, DWORD PTR _theRect$[ebp+12]
  018dd	0f af 55 0c	 imul	 edx, DWORD PTR _theWidth$[ebp]
  018e1	8b 45 18	 mov	 eax, DWORD PTR _theRect$[ebp+8]
  018e4	8d 4c 02 2e	 lea	 ecx, DWORD PTR [edx+eax+46]
  018e8	51		 push	 ecx
  018e9	68 00 00 00 00	 push	 OFFSET FLAT:$SG62913
  018ee	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  018f4	52		 push	 edx
  018f5	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  018fa	83 c4 10	 add	 esp, 16			; 00000010H
$L62912:

; 734  : 
; 735  : 	// Calculate the box address
; 736  : 	char* penAddr = (char*) memMgr->GetAddr(theBM);

  018fd	8d 4d 08	 lea	 ecx, DWORD PTR _theBM$[ebp]
  01900	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  01905	50		 push	 eax
  01906	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  0190c	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr
  01911	89 45 fc	 mov	 DWORD PTR _penAddr$[ebp], eax

; 737  : 	penAddr +=      theRect.A.y*theWidth + theRect.A.x + CELHEADERSIZE;

  01914	8b 45 14	 mov	 eax, DWORD PTR _theRect$[ebp+4]
  01917	0f af 45 0c	 imul	 eax, DWORD PTR _theWidth$[ebp]
  0191b	03 45 10	 add	 eax, DWORD PTR _theRect$[ebp]
  0191e	8b 4d fc	 mov	 ecx, DWORD PTR _penAddr$[ebp]
  01921	8d 54 01 2e	 lea	 edx, DWORD PTR [ecx+eax+46]
  01925	89 55 fc	 mov	 DWORD PTR _penAddr$[ebp], edx

; 738  : 	// Setup
; 739  : 	int vRun = theRect.Ylen();

  01928	8d 4d 10	 lea	 ecx, DWORD PTR _theRect$[ebp]
  0192b	e8 00 00 00 00	 call	 ?Ylen@SOL_Rect@@QBEHXZ	; SOL_Rect::Ylen
  01930	89 45 f8	 mov	 DWORD PTR _vRun$[ebp], eax

; 740  : 	int hRun = theRect.Xlen();

  01933	8d 4d 10	 lea	 ecx, DWORD PTR _theRect$[ebp]
  01936	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  0193b	89 45 f4	 mov	 DWORD PTR _hRun$[ebp], eax
$L62919:

; 741  : 
; 742  : 	while(vRun--) {

  0193e	8b 45 f8	 mov	 eax, DWORD PTR _vRun$[ebp]
  01941	8b 4d f8	 mov	 ecx, DWORD PTR _vRun$[ebp]
  01944	83 e9 01	 sub	 ecx, 1
  01947	89 4d f8	 mov	 DWORD PTR _vRun$[ebp], ecx
  0194a	85 c0		 test	 eax, eax
  0194c	74 61		 je	 SHORT $L62920

; 743  : 		for (int i = 0;i < hRun;++i) {

  0194e	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$62921[ebp], 0
  01955	eb 09		 jmp	 SHORT $L62922
$L62923:
  01957	8b 55 e4	 mov	 edx, DWORD PTR _i$62921[ebp]
  0195a	83 c2 01	 add	 edx, 1
  0195d	89 55 e4	 mov	 DWORD PTR _i$62921[ebp], edx
$L62922:
  01960	8b 45 e4	 mov	 eax, DWORD PTR _i$62921[ebp]
  01963	3b 45 f4	 cmp	 eax, DWORD PTR _hRun$[ebp]
  01966	7d 3c		 jge	 SHORT $L62924

; 744  : 			if (penAddr[i] == fore)

  01968	8b 4d fc	 mov	 ecx, DWORD PTR _penAddr$[ebp]
  0196b	03 4d e4	 add	 ecx, DWORD PTR _i$62921[ebp]
  0196e	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  01971	0f be 45 20	 movsx	 eax, BYTE PTR _fore$[ebp]
  01975	3b d0		 cmp	 edx, eax
  01977	75 0d		 jne	 SHORT $L62925

; 745  : 				penAddr[i] = back;

  01979	8b 4d fc	 mov	 ecx, DWORD PTR _penAddr$[ebp]
  0197c	03 4d e4	 add	 ecx, DWORD PTR _i$62921[ebp]
  0197f	8a 55 24	 mov	 dl, BYTE PTR _back$[ebp]
  01982	88 11		 mov	 BYTE PTR [ecx], dl

; 746  : 			else

  01984	eb 1c		 jmp	 SHORT $L62927
$L62925:

; 747  : 				if (penAddr[i] == back)

  01986	8b 45 fc	 mov	 eax, DWORD PTR _penAddr$[ebp]
  01989	03 45 e4	 add	 eax, DWORD PTR _i$62921[ebp]
  0198c	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0198f	0f be 55 24	 movsx	 edx, BYTE PTR _back$[ebp]
  01993	3b ca		 cmp	 ecx, edx
  01995	75 0b		 jne	 SHORT $L62927

; 748  : 					penAddr[i] = fore;

  01997	8b 45 fc	 mov	 eax, DWORD PTR _penAddr$[ebp]
  0199a	03 45 e4	 add	 eax, DWORD PTR _i$62921[ebp]
  0199d	8a 4d 20	 mov	 cl, BYTE PTR _fore$[ebp]
  019a0	88 08		 mov	 BYTE PTR [eax], cl
$L62927:

; 749  : 		}

  019a2	eb b3		 jmp	 SHORT $L62923
$L62924:

; 750  : 		penAddr += theWidth;

  019a4	8b 55 fc	 mov	 edx, DWORD PTR _penAddr$[ebp]
  019a7	03 55 0c	 add	 edx, DWORD PTR _theWidth$[ebp]
  019aa	89 55 fc	 mov	 DWORD PTR _penAddr$[ebp], edx

; 751  : 	}

  019ad	eb 8f		 jmp	 SHORT $L62919
$L62920:

; 752  : }

  019af	5e		 pop	 esi
  019b0	8b e5		 mov	 esp, ebp
  019b2	5d		 pop	 ebp
  019b3	c2 24 00	 ret	 36			; 00000024H
?InvertRect@FontMgr@@QAEXVMemID@@HVSOL_Rect@@DDH@Z ENDP	; FontMgr::InvertRect
_TEXT	ENDS
;	COMDAT ?GetSize@MemoryMgr@@QAEIG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -4
?GetSize@MemoryMgr@@QAEIG@Z PROC NEAR			; MemoryMgr::GetSize, COMDAT

; 357  : 	size_t GetSize(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 358  : //		CheckValid(theID);
; 359  : 		return desc[theID].size;

  00007	8b 45 08	 mov	 eax, DWORD PTR _theID$[ebp]
  0000a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0000f	c1 e0 04	 shl	 eax, 4
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00018	8b 44 02 08	 mov	 eax, DWORD PTR [edx+eax+8]

; 360  : 	}

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?GetSize@MemoryMgr@@QAEIG@Z ENDP			; MemoryMgr::GetSize
_TEXT	ENDS
PUBLIC	??0SOL_Rect@@QAE@XZ				; SOL_Rect::SOL_Rect
PUBLIC	?ClearChar@FontMgr@@IAEXE@Z			; FontMgr::ClearChar
_TEXT	SEGMENT
_theChar$ = 8
_this$ = -20
_theRect$ = -16
?ClearChar@FontMgr@@IAEXE@Z PROC NEAR			; FontMgr::ClearChar

; 756  : {

  019b6	55		 push	 ebp
  019b7	8b ec		 mov	 ebp, esp
  019b9	83 ec 14	 sub	 esp, 20			; 00000014H
  019bc	53		 push	 ebx
  019bd	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 757  : 	// Clear the given character at the current pen location
; 758  :    // MustRewrite for Imbedded font
; 759  : 	SOL_Rect theRect;

  019c0	8d 4d f0	 lea	 ecx, DWORD PTR _theRect$[ebp]
  019c3	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@XZ	; SOL_Rect::SOL_Rect

; 760  : 
; 761  : 	theRect.A.y = penY;

  019c8	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  019cb	33 c9		 xor	 ecx, ecx
  019cd	66 8b 48 4a	 mov	 cx, WORD PTR [eax+74]
  019d1	89 4d f4	 mov	 DWORD PTR _theRect$[ebp+4], ecx

; 762  : 	theRect.B.y = penY + pointSize;

  019d4	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  019d7	33 c0		 xor	 eax, eax
  019d9	66 8b 42 4a	 mov	 ax, WORD PTR [edx+74]
  019dd	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  019e0	33 d2		 xor	 edx, edx
  019e2	66 8b 51 4c	 mov	 dx, WORD PTR [ecx+76]
  019e6	03 c2		 add	 eax, edx
  019e8	89 45 fc	 mov	 DWORD PTR _theRect$[ebp+12], eax

; 763  : 
; 764  : 	theRect.A.x = penX;

  019eb	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  019ee	33 c9		 xor	 ecx, ecx
  019f0	66 8b 48 48	 mov	 cx, WORD PTR [eax+72]
  019f4	89 4d f0	 mov	 DWORD PTR _theRect$[ebp], ecx

; 765  : 	theRect.B.x = penX + fontWidths[theChar];

  019f7	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  019fa	33 c0		 xor	 eax, eax
  019fc	66 8b 42 48	 mov	 ax, WORD PTR [edx+72]
  01a00	8b 4d 08	 mov	 ecx, DWORD PTR _theChar$[ebp]
  01a03	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  01a09	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  01a0c	33 db		 xor	 ebx, ebx
  01a0e	8a 5c 0a 58	 mov	 bl, BYTE PTR [edx+ecx+88]
  01a12	03 c3		 add	 eax, ebx
  01a14	89 45 f8	 mov	 DWORD PTR _theRect$[ebp+8], eax

; 766  : 
; 767  : 	Erase(theRect,False);

  01a17	6a 00		 push	 0
  01a19	8d 45 f0	 lea	 eax, DWORD PTR _theRect$[ebp]
  01a1c	50		 push	 eax
  01a1d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01a20	e8 00 00 00 00	 call	 ?Erase@FontMgr@@QAEXAAVSOL_Rect@@H@Z ; FontMgr::Erase

; 768  : }

  01a25	5b		 pop	 ebx
  01a26	8b e5		 mov	 esp, ebp
  01a28	5d		 pop	 ebp
  01a29	c2 04 00	 ret	 4
?ClearChar@FontMgr@@IAEXE@Z ENDP			; FontMgr::ClearChar
_TEXT	ENDS
EXTRN	?sciSystemFont@@3PAEA:BYTE			; sciSystemFont
_TEXT	SEGMENT
$T63596 = -24
_theFont$ = 8
_this$ = -28
_i$ = -8
_fontHeader$ = -4
_fontID$62945 = -16
_charRecsAddr$ = -12
_info$62967 = -20
?BuildFontTable@FontMgr@@IAEXH@Z PROC NEAR		; FontMgr::BuildFontTable

; 772  : {

  01a2c	55		 push	 ebp
  01a2d	8b ec		 mov	 ebp, esp
  01a2f	83 ec 1c	 sub	 esp, 28			; 0000001cH
  01a32	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 773  : 	int i;
; 774  : 	assert(theFont >= 0);
; 775  : 	if (font == theFont)

  01a35	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  01a38	33 c9		 xor	 ecx, ecx
  01a3a	66 8b 48 28	 mov	 cx, WORD PTR [eax+40]
  01a3e	3b 4d 08	 cmp	 ecx, DWORD PTR _theFont$[ebp]
  01a41	75 05		 jne	 SHORT $L62939

; 776  : 		return;

  01a43	e9 75 01 00 00	 jmp	 $L62936
$L62939:

; 777  : 
; 778  : 	font = theFont;

  01a48	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  01a4b	66 8b 45 08	 mov	 ax, WORD PTR _theFont$[ebp]
  01a4f	66 89 42 28	 mov	 WORD PTR [edx+40], ax

; 779  : 	// Build the table of font widths and initializes the font pointSize
; 780  : 
; 781  : 	FontHeader * fontHeader;
; 782  : 
; 783  : #ifdef MACINTOSH
; 784  : 
; 785  : 	MemID fontID = resMgr->Get(MemResFont,font);
; 786  : 	fontHeader = (FontHeader *) memMgr->GetAddr(fontID);
; 787  : 
; 788  : #else
; 789  : 
; 790  : 	if (font == SYSTEMFONT)

  01a53	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  01a56	33 d2		 xor	 edx, edx
  01a58	66 8b 51 28	 mov	 dx, WORD PTR [ecx+40]
  01a5c	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  01a62	75 09		 jne	 SHORT $L62942

; 792  : 		fontHeader = (FontHeader *) sciSystemFont;

  01a64	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fontHeader$[ebp], OFFSET FLAT:?sciSystemFont@@3PAEA ; sciSystemFont

; 794  : 	else

  01a6b	eb 40		 jmp	 SHORT $L62944
$L62942:

; 796  : 		MemID fontID = resMgr->Get(MemResFont,font);

  01a6d	6a 00		 push	 0
  01a6f	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  01a72	66 8b 48 28	 mov	 cx, WORD PTR [eax+40]
  01a76	51		 push	 ecx
  01a77	6a 07		 push	 7
  01a79	8d 55 e8	 lea	 edx, DWORD PTR $T63596[ebp]
  01a7c	52		 push	 edx
  01a7d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?resMgr@@3PAVResourceMgr@@A ; resMgr
  01a82	8b 10		 mov	 edx, DWORD PTR [eax]
  01a84	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMgr@@3PAVResourceMgr@@A ; resMgr
  01a8a	ff 52 20	 call	 DWORD PTR [edx+32]
  01a8d	50		 push	 eax
  01a8e	8d 4d f0	 lea	 ecx, DWORD PTR _fontID$62945[ebp]
  01a91	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID

; 797  : 		fontHeader = (FontHeader *) memMgr->GetAddr(fontID);

  01a96	8d 4d f0	 lea	 ecx, DWORD PTR _fontID$62945[ebp]
  01a99	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  01a9e	50		 push	 eax
  01a9f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  01aa5	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr
  01aaa	89 45 fc	 mov	 DWORD PTR _fontHeader$[ebp], eax
$L62944:

; 799  : 
; 800  : #endif
; 801  : 	
; 802  : 	// initialize the font constants
; 803  : 	assert(fontHeader != NULL);
; 804  : 	pointSize = fontHeader->pointSize;

  01aad	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  01ab0	8b 4d fc	 mov	 ecx, DWORD PTR _fontHeader$[ebp]
  01ab3	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  01ab7	66 89 50 4c	 mov	 WORD PTR [eax+76], dx

; 805  : 	lowChar = fontHeader->lowChar;

  01abb	8b 45 fc	 mov	 eax, DWORD PTR _fontHeader$[ebp]
  01abe	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  01ac1	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  01ac4	89 4a 50	 mov	 DWORD PTR [edx+80], ecx

; 806  : 	highChar = fontHeader->highChar;

  01ac7	8b 45 fc	 mov	 eax, DWORD PTR _fontHeader$[ebp]
  01aca	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  01ace	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  01ad1	89 4a 54	 mov	 DWORD PTR [edx+84], ecx

; 807  : 	if (highChar > 255)

  01ad4	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  01ad7	81 78 54 ff 00
	00 00		 cmp	 DWORD PTR [eax+84], 255	; 000000ffH
  01ade	7e 0a		 jle	 SHORT $L62949

; 808  : 		highChar = 255;			//  DDF - Yuck! Font Editor can return 256 here, but lower values

  01ae0	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  01ae3	c7 41 54 ff 00
	00 00		 mov	 DWORD PTR [ecx+84], 255	; 000000ffH
$L62949:

; 809  : 										//  seem correct
; 810  : 
; 811  : 	Int16* charRecsAddr = (Int16*) &fontHeader->charRecs;

  01aea	8b 55 fc	 mov	 edx, DWORD PTR _fontHeader$[ebp]
  01aed	83 c2 06	 add	 edx, 6
  01af0	89 55 f4	 mov	 DWORD PTR _charRecsAddr$[ebp], edx

; 812  : 	assert(charRecsAddr != NULL);
; 813  : 	assert(lowChar >= 0);
; 814  : 	assert(lowChar < MAXFONTSIZE);
; 815  : 	assert(lowChar < highChar);
; 816  : 	assert(highChar > 0);
; 817  : 	assert(highChar < MAXFONTSIZE);
; 818  : 
; 819  : 	// fill in the font widths and heights tables
; 820  : 	for (i = 0;i < lowChar;++i)

  01af3	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  01afa	eb 09		 jmp	 SHORT $L62958
$L62959:
  01afc	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01aff	83 c0 01	 add	 eax, 1
  01b02	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L62958:
  01b05	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  01b08	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  01b0b	3b 51 50	 cmp	 edx, DWORD PTR [ecx+80]
  01b0e	7d 19		 jge	 SHORT $L62960

; 822  : 		fontWidths[i] = 0;

  01b10	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  01b13	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  01b16	c6 40 58 00	 mov	 BYTE PTR [eax+88], 0

; 823  : 		fontHeights[i] = 0;

  01b1a	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  01b1d	03 4d f8	 add	 ecx, DWORD PTR _i$[ebp]
  01b20	c6 81 58 01 00
	00 00		 mov	 BYTE PTR [ecx+344], 0

; 824  : 	}

  01b27	eb d3		 jmp	 SHORT $L62959
$L62960:

; 825  : 	for (i = highChar+1;i < MAXFONTSIZE;++i)

  01b29	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  01b2c	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  01b2f	83 c0 01	 add	 eax, 1
  01b32	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  01b35	eb 09		 jmp	 SHORT $L62961
$L62962:
  01b37	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  01b3a	83 c1 01	 add	 ecx, 1
  01b3d	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
$L62961:
  01b40	81 7d f8 00 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 256	; 00000100H
  01b47	7d 19		 jge	 SHORT $L62963

; 827  : 		fontWidths[i] = 0;

  01b49	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  01b4c	03 55 f8	 add	 edx, DWORD PTR _i$[ebp]
  01b4f	c6 42 58 00	 mov	 BYTE PTR [edx+88], 0

; 828  : 		fontHeights[i] = 0;

  01b53	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  01b56	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  01b59	c6 80 58 01 00
	00 00		 mov	 BYTE PTR [eax+344], 0

; 829  : 	}

  01b60	eb d5		 jmp	 SHORT $L62962
$L62963:

; 830  : 
; 831  : 	for (i = lowChar;i < highChar;++i)

  01b62	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  01b65	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  01b68	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
  01b6b	eb 09		 jmp	 SHORT $L62964
$L62965:
  01b6d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01b70	83 c0 01	 add	 eax, 1
  01b73	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L62964:
  01b76	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  01b79	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  01b7c	3b 51 54	 cmp	 edx, DWORD PTR [ecx+84]
  01b7f	7d 3c		 jge	 SHORT $L62966

; 833  : 		uchar* info = (uchar *) fontHeader + charRecsAddr[i];

  01b81	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01b84	8b 4d f4	 mov	 ecx, DWORD PTR _charRecsAddr$[ebp]
  01b87	0f bf 14 41	 movsx	 edx, WORD PTR [ecx+eax*2]
  01b8b	8b 45 fc	 mov	 eax, DWORD PTR _fontHeader$[ebp]
  01b8e	03 c2		 add	 eax, edx
  01b90	89 45 ec	 mov	 DWORD PTR _info$62967[ebp], eax

; 834  : 		fontWidths[i] = *info;

  01b93	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  01b96	03 4d f8	 add	 ecx, DWORD PTR _i$[ebp]
  01b99	8b 55 ec	 mov	 edx, DWORD PTR _info$62967[ebp]
  01b9c	8a 02		 mov	 al, BYTE PTR [edx]
  01b9e	88 41 58	 mov	 BYTE PTR [ecx+88], al

; 835  : 		fontHeights[i] = *(++info);

  01ba1	8b 4d ec	 mov	 ecx, DWORD PTR _info$62967[ebp]
  01ba4	83 c1 01	 add	 ecx, 1
  01ba7	89 4d ec	 mov	 DWORD PTR _info$62967[ebp], ecx
  01baa	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  01bad	03 55 f8	 add	 edx, DWORD PTR _i$[ebp]
  01bb0	8b 45 ec	 mov	 eax, DWORD PTR _info$62967[ebp]
  01bb3	8a 08		 mov	 cl, BYTE PTR [eax]
  01bb5	88 8a 58 01 00
	00		 mov	 BYTE PTR [edx+344], cl

; 836  : 	}

  01bbb	eb b0		 jmp	 SHORT $L62965
$L62966:
$L62936:

; 837  : }

  01bbd	8b e5		 mov	 esp, ebp
  01bbf	5d		 pop	 ebp
  01bc0	c2 04 00	 ret	 4
?BuildFontTable@FontMgr@@IAEXH@Z ENDP			; FontMgr::BuildFontTable
_index$ = 8
_count$ = 12
_width$ = 16
_height$ = 20
_this$ = -16
_str$ = -4
_newNum$62982 = -8
_action$62986 = -12
?TextDimensions@FontMgr@@IAEXHHAAH0@Z PROC NEAR		; FontMgr::TextDimensions

; 841  : {

  01bc3	55		 push	 ebp
  01bc4	8b ec		 mov	 ebp, esp
  01bc6	83 ec 14	 sub	 esp, 20			; 00000014H
  01bc9	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 842  : 	// Adds the widths of the characters in the given string
; 843  : 	// from the character str[index] for a length of count up
; 844  : 	// to the end of the string
; 845  : 	
; 846  : 	// Set up to add the widths
; 847  : 	width = 0;

  01bcc	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  01bcf	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 848  : 	height = 0;

  01bd5	8b 4d 14	 mov	 ecx, DWORD PTR _height$[ebp]
  01bd8	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 849  : 	uchar* str = (uchar*) memMgr->GetAddr(text) + index;

  01bde	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01be1	83 c1 0e	 add	 ecx, 14			; 0000000eH
  01be4	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  01be9	50		 push	 eax
  01bea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  01bf0	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr
  01bf5	03 45 08	 add	 eax, DWORD PTR _index$[ebp]
  01bf8	89 45 fc	 mov	 DWORD PTR _str$[ebp], eax
$L62979:

; 850  : //	msgMgr->Mono ( "processing %s\n", str );
; 851  : 
; 852  : 	while (count-- > 0 && (*str != 0)) {

  01bfb	8b 55 0c	 mov	 edx, DWORD PTR _count$[ebp]
  01bfe	8b 45 0c	 mov	 eax, DWORD PTR _count$[ebp]
  01c01	83 e8 01	 sub	 eax, 1
  01c04	89 45 0c	 mov	 DWORD PTR _count$[ebp], eax
  01c07	85 d2		 test	 edx, edx
  01c09	0f 8e e3 01 00
	00		 jle	 $L62980
  01c0f	8b 4d fc	 mov	 ecx, DWORD PTR _str$[ebp]
  01c12	33 d2		 xor	 edx, edx
  01c14	8a 11		 mov	 dl, BYTE PTR [ecx]
  01c16	85 d2		 test	 edx, edx
  01c18	0f 84 d4 01 00
	00		 je	 $L62980

; 853  : 		if(*str == CTRL_CHAR) {

  01c1e	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  01c21	33 c9		 xor	 ecx, ecx
  01c23	8a 08		 mov	 cl, BYTE PTR [eax]
  01c25	83 f9 7c	 cmp	 ecx, 124		; 0000007cH
  01c28	0f 85 68 01 00
	00		 jne	 $L62981

; 854  : 			int newNum;
; 855  : 			newNum = 0;

  01c2e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _newNum$62982[ebp], 0

; 856  : 			str++;

  01c35	8b 55 fc	 mov	 edx, DWORD PTR _str$[ebp]
  01c38	83 c2 01	 add	 edx, 1
  01c3b	89 55 fc	 mov	 DWORD PTR _str$[ebp], edx

; 857  : 			if(!(count-- > 0)) break;

  01c3e	8b 45 0c	 mov	 eax, DWORD PTR _count$[ebp]
  01c41	8b 4d 0c	 mov	 ecx, DWORD PTR _count$[ebp]
  01c44	83 e9 01	 sub	 ecx, 1
  01c47	89 4d 0c	 mov	 DWORD PTR _count$[ebp], ecx
  01c4a	85 c0		 test	 eax, eax
  01c4c	7f 05		 jg	 SHORT $L62983
  01c4e	e9 9f 01 00 00	 jmp	 $L62980
$L62983:

; 858  : 
; 859  : 			if((*str == 'c' || *str == 'a' || *str == 'f' || *str == 'x') &&  count-- > 0) {

  01c53	8b 55 fc	 mov	 edx, DWORD PTR _str$[ebp]
  01c56	33 c0		 xor	 eax, eax
  01c58	8a 02		 mov	 al, BYTE PTR [edx]
  01c5a	83 f8 63	 cmp	 eax, 99			; 00000063H
  01c5d	74 28		 je	 SHORT $L62985
  01c5f	8b 4d fc	 mov	 ecx, DWORD PTR _str$[ebp]
  01c62	33 d2		 xor	 edx, edx
  01c64	8a 11		 mov	 dl, BYTE PTR [ecx]
  01c66	83 fa 61	 cmp	 edx, 97			; 00000061H
  01c69	74 1c		 je	 SHORT $L62985
  01c6b	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  01c6e	33 c9		 xor	 ecx, ecx
  01c70	8a 08		 mov	 cl, BYTE PTR [eax]
  01c72	83 f9 66	 cmp	 ecx, 102		; 00000066H
  01c75	74 10		 je	 SHORT $L62985
  01c77	8b 55 fc	 mov	 edx, DWORD PTR _str$[ebp]
  01c7a	33 c0		 xor	 eax, eax
  01c7c	8a 02		 mov	 al, BYTE PTR [edx]
  01c7e	83 f8 78	 cmp	 eax, 120		; 00000078H
  01c81	0f 85 e7 00 00
	00		 jne	 $L62992
$L62985:
  01c87	8b 4d 0c	 mov	 ecx, DWORD PTR _count$[ebp]
  01c8a	8b 55 0c	 mov	 edx, DWORD PTR _count$[ebp]
  01c8d	83 ea 01	 sub	 edx, 1
  01c90	89 55 0c	 mov	 DWORD PTR _count$[ebp], edx
  01c93	85 c9		 test	 ecx, ecx
  01c95	0f 8e d3 00 00
	00		 jle	 $L62992

; 860  : 				int action = *str;

  01c9b	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  01c9e	33 c9		 xor	 ecx, ecx
  01ca0	8a 08		 mov	 cl, BYTE PTR [eax]
  01ca2	89 4d f4	 mov	 DWORD PTR _action$62986[ebp], ecx

; 861  : 				str++;

  01ca5	8b 55 fc	 mov	 edx, DWORD PTR _str$[ebp]
  01ca8	83 c2 01	 add	 edx, 1
  01cab	89 55 fc	 mov	 DWORD PTR _str$[ebp], edx
$L62988:

; 862  : 				while(*str >= '0' && *str <= '9' && count) {

  01cae	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  01cb1	33 c9		 xor	 ecx, ecx
  01cb3	8a 08		 mov	 cl, BYTE PTR [eax]
  01cb5	83 f9 30	 cmp	 ecx, 48			; 00000030H
  01cb8	7c 40		 jl	 SHORT $L62989
  01cba	8b 55 fc	 mov	 edx, DWORD PTR _str$[ebp]
  01cbd	33 c0		 xor	 eax, eax
  01cbf	8a 02		 mov	 al, BYTE PTR [edx]
  01cc1	83 f8 39	 cmp	 eax, 57			; 00000039H
  01cc4	7f 34		 jg	 SHORT $L62989
  01cc6	83 7d 0c 00	 cmp	 DWORD PTR _count$[ebp], 0
  01cca	74 2e		 je	 SHORT $L62989

; 863  : 					newNum *= 10;

  01ccc	8b 4d f8	 mov	 ecx, DWORD PTR _newNum$62982[ebp]
  01ccf	6b c9 0a	 imul	 ecx, 10			; 0000000aH
  01cd2	89 4d f8	 mov	 DWORD PTR _newNum$62982[ebp], ecx

; 864  : 					newNum += *str++ - '0';

  01cd5	8b 55 fc	 mov	 edx, DWORD PTR _str$[ebp]
  01cd8	33 c0		 xor	 eax, eax
  01cda	8a 02		 mov	 al, BYTE PTR [edx]
  01cdc	8b 4d f8	 mov	 ecx, DWORD PTR _newNum$62982[ebp]
  01cdf	8d 54 01 d0	 lea	 edx, DWORD PTR [ecx+eax-48]
  01ce3	89 55 f8	 mov	 DWORD PTR _newNum$62982[ebp], edx
  01ce6	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  01ce9	83 c0 01	 add	 eax, 1
  01cec	89 45 fc	 mov	 DWORD PTR _str$[ebp], eax

; 865  : 	   		   count--;

  01cef	8b 4d 0c	 mov	 ecx, DWORD PTR _count$[ebp]
  01cf2	83 e9 01	 sub	 ecx, 1
  01cf5	89 4d 0c	 mov	 DWORD PTR _count$[ebp], ecx

; 866  : 				}

  01cf8	eb b4		 jmp	 SHORT $L62988
$L62989:

; 867  : 			   if(count > 0)

  01cfa	83 7d 0c 00	 cmp	 DWORD PTR _count$[ebp], 0
  01cfe	7e 6e		 jle	 SHORT $L62992

; 868  : 				   switch(action) {

  01d00	8b 55 f4	 mov	 edx, DWORD PTR _action$62986[ebp]
  01d03	89 55 ec	 mov	 DWORD PTR -20+[ebp], edx
  01d06	8b 45 ec	 mov	 eax, DWORD PTR -20+[ebp]
  01d09	83 e8 61	 sub	 eax, 97			; 00000061H
  01d0c	89 45 ec	 mov	 DWORD PTR -20+[ebp], eax
  01d0f	83 7d ec 17	 cmp	 DWORD PTR -20+[ebp], 23	; 00000017H
  01d13	77 59		 ja	 SHORT $L62992
  01d15	8b 55 ec	 mov	 edx, DWORD PTR -20+[ebp]
  01d18	33 c9		 xor	 ecx, ecx
  01d1a	8a 8a 00 00 00
	00		 mov	 cl, BYTE PTR $L63598[edx]
  01d20	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L63599[ecx*4]
$L62995:

; 869  : 					   case 'c':
; 870  : 						   fore = newNum;

  01d27	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  01d2a	66 8b 4d f8	 mov	 cx, WORD PTR _newNum$62982[ebp]
  01d2e	66 89 48 06	 mov	 WORD PTR [eax+6], cx

; 871  : 							lastColor = fore;

  01d32	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  01d35	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  01d38	66 8b 48 06	 mov	 cx, WORD PTR [eax+6]
  01d3c	66 89 0a	 mov	 WORD PTR [edx], cx

; 872  : //							msgMgr->Mono ( "lastColor changed to %d\n", newNum );
; 873  : 						   break;

  01d3f	eb 2d		 jmp	 SHORT $L62992
$L62996:

; 874  : 					   case 'a': 
; 875  : 						   mode = newNum;

  01d41	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  01d44	66 8b 45 f8	 mov	 ax, WORD PTR _newNum$62982[ebp]
  01d48	66 89 42 46	 mov	 WORD PTR [edx+70], ax

; 876  : 						   break;

  01d4c	eb 20		 jmp	 SHORT $L62992
$L62997:

; 877  : 					   case 'f':
; 878  : 						   SetFont(newNum);

  01d4e	8b 4d f8	 mov	 ecx, DWORD PTR _newNum$62982[ebp]
  01d51	51		 push	 ecx
  01d52	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01d55	e8 00 00 00 00	 call	 ?SetFont@FontMgr@@QAEXH@Z ; FontMgr::SetFont

; 879  : 						   break;

  01d5a	eb 12		 jmp	 SHORT $L62992
$L62998:

; 880  : 						case 'x': 
; 881  : 							if ( newNum > width )

  01d5c	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  01d5f	8b 45 f8	 mov	 eax, DWORD PTR _newNum$62982[ebp]
  01d62	3b 02		 cmp	 eax, DWORD PTR [edx]
  01d64	7e 08		 jle	 SHORT $L62999

; 882  : 								width = newNum;

  01d66	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  01d69	8b 55 f8	 mov	 edx, DWORD PTR _newNum$62982[ebp]
  01d6c	89 11		 mov	 DWORD PTR [ecx], edx
$L62999:
$L62992:

; 886  : 	 
; 887  : 			while(count > 0 && *str != CTRL_CHAR) {

  01d6e	83 7d 0c 00	 cmp	 DWORD PTR _count$[ebp], 0
  01d72	7e 20		 jle	 SHORT $L63002
  01d74	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  01d77	33 c9		 xor	 ecx, ecx
  01d79	8a 08		 mov	 cl, BYTE PTR [eax]
  01d7b	83 f9 7c	 cmp	 ecx, 124		; 0000007cH
  01d7e	74 14		 je	 SHORT $L63002

; 888  : 				count--;

  01d80	8b 55 0c	 mov	 edx, DWORD PTR _count$[ebp]
  01d83	83 ea 01	 sub	 edx, 1
  01d86	89 55 0c	 mov	 DWORD PTR _count$[ebp], edx

; 889  : 				str++;

  01d89	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  01d8c	83 c0 01	 add	 eax, 1
  01d8f	89 45 fc	 mov	 DWORD PTR _str$[ebp], eax

; 890  : 			}

  01d92	eb da		 jmp	 SHORT $L62992
$L63002:

; 893  : 		else {

  01d94	eb 4e		 jmp	 SHORT $L63004
$L62981:

; 894  : 			width += fontWidths[*str];

  01d96	8b 4d fc	 mov	 ecx, DWORD PTR _str$[ebp]
  01d99	33 d2		 xor	 edx, edx
  01d9b	8a 11		 mov	 dl, BYTE PTR [ecx]
  01d9d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  01da0	33 c9		 xor	 ecx, ecx
  01da2	8a 4c 10 58	 mov	 cl, BYTE PTR [eax+edx+88]
  01da6	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  01da9	8b 02		 mov	 eax, DWORD PTR [edx]
  01dab	03 c1		 add	 eax, ecx
  01dad	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  01db0	89 01		 mov	 DWORD PTR [ecx], eax

; 895  : 			if (height < fontHeights[*str])

  01db2	8b 55 fc	 mov	 edx, DWORD PTR _str$[ebp]
  01db5	33 c0		 xor	 eax, eax
  01db7	8a 02		 mov	 al, BYTE PTR [edx]
  01db9	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01dbc	33 d2		 xor	 edx, edx
  01dbe	8a 94 01 58 01
	00 00		 mov	 dl, BYTE PTR [ecx+eax+344]
  01dc5	8b 45 14	 mov	 eax, DWORD PTR _height$[ebp]
  01dc8	39 10		 cmp	 DWORD PTR [eax], edx
  01dca	7d 18		 jge	 SHORT $L63004

; 896  : 				height = fontHeights[*str];

  01dcc	8b 4d fc	 mov	 ecx, DWORD PTR _str$[ebp]
  01dcf	33 d2		 xor	 edx, edx
  01dd1	8a 11		 mov	 dl, BYTE PTR [ecx]
  01dd3	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  01dd6	33 c9		 xor	 ecx, ecx
  01dd8	8a 8c 10 58 01
	00 00		 mov	 cl, BYTE PTR [eax+edx+344]
  01ddf	8b 55 14	 mov	 edx, DWORD PTR _height$[ebp]
  01de2	89 0a		 mov	 DWORD PTR [edx], ecx
$L63004:

; 898  : 
; 899  :       str++;

  01de4	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  01de7	83 c0 01	 add	 eax, 1
  01dea	89 45 fc	 mov	 DWORD PTR _str$[ebp], eax

; 900  : 	}

  01ded	e9 09 fe ff ff	 jmp	 $L62979
$L62980:

; 901  : }

  01df2	8b e5		 mov	 esp, ebp
  01df4	5d		 pop	 ebp
  01df5	c2 10 00	 ret	 16			; 00000010H
$L63599:
  01df8	00 00 00 00	 DD	 $L62996
  01dfc	00 00 00 00	 DD	 $L62995
  01e00	00 00 00 00	 DD	 $L62997
  01e04	00 00 00 00	 DD	 $L62998
  01e08	00 00 00 00	 DD	 $L62992
$L63598:
  01e0c	00		 DB	 0
  01e0d	04		 DB	 4
  01e0e	01		 DB	 1
  01e0f	04		 DB	 4
  01e10	04		 DB	 4
  01e11	02		 DB	 2
  01e12	04		 DB	 4
  01e13	04		 DB	 4
  01e14	04		 DB	 4
  01e15	04		 DB	 4
  01e16	04		 DB	 4
  01e17	04		 DB	 4
  01e18	04		 DB	 4
  01e19	04		 DB	 4
  01e1a	04		 DB	 4
  01e1b	04		 DB	 4
  01e1c	04		 DB	 4
  01e1d	04		 DB	 4
  01e1e	04		 DB	 4
  01e1f	04		 DB	 4
  01e20	04		 DB	 4
  01e21	04		 DB	 4
  01e22	04		 DB	 4
  01e23	03		 DB	 3
?TextDimensions@FontMgr@@IAEXHHAAH0@Z ENDP		; FontMgr::TextDimensions
_TEXT	ENDS
PUBLIC	?TextWidth@FontMgr@@QAEHVMemID@@HH@Z		; FontMgr::TextWidth
_TEXT	SEGMENT
_theText$ = 8
_first$ = 12
_count$ = 16
_this$ = -12
_width$ = -4
_height$ = -8
?TextWidth@FontMgr@@QAEHVMemID@@HH@Z PROC NEAR		; FontMgr::TextWidth

; 905  : {

  01e24	55		 push	 ebp
  01e25	8b ec		 mov	 ebp, esp
  01e27	83 ec 0c	 sub	 esp, 12			; 0000000cH
  01e2a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 906  : 	// Adds the widths of the characters in the given string
; 907  : 	// from the character str[index] for a length of count up
; 908  : 	// to the end of the string
; 909  : 	text = theText;

  01e2d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  01e30	66 8b 4d 08	 mov	 cx, WORD PTR _theText$[ebp]
  01e34	66 89 48 0e	 mov	 WORD PTR [eax+14], cx

; 910  : 	int width;
; 911  : 	int height;
; 912  : 	TextDimensions(first,count,width,height);

  01e38	8d 55 f8	 lea	 edx, DWORD PTR _height$[ebp]
  01e3b	52		 push	 edx
  01e3c	8d 45 fc	 lea	 eax, DWORD PTR _width$[ebp]
  01e3f	50		 push	 eax
  01e40	8b 4d 10	 mov	 ecx, DWORD PTR _count$[ebp]
  01e43	51		 push	 ecx
  01e44	8b 55 0c	 mov	 edx, DWORD PTR _first$[ebp]
  01e47	52		 push	 edx
  01e48	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  01e4b	e8 00 00 00 00	 call	 ?TextDimensions@FontMgr@@IAEXHHAAH0@Z ; FontMgr::TextDimensions

; 913  : 	return (width*SCIRESX + xRes - 1)/xRes;

  01e50	8b 45 fc	 mov	 eax, DWORD PTR _width$[ebp]
  01e53	69 c0 80 02 00
	00		 imul	 eax, 640		; 00000280H
  01e59	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes
  01e5f	8d 44 08 ff	 lea	 eax, DWORD PTR [eax+ecx-1]
  01e63	99		 cdq
  01e64	f7 3d 00 00 00
	00		 idiv	 DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes

; 914  : }

  01e6a	8b e5		 mov	 esp, ebp
  01e6c	5d		 pop	 ebp
  01e6d	c2 0c 00	 ret	 12			; 0000000cH
?TextWidth@FontMgr@@QAEHVMemID@@HH@Z ENDP		; FontMgr::TextWidth
_TEXT	ENDS
PUBLIC	?CharWidth@FontMgr@@QAEEEH@Z			; FontMgr::CharWidth
_TEXT	SEGMENT
_theChar$ = 8
_scale$ = 12
_this$ = -4
?CharWidth@FontMgr@@QAEEEH@Z PROC NEAR			; FontMgr::CharWidth

; 918  : {

  01e70	55		 push	 ebp
  01e71	8b ec		 mov	 ebp, esp
  01e73	51		 push	 ecx
  01e74	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 919  : 	// Determine the given character's width using the current font
; 920  : 	if(scale)

  01e77	83 7d 0c 00	 cmp	 DWORD PTR _scale$[ebp], 0
  01e7b	74 29		 je	 SHORT $L63018

; 921  : 		return (fontWidths[theChar] * SCIRESX + xRes - 1) / xRes;

  01e7d	8b 45 08	 mov	 eax, DWORD PTR _theChar$[ebp]
  01e80	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01e85	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01e88	33 d2		 xor	 edx, edx
  01e8a	8a 54 01 58	 mov	 dl, BYTE PTR [ecx+eax+88]
  01e8e	69 d2 80 02 00
	00		 imul	 edx, 640		; 00000280H
  01e94	a1 00 00 00 00	 mov	 eax, DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes
  01e99	8d 44 02 ff	 lea	 eax, DWORD PTR [edx+eax-1]
  01e9d	99		 cdq
  01e9e	f7 3d 00 00 00
	00		 idiv	 DWORD PTR ?xRes@FontMgr@@1HA ; FontMgr::xRes
  01ea4	eb 10		 jmp	 SHORT $L63017
$L63018:

; 922  : 
; 923  : 	return fontWidths[theChar];

  01ea6	8b 4d 08	 mov	 ecx, DWORD PTR _theChar$[ebp]
  01ea9	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  01eaf	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01eb2	8a 44 0a 58	 mov	 al, BYTE PTR [edx+ecx+88]
$L63017:

; 924  : }

  01eb6	8b e5		 mov	 esp, ebp
  01eb8	5d		 pop	 ebp
  01eb9	c2 08 00	 ret	 8
?CharWidth@FontMgr@@QAEEEH@Z ENDP			; FontMgr::CharWidth
_TEXT	ENDS
PUBLIC	?CharHeight@FontMgr@@QAEEEH@Z			; FontMgr::CharHeight
_TEXT	SEGMENT
_theChar$ = 8
_scale$ = 12
_this$ = -4
?CharHeight@FontMgr@@QAEEEH@Z PROC NEAR			; FontMgr::CharHeight

; 928  : {

  01ebc	55		 push	 ebp
  01ebd	8b ec		 mov	 ebp, esp
  01ebf	51		 push	 ecx
  01ec0	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 929  : 	// Determine the given character's height using the current font
; 930  : 	
; 931  : 	if(scale)

  01ec3	83 7d 0c 00	 cmp	 DWORD PTR _scale$[ebp], 0
  01ec7	74 2c		 je	 SHORT $L63024

; 932  : 		return (fontHeights[theChar] * SCIRESY + yRes - 1) / yRes;

  01ec9	8b 45 08	 mov	 eax, DWORD PTR _theChar$[ebp]
  01ecc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01ed1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01ed4	33 d2		 xor	 edx, edx
  01ed6	8a 94 01 58 01
	00 00		 mov	 dl, BYTE PTR [ecx+eax+344]
  01edd	69 d2 e0 01 00
	00		 imul	 edx, 480		; 000001e0H
  01ee3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?yRes@FontMgr@@1HA ; FontMgr::yRes
  01ee8	8d 44 02 ff	 lea	 eax, DWORD PTR [edx+eax-1]
  01eec	99		 cdq
  01eed	f7 3d 00 00 00
	00		 idiv	 DWORD PTR ?yRes@FontMgr@@1HA ; FontMgr::yRes
  01ef3	eb 13		 jmp	 SHORT $L63023
$L63024:

; 933  : 
; 934  : 	return fontHeights[theChar];

  01ef5	8b 4d 08	 mov	 ecx, DWORD PTR _theChar$[ebp]
  01ef8	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  01efe	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01f01	8a 84 0a 58 01
	00 00		 mov	 al, BYTE PTR [edx+ecx+344]
$L63023:

; 935  : }

  01f08	8b e5		 mov	 esp, ebp
  01f0a	5d		 pop	 ebp
  01f0b	c2 08 00	 ret	 8
?CharHeight@FontMgr@@QAEEEH@Z ENDP			; FontMgr::CharHeight
_TEXT	ENDS
PUBLIC	?DrawTextA@FontMgr@@IAEXHH@Z			; FontMgr::DrawTextA
_TEXT	SEGMENT
_this$ = -40
_wide$ = -4
_str$ = -8
_strOffset$ = -12
_start$ = -16
_oldfont$63037 = -32
_oldcolor$63038 = -20
_drawCount$63039 = -28
_length$63040 = -24
_height$63041 = -36
?DrawTextBox@FontMgr@@QAEXXZ PROC NEAR			; FontMgr::DrawTextBox

; 939  : {

  01f0e	55		 push	 ebp
  01f0f	8b ec		 mov	 ebp, esp
  01f11	83 ec 2c	 sub	 esp, 44			; 0000002cH
  01f14	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx

; 940  : 	// Put the text to the textBox in mode requested 
; 941  : 
; 942  : 	int wide = textBox.Xlen();

  01f17	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01f1a	83 c1 14	 add	 ecx, 20			; 00000014H
  01f1d	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  01f22	89 45 fc	 mov	 DWORD PTR _wide$[ebp], eax

; 943  : 	uchar* str = (uchar*) memMgr->GetAddr(text);

  01f25	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01f28	83 c1 0e	 add	 ecx, 14			; 0000000eH
  01f2b	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  01f30	50		 push	 eax
  01f31	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  01f37	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr
  01f3c	89 45 f8	 mov	 DWORD PTR _str$[ebp], eax

; 944  :    if (!*str)

  01f3f	8b 45 f8	 mov	 eax, DWORD PTR _str$[ebp]
  01f42	33 c9		 xor	 ecx, ecx
  01f44	8a 08		 mov	 cl, BYTE PTR [eax]
  01f46	85 c9		 test	 ecx, ecx
  01f48	75 05		 jne	 SHORT $L63031

; 945  :       return;

  01f4a	e9 49 01 00 00	 jmp	 $L63027
$L63031:

; 946  : 
; 947  : 	// Set the penY into the textBox at the draw position
; 948  : 	penY = textBox.A.y;

  01f4f	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  01f52	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  01f55	66 8b 48 18	 mov	 cx, WORD PTR [eax+24]
  01f59	66 89 4a 4a	 mov	 WORD PTR [edx+74], cx

; 949  : 
; 950  : 	int strOffset = 0;

  01f5d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _strOffset$[ebp], 0

; 951  : 	int start = 0;

  01f64	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _start$[ebp], 0
$L63035:

; 952  : 
; 953  : 	while (*str) { 

  01f6b	8b 55 f8	 mov	 edx, DWORD PTR _str$[ebp]
  01f6e	33 c0		 xor	 eax, eax
  01f70	8a 02		 mov	 al, BYTE PTR [edx]
  01f72	85 c0		 test	 eax, eax
  01f74	0f 84 1e 01 00
	00		 je	 $L63036

; 954  : 		int oldfont = font;

  01f7a	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01f7d	33 d2		 xor	 edx, edx
  01f7f	66 8b 51 28	 mov	 dx, WORD PTR [ecx+40]
  01f83	89 55 e0	 mov	 DWORD PTR _oldfont$63037[ebp], edx

; 955  : 		int oldcolor = fore;

  01f86	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  01f89	33 c9		 xor	 ecx, ecx
  01f8b	66 8b 48 06	 mov	 cx, WORD PTR [eax+6]
  01f8f	89 4d ec	 mov	 DWORD PTR _oldcolor$63038[ebp], ecx

; 956  : 		// Set the penX into the textBox at the draw position
; 957  : 		penX = textBox.A.x;

  01f92	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  01f95	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  01f98	66 8b 48 14	 mov	 cx, WORD PTR [eax+20]
  01f9c	66 89 4a 48	 mov	 WORD PTR [edx+72], cx

; 958  : 		//Getlongest assumes the string is text
; 959  : 		int drawCount = GetLongest(&strOffset,wide);

  01fa0	8b 55 fc	 mov	 edx, DWORD PTR _wide$[ebp]
  01fa3	52		 push	 edx
  01fa4	8d 45 f4	 lea	 eax, DWORD PTR _strOffset$[ebp]
  01fa7	50		 push	 eax
  01fa8	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01fab	e8 00 00 00 00	 call	 ?GetLongest@FontMgr@@QAEGPAHH@Z ; FontMgr::GetLongest
  01fb0	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  01fb5	89 45 e4	 mov	 DWORD PTR _drawCount$63039[ebp], eax

; 960  : 		SetFont(oldfont);

  01fb8	8b 4d e0	 mov	 ecx, DWORD PTR _oldfont$63037[ebp]
  01fbb	51		 push	 ecx
  01fbc	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01fbf	e8 00 00 00 00	 call	 ?SetFont@FontMgr@@QAEXH@Z ; FontMgr::SetFont

; 961  : 		fore = oldcolor;

  01fc4	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  01fc7	66 8b 45 ec	 mov	 ax, WORD PTR _oldcolor$63038[ebp]
  01fcb	66 89 42 06	 mov	 WORD PTR [edx+6], ax

; 962  : 		// drawCount is the count of characters to print
; 963  : 		// strOffset is where to resume printing from
; 964  : 		// GetLongest may pass over non-printable characters
; 965  : 		int length;
; 966  :  		int height;
; 967  : 		TextDimensions(start,drawCount,length,height); 

  01fcf	8d 4d dc	 lea	 ecx, DWORD PTR _height$63041[ebp]
  01fd2	51		 push	 ecx
  01fd3	8d 55 e8	 lea	 edx, DWORD PTR _length$63040[ebp]
  01fd6	52		 push	 edx
  01fd7	8b 45 e4	 mov	 eax, DWORD PTR _drawCount$63039[ebp]
  01fda	50		 push	 eax
  01fdb	8b 4d f0	 mov	 ecx, DWORD PTR _start$[ebp]
  01fde	51		 push	 ecx
  01fdf	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01fe2	e8 00 00 00 00	 call	 ?TextDimensions@FontMgr@@IAEXHHAAH0@Z ; FontMgr::TextDimensions

; 968  : 		SetFont(oldfont);

  01fe7	8b 55 e0	 mov	 edx, DWORD PTR _oldfont$63037[ebp]
  01fea	52		 push	 edx
  01feb	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  01fee	e8 00 00 00 00	 call	 ?SetFont@FontMgr@@QAEXH@Z ; FontMgr::SetFont

; 969  : 		fore = oldcolor;

  01ff3	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  01ff6	66 8b 4d ec	 mov	 cx, WORD PTR _oldcolor$63038[ebp]
  01ffa	66 89 48 06	 mov	 WORD PTR [eax+6], cx

; 970  : 	   // determine justification and draw the line
; 971  : 		switch (mode) {

  01ffe	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  02001	0f bf 42 46	 movsx	 eax, WORD PTR [edx+70]
  02005	89 45 d4	 mov	 DWORD PTR -44+[ebp], eax
  02008	83 7d d4 01	 cmp	 DWORD PTR -44+[ebp], 1
  0200c	74 08		 je	 SHORT $L63046
  0200e	83 7d d4 02	 cmp	 DWORD PTR -44+[ebp], 2
  02012	74 20		 je	 SHORT $L63047
  02014	eb 35		 jmp	 SHORT $L63043
$L63046:

; 972  : 			case TEJUSTCENTER:
; 973  : 				penX += (wide - length)/2;

  02016	8b 45 fc	 mov	 eax, DWORD PTR _wide$[ebp]
  02019	2b 45 e8	 sub	 eax, DWORD PTR _length$63040[ebp]
  0201c	99		 cdq
  0201d	2b c2		 sub	 eax, edx
  0201f	d1 f8		 sar	 eax, 1
  02021	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  02024	66 8b 51 48	 mov	 dx, WORD PTR [ecx+72]
  02028	66 03 d0	 add	 dx, ax
  0202b	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  0202e	66 89 50 48	 mov	 WORD PTR [eax+72], dx

; 974  : 				break;

  02032	eb 17		 jmp	 SHORT $L63043
$L63047:

; 975  : 			case TEJUSTRIGHT:
; 976  : 				penX += wide - length;

  02034	8b 4d fc	 mov	 ecx, DWORD PTR _wide$[ebp]
  02037	2b 4d e8	 sub	 ecx, DWORD PTR _length$63040[ebp]
  0203a	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  0203d	66 8b 42 48	 mov	 ax, WORD PTR [edx+72]
  02041	66 03 c1	 add	 ax, cx
  02044	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  02047	66 89 41 48	 mov	 WORD PTR [ecx+72], ax
$L63043:

; 982  : 		DrawText(start,drawCount);

  0204b	8b 55 e4	 mov	 edx, DWORD PTR _drawCount$63039[ebp]
  0204e	52		 push	 edx
  0204f	8b 45 f0	 mov	 eax, DWORD PTR _start$[ebp]
  02052	50		 push	 eax
  02053	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  02056	e8 00 00 00 00	 call	 ?DrawTextA@FontMgr@@IAEXHH@Z ; FontMgr::DrawTextA

; 983  : 		start = strOffset;

  0205b	8b 4d f4	 mov	 ecx, DWORD PTR _strOffset$[ebp]
  0205e	89 4d f0	 mov	 DWORD PTR _start$[ebp], ecx

; 984  : 		str = (uchar*) memMgr->GetAddr(text) + strOffset;

  02061	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  02064	83 c1 0e	 add	 ecx, 14			; 0000000eH
  02067	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  0206c	50		 push	 eax
  0206d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  02073	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr
  02078	03 45 f4	 add	 eax, DWORD PTR _strOffset$[ebp]
  0207b	89 45 f8	 mov	 DWORD PTR _str$[ebp], eax

; 985  : 		// put the penY down one line
; 986  : 		penY += pointSize;

  0207e	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  02081	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  02084	66 8b 4a 4a	 mov	 cx, WORD PTR [edx+74]
  02088	66 03 48 4c	 add	 cx, WORD PTR [eax+76]
  0208c	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  0208f	66 89 4a 4a	 mov	 WORD PTR [edx+74], cx

; 987  :    }

  02093	e9 d3 fe ff ff	 jmp	 $L63035
$L63036:
$L63027:

; 988  : }

  02098	8b e5		 mov	 esp, ebp
  0209a	5d		 pop	 ebp
  0209b	c3		 ret	 0
?DrawTextBox@FontMgr@@QAEXXZ ENDP			; FontMgr::DrawTextBox
_TEXT	ENDS
PUBLIC	?DrawChar@FontMgr@@IAEXE@Z			; FontMgr::DrawChar
_TEXT	SEGMENT
_index$ = 8
_count$ = 12
_this$ = -20
_startX$ = -8
_str$ = -4
_newNum$63061 = -12
_action$63065 = -16
?DrawTextA@FontMgr@@IAEXHH@Z PROC NEAR			; FontMgr::DrawTextA

; 992  : {

  0209c	55		 push	 ebp
  0209d	8b ec		 mov	 ebp, esp
  0209f	83 ec 18	 sub	 esp, 24			; 00000018H
  020a2	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 993  : 	int startX = penX;

  020a5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  020a8	33 c9		 xor	 ecx, ecx
  020aa	66 8b 48 48	 mov	 cx, WORD PTR [eax+72]
  020ae	89 4d f8	 mov	 DWORD PTR _startX$[ebp], ecx

; 994  : 
; 995  : 	uchar* str = (uchar*) memMgr->GetAddr(text);

  020b1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  020b4	83 c1 0e	 add	 ecx, 14			; 0000000eH
  020b7	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  020bc	50		 push	 eax
  020bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  020c3	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr
  020c8	89 45 fc	 mov	 DWORD PTR _str$[ebp], eax
$L63058:

; 996  : 	while(count-- > 0) {

  020cb	8b 55 0c	 mov	 edx, DWORD PTR _count$[ebp]
  020ce	8b 45 0c	 mov	 eax, DWORD PTR _count$[ebp]
  020d1	83 e8 01	 sub	 eax, 1
  020d4	89 45 0c	 mov	 DWORD PTR _count$[ebp], eax
  020d7	85 d2		 test	 edx, edx
  020d9	0f 8e ad 01 00
	00		 jle	 $L63059

; 997  : 		if(str[index] == CTRL_CHAR) {

  020df	8b 4d fc	 mov	 ecx, DWORD PTR _str$[ebp]
  020e2	03 4d 08	 add	 ecx, DWORD PTR _index$[ebp]
  020e5	33 d2		 xor	 edx, edx
  020e7	8a 11		 mov	 dl, BYTE PTR [ecx]
  020e9	83 fa 7c	 cmp	 edx, 124		; 0000007cH
  020ec	0f 85 7b 01 00
	00		 jne	 $L63060

; 998  : 			int newNum;
; 999  : 			newNum = 0;

  020f2	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _newNum$63061[ebp], 0

; 1000 : 			index++;

  020f9	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  020fc	83 c0 01	 add	 eax, 1
  020ff	89 45 08	 mov	 DWORD PTR _index$[ebp], eax

; 1001 : 			if(!count--) break;

  02102	8b 4d 0c	 mov	 ecx, DWORD PTR _count$[ebp]
  02105	8b 55 0c	 mov	 edx, DWORD PTR _count$[ebp]
  02108	83 ea 01	 sub	 edx, 1
  0210b	89 55 0c	 mov	 DWORD PTR _count$[ebp], edx
  0210e	85 c9		 test	 ecx, ecx
  02110	75 05		 jne	 SHORT $L63062
  02112	e9 75 01 00 00	 jmp	 $L63059
$L63062:

; 1002 : 
; 1003 : 			if((str[index] == 'c' || str[index] == 'a' || str[index] == 'f' || str[index] == 'x') &&  count--) {

  02117	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  0211a	03 45 08	 add	 eax, DWORD PTR _index$[ebp]
  0211d	33 c9		 xor	 ecx, ecx
  0211f	8a 08		 mov	 cl, BYTE PTR [eax]
  02121	83 f9 63	 cmp	 ecx, 99			; 00000063H
  02124	74 31		 je	 SHORT $L63064
  02126	8b 55 fc	 mov	 edx, DWORD PTR _str$[ebp]
  02129	03 55 08	 add	 edx, DWORD PTR _index$[ebp]
  0212c	33 c0		 xor	 eax, eax
  0212e	8a 02		 mov	 al, BYTE PTR [edx]
  02130	83 f8 61	 cmp	 eax, 97			; 00000061H
  02133	74 22		 je	 SHORT $L63064
  02135	8b 4d fc	 mov	 ecx, DWORD PTR _str$[ebp]
  02138	03 4d 08	 add	 ecx, DWORD PTR _index$[ebp]
  0213b	33 d2		 xor	 edx, edx
  0213d	8a 11		 mov	 dl, BYTE PTR [ecx]
  0213f	83 fa 66	 cmp	 edx, 102		; 00000066H
  02142	74 13		 je	 SHORT $L63064
  02144	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  02147	03 45 08	 add	 eax, DWORD PTR _index$[ebp]
  0214a	33 c9		 xor	 ecx, ecx
  0214c	8a 08		 mov	 cl, BYTE PTR [eax]
  0214e	83 f9 78	 cmp	 ecx, 120		; 00000078H
  02151	0f 85 eb 00 00
	00		 jne	 $L63071
$L63064:
  02157	8b 55 0c	 mov	 edx, DWORD PTR _count$[ebp]
  0215a	8b 45 0c	 mov	 eax, DWORD PTR _count$[ebp]
  0215d	83 e8 01	 sub	 eax, 1
  02160	89 45 0c	 mov	 DWORD PTR _count$[ebp], eax
  02163	85 d2		 test	 edx, edx
  02165	0f 84 d7 00 00
	00		 je	 $L63071

; 1004 : 		int action = str[index];

  0216b	8b 4d fc	 mov	 ecx, DWORD PTR _str$[ebp]
  0216e	03 4d 08	 add	 ecx, DWORD PTR _index$[ebp]
  02171	33 d2		 xor	 edx, edx
  02173	8a 11		 mov	 dl, BYTE PTR [ecx]
  02175	89 55 f0	 mov	 DWORD PTR _action$63065[ebp], edx

; 1005 : 				index++;

  02178	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0217b	83 c0 01	 add	 eax, 1
  0217e	89 45 08	 mov	 DWORD PTR _index$[ebp], eax
$L63067:

; 1006 : 				while(str[index] >= '0' && str[index] <= '9' && count) {

  02181	8b 4d fc	 mov	 ecx, DWORD PTR _str$[ebp]
  02184	03 4d 08	 add	 ecx, DWORD PTR _index$[ebp]
  02187	33 d2		 xor	 edx, edx
  02189	8a 11		 mov	 dl, BYTE PTR [ecx]
  0218b	83 fa 30	 cmp	 edx, 48			; 00000030H
  0218e	7c 46		 jl	 SHORT $L63068
  02190	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  02193	03 45 08	 add	 eax, DWORD PTR _index$[ebp]
  02196	33 c9		 xor	 ecx, ecx
  02198	8a 08		 mov	 cl, BYTE PTR [eax]
  0219a	83 f9 39	 cmp	 ecx, 57			; 00000039H
  0219d	7f 37		 jg	 SHORT $L63068
  0219f	83 7d 0c 00	 cmp	 DWORD PTR _count$[ebp], 0
  021a3	74 31		 je	 SHORT $L63068

; 1007 : 					newNum *= 10;

  021a5	8b 55 f4	 mov	 edx, DWORD PTR _newNum$63061[ebp]
  021a8	6b d2 0a	 imul	 edx, 10			; 0000000aH
  021ab	89 55 f4	 mov	 DWORD PTR _newNum$63061[ebp], edx

; 1008 : 					newNum += str[index++] - '0';

  021ae	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  021b1	03 45 08	 add	 eax, DWORD PTR _index$[ebp]
  021b4	33 c9		 xor	 ecx, ecx
  021b6	8a 08		 mov	 cl, BYTE PTR [eax]
  021b8	8b 55 f4	 mov	 edx, DWORD PTR _newNum$63061[ebp]
  021bb	8d 44 0a d0	 lea	 eax, DWORD PTR [edx+ecx-48]
  021bf	89 45 f4	 mov	 DWORD PTR _newNum$63061[ebp], eax
  021c2	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  021c5	83 c1 01	 add	 ecx, 1
  021c8	89 4d 08	 mov	 DWORD PTR _index$[ebp], ecx

; 1009 : 	       count--;

  021cb	8b 55 0c	 mov	 edx, DWORD PTR _count$[ebp]
  021ce	83 ea 01	 sub	 edx, 1
  021d1	89 55 0c	 mov	 DWORD PTR _count$[ebp], edx

; 1010 : 				}

  021d4	eb ab		 jmp	 SHORT $L63067
$L63068:

; 1011 : 	    if(count)

  021d6	83 7d 0c 00	 cmp	 DWORD PTR _count$[ebp], 0
  021da	74 66		 je	 SHORT $L63071

; 1012 : 				   switch(action) {

  021dc	8b 45 f0	 mov	 eax, DWORD PTR _action$63065[ebp]
  021df	89 45 e8	 mov	 DWORD PTR -24+[ebp], eax
  021e2	8b 4d e8	 mov	 ecx, DWORD PTR -24+[ebp]
  021e5	83 e9 61	 sub	 ecx, 97			; 00000061H
  021e8	89 4d e8	 mov	 DWORD PTR -24+[ebp], ecx
  021eb	83 7d e8 17	 cmp	 DWORD PTR -24+[ebp], 23	; 00000017H
  021ef	77 51		 ja	 SHORT $L63071
  021f1	8b 45 e8	 mov	 eax, DWORD PTR -24+[ebp]
  021f4	33 d2		 xor	 edx, edx
  021f6	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR $L63605[eax]
  021fc	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L63606[edx*4]
$L63074:

; 1013 : 					   case 'c':
; 1014 : 						   fore = newNum;

  02203	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  02206	66 8b 55 f4	 mov	 dx, WORD PTR _newNum$63061[ebp]
  0220a	66 89 51 06	 mov	 WORD PTR [ecx+6], dx

; 1015 : 							lastColor = newNum;

  0220e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  02211	66 8b 4d f4	 mov	 cx, WORD PTR _newNum$63061[ebp]
  02215	66 89 08	 mov	 WORD PTR [eax], cx

; 1016 : 						   break;

  02218	eb 28		 jmp	 SHORT $L63071
$L63075:

; 1017 : 					   case 'a': 
; 1018 : 						   mode = newNum;

  0221a	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0221d	66 8b 45 f4	 mov	 ax, WORD PTR _newNum$63061[ebp]
  02221	66 89 42 46	 mov	 WORD PTR [edx+70], ax

; 1019 : 						   break;

  02225	eb 1b		 jmp	 SHORT $L63071
$L63076:

; 1020 : 					   case 'f':
; 1021 : 						   SetFont(newNum);

  02227	8b 4d f4	 mov	 ecx, DWORD PTR _newNum$63061[ebp]
  0222a	51		 push	 ecx
  0222b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0222e	e8 00 00 00 00	 call	 ?SetFont@FontMgr@@QAEXH@Z ; FontMgr::SetFont

; 1022 : 						   break;

  02233	eb 0d		 jmp	 SHORT $L63071
$L63077:

; 1023 : 						case 'x':
; 1024 :  							penX = startX + newNum;

  02235	8b 55 f8	 mov	 edx, DWORD PTR _startX$[ebp]
  02238	03 55 f4	 add	 edx, DWORD PTR _newNum$63061[ebp]
  0223b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0223e	66 89 50 48	 mov	 WORD PTR [eax+72], dx
$L63071:

; 1028 : 	 
; 1029 : 			while(count > 0 && str[index] != CTRL_CHAR) {

  02242	83 7d 0c 00	 cmp	 DWORD PTR _count$[ebp], 0
  02246	7e 23		 jle	 SHORT $L63080
  02248	8b 4d fc	 mov	 ecx, DWORD PTR _str$[ebp]
  0224b	03 4d 08	 add	 ecx, DWORD PTR _index$[ebp]
  0224e	33 d2		 xor	 edx, edx
  02250	8a 11		 mov	 dl, BYTE PTR [ecx]
  02252	83 fa 7c	 cmp	 edx, 124		; 0000007cH
  02255	74 14		 je	 SHORT $L63080

; 1030 : 				count--;

  02257	8b 45 0c	 mov	 eax, DWORD PTR _count$[ebp]
  0225a	83 e8 01	 sub	 eax, 1
  0225d	89 45 0c	 mov	 DWORD PTR _count$[ebp], eax

; 1031 : 				index++;

  02260	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  02263	83 c1 01	 add	 ecx, 1
  02266	89 4d 08	 mov	 DWORD PTR _index$[ebp], ecx

; 1032 : 			}

  02269	eb d7		 jmp	 SHORT $L63071
$L63080:

; 1033 : 		} else 

  0226b	eb 11		 jmp	 SHORT $L63081
$L63060:

; 1034 : 			DrawChar(str[index]);

  0226d	8b 55 fc	 mov	 edx, DWORD PTR _str$[ebp]
  02270	03 55 08	 add	 edx, DWORD PTR _index$[ebp]
  02273	8a 02		 mov	 al, BYTE PTR [edx]
  02275	50		 push	 eax
  02276	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  02279	e8 00 00 00 00	 call	 ?DrawChar@FontMgr@@IAEXE@Z ; FontMgr::DrawChar
$L63081:

; 1035 :       index++;

  0227e	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  02281	83 c1 01	 add	 ecx, 1
  02284	89 4d 08	 mov	 DWORD PTR _index$[ebp], ecx

; 1036 : 	}

  02287	e9 3f fe ff ff	 jmp	 $L63058
$L63059:

; 1037 : }

  0228c	8b e5		 mov	 esp, ebp
  0228e	5d		 pop	 ebp
  0228f	c2 08 00	 ret	 8
$L63606:
  02292	00 00 00 00	 DD	 $L63075
  02296	00 00 00 00	 DD	 $L63074
  0229a	00 00 00 00	 DD	 $L63076
  0229e	00 00 00 00	 DD	 $L63077
  022a2	00 00 00 00	 DD	 $L63071
$L63605:
  022a6	00		 DB	 0
  022a7	04		 DB	 4
  022a8	01		 DB	 1
  022a9	04		 DB	 4
  022aa	04		 DB	 4
  022ab	02		 DB	 2
  022ac	04		 DB	 4
  022ad	04		 DB	 4
  022ae	04		 DB	 4
  022af	04		 DB	 4
  022b0	04		 DB	 4
  022b1	04		 DB	 4
  022b2	04		 DB	 4
  022b3	04		 DB	 4
  022b4	04		 DB	 4
  022b5	04		 DB	 4
  022b6	04		 DB	 4
  022b7	04		 DB	 4
  022b8	04		 DB	 4
  022b9	04		 DB	 4
  022ba	04		 DB	 4
  022bb	04		 DB	 4
  022bc	04		 DB	 4
  022bd	03		 DB	 3
?DrawTextA@FontMgr@@IAEXHH@Z ENDP			; FontMgr::DrawTextA
_TEXT	ENDS
PUBLIC	?DownOneLine@FontMgr@@QAEXIIH@Z			; FontMgr::DownOneLine
EXTRN	_memcpy:NEAR
_TEXT	SEGMENT
_drawCount$ = 8
_maxLines$ = 12
_theFont$ = 16
_this$ = -60
_bits$ = -40
_target$ = -56
_source$ = -32
_vRun$ = -28
_hRun$ = -36
_r$ = -20
_oldfont$ = -48
_oldcolor$ = -24
_length$ = -44
_height$ = -52
_wide$ = -4
?DownOneLine@FontMgr@@QAEXIIH@Z PROC NEAR		; FontMgr::DownOneLine

; 1041 : {

  022be	55		 push	 ebp
  022bf	8b ec		 mov	 ebp, esp
  022c1	83 ec 40	 sub	 esp, 64			; 00000040H
  022c4	56		 push	 esi
  022c5	89 4d c4	 mov	 DWORD PTR _this$[ebp], ecx

; 1042 : 	// Shift down the textBox bits one line
; 1043 : 	uchar* bits = ((uchar*) *BM) + CELHEADERSIZE;

  022c8	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  022cb	83 c1 4e	 add	 ecx, 78			; 0000004eH
  022ce	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  022d3	83 c0 2e	 add	 eax, 46			; 0000002eH
  022d6	89 45 d8	 mov	 DWORD PTR _bits$[ebp], eax

; 1044 : 	uchar* target = bits + BMWidth*(textBox.A.y+maxLines*pointSize-1) + textBox.A.x;

  022d9	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  022dc	33 c9		 xor	 ecx, ecx
  022de	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  022e2	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  022e5	33 c0		 xor	 eax, eax
  022e7	66 8b 42 4c	 mov	 ax, WORD PTR [edx+76]
  022eb	8b 55 0c	 mov	 edx, DWORD PTR _maxLines$[ebp]
  022ee	0f af d0	 imul	 edx, eax
  022f1	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  022f4	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  022f7	8d 54 10 ff	 lea	 edx, DWORD PTR [eax+edx-1]
  022fb	0f af ca	 imul	 ecx, edx
  022fe	8b 45 d8	 mov	 eax, DWORD PTR _bits$[ebp]
  02301	03 c1		 add	 eax, ecx
  02303	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02306	03 41 14	 add	 eax, DWORD PTR [ecx+20]
  02309	89 45 c8	 mov	 DWORD PTR _target$[ebp], eax

; 1045 : 	uchar* source = bits + BMWidth*(textBox.A.y+(maxLines-1)*pointSize-1) + textBox.A.x;

  0230c	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  0230f	33 c0		 xor	 eax, eax
  02311	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  02315	8b 4d 0c	 mov	 ecx, DWORD PTR _maxLines$[ebp]
  02318	83 e9 01	 sub	 ecx, 1
  0231b	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  0231e	33 f6		 xor	 esi, esi
  02320	66 8b 72 4c	 mov	 si, WORD PTR [edx+76]
  02324	0f af ce	 imul	 ecx, esi
  02327	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  0232a	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  0232d	8d 4c 0a ff	 lea	 ecx, DWORD PTR [edx+ecx-1]
  02331	0f af c1	 imul	 eax, ecx
  02334	8b 55 d8	 mov	 edx, DWORD PTR _bits$[ebp]
  02337	03 d0		 add	 edx, eax
  02339	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  0233c	03 50 14	 add	 edx, DWORD PTR [eax+20]
  0233f	89 55 e0	 mov	 DWORD PTR _source$[ebp], edx

; 1046 : 	uint vRun = (maxLines-1)*pointSize;

  02342	8b 4d 0c	 mov	 ecx, DWORD PTR _maxLines$[ebp]
  02345	83 e9 01	 sub	 ecx, 1
  02348	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  0234b	33 c0		 xor	 eax, eax
  0234d	66 8b 42 4c	 mov	 ax, WORD PTR [edx+76]
  02351	0f af c8	 imul	 ecx, eax
  02354	89 4d e4	 mov	 DWORD PTR _vRun$[ebp], ecx

; 1047 : 	uint hRun = textBox.Xlen();

  02357	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  0235a	83 c1 14	 add	 ecx, 20			; 00000014H
  0235d	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  02362	89 45 dc	 mov	 DWORD PTR _hRun$[ebp], eax
$L63095:

; 1048 : 	while (vRun--) {

  02365	8b 4d e4	 mov	 ecx, DWORD PTR _vRun$[ebp]
  02368	8b 55 e4	 mov	 edx, DWORD PTR _vRun$[ebp]
  0236b	83 ea 01	 sub	 edx, 1
  0236e	89 55 e4	 mov	 DWORD PTR _vRun$[ebp], edx
  02371	85 c9		 test	 ecx, ecx
  02373	74 38		 je	 SHORT $L63096

; 1049 : 		memcpy(target,source,hRun);

  02375	8b 45 dc	 mov	 eax, DWORD PTR _hRun$[ebp]
  02378	50		 push	 eax
  02379	8b 4d e0	 mov	 ecx, DWORD PTR _source$[ebp]
  0237c	51		 push	 ecx
  0237d	8b 55 c8	 mov	 edx, DWORD PTR _target$[ebp]
  02380	52		 push	 edx
  02381	e8 00 00 00 00	 call	 _memcpy
  02386	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1050 : 		target -= BMWidth;

  02389	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  0238c	33 c9		 xor	 ecx, ecx
  0238e	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  02392	8b 55 c8	 mov	 edx, DWORD PTR _target$[ebp]
  02395	2b d1		 sub	 edx, ecx
  02397	89 55 c8	 mov	 DWORD PTR _target$[ebp], edx

; 1051 : 		source -= BMWidth;

  0239a	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  0239d	33 c9		 xor	 ecx, ecx
  0239f	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  023a3	8b 55 e0	 mov	 edx, DWORD PTR _source$[ebp]
  023a6	2b d1		 sub	 edx, ecx
  023a8	89 55 e0	 mov	 DWORD PTR _source$[ebp], edx

; 1052 : 	}

  023ab	eb b8		 jmp	 SHORT $L63095
$L63096:

; 1053 : 	// Now put in the first line
; 1054 : 	SOL_Rect r(textBox);

  023ad	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  023b0	83 c0 14	 add	 eax, 20			; 00000014H
  023b3	50		 push	 eax
  023b4	8d 4d ec	 lea	 ecx, DWORD PTR _r$[ebp]
  023b7	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@ABV0@@Z ; SOL_Rect::SOL_Rect

; 1055 : 	r.B.y = r.A.y + pointSize - 1;

  023bc	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  023bf	33 d2		 xor	 edx, edx
  023c1	66 8b 51 4c	 mov	 dx, WORD PTR [ecx+76]
  023c5	8b 45 f0	 mov	 eax, DWORD PTR _r$[ebp+4]
  023c8	8d 4c 10 ff	 lea	 ecx, DWORD PTR [eax+edx-1]
  023cc	89 4d f8	 mov	 DWORD PTR _r$[ebp+12], ecx

; 1056 : 	Erase(r,False);

  023cf	6a 00		 push	 0
  023d1	8d 55 ec	 lea	 edx, DWORD PTR _r$[ebp]
  023d4	52		 push	 edx
  023d5	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  023d8	e8 00 00 00 00	 call	 ?Erase@FontMgr@@QAEXAAVSOL_Rect@@H@Z ; FontMgr::Erase

; 1057 : 	penX = textBox.A.x;

  023dd	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  023e0	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  023e3	66 8b 51 14	 mov	 dx, WORD PTR [ecx+20]
  023e7	66 89 50 48	 mov	 WORD PTR [eax+72], dx

; 1058 : 	penY = textBox.A.y; 

  023eb	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  023ee	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  023f1	66 8b 51 18	 mov	 dx, WORD PTR [ecx+24]
  023f5	66 89 50 4a	 mov	 WORD PTR [eax+74], dx

; 1059 : 	SetFont(theFont);

  023f9	8b 45 10	 mov	 eax, DWORD PTR _theFont$[ebp]
  023fc	50		 push	 eax
  023fd	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02400	e8 00 00 00 00	 call	 ?SetFont@FontMgr@@QAEXH@Z ; FontMgr::SetFont

; 1060 : 	// determine justification and draw the line
; 1061 : 	int oldfont = font;

  02405	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02408	33 d2		 xor	 edx, edx
  0240a	66 8b 51 28	 mov	 dx, WORD PTR [ecx+40]
  0240e	89 55 d0	 mov	 DWORD PTR _oldfont$[ebp], edx

; 1062 : 	int oldcolor = fore;

  02411	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  02414	33 c9		 xor	 ecx, ecx
  02416	66 8b 48 06	 mov	 cx, WORD PTR [eax+6]
  0241a	89 4d e8	 mov	 DWORD PTR _oldcolor$[ebp], ecx

; 1063 : 	int length;
; 1064 : 	int height;
; 1065 : 	TextDimensions(0,drawCount,length,height);

  0241d	8d 55 cc	 lea	 edx, DWORD PTR _height$[ebp]
  02420	52		 push	 edx
  02421	8d 45 d4	 lea	 eax, DWORD PTR _length$[ebp]
  02424	50		 push	 eax
  02425	8b 4d 08	 mov	 ecx, DWORD PTR _drawCount$[ebp]
  02428	51		 push	 ecx
  02429	6a 00		 push	 0
  0242b	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  0242e	e8 00 00 00 00	 call	 ?TextDimensions@FontMgr@@IAEXHHAAH0@Z ; FontMgr::TextDimensions

; 1066 : 	int wide = textBox.Xlen();

  02433	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02436	83 c1 14	 add	 ecx, 20			; 00000014H
  02439	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  0243e	89 45 fc	 mov	 DWORD PTR _wide$[ebp], eax

; 1067 : 	switch (mode) {

  02441	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  02444	0f bf 42 46	 movsx	 eax, WORD PTR [edx+70]
  02448	89 45 c0	 mov	 DWORD PTR -64+[ebp], eax
  0244b	83 7d c0 01	 cmp	 DWORD PTR -64+[ebp], 1
  0244f	74 08		 je	 SHORT $L63107
  02451	83 7d c0 02	 cmp	 DWORD PTR -64+[ebp], 2
  02455	74 20		 je	 SHORT $L63108
  02457	eb 35		 jmp	 SHORT $L63104
$L63107:

; 1068 : 		case TEJUSTCENTER:
; 1069 : 			penX += (wide - length)/2;

  02459	8b 45 fc	 mov	 eax, DWORD PTR _wide$[ebp]
  0245c	2b 45 d4	 sub	 eax, DWORD PTR _length$[ebp]
  0245f	99		 cdq
  02460	2b c2		 sub	 eax, edx
  02462	d1 f8		 sar	 eax, 1
  02464	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02467	66 8b 51 48	 mov	 dx, WORD PTR [ecx+72]
  0246b	66 03 d0	 add	 dx, ax
  0246e	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  02471	66 89 50 48	 mov	 WORD PTR [eax+72], dx

; 1070 : 			break;

  02475	eb 17		 jmp	 SHORT $L63104
$L63108:

; 1071 : 		case TEJUSTRIGHT:
; 1072 : 			penX += wide - length;

  02477	8b 4d fc	 mov	 ecx, DWORD PTR _wide$[ebp]
  0247a	2b 4d d4	 sub	 ecx, DWORD PTR _length$[ebp]
  0247d	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  02480	66 8b 42 48	 mov	 ax, WORD PTR [edx+72]
  02484	66 03 c1	 add	 ax, cx
  02487	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  0248a	66 89 41 48	 mov	 WORD PTR [ecx+72], ax
$L63104:

; 1075 :    SetFont(oldfont);

  0248e	8b 55 d0	 mov	 edx, DWORD PTR _oldfont$[ebp]
  02491	52		 push	 edx
  02492	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02495	e8 00 00 00 00	 call	 ?SetFont@FontMgr@@QAEXH@Z ; FontMgr::SetFont

; 1076 :    fore = oldcolor;

  0249a	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  0249d	66 8b 4d e8	 mov	 cx, WORD PTR _oldcolor$[ebp]
  024a1	66 89 48 06	 mov	 WORD PTR [eax+6], cx

; 1077 : 	DrawText(0,drawCount);

  024a5	8b 55 08	 mov	 edx, DWORD PTR _drawCount$[ebp]
  024a8	52		 push	 edx
  024a9	6a 00		 push	 0
  024ab	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  024ae	e8 00 00 00 00	 call	 ?DrawTextA@FontMgr@@IAEXHH@Z ; FontMgr::DrawTextA

; 1078 : }

  024b3	5e		 pop	 esi
  024b4	8b e5		 mov	 esp, ebp
  024b6	5d		 pop	 ebp
  024b7	c2 0c 00	 ret	 12			; 0000000cH
?DownOneLine@FontMgr@@QAEXIIH@Z ENDP			; FontMgr::DownOneLine
_TEXT	ENDS
PUBLIC	?UpOneLine@FontMgr@@QAEXIIIH@Z			; FontMgr::UpOneLine
_TEXT	SEGMENT
_startDraw$ = 8
_drawCount$ = 12
_maxLines$ = 16
_theFont$ = 20
_this$ = -60
_bits$ = -40
_target$ = -56
_source$ = -32
_vRun$ = -28
_hRun$ = -36
_r$ = -20
_oldfont$ = -48
_oldcolor$ = -24
_length$ = -44
_height$ = -52
_wide$ = -4
?UpOneLine@FontMgr@@QAEXIIIH@Z PROC NEAR		; FontMgr::UpOneLine

; 1082 : {

  024ba	55		 push	 ebp
  024bb	8b ec		 mov	 ebp, esp
  024bd	83 ec 40	 sub	 esp, 64			; 00000040H
  024c0	89 4d c4	 mov	 DWORD PTR _this$[ebp], ecx

; 1083 : 	// Shift up the textBox bits one line
; 1084 : 	uchar* bits = ((uchar*) *BM) + CELHEADERSIZE;

  024c3	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  024c6	83 c1 4e	 add	 ecx, 78			; 0000004eH
  024c9	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  024ce	83 c0 2e	 add	 eax, 46			; 0000002eH
  024d1	89 45 d8	 mov	 DWORD PTR _bits$[ebp], eax

; 1085 : 	uchar* target = bits + BMWidth*textBox.A.y + textBox.A.x;

  024d4	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  024d7	33 c9		 xor	 ecx, ecx
  024d9	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  024dd	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  024e0	0f af 4a 18	 imul	 ecx, DWORD PTR [edx+24]
  024e4	8b 45 d8	 mov	 eax, DWORD PTR _bits$[ebp]
  024e7	03 c1		 add	 eax, ecx
  024e9	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  024ec	03 41 14	 add	 eax, DWORD PTR [ecx+20]
  024ef	89 45 c8	 mov	 DWORD PTR _target$[ebp], eax

; 1086 : 	uchar* source = bits + BMWidth*(textBox.A.y+pointSize) + textBox.A.x;

  024f2	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  024f5	33 c0		 xor	 eax, eax
  024f7	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  024fb	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  024fe	33 d2		 xor	 edx, edx
  02500	66 8b 51 4c	 mov	 dx, WORD PTR [ecx+76]
  02504	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02507	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  0250a	03 ca		 add	 ecx, edx
  0250c	0f af c1	 imul	 eax, ecx
  0250f	8b 55 d8	 mov	 edx, DWORD PTR _bits$[ebp]
  02512	03 d0		 add	 edx, eax
  02514	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  02517	03 50 14	 add	 edx, DWORD PTR [eax+20]
  0251a	89 55 e0	 mov	 DWORD PTR _source$[ebp], edx

; 1087 : 	uint vRun = (maxLines-1)*pointSize;

  0251d	8b 4d 10	 mov	 ecx, DWORD PTR _maxLines$[ebp]
  02520	83 e9 01	 sub	 ecx, 1
  02523	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  02526	33 c0		 xor	 eax, eax
  02528	66 8b 42 4c	 mov	 ax, WORD PTR [edx+76]
  0252c	0f af c8	 imul	 ecx, eax
  0252f	89 4d e4	 mov	 DWORD PTR _vRun$[ebp], ecx

; 1088 : 	uint hRun = textBox.Xlen();

  02532	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02535	83 c1 14	 add	 ecx, 20			; 00000014H
  02538	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  0253d	89 45 dc	 mov	 DWORD PTR _hRun$[ebp], eax
$L63123:

; 1089 : 	while (vRun--) {

  02540	8b 4d e4	 mov	 ecx, DWORD PTR _vRun$[ebp]
  02543	8b 55 e4	 mov	 edx, DWORD PTR _vRun$[ebp]
  02546	83 ea 01	 sub	 edx, 1
  02549	89 55 e4	 mov	 DWORD PTR _vRun$[ebp], edx
  0254c	85 c9		 test	 ecx, ecx
  0254e	74 38		 je	 SHORT $L63124

; 1090 : 		memcpy(target,source,hRun);

  02550	8b 45 dc	 mov	 eax, DWORD PTR _hRun$[ebp]
  02553	50		 push	 eax
  02554	8b 4d e0	 mov	 ecx, DWORD PTR _source$[ebp]
  02557	51		 push	 ecx
  02558	8b 55 c8	 mov	 edx, DWORD PTR _target$[ebp]
  0255b	52		 push	 edx
  0255c	e8 00 00 00 00	 call	 _memcpy
  02561	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1091 : 		target += BMWidth;

  02564	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  02567	33 c9		 xor	 ecx, ecx
  02569	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  0256d	8b 55 c8	 mov	 edx, DWORD PTR _target$[ebp]
  02570	03 d1		 add	 edx, ecx
  02572	89 55 c8	 mov	 DWORD PTR _target$[ebp], edx

; 1092 : 		source += BMWidth;

  02575	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  02578	33 c9		 xor	 ecx, ecx
  0257a	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  0257e	8b 55 e0	 mov	 edx, DWORD PTR _source$[ebp]
  02581	03 d1		 add	 edx, ecx
  02583	89 55 e0	 mov	 DWORD PTR _source$[ebp], edx

; 1093 : 	}

  02586	eb b8		 jmp	 SHORT $L63123
$L63124:

; 1094 : 	// Now put in the last line
; 1095 : 	SOL_Rect r(textBox);

  02588	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  0258b	83 c0 14	 add	 eax, 20			; 00000014H
  0258e	50		 push	 eax
  0258f	8d 4d ec	 lea	 ecx, DWORD PTR _r$[ebp]
  02592	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@ABV0@@Z ; SOL_Rect::SOL_Rect

; 1096 : 	r.A.y += pointSize*(maxLines - 1);

  02597	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  0259a	33 d2		 xor	 edx, edx
  0259c	66 8b 51 4c	 mov	 dx, WORD PTR [ecx+76]
  025a0	8b 45 10	 mov	 eax, DWORD PTR _maxLines$[ebp]
  025a3	83 e8 01	 sub	 eax, 1
  025a6	0f af d0	 imul	 edx, eax
  025a9	8b 4d f0	 mov	 ecx, DWORD PTR _r$[ebp+4]
  025ac	03 ca		 add	 ecx, edx
  025ae	89 4d f0	 mov	 DWORD PTR _r$[ebp+4], ecx

; 1097 : 	r.B.y += 1;

  025b1	8b 55 f8	 mov	 edx, DWORD PTR _r$[ebp+12]
  025b4	83 c2 01	 add	 edx, 1
  025b7	89 55 f8	 mov	 DWORD PTR _r$[ebp+12], edx

; 1098 : 	Erase(r,False);

  025ba	6a 00		 push	 0
  025bc	8d 45 ec	 lea	 eax, DWORD PTR _r$[ebp]
  025bf	50		 push	 eax
  025c0	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  025c3	e8 00 00 00 00	 call	 ?Erase@FontMgr@@QAEXAAVSOL_Rect@@H@Z ; FontMgr::Erase

; 1099 : 	penX = textBox.A.x;

  025c8	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  025cb	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  025ce	66 8b 42 14	 mov	 ax, WORD PTR [edx+20]
  025d2	66 89 41 48	 mov	 WORD PTR [ecx+72], ax

; 1100 : 	penY = textBox.A.y+(maxLines-1)*pointSize;

  025d6	8b 4d 10	 mov	 ecx, DWORD PTR _maxLines$[ebp]
  025d9	83 e9 01	 sub	 ecx, 1
  025dc	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  025df	33 c0		 xor	 eax, eax
  025e1	66 8b 42 4c	 mov	 ax, WORD PTR [edx+76]
  025e5	0f af c8	 imul	 ecx, eax
  025e8	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  025eb	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  025ee	03 c1		 add	 eax, ecx
  025f0	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  025f3	66 89 41 4a	 mov	 WORD PTR [ecx+74], ax

; 1101 : 	SetFont(theFont);

  025f7	8b 55 14	 mov	 edx, DWORD PTR _theFont$[ebp]
  025fa	52		 push	 edx
  025fb	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  025fe	e8 00 00 00 00	 call	 ?SetFont@FontMgr@@QAEXH@Z ; FontMgr::SetFont

; 1102 : 	// determine justification and draw the line
; 1103 : 	int oldfont = font;

  02603	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  02606	33 c9		 xor	 ecx, ecx
  02608	66 8b 48 28	 mov	 cx, WORD PTR [eax+40]
  0260c	89 4d d0	 mov	 DWORD PTR _oldfont$[ebp], ecx

; 1104 : 	int oldcolor = fore;

  0260f	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  02612	33 c0		 xor	 eax, eax
  02614	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  02618	89 45 e8	 mov	 DWORD PTR _oldcolor$[ebp], eax

; 1105 : 	int length;
; 1106 : 	int height;
; 1107 : 	TextDimensions(startDraw,drawCount,length,height);

  0261b	8d 4d cc	 lea	 ecx, DWORD PTR _height$[ebp]
  0261e	51		 push	 ecx
  0261f	8d 55 d4	 lea	 edx, DWORD PTR _length$[ebp]
  02622	52		 push	 edx
  02623	8b 45 0c	 mov	 eax, DWORD PTR _drawCount$[ebp]
  02626	50		 push	 eax
  02627	8b 4d 08	 mov	 ecx, DWORD PTR _startDraw$[ebp]
  0262a	51		 push	 ecx
  0262b	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  0262e	e8 00 00 00 00	 call	 ?TextDimensions@FontMgr@@IAEXHHAAH0@Z ; FontMgr::TextDimensions

; 1108 : 	int wide = textBox.Xlen();

  02633	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02636	83 c1 14	 add	 ecx, 20			; 00000014H
  02639	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  0263e	89 45 fc	 mov	 DWORD PTR _wide$[ebp], eax

; 1109 : 	switch (mode) {

  02641	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  02644	0f bf 42 46	 movsx	 eax, WORD PTR [edx+70]
  02648	89 45 c0	 mov	 DWORD PTR -64+[ebp], eax
  0264b	83 7d c0 01	 cmp	 DWORD PTR -64+[ebp], 1
  0264f	74 08		 je	 SHORT $L63135
  02651	83 7d c0 02	 cmp	 DWORD PTR -64+[ebp], 2
  02655	74 20		 je	 SHORT $L63136
  02657	eb 35		 jmp	 SHORT $L63132
$L63135:

; 1110 : 		case TEJUSTCENTER:
; 1111 : 			penX += (wide - length)/2;

  02659	8b 45 fc	 mov	 eax, DWORD PTR _wide$[ebp]
  0265c	2b 45 d4	 sub	 eax, DWORD PTR _length$[ebp]
  0265f	99		 cdq
  02660	2b c2		 sub	 eax, edx
  02662	d1 f8		 sar	 eax, 1
  02664	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02667	66 8b 51 48	 mov	 dx, WORD PTR [ecx+72]
  0266b	66 03 d0	 add	 dx, ax
  0266e	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  02671	66 89 50 48	 mov	 WORD PTR [eax+72], dx

; 1112 : 			break;

  02675	eb 17		 jmp	 SHORT $L63132
$L63136:

; 1113 : 		case TEJUSTRIGHT:
; 1114 : 			penX += wide - length;

  02677	8b 4d fc	 mov	 ecx, DWORD PTR _wide$[ebp]
  0267a	2b 4d d4	 sub	 ecx, DWORD PTR _length$[ebp]
  0267d	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  02680	66 8b 42 48	 mov	 ax, WORD PTR [edx+72]
  02684	66 03 c1	 add	 ax, cx
  02687	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  0268a	66 89 41 48	 mov	 WORD PTR [ecx+72], ax
$L63132:

; 1117 :    SetFont(oldfont);

  0268e	8b 55 d0	 mov	 edx, DWORD PTR _oldfont$[ebp]
  02691	52		 push	 edx
  02692	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02695	e8 00 00 00 00	 call	 ?SetFont@FontMgr@@QAEXH@Z ; FontMgr::SetFont

; 1118 :    fore = oldcolor;

  0269a	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  0269d	66 8b 4d e8	 mov	 cx, WORD PTR _oldcolor$[ebp]
  026a1	66 89 48 06	 mov	 WORD PTR [eax+6], cx

; 1119 : 	DrawText(startDraw,drawCount);

  026a5	8b 55 0c	 mov	 edx, DWORD PTR _drawCount$[ebp]
  026a8	52		 push	 edx
  026a9	8b 45 08	 mov	 eax, DWORD PTR _startDraw$[ebp]
  026ac	50		 push	 eax
  026ad	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  026b0	e8 00 00 00 00	 call	 ?DrawTextA@FontMgr@@IAEXHH@Z ; FontMgr::DrawTextA

; 1120 : }

  026b5	8b e5		 mov	 esp, ebp
  026b7	5d		 pop	 ebp
  026b8	c2 10 00	 ret	 16			; 00000010H
?UpOneLine@FontMgr@@QAEXIIIH@Z ENDP			; FontMgr::UpOneLine
_TEXT	ENDS
;	COMDAT ??0Ratio@@QAE@HH@Z
_TEXT	SEGMENT
_num$ = 8
_denom$ = 12
_this$ = -4
??0Ratio@@QAE@HH@Z PROC NEAR				; Ratio::Ratio, COMDAT

; 9    : 	Ratio(int num, int denom)	:	numer(num), denom(denom) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _num$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _denom$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0Ratio@@QAE@HH@Z ENDP					; Ratio::Ratio
_TEXT	ENDS
_TEXT	SEGMENT
_theChar$ = 8
_this$ = -48
_fontHeader$ = -8
_charRecsAddr$ = -36
_charAddr$ = -28
_cWide$ = -20
_cHigh$ = -12
_bmAddr$ = -16
_penAddr$ = -4
_skip$ = -24
_bitMapEnd$ = -32
_dotPos$63167 = -40
_pattern$63168 = -44
?DrawChar@FontMgr@@IAEXE@Z PROC NEAR			; FontMgr::DrawChar

; 1124 : {

  026bb	55		 push	 ebp
  026bc	8b ec		 mov	 ebp, esp
  026be	83 ec 30	 sub	 esp, 48			; 00000030H
  026c1	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx

; 1125 : 	// Draw a font character into the created BM at 
; 1126 : 	// the given pen location with the given color
; 1127 : 
; 1128 : 	// Address the character pattern
; 1129 : 	FontHeader * fontHeader;
; 1130 : 
; 1131 : 	if(font == SYSTEMFONT) {

  026c4	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  026c7	33 c9		 xor	 ecx, ecx
  026c9	66 8b 48 28	 mov	 cx, WORD PTR [eax+40]
  026cd	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  026d3	75 09		 jne	 SHORT $L63143

; 1132 : 		fontHeader = (FontHeader *) sciSystemFont;

  026d5	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _fontHeader$[ebp], OFFSET FLAT:?sciSystemFont@@3PAEA ; sciSystemFont

; 1133 : 	} else {

  026dc	eb 13		 jmp	 SHORT $L63145
$L63143:

; 1134 : //		MemID fontID = resMgr->Get(MemResFont,font);
; 1135 : //		fontHeader = (FontHeader *) memMgr->GetAddr(fontID);
; 1136 : 		fontHeader = (FontHeader *)gFontTable[font];

  026de	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  026e1	33 c0		 xor	 eax, eax
  026e3	66 8b 42 28	 mov	 ax, WORD PTR [edx+40]
  026e7	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?gFontTable@@3PAPAXA[eax*4]
  026ee	89 4d f8	 mov	 DWORD PTR _fontHeader$[ebp], ecx
$L63145:

; 1138 : 
; 1139 : 	// Check for a valid character
; 1140 : 	if ((theChar >= highChar) || (theChar < lowChar))

  026f1	8b 55 08	 mov	 edx, DWORD PTR _theChar$[ebp]
  026f4	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  026fa	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  026fd	3b 50 54	 cmp	 edx, DWORD PTR [eax+84]
  02700	7d 11		 jge	 SHORT $L63148
  02702	8b 4d 08	 mov	 ecx, DWORD PTR _theChar$[ebp]
  02705	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0270b	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  0270e	3b 4a 50	 cmp	 ecx, DWORD PTR [edx+80]
  02711	7d 05		 jge	 SHORT $L63147
$L63148:

; 1141 : 		return;

  02713	e9 30 02 00 00	 jmp	 $L63140
$L63147:

; 1142 : 
; 1143 : 	// Get the characters dimensions
; 1144 : 	Int16* charRecsAddr = (Int16*) &fontHeader->charRecs;

  02718	8b 45 f8	 mov	 eax, DWORD PTR _fontHeader$[ebp]
  0271b	83 c0 06	 add	 eax, 6
  0271e	89 45 dc	 mov	 DWORD PTR _charRecsAddr$[ebp], eax

; 1145 : 	uchar * charAddr = (uchar*) fontHeader + charRecsAddr[theChar];

  02721	8b 4d 08	 mov	 ecx, DWORD PTR _theChar$[ebp]
  02724	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0272a	8b 55 dc	 mov	 edx, DWORD PTR _charRecsAddr$[ebp]
  0272d	0f bf 04 4a	 movsx	 eax, WORD PTR [edx+ecx*2]
  02731	8b 4d f8	 mov	 ecx, DWORD PTR _fontHeader$[ebp]
  02734	03 c8		 add	 ecx, eax
  02736	89 4d e4	 mov	 DWORD PTR _charAddr$[ebp], ecx

; 1146 : 	int cWide =     *charAddr++;

  02739	8b 55 e4	 mov	 edx, DWORD PTR _charAddr$[ebp]
  0273c	33 c0		 xor	 eax, eax
  0273e	8a 02		 mov	 al, BYTE PTR [edx]
  02740	89 45 ec	 mov	 DWORD PTR _cWide$[ebp], eax
  02743	8b 4d e4	 mov	 ecx, DWORD PTR _charAddr$[ebp]
  02746	83 c1 01	 add	 ecx, 1
  02749	89 4d e4	 mov	 DWORD PTR _charAddr$[ebp], ecx

; 1147 : 	int cHigh =     *charAddr++;

  0274c	8b 55 e4	 mov	 edx, DWORD PTR _charAddr$[ebp]
  0274f	33 c0		 xor	 eax, eax
  02751	8a 02		 mov	 al, BYTE PTR [edx]
  02753	89 45 f4	 mov	 DWORD PTR _cHigh$[ebp], eax
  02756	8b 4d e4	 mov	 ecx, DWORD PTR _charAddr$[ebp]
  02759	83 c1 01	 add	 ecx, 1
  0275c	89 4d e4	 mov	 DWORD PTR _charAddr$[ebp], ecx

; 1148 : 	// charAddr now points to the characters line patterns
; 1149 : 
; 1150 : 	// check to see if this character is outside of the bitmap
; 1151 : 	if ( penX < 0 || penX > BMWidth || penY < 0 || penY > BMHeight || (penX + cWide) > BMWidth || (penY + cHigh) > BMHeight ) {

  0275f	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  02762	33 c0		 xor	 eax, eax
  02764	66 8b 42 48	 mov	 ax, WORD PTR [edx+72]
  02768	85 c0		 test	 eax, eax
  0276a	7c 6b		 jl	 SHORT $L63156
  0276c	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  0276f	33 d2		 xor	 edx, edx
  02771	66 8b 51 48	 mov	 dx, WORD PTR [ecx+72]
  02775	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  02778	33 c9		 xor	 ecx, ecx
  0277a	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  0277e	3b d1		 cmp	 edx, ecx
  02780	7f 55		 jg	 SHORT $L63156
  02782	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  02785	33 c0		 xor	 eax, eax
  02787	66 8b 42 4a	 mov	 ax, WORD PTR [edx+74]
  0278b	85 c0		 test	 eax, eax
  0278d	7c 48		 jl	 SHORT $L63156
  0278f	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  02792	33 d2		 xor	 edx, edx
  02794	66 8b 51 4a	 mov	 dx, WORD PTR [ecx+74]
  02798	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  0279b	33 c9		 xor	 ecx, ecx
  0279d	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  027a1	3b d1		 cmp	 edx, ecx
  027a3	7f 32		 jg	 SHORT $L63156
  027a5	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  027a8	33 c0		 xor	 eax, eax
  027aa	66 8b 42 48	 mov	 ax, WORD PTR [edx+72]
  027ae	03 45 ec	 add	 eax, DWORD PTR _cWide$[ebp]
  027b1	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  027b4	33 d2		 xor	 edx, edx
  027b6	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  027ba	3b c2		 cmp	 eax, edx
  027bc	7f 19		 jg	 SHORT $L63156
  027be	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  027c1	33 c9		 xor	 ecx, ecx
  027c3	66 8b 48 4a	 mov	 cx, WORD PTR [eax+74]
  027c7	03 4d f4	 add	 ecx, DWORD PTR _cHigh$[ebp]
  027ca	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  027cd	33 c0		 xor	 eax, eax
  027cf	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  027d3	3b c8		 cmp	 ecx, eax
  027d5	7e 05		 jle	 SHORT $L63155
$L63156:

; 1152 : #ifdef DEBUG
; 1153 : 		msgMgr->Mono ( "clipped char '%c'\n", theChar );
; 1154 : #endif
; 1155 : 		return;

  027d7	e9 6c 01 00 00	 jmp	 $L63140
$L63155:

; 1157 : 
; 1158 : 	// start drawing into the BM at:
; 1159 : 	//      penY*width + penX + BMaddress
; 1160 : 	uchar *bmAddr = (uchar *)memMgr->GetAddr ( BM );

  027dc	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  027df	83 c1 4e	 add	 ecx, 78			; 0000004eH
  027e2	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  027e7	50		 push	 eax
  027e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  027ee	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr
  027f3	89 45 f0	 mov	 DWORD PTR _bmAddr$[ebp], eax

; 1161 : 	uchar* penAddr = bmAddr + (penY * BMWidth) + penX + CELHEADERSIZE;

  027f6	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  027f9	33 d2		 xor	 edx, edx
  027fb	66 8b 51 4a	 mov	 dx, WORD PTR [ecx+74]
  027ff	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  02802	33 c9		 xor	 ecx, ecx
  02804	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  02808	0f af d1	 imul	 edx, ecx
  0280b	8b 45 f0	 mov	 eax, DWORD PTR _bmAddr$[ebp]
  0280e	03 c2		 add	 eax, edx
  02810	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  02813	33 d2		 xor	 edx, edx
  02815	66 8b 51 48	 mov	 dx, WORD PTR [ecx+72]
  02819	8d 44 10 2e	 lea	 eax, DWORD PTR [eax+edx+46]
  0281d	89 45 fc	 mov	 DWORD PTR _penAddr$[ebp], eax

; 1162 : 
; 1163 : 	// the skip to the next line of the character
; 1164 : 	int skip = BMWidth - cWide;

  02820	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  02823	33 d2		 xor	 edx, edx
  02825	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  02829	2b 55 ec	 sub	 edx, DWORD PTR _cWide$[ebp]
  0282c	89 55 e8	 mov	 DWORD PTR _skip$[ebp], edx

; 1165 : 
; 1166 : 	// Lets check for writing outside of the bitmap
; 1167 : 	uchar* bitMapEnd = bmAddr;

  0282f	8b 45 f0	 mov	 eax, DWORD PTR _bmAddr$[ebp]
  02832	89 45 e0	 mov	 DWORD PTR _bitMapEnd$[ebp], eax

; 1168 : 	bitMapEnd += BMWidth*BMHeight + CELHEADERSIZE;

  02835	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  02838	33 d2		 xor	 edx, edx
  0283a	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  0283e	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  02841	33 c9		 xor	 ecx, ecx
  02843	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  02847	0f af d1	 imul	 edx, ecx
  0284a	8b 45 e0	 mov	 eax, DWORD PTR _bitMapEnd$[ebp]
  0284d	8d 4c 10 2e	 lea	 ecx, DWORD PTR [eax+edx+46]
  02851	89 4d e0	 mov	 DWORD PTR _bitMapEnd$[ebp], ecx

; 1169 : 
; 1170 : 	if ((penAddr + (cHigh-1)*BMWidth + cWide) >= bitMapEnd) {

  02854	8b 55 f4	 mov	 edx, DWORD PTR _cHigh$[ebp]
  02857	83 ea 01	 sub	 edx, 1
  0285a	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  0285d	33 c9		 xor	 ecx, ecx
  0285f	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  02863	0f af d1	 imul	 edx, ecx
  02866	8b 45 fc	 mov	 eax, DWORD PTR _penAddr$[ebp]
  02869	03 c2		 add	 eax, edx
  0286b	03 45 ec	 add	 eax, DWORD PTR _cWide$[ebp]
  0286e	3b 45 e0	 cmp	 eax, DWORD PTR _bitMapEnd$[ebp]
  02871	72 2d		 jb	 SHORT $L63163

; 1171 : 			// Let's shorten the character
; 1172 : 			cHigh = (bitMapEnd-1-cWide-penAddr)/BMWidth + 1;

  02873	8b 45 e0	 mov	 eax, DWORD PTR _bitMapEnd$[ebp]
  02876	83 e8 01	 sub	 eax, 1
  02879	2b 45 ec	 sub	 eax, DWORD PTR _cWide$[ebp]
  0287c	2b 45 fc	 sub	 eax, DWORD PTR _penAddr$[ebp]
  0287f	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  02882	33 d2		 xor	 edx, edx
  02884	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  02888	8b ca		 mov	 ecx, edx
  0288a	99		 cdq
  0288b	f7 f9		 idiv	 ecx
  0288d	83 c0 01	 add	 eax, 1
  02890	89 45 f4	 mov	 DWORD PTR _cHigh$[ebp], eax

; 1173 : 			if (cHigh < 0)

  02893	83 7d f4 00	 cmp	 DWORD PTR _cHigh$[ebp], 0
  02897	7d 07		 jge	 SHORT $L63163

; 1174 : 				// This could happen if the cWide was
; 1175 : 				// greater than the bitmap width
; 1176 : 				cHigh = 0;

  02899	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _cHigh$[ebp], 0
$L63163:

; 1178 : 
; 1179 : 	while (cHigh) {

  028a0	83 7d f4 00	 cmp	 DWORD PTR _cHigh$[ebp], 0
  028a4	0f 84 8c 00 00
	00		 je	 $L63166

; 1180 : 		// the current dot position in the character
; 1181 : 		int dotPos = 0;

  028aa	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _dotPos$63167[ebp], 0

; 1182 : 
; 1183 : 		// get the next byte of pattern
; 1184 : 		signed char pattern = (signed char) *charAddr++;

  028b1	8b 55 e4	 mov	 edx, DWORD PTR _charAddr$[ebp]
  028b4	8a 02		 mov	 al, BYTE PTR [edx]
  028b6	88 45 d4	 mov	 BYTE PTR _pattern$63168[ebp], al
  028b9	8b 4d e4	 mov	 ecx, DWORD PTR _charAddr$[ebp]
  028bc	83 c1 01	 add	 ecx, 1
  028bf	89 4d e4	 mov	 DWORD PTR _charAddr$[ebp], ecx
$L63171:

; 1185 : 
; 1186 : 		while (dotPos < cWide) {

  028c2	8b 55 d8	 mov	 edx, DWORD PTR _dotPos$63167[ebp]
  028c5	3b 55 ec	 cmp	 edx, DWORD PTR _cWide$[ebp]
  028c8	7d 55		 jge	 SHORT $L63172

; 1187 : 			if (pattern < 0)

  028ca	0f be 45 d4	 movsx	 eax, BYTE PTR _pattern$63168[ebp]
  028ce	85 c0		 test	 eax, eax
  028d0	7d 0b		 jge	 SHORT $L63173

; 1188 : 				*penAddr        = fore;

  028d2	8b 4d fc	 mov	 ecx, DWORD PTR _penAddr$[ebp]
  028d5	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  028d8	8a 42 06	 mov	 al, BYTE PTR [edx+6]
  028db	88 01		 mov	 BYTE PTR [ecx], al
$L63173:

; 1189 : 
; 1190 : 			penAddr++;

  028dd	8b 4d fc	 mov	 ecx, DWORD PTR _penAddr$[ebp]
  028e0	83 c1 01	 add	 ecx, 1
  028e3	89 4d fc	 mov	 DWORD PTR _penAddr$[ebp], ecx

; 1191 : 			dotPos++;

  028e6	8b 55 d8	 mov	 edx, DWORD PTR _dotPos$63167[ebp]
  028e9	83 c2 01	 add	 edx, 1
  028ec	89 55 d8	 mov	 DWORD PTR _dotPos$63167[ebp], edx

; 1192 : 
; 1193 : 			// shift the dot out the left
; 1194 : 			pattern = pattern << 1;

  028ef	0f be 45 d4	 movsx	 eax, BYTE PTR _pattern$63168[ebp]
  028f3	d1 e0		 shl	 eax, 1
  028f5	88 45 d4	 mov	 BYTE PTR _pattern$63168[ebp], al

; 1195 : 
; 1196 : 			// Following line prevents skiping a 
; 1197 : 			// byte of pattern when cWide == 8
; 1198 : 			if (dotPos == cWide) break;

  028f8	8b 4d d8	 mov	 ecx, DWORD PTR _dotPos$63167[ebp]
  028fb	3b 4d ec	 cmp	 ecx, DWORD PTR _cWide$[ebp]
  028fe	75 02		 jne	 SHORT $L63174
  02900	eb 1d		 jmp	 SHORT $L63172
$L63174:

; 1199 : 
; 1200 : 			// check for byte reload
; 1201 : 			if (!(dotPos & 7))

  02902	8b 55 d8	 mov	 edx, DWORD PTR _dotPos$63167[ebp]
  02905	83 e2 07	 and	 edx, 7
  02908	85 d2		 test	 edx, edx
  0290a	75 11		 jne	 SHORT $L63175

; 1202 : 				pattern = (signed char) *charAddr++;

  0290c	8b 45 e4	 mov	 eax, DWORD PTR _charAddr$[ebp]
  0290f	8a 08		 mov	 cl, BYTE PTR [eax]
  02911	88 4d d4	 mov	 BYTE PTR _pattern$63168[ebp], cl
  02914	8b 55 e4	 mov	 edx, DWORD PTR _charAddr$[ebp]
  02917	83 c2 01	 add	 edx, 1
  0291a	89 55 e4	 mov	 DWORD PTR _charAddr$[ebp], edx
$L63175:

; 1203 : 		}

  0291d	eb a3		 jmp	 SHORT $L63171
$L63172:

; 1204 : 
; 1205 : 		// a line of pattern done get to the next line in the BM
; 1206 : 		penAddr += skip;

  0291f	8b 45 fc	 mov	 eax, DWORD PTR _penAddr$[ebp]
  02922	03 45 e8	 add	 eax, DWORD PTR _skip$[ebp]
  02925	89 45 fc	 mov	 DWORD PTR _penAddr$[ebp], eax

; 1207 : 		--cHigh;

  02928	8b 4d f4	 mov	 ecx, DWORD PTR _cHigh$[ebp]
  0292b	83 e9 01	 sub	 ecx, 1
  0292e	89 4d f4	 mov	 DWORD PTR _cHigh$[ebp], ecx

; 1208 : 	}

  02931	e9 6a ff ff ff	 jmp	 $L63163
$L63166:

; 1209 : 
; 1210 : 	// put the pen in place for the next character
; 1211 : 	penX += cWide;

  02936	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  02939	66 8b 42 48	 mov	 ax, WORD PTR [edx+72]
  0293d	66 03 45 ec	 add	 ax, WORD PTR _cWide$[ebp]
  02941	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  02944	66 89 41 48	 mov	 WORD PTR [ecx+72], ax
$L63140:

; 1212 : }

  02948	8b e5		 mov	 esp, ebp
  0294a	5d		 pop	 ebp
  0294b	c2 04 00	 ret	 4
?DrawChar@FontMgr@@IAEXE@Z ENDP				; FontMgr::DrawChar
_TEXT	ENDS
_DATA	SEGMENT
	ORG $+3
$SG63227 DB	'Text box too small for first character', 00H
_DATA	ENDS
_TEXT	SEGMENT
_strOffset$ = 8
_maxPixels$ = 12
_this$ = -60
_c$ = -36
_width$ = -16
_height$ = -56
_count$ = -44
_lastCount$ = -32
_first$ = -28
_str$ = -12
_last$ = -24
_oldFont$ = -52
_oldcolor$ = -20
_oldmode$ = -4
_lastFont$ = -40
_lastColor$ = -48
_lastMode$ = -8
?GetLongest@FontMgr@@QAEGPAHH@Z PROC NEAR		; FontMgr::GetLongest

; 1216 : {

  0294e	55		 push	 ebp
  0294f	8b ec		 mov	 ebp, esp
  02951	83 ec 3c	 sub	 esp, 60			; 0000003cH
  02954	89 4d c4	 mov	 DWORD PTR _this$[ebp], ecx

; 1217 : 	// return count of chars that fit in the given pixel length
; 1218 : 
; 1219 : 	uchar c;
; 1220 : 	int 	width;
; 1221 : 	int 	height;
; 1222 : 	int 	count = 0;

  02957	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 1223 : 	int 	lastCount = 0;

  0295e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _lastCount$[ebp], 0

; 1224 : 
; 1225 : 	int first = *strOffset;

  02965	8b 45 08	 mov	 eax, DWORD PTR _strOffset$[ebp]
  02968	8b 08		 mov	 ecx, DWORD PTR [eax]
  0296a	89 4d e4	 mov	 DWORD PTR _first$[ebp], ecx

; 1226 : 	uchar* str = (uchar*) memMgr->GetAddr(text) + first;

  0296d	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02970	83 c1 0e	 add	 ecx, 14			; 0000000eH
  02973	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  02978	50		 push	 eax
  02979	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  0297f	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr
  02984	03 45 e4	 add	 eax, DWORD PTR _first$[ebp]
  02987	89 45 f4	 mov	 DWORD PTR _str$[ebp], eax

; 1227 : 
; 1228 : 	int last = first;

  0298a	8b 55 e4	 mov	 edx, DWORD PTR _first$[ebp]
  0298d	89 55 e8	 mov	 DWORD PTR _last$[ebp], edx

; 1229 : 
; 1230 : 	// find a HARD terminator or LAST SPACE that fits on line
; 1231 : 
; 1232 : #define LF                      0x0a
; 1233 : #define CR                      0x0d
; 1234 : #define SP                      0x20
; 1235 : 	int oldFont = font;

  02990	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  02993	33 c9		 xor	 ecx, ecx
  02995	66 8b 48 28	 mov	 cx, WORD PTR [eax+40]
  02999	89 4d cc	 mov	 DWORD PTR _oldFont$[ebp], ecx

; 1236 : 	int oldcolor = fore;

  0299c	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  0299f	33 c0		 xor	 eax, eax
  029a1	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  029a5	89 45 ec	 mov	 DWORD PTR _oldcolor$[ebp], eax

; 1237 : 	int oldmode = mode;

  029a8	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  029ab	0f bf 51 46	 movsx	 edx, WORD PTR [ecx+70]
  029af	89 55 fc	 mov	 DWORD PTR _oldmode$[ebp], edx

; 1238 : 	int lastFont = font;

  029b2	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  029b5	33 c9		 xor	 ecx, ecx
  029b7	66 8b 48 28	 mov	 cx, WORD PTR [eax+40]
  029bb	89 4d d8	 mov	 DWORD PTR _lastFont$[ebp], ecx

; 1239 : 	int lastColor = fore;

  029be	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  029c1	33 c0		 xor	 eax, eax
  029c3	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  029c7	89 45 d0	 mov	 DWORD PTR _lastColor$[ebp], eax

; 1240 : 	int lastMode = mode;

  029ca	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  029cd	0f bf 51 46	 movsx	 edx, WORD PTR [ecx+70]
  029d1	89 55 f8	 mov	 DWORD PTR _lastMode$[ebp], edx
$L63201:

; 1241 : 
; 1242 : 	while(True) {

  029d4	b8 01 00 00 00	 mov	 eax, 1
  029d9	85 c0		 test	 eax, eax
  029db	0f 84 62 03 00
	00		 je	 $L63202

; 1243 : 		SetFont(oldFont);

  029e1	8b 4d cc	 mov	 ecx, DWORD PTR _oldFont$[ebp]
  029e4	51		 push	 ecx
  029e5	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  029e8	e8 00 00 00 00	 call	 ?SetFont@FontMgr@@QAEXH@Z ; FontMgr::SetFont

; 1244 : 
; 1245 : 		fore = oldcolor;

  029ed	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  029f0	66 8b 45 ec	 mov	 ax, WORD PTR _oldcolor$[ebp]
  029f4	66 89 42 06	 mov	 WORD PTR [edx+6], ax

; 1246 : 		mode = oldmode;

  029f8	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  029fb	66 8b 55 fc	 mov	 dx, WORD PTR _oldmode$[ebp]
  029ff	66 89 51 46	 mov	 WORD PTR [ecx+70], dx

; 1247 : 
; 1248 : 		c = *str;

  02a03	8b 45 f4	 mov	 eax, DWORD PTR _str$[ebp]
  02a06	8a 08		 mov	 cl, BYTE PTR [eax]
  02a08	88 4d dc	 mov	 BYTE PTR _c$[ebp], cl

; 1249 : 
; 1250 : 		if (c == CR) {

  02a0b	8b 55 dc	 mov	 edx, DWORD PTR _c$[ebp]
  02a0e	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  02a14	83 fa 0d	 cmp	 edx, 13			; 0000000dH
  02a17	0f 85 89 00 00
	00		 jne	 $L63203

; 1251 : 			if (str[1] == LF) 

  02a1d	8b 45 f4	 mov	 eax, DWORD PTR _str$[ebp]
  02a20	33 c9		 xor	 ecx, ecx
  02a22	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  02a25	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  02a28	75 0d		 jne	 SHORT $L63204

; 1252 : 				(*strOffset)++;

  02a2a	8b 55 08	 mov	 edx, DWORD PTR _strOffset$[ebp]
  02a2d	8b 02		 mov	 eax, DWORD PTR [edx]
  02a2f	83 c0 01	 add	 eax, 1
  02a32	8b 4d 08	 mov	 ecx, DWORD PTR _strOffset$[ebp]
  02a35	89 01		 mov	 DWORD PTR [ecx], eax
$L63204:

; 1253 : 
; 1254 : 			TextDimensions(first,count,width,height);

  02a37	8d 55 c8	 lea	 edx, DWORD PTR _height$[ebp]
  02a3a	52		 push	 edx
  02a3b	8d 45 f0	 lea	 eax, DWORD PTR _width$[ebp]
  02a3e	50		 push	 eax
  02a3f	8b 4d d4	 mov	 ecx, DWORD PTR _count$[ebp]
  02a42	51		 push	 ecx
  02a43	8b 55 e4	 mov	 edx, DWORD PTR _first$[ebp]
  02a46	52		 push	 edx
  02a47	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02a4a	e8 00 00 00 00	 call	 ?TextDimensions@FontMgr@@IAEXHHAAH0@Z ; FontMgr::TextDimensions

; 1255 : 
; 1256 : 			if (lastCount && (maxPixels < width)) {

  02a4f	83 7d e0 00	 cmp	 DWORD PTR _lastCount$[ebp], 0
  02a53	74 19		 je	 SHORT $L63205
  02a55	8b 45 0c	 mov	 eax, DWORD PTR _maxPixels$[ebp]
  02a58	3b 45 f0	 cmp	 eax, DWORD PTR _width$[ebp]
  02a5b	7d 11		 jge	 SHORT $L63205

; 1257 : 				*strOffset = last;

  02a5d	8b 4d 08	 mov	 ecx, DWORD PTR _strOffset$[ebp]
  02a60	8b 55 e8	 mov	 edx, DWORD PTR _last$[ebp]
  02a63	89 11		 mov	 DWORD PTR [ecx], edx

; 1258 : 				return(lastCount);

  02a65	66 8b 45 e0	 mov	 ax, WORD PTR _lastCount$[ebp]
  02a69	e9 d9 02 00 00	 jmp	 $L63181
$L63205:

; 1260 :          	// verify the color and mode
; 1261 : 				SetFont(oldFont);

  02a6e	8b 45 cc	 mov	 eax, DWORD PTR _oldFont$[ebp]
  02a71	50		 push	 eax
  02a72	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02a75	e8 00 00 00 00	 call	 ?SetFont@FontMgr@@QAEXH@Z ; FontMgr::SetFont

; 1262 : 				fore = oldcolor;

  02a7a	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02a7d	66 8b 55 ec	 mov	 dx, WORD PTR _oldcolor$[ebp]
  02a81	66 89 51 06	 mov	 WORD PTR [ecx+6], dx

; 1263 : 				mode = oldmode;

  02a85	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  02a88	66 8b 4d fc	 mov	 cx, WORD PTR _oldmode$[ebp]
  02a8c	66 89 48 46	 mov	 WORD PTR [eax+70], cx

; 1264 : 
; 1265 : 				// so we don't see it later
; 1266 : 				(*strOffset)++;

  02a90	8b 55 08	 mov	 edx, DWORD PTR _strOffset$[ebp]
  02a93	8b 02		 mov	 eax, DWORD PTR [edx]
  02a95	83 c0 01	 add	 eax, 1
  02a98	8b 4d 08	 mov	 ecx, DWORD PTR _strOffset$[ebp]
  02a9b	89 01		 mov	 DWORD PTR [ecx], eax

; 1267 : 
; 1268 : 				// caller sees end of string
; 1269 : 				return(count);

  02a9d	66 8b 45 d4	 mov	 ax, WORD PTR _count$[ebp]
  02aa1	e9 a1 02 00 00	 jmp	 $L63181
$L63203:

; 1272 : 
; 1273 : 		else if (c == LF) {

  02aa6	8b 55 dc	 mov	 edx, DWORD PTR _c$[ebp]
  02aa9	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  02aaf	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  02ab2	0f 85 96 00 00
	00		 jne	 $L63208

; 1274 : 			// by Corey for 68k
; 1275 : 			if ((str[1] == CR) && (str[2] != LF))

  02ab8	8b 45 f4	 mov	 eax, DWORD PTR _str$[ebp]
  02abb	33 c9		 xor	 ecx, ecx
  02abd	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  02ac0	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  02ac3	75 1a		 jne	 SHORT $L63209
  02ac5	8b 55 f4	 mov	 edx, DWORD PTR _str$[ebp]
  02ac8	33 c0		 xor	 eax, eax
  02aca	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  02acd	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  02ad0	74 0d		 je	 SHORT $L63209

; 1276 : 				(*strOffset)++;

  02ad2	8b 4d 08	 mov	 ecx, DWORD PTR _strOffset$[ebp]
  02ad5	8b 11		 mov	 edx, DWORD PTR [ecx]
  02ad7	83 c2 01	 add	 edx, 1
  02ada	8b 45 08	 mov	 eax, DWORD PTR _strOffset$[ebp]
  02add	89 10		 mov	 DWORD PTR [eax], edx
$L63209:

; 1277 : 
; 1278 : 			TextDimensions(first,count,width,height);

  02adf	8d 4d c8	 lea	 ecx, DWORD PTR _height$[ebp]
  02ae2	51		 push	 ecx
  02ae3	8d 55 f0	 lea	 edx, DWORD PTR _width$[ebp]
  02ae6	52		 push	 edx
  02ae7	8b 45 d4	 mov	 eax, DWORD PTR _count$[ebp]
  02aea	50		 push	 eax
  02aeb	8b 4d e4	 mov	 ecx, DWORD PTR _first$[ebp]
  02aee	51		 push	 ecx
  02aef	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02af2	e8 00 00 00 00	 call	 ?TextDimensions@FontMgr@@IAEXHHAAH0@Z ; FontMgr::TextDimensions

; 1279 : 
; 1280 : 			if (lastCount && (maxPixels < width)) {

  02af7	83 7d e0 00	 cmp	 DWORD PTR _lastCount$[ebp], 0
  02afb	74 19		 je	 SHORT $L63210
  02afd	8b 55 0c	 mov	 edx, DWORD PTR _maxPixels$[ebp]
  02b00	3b 55 f0	 cmp	 edx, DWORD PTR _width$[ebp]
  02b03	7d 11		 jge	 SHORT $L63210

; 1281 : 				*strOffset = last;

  02b05	8b 45 08	 mov	 eax, DWORD PTR _strOffset$[ebp]
  02b08	8b 4d e8	 mov	 ecx, DWORD PTR _last$[ebp]
  02b0b	89 08		 mov	 DWORD PTR [eax], ecx

; 1282 : 				return(lastCount);

  02b0d	66 8b 45 e0	 mov	 ax, WORD PTR _lastCount$[ebp]
  02b11	e9 31 02 00 00	 jmp	 $L63181
$L63210:

; 1285 :          	// verify the color and mode
; 1286 : 				SetFont(oldFont);

  02b16	8b 55 cc	 mov	 edx, DWORD PTR _oldFont$[ebp]
  02b19	52		 push	 edx
  02b1a	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02b1d	e8 00 00 00 00	 call	 ?SetFont@FontMgr@@QAEXH@Z ; FontMgr::SetFont

; 1287 : 				fore = oldcolor;

  02b22	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  02b25	66 8b 4d ec	 mov	 cx, WORD PTR _oldcolor$[ebp]
  02b29	66 89 48 06	 mov	 WORD PTR [eax+6], cx

; 1288 : 				mode = oldmode;

  02b2d	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  02b30	66 8b 45 fc	 mov	 ax, WORD PTR _oldmode$[ebp]
  02b34	66 89 42 46	 mov	 WORD PTR [edx+70], ax

; 1289 : 
; 1290 : 				// so we don't see it later
; 1291 : 				(*strOffset)++;

  02b38	8b 4d 08	 mov	 ecx, DWORD PTR _strOffset$[ebp]
  02b3b	8b 11		 mov	 edx, DWORD PTR [ecx]
  02b3d	83 c2 01	 add	 edx, 1
  02b40	8b 45 08	 mov	 eax, DWORD PTR _strOffset$[ebp]
  02b43	89 10		 mov	 DWORD PTR [eax], edx

; 1292 : 
; 1293 : 				// caller sees end of string
; 1294 : 				return(count);

  02b45	66 8b 45 d4	 mov	 ax, WORD PTR _count$[ebp]
  02b49	e9 f9 01 00 00	 jmp	 $L63181
$L63208:

; 1297 : 
; 1298 : 		else if (c == '\0') {

  02b4e	8b 4d dc	 mov	 ecx, DWORD PTR _c$[ebp]
  02b51	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  02b57	85 c9		 test	 ecx, ecx
  02b59	75 62		 jne	 SHORT $L63213

; 1299 : 			TextDimensions(first,count,width,height);

  02b5b	8d 55 c8	 lea	 edx, DWORD PTR _height$[ebp]
  02b5e	52		 push	 edx
  02b5f	8d 45 f0	 lea	 eax, DWORD PTR _width$[ebp]
  02b62	50		 push	 eax
  02b63	8b 4d d4	 mov	 ecx, DWORD PTR _count$[ebp]
  02b66	51		 push	 ecx
  02b67	8b 55 e4	 mov	 edx, DWORD PTR _first$[ebp]
  02b6a	52		 push	 edx
  02b6b	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02b6e	e8 00 00 00 00	 call	 ?TextDimensions@FontMgr@@IAEXHHAAH0@Z ; FontMgr::TextDimensions

; 1300 : 
; 1301 : 			if (lastCount && (maxPixels < width)) {

  02b73	83 7d e0 00	 cmp	 DWORD PTR _lastCount$[ebp], 0
  02b77	74 19		 je	 SHORT $L63214
  02b79	8b 45 0c	 mov	 eax, DWORD PTR _maxPixels$[ebp]
  02b7c	3b 45 f0	 cmp	 eax, DWORD PTR _width$[ebp]
  02b7f	7d 11		 jge	 SHORT $L63214

; 1302 : 				*strOffset = last;

  02b81	8b 4d 08	 mov	 ecx, DWORD PTR _strOffset$[ebp]
  02b84	8b 55 e8	 mov	 edx, DWORD PTR _last$[ebp]
  02b87	89 11		 mov	 DWORD PTR [ecx], edx

; 1303 : 				return(lastCount);

  02b89	66 8b 45 e0	 mov	 ax, WORD PTR _lastCount$[ebp]
  02b8d	e9 b5 01 00 00	 jmp	 $L63181
$L63214:

; 1307 :          	// verify the color and mode
; 1308 : 				SetFont(oldFont);

  02b92	8b 45 cc	 mov	 eax, DWORD PTR _oldFont$[ebp]
  02b95	50		 push	 eax
  02b96	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02b99	e8 00 00 00 00	 call	 ?SetFont@FontMgr@@QAEXH@Z ; FontMgr::SetFont

; 1309 : 
; 1310 : 				fore = oldcolor;

  02b9e	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02ba1	66 8b 55 ec	 mov	 dx, WORD PTR _oldcolor$[ebp]
  02ba5	66 89 51 06	 mov	 WORD PTR [ecx+6], dx

; 1311 : 				mode = oldmode;

  02ba9	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  02bac	66 8b 4d fc	 mov	 cx, WORD PTR _oldmode$[ebp]
  02bb0	66 89 48 46	 mov	 WORD PTR [eax+70], cx

; 1312 : 
; 1313 : 				// caller sees end of string
; 1314 : 				return(count);

  02bb4	66 8b 45 d4	 mov	 ax, WORD PTR _count$[ebp]
  02bb8	e9 8a 01 00 00	 jmp	 $L63181
$L63213:

; 1317 : 
; 1318 : 		else if (c == SP) {

  02bbd	8b 55 dc	 mov	 edx, DWORD PTR _c$[ebp]
  02bc0	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  02bc6	83 fa 20	 cmp	 edx, 32			; 00000020H
  02bc9	0f 85 d1 00 00
	00		 jne	 $L63219

; 1319 : 			TextDimensions(first,count,width,height);

  02bcf	8d 45 c8	 lea	 eax, DWORD PTR _height$[ebp]
  02bd2	50		 push	 eax
  02bd3	8d 4d f0	 lea	 ecx, DWORD PTR _width$[ebp]
  02bd6	51		 push	 ecx
  02bd7	8b 55 d4	 mov	 edx, DWORD PTR _count$[ebp]
  02bda	52		 push	 edx
  02bdb	8b 45 e4	 mov	 eax, DWORD PTR _first$[ebp]
  02bde	50		 push	 eax
  02bdf	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02be2	e8 00 00 00 00	 call	 ?TextDimensions@FontMgr@@IAEXHHAAH0@Z ; FontMgr::TextDimensions

; 1320 : 
; 1321 : 			// check word wrap
; 1322 : 			if (maxPixels >= width) {

  02be7	8b 4d 0c	 mov	 ecx, DWORD PTR _maxPixels$[ebp]
  02bea	3b 4d f0	 cmp	 ecx, DWORD PTR _width$[ebp]
  02bed	7c 3b		 jl	 SHORT $L63218

; 1323 : 				last = *strOffset;

  02bef	8b 55 08	 mov	 edx, DWORD PTR _strOffset$[ebp]
  02bf2	8b 02		 mov	 eax, DWORD PTR [edx]
  02bf4	89 45 e8	 mov	 DWORD PTR _last$[ebp], eax

; 1324 : 
; 1325 : 				// so we don't see space again
; 1326 : 				++last;

  02bf7	8b 4d e8	 mov	 ecx, DWORD PTR _last$[ebp]
  02bfa	83 c1 01	 add	 ecx, 1
  02bfd	89 4d e8	 mov	 DWORD PTR _last$[ebp], ecx

; 1327 : 
; 1328 : 				lastCount = count;

  02c00	8b 55 d4	 mov	 edx, DWORD PTR _count$[ebp]
  02c03	89 55 e0	 mov	 DWORD PTR _lastCount$[ebp], edx

; 1329 : 				lastFont = font;

  02c06	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  02c09	33 c9		 xor	 ecx, ecx
  02c0b	66 8b 48 28	 mov	 cx, WORD PTR [eax+40]
  02c0f	89 4d d8	 mov	 DWORD PTR _lastFont$[ebp], ecx

; 1330 : 				lastColor = fore;

  02c12	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  02c15	33 c0		 xor	 eax, eax
  02c17	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  02c1b	89 45 d0	 mov	 DWORD PTR _lastColor$[ebp], eax

; 1331 : 				lastMode = mode;

  02c1e	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02c21	0f bf 51 46	 movsx	 edx, WORD PTR [ecx+70]
  02c25	89 55 f8	 mov	 DWORD PTR _lastMode$[ebp], edx

; 1332 : 			} else {

  02c28	eb 76		 jmp	 SHORT $L63219
$L63218:

; 1333 : 				*strOffset = last;

  02c2a	8b 45 08	 mov	 eax, DWORD PTR _strOffset$[ebp]
  02c2d	8b 4d e8	 mov	 ecx, DWORD PTR _last$[ebp]
  02c30	89 08		 mov	 DWORD PTR [eax], ecx

; 1334 : 
; 1335 : 				// eliminate trailing spaces
; 1336 : 				str = (uchar*) memMgr->GetAddr(text) + *strOffset;

  02c32	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02c35	83 c1 0e	 add	 ecx, 14			; 0000000eH
  02c38	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  02c3d	50		 push	 eax
  02c3e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  02c44	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr
  02c49	8b 55 08	 mov	 edx, DWORD PTR _strOffset$[ebp]
  02c4c	03 02		 add	 eax, DWORD PTR [edx]
  02c4e	89 45 f4	 mov	 DWORD PTR _str$[ebp], eax
$L63222:

; 1337 : 
; 1338 : 				while (*str++ == ' ')

  02c51	8b 45 f4	 mov	 eax, DWORD PTR _str$[ebp]
  02c54	33 c9		 xor	 ecx, ecx
  02c56	8a 08		 mov	 cl, BYTE PTR [eax]
  02c58	8b 55 f4	 mov	 edx, DWORD PTR _str$[ebp]
  02c5b	83 c2 01	 add	 edx, 1
  02c5e	89 55 f4	 mov	 DWORD PTR _str$[ebp], edx
  02c61	83 f9 20	 cmp	 ecx, 32			; 00000020H
  02c64	75 0f		 jne	 SHORT $L63223

; 1339 : 					(*strOffset)++;

  02c66	8b 45 08	 mov	 eax, DWORD PTR _strOffset$[ebp]
  02c69	8b 08		 mov	 ecx, DWORD PTR [eax]
  02c6b	83 c1 01	 add	 ecx, 1
  02c6e	8b 55 08	 mov	 edx, DWORD PTR _strOffset$[ebp]
  02c71	89 0a		 mov	 DWORD PTR [edx], ecx
  02c73	eb dc		 jmp	 SHORT $L63222
$L63223:

; 1340 : 
; 1341 : 				SetFont(lastFont);

  02c75	8b 45 d8	 mov	 eax, DWORD PTR _lastFont$[ebp]
  02c78	50		 push	 eax
  02c79	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02c7c	e8 00 00 00 00	 call	 ?SetFont@FontMgr@@QAEXH@Z ; FontMgr::SetFont

; 1342 : 
; 1343 : 				fore = lastColor;

  02c81	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02c84	66 8b 55 d0	 mov	 dx, WORD PTR _lastColor$[ebp]
  02c88	66 89 51 06	 mov	 WORD PTR [ecx+6], dx

; 1344 : 				mode = lastMode;

  02c8c	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  02c8f	66 8b 4d f8	 mov	 cx, WORD PTR _lastMode$[ebp]
  02c93	66 89 48 46	 mov	 WORD PTR [eax+70], cx

; 1345 : 
; 1346 : 				return(lastCount);

  02c97	66 8b 45 e0	 mov	 ax, WORD PTR _lastCount$[ebp]
  02c9b	e9 a7 00 00 00	 jmp	 $L63181
$L63219:

; 1349 : 
; 1350 : 		// all is still cool
; 1351 : 		++count;

  02ca0	8b 55 d4	 mov	 edx, DWORD PTR _count$[ebp]
  02ca3	83 c2 01	 add	 edx, 1
  02ca6	89 55 d4	 mov	 DWORD PTR _count$[ebp], edx

; 1352 : 		str++;

  02ca9	8b 45 f4	 mov	 eax, DWORD PTR _str$[ebp]
  02cac	83 c0 01	 add	 eax, 1
  02caf	89 45 f4	 mov	 DWORD PTR _str$[ebp], eax

; 1353 : 
; 1354 : 		(*strOffset)++;

  02cb2	8b 4d 08	 mov	 ecx, DWORD PTR _strOffset$[ebp]
  02cb5	8b 11		 mov	 edx, DWORD PTR [ecx]
  02cb7	83 c2 01	 add	 edx, 1
  02cba	8b 45 08	 mov	 eax, DWORD PTR _strOffset$[ebp]
  02cbd	89 10		 mov	 DWORD PTR [eax], edx

; 1355 : 
; 1356 : 		// we may never see a space to break on
; 1357 : 		SetFont(oldFont); 

  02cbf	8b 4d cc	 mov	 ecx, DWORD PTR _oldFont$[ebp]
  02cc2	51		 push	 ecx
  02cc3	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02cc6	e8 00 00 00 00	 call	 ?SetFont@FontMgr@@QAEXH@Z ; FontMgr::SetFont

; 1358 : 
; 1359 : 		fore = oldcolor;

  02ccb	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  02cce	66 8b 45 ec	 mov	 ax, WORD PTR _oldcolor$[ebp]
  02cd2	66 89 42 06	 mov	 WORD PTR [edx+6], ax

; 1360 : 		mode = oldmode;

  02cd6	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02cd9	66 8b 55 fc	 mov	 dx, WORD PTR _oldmode$[ebp]
  02cdd	66 89 51 46	 mov	 WORD PTR [ecx+70], dx

; 1361 : 
; 1362 : 		TextDimensions(first,count,width,height);

  02ce1	8d 45 c8	 lea	 eax, DWORD PTR _height$[ebp]
  02ce4	50		 push	 eax
  02ce5	8d 4d f0	 lea	 ecx, DWORD PTR _width$[ebp]
  02ce8	51		 push	 ecx
  02ce9	8b 55 d4	 mov	 edx, DWORD PTR _count$[ebp]
  02cec	52		 push	 edx
  02ced	8b 45 e4	 mov	 eax, DWORD PTR _first$[ebp]
  02cf0	50		 push	 eax
  02cf1	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  02cf4	e8 00 00 00 00	 call	 ?TextDimensions@FontMgr@@IAEXHHAAH0@Z ; FontMgr::TextDimensions

; 1363 : 
; 1364 : 		if (!lastCount &&  (width > maxPixels)) {

  02cf9	83 7d e0 00	 cmp	 DWORD PTR _lastCount$[ebp], 0
  02cfd	75 3f		 jne	 SHORT $L63224
  02cff	8b 4d f0	 mov	 ecx, DWORD PTR _width$[ebp]
  02d02	3b 4d 0c	 cmp	 ecx, DWORD PTR _maxPixels$[ebp]
  02d05	7e 37		 jle	 SHORT $L63224

; 1365 : 			if (--count) {

  02d07	8b 55 d4	 mov	 edx, DWORD PTR _count$[ebp]
  02d0a	83 ea 01	 sub	 edx, 1
  02d0d	89 55 d4	 mov	 DWORD PTR _count$[ebp], edx
  02d10	83 7d d4 00	 cmp	 DWORD PTR _count$[ebp], 0
  02d14	74 13		 je	 SHORT $L63225

; 1366 : 				last += count;

  02d16	8b 45 e8	 mov	 eax, DWORD PTR _last$[ebp]
  02d19	03 45 d4	 add	 eax, DWORD PTR _count$[ebp]
  02d1c	89 45 e8	 mov	 DWORD PTR _last$[ebp], eax

; 1367 : 				*strOffset = last;

  02d1f	8b 4d 08	 mov	 ecx, DWORD PTR _strOffset$[ebp]
  02d22	8b 55 e8	 mov	 edx, DWORD PTR _last$[ebp]
  02d25	89 11		 mov	 DWORD PTR [ecx], edx

; 1368 : 			} else {

  02d27	eb 13		 jmp	 SHORT $L63226
$L63225:

; 1369 : 				msgMgr->Fatal("Text box too small for first character");

  02d29	68 00 00 00 00	 push	 OFFSET FLAT:$SG63227
  02d2e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  02d33	50		 push	 eax
  02d34	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  02d39	83 c4 08	 add	 esp, 8
$L63226:

; 1371 : 			break;

  02d3c	eb 05		 jmp	 SHORT $L63202
$L63224:

; 1373 : 	}

  02d3e	e9 91 fc ff ff	 jmp	 $L63201
$L63202:

; 1374 : 
; 1375 : 	return(count);

  02d43	66 8b 45 d4	 mov	 ax, WORD PTR _count$[ebp]
$L63181:

; 1376 : }

  02d47	8b e5		 mov	 esp, ebp
  02d49	5d		 pop	 ebp
  02d4a	c2 08 00	 ret	 8
?GetLongest@FontMgr@@QAEGPAHH@Z ENDP			; FontMgr::GetLongest
_TEXT	ENDS
;	COMDAT ?View@Bitmap@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?View@Bitmap@@QBEHXZ PROC NEAR				; Bitmap::View, COMDAT

; 137  : 	int	View() const			{return view;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?View@Bitmap@@QBEHXZ ENDP				; Bitmap::View
_TEXT	ENDS
;	COMDAT ?Loop@Bitmap@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Loop@Bitmap@@QBEHXZ PROC NEAR				; Bitmap::Loop, COMDAT

; 138  : 	int	Loop() const			{return loop;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Loop@Bitmap@@QBEHXZ ENDP				; Bitmap::Loop
_TEXT	ENDS
;	COMDAT ?Cel@Bitmap@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Cel@Bitmap@@QBEHXZ PROC NEAR				; Bitmap::Cel, COMDAT

; 139  : 	int	Cel() const				{return cel;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Cel@Bitmap@@QBEHXZ ENDP				; Bitmap::Cel
_TEXT	ENDS
PUBLIC	??0MemID@@QAE@G@Z				; MemID::MemID
PUBLIC	?KInvertRect@@YAXPAF@Z				; KInvertRect
_TEXT	SEGMENT
_args$ = 8
_r$ = -16
?KInvertRect@@YAXPAF@Z PROC NEAR			; KInvertRect

; 1380 : {

  02d4d	55		 push	 ebp
  02d4e	8b ec		 mov	 ebp, esp
  02d50	83 ec 18	 sub	 esp, 24			; 00000018H

; 1381 : 	// Input
; 1382 : 	//      arg1-----the bitmap memID
; 1383 : 	//              arg2-----the rectangle x1
; 1384 : 	//              arg3-----the rectangle y1
; 1385 : 	//              arg4-----the rectangle x2
; 1386 : 	//              arg5-----the rectangle y2
; 1387 : 	//              arg6-----the bitmap width
; 1388 : 	//              arg7-----the foreground color
; 1389 : 	//              arg8-----the background color
; 1390 : 	//
; 1391 : 	// Ouput
; 1392 : 	//    acc------the number of cels in the object's view,loop
; 1393 : 
; 1394 : 	SOL_Rect r(arg(2),arg(3),arg(4),arg(5));

  02d53	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  02d56	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  02d5a	51		 push	 ecx
  02d5b	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  02d5e	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  02d62	50		 push	 eax
  02d63	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  02d66	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  02d6a	52		 push	 edx
  02d6b	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  02d6e	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  02d72	51		 push	 ecx
  02d73	8d 4d f0	 lea	 ecx, DWORD PTR _r$[ebp]
  02d76	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@HHHH@Z	; SOL_Rect::SOL_Rect

; 1395 : 
; 1396 : 	fontMgr->InvertRect(arg(1),
; 1397 : 							  arg(6),
; 1398 : 							  r,
; 1399 : 							  arg(7),
; 1400 : 							  arg(8));

  02d7b	6a 01		 push	 1
  02d7d	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  02d80	8a 42 10	 mov	 al, BYTE PTR [edx+16]
  02d83	50		 push	 eax
  02d84	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  02d87	8a 51 0e	 mov	 dl, BYTE PTR [ecx+14]
  02d8a	52		 push	 edx
  02d8b	83 ec 10	 sub	 esp, 16			; 00000010H
  02d8e	8b cc		 mov	 ecx, esp
  02d90	8d 45 f0	 lea	 eax, DWORD PTR _r$[ebp]
  02d93	50		 push	 eax
  02d94	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@ABV0@@Z ; SOL_Rect::SOL_Rect
  02d99	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  02d9c	0f bf 51 0c	 movsx	 edx, WORD PTR [ecx+12]
  02da0	52		 push	 edx
  02da1	51		 push	 ecx
  02da2	8b cc		 mov	 ecx, esp
  02da4	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  02da7	66 8b 50 02	 mov	 dx, WORD PTR [eax+2]
  02dab	52		 push	 edx
  02dac	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  02db1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?fontMgr@@3PAVFontMgr@@A ; fontMgr
  02db7	e8 00 00 00 00	 call	 ?InvertRect@FontMgr@@QAEXVMemID@@HVSOL_Rect@@DDH@Z ; FontMgr::InvertRect

; 1401 : }

  02dbc	8b e5		 mov	 esp, ebp
  02dbe	5d		 pop	 ebp
  02dbf	c3		 ret	 0
?KInvertRect@@YAXPAF@Z ENDP				; KInvertRect
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0MemID@@QAE@G@Z PROC NEAR				; MemID::MemID, COMDAT

; 23   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 4d 08	 mov	 cx, WORD PTR _h$[ebp]
  0000e	66 89 08	 mov	 WORD PTR [eax], cx

; 24   : 	}

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??0MemID@@QAE@G@Z ENDP					; MemID::MemID
_TEXT	ENDS
PUBLIC	??0TextID@@QAE@ABV0@@Z				; TextID::TextID
PUBLIC	?KText@@YAXPAF@Z				; KText
PUBLIC	?IsValid@MemID@@QBEHXZ				; MemID::IsValid
PUBLIC	??0ArrayID@@QAE@G@Z				; ArrayID::ArrayID
PUBLIC	?Data@ArrayID@@QAEPAXXZ				; ArrayID::Data
PUBLIC	?SetText@FontMgr@@QAEXVMemID@@@Z		; FontMgr::SetText
EXTRN	?pm@@3VPMachine@@A:BYTE				; pm
EXTRN	??0TextID@@QAE@G@Z:NEAR				; TextID::TextID
_DATA	SEGMENT
	ORG $+1
$SG63253 DB	'TextSize called with invalid Array to hold resulting siz'
	DB	'e. (0x%x)', 00H
	ORG $+2
$SG63258 DB	'TextSize called with invalid TextID. (0x%x)', 00H
$SG63275 DB	'TextWidth called with invalid TextID. (0x%x)', 00H
	ORG $+3
$SG63284 DB	'TextGetLongest called with invalid TextID. (0x%x)', 00H
	ORG $+2
$SG63291 DB	'Unknown command in call to KText.', 00H
_DATA	ENDS
_TEXT	SEGMENT
$T63620 = -48
$T63621 = -52
$T63623 = -60
$T63624 = -64
$T63626 = -72
_args$ = 8
_width$63259 = -24
_scale$63260 = -4
_r$63263 = -20
_data$63267 = -28
_memID$63272 = -32
_theStr$63279 = -36
_theWidth$63285 = -44
_junk$63287 = -40
?KText@@YAXPAF@Z PROC NEAR				; KText

; 1405 : {

  02dc0	55		 push	 ebp
  02dc1	8b ec		 mov	 ebp, esp
  02dc3	83 ec 50	 sub	 esp, 80			; 00000050H

; 1406 : 	enum {
; 1407 : 		fTextSize,
; 1408 : 		fTextWidth,
; 1409 : 		fTextColors,
; 1410 : 		fTextFonts,
; 1411 : 		fTextGetLongest,
; 1412 : 		fTextGetLastColor
; 1413 : 	};
; 1414 : 
; 1415 : 	switch ( arg(1) ) {

  02dc6	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  02dc9	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  02dcd	89 4d b0	 mov	 DWORD PTR -80+[ebp], ecx
  02dd0	83 7d b0 05	 cmp	 DWORD PTR -80+[ebp], 5
  02dd4	0f 87 7a 02 00
	00		 ja	 $L63290
  02dda	8b 55 b0	 mov	 edx, DWORD PTR -80+[ebp]
  02ddd	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L63628[edx*4]
$L63248:

; 1426 : 			if ( !((MemID)arg(2)).IsValid() ) 

  02de4	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  02de7	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  02deb	51		 push	 ecx
  02dec	8d 4d d0	 lea	 ecx, DWORD PTR $T63620[ebp]
  02def	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  02df4	8b c8		 mov	 ecx, eax
  02df6	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  02dfb	85 c0		 test	 eax, eax
  02dfd	75 1e		 jne	 SHORT $L63251

; 1427 : 				msgMgr->Fatal ( "TextSize called with invalid Array to hold resulting size. (0x%x)", (SCIUWord)arg(2) );

  02dff	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  02e02	33 c0		 xor	 eax, eax
  02e04	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  02e08	50		 push	 eax
  02e09	68 00 00 00 00	 push	 OFFSET FLAT:$SG63253
  02e0e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  02e14	51		 push	 ecx
  02e15	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  02e1a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L63251:

; 1428 : 
; 1429 : 			if ( !((MemID)arg(3)).IsValid() ) 

  02e1d	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  02e20	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  02e24	50		 push	 eax
  02e25	8d 4d cc	 lea	 ecx, DWORD PTR $T63621[ebp]
  02e28	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  02e2d	8b c8		 mov	 ecx, eax
  02e2f	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  02e34	85 c0		 test	 eax, eax
  02e36	75 1d		 jne	 SHORT $L63256

; 1430 : 				msgMgr->Fatal ( "TextSize called with invalid TextID. (0x%x)", (SCIUWord)arg(3) );

  02e38	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  02e3b	33 d2		 xor	 edx, edx
  02e3d	66 8b 51 06	 mov	 dx, WORD PTR [ecx+6]
  02e41	52		 push	 edx
  02e42	68 00 00 00 00	 push	 OFFSET FLAT:$SG63258
  02e47	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  02e4c	50		 push	 eax
  02e4d	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  02e52	83 c4 0c	 add	 esp, 12			; 0000000cH
$L63256:

; 1431 : 
; 1432 : 			uint width = 0;

  02e55	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _width$63259[ebp], 0

; 1433 :    		Bool scale = True;

  02e5c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _scale$63260[ebp], 1

; 1434 : 
; 1435 :    		if (argCount >= 6)

  02e63	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  02e66	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  02e69	83 fa 06	 cmp	 edx, 6
  02e6c	7c 0a		 jl	 SHORT $L63261

; 1436 :       		scale = arg(6);

  02e6e	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  02e71	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  02e75	89 4d fc	 mov	 DWORD PTR _scale$63260[ebp], ecx
$L63261:

; 1437 : 
; 1438 : 			if (argCount >= 5)

  02e78	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  02e7b	0f bf 02	 movsx	 eax, WORD PTR [edx]
  02e7e	83 f8 05	 cmp	 eax, 5
  02e81	7c 0a		 jl	 SHORT $L63262

; 1439 : 				width = arg(5);

  02e83	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  02e86	0f bf 51 0a	 movsx	 edx, WORD PTR [ecx+10]
  02e8a	89 55 e8	 mov	 DWORD PTR _width$63259[ebp], edx
$L63262:

; 1440 : 
; 1441 : 			SOL_Rect r(0,0,0,0);

  02e8d	6a 00		 push	 0
  02e8f	6a 00		 push	 0
  02e91	6a 00		 push	 0
  02e93	6a 00		 push	 0
  02e95	8d 4d ec	 lea	 ecx, DWORD PTR _r$63263[ebp]
  02e98	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@HHHH@Z	; SOL_Rect::SOL_Rect

; 1442 : 
; 1443 : 			fontMgr->SetFont(arg(4));

  02e9d	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  02ea0	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  02ea4	51		 push	 ecx
  02ea5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?fontMgr@@3PAVFontMgr@@A ; fontMgr
  02eab	e8 00 00 00 00	 call	 ?SetFont@FontMgr@@QAEXH@Z ; FontMgr::SetFont

; 1444 : 			fontMgr->TextSize((MemID) arg(3),width,r,scale);

  02eb0	8b 55 fc	 mov	 edx, DWORD PTR _scale$63260[ebp]
  02eb3	52		 push	 edx
  02eb4	8d 45 ec	 lea	 eax, DWORD PTR _r$63263[ebp]
  02eb7	50		 push	 eax
  02eb8	8b 4d e8	 mov	 ecx, DWORD PTR _width$63259[ebp]
  02ebb	51		 push	 ecx
  02ebc	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  02ebf	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  02ec3	50		 push	 eax
  02ec4	8d 4d c4	 lea	 ecx, DWORD PTR $T63623[ebp]
  02ec7	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  02ecc	51		 push	 ecx
  02ecd	8b cc		 mov	 ecx, esp
  02ecf	50		 push	 eax
  02ed0	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  02ed5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?fontMgr@@3PAVFontMgr@@A ; fontMgr
  02edb	e8 00 00 00 00	 call	 ?TextSize@FontMgr@@QAEXVMemID@@HAAVSOL_Rect@@H@Z ; FontMgr::TextSize

; 1445 : 			SCIWord* data = (SCIWord*) ((ArrayID) arg(2)).Data();

  02ee0	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  02ee3	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  02ee7	52		 push	 edx
  02ee8	8d 4d c0	 lea	 ecx, DWORD PTR $T63624[ebp]
  02eeb	e8 00 00 00 00	 call	 ??0ArrayID@@QAE@G@Z	; ArrayID::ArrayID
  02ef0	8b c8		 mov	 ecx, eax
  02ef2	e8 00 00 00 00	 call	 ?Data@ArrayID@@QAEPAXXZ	; ArrayID::Data
  02ef7	89 45 e4	 mov	 DWORD PTR _data$63267[ebp], eax

; 1446 : 
; 1447 : 			data[0] = r.A.x;

  02efa	8b 45 e4	 mov	 eax, DWORD PTR _data$63267[ebp]
  02efd	66 8b 4d ec	 mov	 cx, WORD PTR _r$63263[ebp]
  02f01	66 89 08	 mov	 WORD PTR [eax], cx

; 1448 : 			data[1] = r.A.y;

  02f04	8b 55 e4	 mov	 edx, DWORD PTR _data$63267[ebp]
  02f07	66 8b 45 f0	 mov	 ax, WORD PTR _r$63263[ebp+4]
  02f0b	66 89 42 02	 mov	 WORD PTR [edx+2], ax

; 1449 : 			data[2] = r.B.x;

  02f0f	8b 4d e4	 mov	 ecx, DWORD PTR _data$63267[ebp]
  02f12	66 8b 55 f4	 mov	 dx, WORD PTR _r$63263[ebp+8]
  02f16	66 89 51 04	 mov	 WORD PTR [ecx+4], dx

; 1450 : 			data[3] = r.B.y;

  02f1a	8b 45 e4	 mov	 eax, DWORD PTR _data$63267[ebp]
  02f1d	66 8b 4d f8	 mov	 cx, WORD PTR _r$63263[ebp+12]
  02f21	66 89 48 06	 mov	 WORD PTR [eax+6], cx

; 1451 : 
; 1452 : 			break;

  02f25	e9 3e 01 00 00	 jmp	 $L63245
$L63271:

; 1456 : 			MemID memID = arg(2);

  02f2a	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  02f2d	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  02f31	50		 push	 eax
  02f32	8d 4d e0	 lea	 ecx, DWORD PTR _memID$63272[ebp]
  02f35	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID

; 1457 : 
; 1458 : 			if ( !memID.IsValid() )

  02f3a	8d 4d e0	 lea	 ecx, DWORD PTR _memID$63272[ebp]
  02f3d	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  02f42	85 c0		 test	 eax, eax
  02f44	75 22		 jne	 SHORT $L63273

; 1459 : 				msgMgr->Fatal ( "TextWidth called with invalid TextID. (0x%x)", (SCIUWord)memID );

  02f46	8d 4d e0	 lea	 ecx, DWORD PTR _memID$63272[ebp]
  02f49	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  02f4e	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  02f53	50		 push	 eax
  02f54	68 00 00 00 00	 push	 OFFSET FLAT:$SG63275
  02f59	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  02f5f	51		 push	 ecx
  02f60	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  02f65	83 c4 0c	 add	 esp, 12			; 0000000cH
$L63273:

; 1460 : 
; 1461 : 			fontMgr->SetFont(arg(3));

  02f68	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  02f6b	0f bf 42 06	 movsx	 eax, WORD PTR [edx+6]
  02f6f	50		 push	 eax
  02f70	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?fontMgr@@3PAVFontMgr@@A ; fontMgr
  02f76	e8 00 00 00 00	 call	 ?SetFont@FontMgr@@QAEXH@Z ; FontMgr::SetFont

; 1462 : 
; 1463 : 			pm.acc = fontMgr->StringWidth(memID);

  02f7b	51		 push	 ecx
  02f7c	8b cc		 mov	 ecx, esp
  02f7e	8d 55 e0	 lea	 edx, DWORD PTR _memID$63272[ebp]
  02f81	52		 push	 edx
  02f82	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  02f87	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?fontMgr@@3PAVFontMgr@@A ; fontMgr
  02f8d	e8 00 00 00 00	 call	 ?StringWidth@FontMgr@@QAEHVMemID@@@Z ; FontMgr::StringWidth
  02f92	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 1464 : 
; 1465 : 			break;

  02f97	e9 cc 00 00 00	 jmp	 $L63245
$L63277:

; 1467 : 
; 1468 : 		case fTextColors:
; 1469 : 		case fTextFonts:
; 1470 : 			break;

  02f9c	e9 c7 00 00 00	 jmp	 $L63245
$L63278:

; 1473 : 			TextID theStr = (TextID)arg(2);

  02fa1	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  02fa4	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  02fa8	51		 push	 ecx
  02fa9	8d 4d b8	 lea	 ecx, DWORD PTR $T63626[ebp]
  02fac	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  02fb1	50		 push	 eax
  02fb2	8d 4d dc	 lea	 ecx, DWORD PTR _theStr$63279[ebp]
  02fb5	e8 00 00 00 00	 call	 ??0TextID@@QAE@ABV0@@Z	; TextID::TextID

; 1474 : 
; 1475 : 			if ( !theStr.IsValid() )

  02fba	8d 4d dc	 lea	 ecx, DWORD PTR _theStr$63279[ebp]
  02fbd	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  02fc2	85 c0		 test	 eax, eax
  02fc4	75 22		 jne	 SHORT $L63282

; 1476 : 				msgMgr->Fatal ( "TextGetLongest called with invalid TextID. (0x%x)", (SCIUWord)theStr );

  02fc6	8d 4d dc	 lea	 ecx, DWORD PTR _theStr$63279[ebp]
  02fc9	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  02fce	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  02fd3	50		 push	 eax
  02fd4	68 00 00 00 00	 push	 OFFSET FLAT:$SG63284
  02fd9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  02fdf	52		 push	 edx
  02fe0	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  02fe5	83 c4 0c	 add	 esp, 12			; 0000000cH
$L63282:

; 1477 : 				
; 1478 : 			int theWidth = (int)arg(3), junk = 0;

  02fe8	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  02feb	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  02fef	89 4d d4	 mov	 DWORD PTR _theWidth$63285[ebp], ecx
  02ff2	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _junk$63287[ebp], 0

; 1479 : 
; 1480 : 			fontMgr->SetFont(arg(4));

  02ff9	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  02ffc	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  03000	50		 push	 eax
  03001	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?fontMgr@@3PAVFontMgr@@A ; fontMgr
  03007	e8 00 00 00 00	 call	 ?SetFont@FontMgr@@QAEXH@Z ; FontMgr::SetFont

; 1481 : 			fontMgr->SetText ( theStr );

  0300c	51		 push	 ecx
  0300d	8b cc		 mov	 ecx, esp
  0300f	8d 55 dc	 lea	 edx, DWORD PTR _theStr$63279[ebp]
  03012	52		 push	 edx
  03013	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  03018	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?fontMgr@@3PAVFontMgr@@A ; fontMgr
  0301e	e8 00 00 00 00	 call	 ?SetText@FontMgr@@QAEXVMemID@@@Z ; FontMgr::SetText

; 1482 : 
; 1483 : 			pm.acc = fontMgr->GetLongest ( &junk, theWidth );

  03023	8b 45 d4	 mov	 eax, DWORD PTR _theWidth$63285[ebp]
  03026	50		 push	 eax
  03027	8d 4d d8	 lea	 ecx, DWORD PTR _junk$63287[ebp]
  0302a	51		 push	 ecx
  0302b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?fontMgr@@3PAVFontMgr@@A ; fontMgr
  03031	e8 00 00 00 00	 call	 ?GetLongest@FontMgr@@QAEGPAHH@Z ; FontMgr::GetLongest
  03036	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0303b	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 1485 : 
; 1486 : 		break;

  03040	eb 26		 jmp	 SHORT $L63245
$L63289:

; 1487 : 
; 1488 : 		case fTextGetLastColor: 
; 1489 : 			pm.acc = fontMgr->lastColor;

  03042	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?fontMgr@@3PAVFontMgr@@A ; fontMgr
  03048	33 c0		 xor	 eax, eax
  0304a	66 8b 02	 mov	 ax, WORD PTR [edx]
  0304d	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 1490 : 			break;

  03052	eb 14		 jmp	 SHORT $L63245
$L63290:

; 1491 : 
; 1492 : 		default:
; 1493 : 			msgMgr->Fatal ( "Unknown command in call to KText." );

  03054	68 00 00 00 00	 push	 OFFSET FLAT:$SG63291
  03059	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  0305f	51		 push	 ecx
  03060	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  03065	83 c4 08	 add	 esp, 8
$L63245:

; 1496 : }

  03068	8b e5		 mov	 esp, ebp
  0306a	5d		 pop	 ebp
  0306b	c3		 ret	 0
$L63628:
  0306c	00 00 00 00	 DD	 $L63248
  03070	00 00 00 00	 DD	 $L63271
  03074	00 00 00 00	 DD	 $L63277
  03078	00 00 00 00	 DD	 $L63277
  0307c	00 00 00 00	 DD	 $L63278
  03080	00 00 00 00	 DD	 $L63289
?KText@@YAXPAF@Z ENDP					; KText
_TEXT	ENDS
PUBLIC	?IsValid@MemoryMgr@@QAEHG@Z			; MemoryMgr::IsValid
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsValid@MemID@@QBEHXZ PROC NEAR			; MemID::IsValid, COMDAT

; 62   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 63   : 		return memMgr->IsValid(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?IsValid@MemoryMgr@@QAEHG@Z ; MemoryMgr::IsValid

; 64   : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?IsValid@MemID@@QBEHXZ ENDP				; MemID::IsValid
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -8
_tempID$ = -4
?IsValid@MemoryMgr@@QAEHG@Z PROC NEAR			; MemoryMgr::IsValid, COMDAT

; 475  : 	inline Bool MemoryMgr::IsValid(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 476  : 		unsigned short tempID = (unsigned short)theID;

  00009	66 8b 45 08	 mov	 ax, WORD PTR _theID$[ebp]
  0000d	66 89 45 fc	 mov	 WORD PTR _tempID$[ebp], ax

; 477  : 
; 478  : 		return(
; 479  : 				(tempID)															&&
; 480  : 				(tempID < maxDescriptors)									&&
; 481  : 				(desc[tempID].memInfo.bits.freeDescriptor == False)	&&
; 482  : 				(desc[tempID].memInfo.bits.freeMemory == False)
; 483  : 				);

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _tempID$[ebp]
  00014	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 58		 je	 SHORT $L63631
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _tempID$[ebp]
  00021	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  0002d	73 47		 jae	 SHORT $L63631
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _tempID$[ebp]
  00032	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00038	c1 e1 04	 shl	 ecx, 4
  0003b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00041	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00044	c1 e1 0e	 shl	 ecx, 14			; 0000000eH
  00047	c1 f9 1f	 sar	 ecx, 31			; 0000001fH
  0004a	85 c9		 test	 ecx, ecx
  0004c	75 28		 jne	 SHORT $L63631
  0004e	8b 55 fc	 mov	 edx, DWORD PTR _tempID$[ebp]
  00051	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00057	c1 e2 04	 shl	 edx, 4
  0005a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00060	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00063	c1 e2 14	 shl	 edx, 20			; 00000014H
  00066	c1 fa 1f	 sar	 edx, 31			; 0000001fH
  00069	85 d2		 test	 edx, edx
  0006b	75 09		 jne	 SHORT $L63631
  0006d	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR -12+[ebp], 1
  00074	eb 07		 jmp	 SHORT $L63632
$L63631:
  00076	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR -12+[ebp], 0
$L63632:
  0007d	8b 45 f4	 mov	 eax, DWORD PTR -12+[ebp]

; 484  : 	}

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 04 00	 ret	 4
?IsValid@MemoryMgr@@QAEHG@Z ENDP			; MemoryMgr::IsValid
_TEXT	ENDS
PUBLIC	??0FakeArrayID@@QAE@G@Z				; FakeArrayID::FakeArrayID
;	COMDAT ??0ArrayID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0ArrayID@@QAE@G@Z PROC NEAR				; ArrayID::ArrayID, COMDAT

; 38   : 	ArrayID(SOL_Handle h) : FakeArrayID(h) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	66 8b 45 08	 mov	 ax, WORD PTR _h$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0FakeArrayID@@QAE@G@Z	; FakeArrayID::FakeArrayID
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0ArrayID@@QAE@G@Z ENDP				; ArrayID::ArrayID
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0FakeArrayID@@QAE@G@Z PROC NEAR			; FakeArrayID::FakeArrayID, COMDAT

; 34   : FakeTemplateID ( FakeArrayID, ArrayHeader, MemArray )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	66 8b 45 08	 mov	 ax, WORD PTR _h$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0FakeArrayID@@QAE@G@Z ENDP				; FakeArrayID::FakeArrayID
_TEXT	ENDS
PUBLIC	??DFakeArrayID@@QBEPAUArrayHeader@@XZ		; FakeArrayID::operator*
;	COMDAT ?Data@ArrayID@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4
?Data@ArrayID@@QAEPAXXZ PROC NEAR			; ArrayID::Data, COMDAT

; 64   : 	void *Data ( void ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 65   : 		return ((char *)**this) + sizeof ( ArrayHeader );

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??DFakeArrayID@@QBEPAUArrayHeader@@XZ ; FakeArrayID::operator*
  0000f	83 c0 04	 add	 eax, 4

; 66   : 	}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?Data@ArrayID@@QAEPAXXZ ENDP				; ArrayID::Data
_TEXT	ENDS
;	COMDAT ??DFakeArrayID@@QBEPAUArrayHeader@@XZ
_TEXT	SEGMENT
_this$ = -4
??DFakeArrayID@@QBEPAUArrayHeader@@XZ PROC NEAR		; FakeArrayID::operator*, COMDAT

; 34   : FakeTemplateID ( FakeArrayID, ArrayHeader, MemArray )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??DFakeArrayID@@QBEPAUArrayHeader@@XZ ENDP		; FakeArrayID::operator*
_TEXT	ENDS
;	COMDAT ?Width@CelObj@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Width@CelObj@@QBEHXZ PROC NEAR				; CelObj::Width, COMDAT

; 177  : 	int	Width() const			{return width;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Width@CelObj@@QBEHXZ ENDP				; CelObj::Width
_TEXT	ENDS
;	COMDAT ?Height@CelObj@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Height@CelObj@@QBEHXZ PROC NEAR			; CelObj::Height, COMDAT

; 178  : 	int	Height() const			{return height;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Height@CelObj@@QBEHXZ ENDP				; CelObj::Height
_TEXT	ENDS
;	COMDAT ?ResX@CelObj@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?ResX@CelObj@@QBEHXZ PROC NEAR				; CelObj::ResX, COMDAT

; 181  : 	int	ResX() const			{return resx;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?ResX@CelObj@@QBEHXZ ENDP				; CelObj::ResX
_TEXT	ENDS
;	COMDAT ?ResY@CelObj@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?ResY@CelObj@@QBEHXZ PROC NEAR				; CelObj::ResY, COMDAT

; 182  : 	int	ResY() const			{return resy;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?ResY@CelObj@@QBEHXZ ENDP				; CelObj::ResY
_TEXT	ENDS
;	COMDAT ?Skip@CelObj@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4
?Skip@CelObj@@QBEEXZ PROC NEAR				; CelObj::Skip, COMDAT

; 184  : 	uchar	Skip() const			{return skip;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 38	 mov	 al, BYTE PTR [eax+56]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Skip@CelObj@@QBEEXZ ENDP				; CelObj::Skip
_TEXT	ENDS
;	COMDAT ??0TextID@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0TextID@@QAE@ABV0@@Z PROC NEAR			; TextID::TextID, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0TextID@@QAE@ABV0@@Z ENDP				; TextID::TextID
_TEXT	ENDS
PUBLIC	?KFont@@YAXPAF@Z				; KFont
PUBLIC	?PointSize@FontMgr@@QAEHH@Z			; FontMgr::PointSize
PUBLIC	?SetRes@FontMgr@@QAEXHH@Z			; FontMgr::SetRes
_DATA	SEGMENT
	ORG $+2
$SG63308 DB	'Unknown command in call to KFont.', 00H
_DATA	ENDS
_TEXT	SEGMENT
_args$ = 8
?KFont@@YAXPAF@Z PROC NEAR				; KFont

; 1500 : {

  03084	55		 push	 ebp
  03085	8b ec		 mov	 ebp, esp
  03087	51		 push	 ecx

; 1501 : 	enum {
; 1502 : 		fPointSize,
; 1503 : 		fSetFontRes
; 1504 : 	};
; 1505 : 
; 1506 : 	switch ( arg(1) ) {

  03088	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  0308b	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  0308f	89 4d fc	 mov	 DWORD PTR -4+[ebp], ecx
  03092	83 7d fc 00	 cmp	 DWORD PTR -4+[ebp], 0
  03096	74 08		 je	 SHORT $L63305
  03098	83 7d fc 01	 cmp	 DWORD PTR -4+[ebp], 1
  0309c	74 29		 je	 SHORT $L63306
  0309e	eb 44		 jmp	 SHORT $L63307
$L63305:

; 1508 : 			fontMgr->SetFont(arg(2));

  030a0	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  030a3	0f bf 42 04	 movsx	 eax, WORD PTR [edx+4]
  030a7	50		 push	 eax
  030a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?fontMgr@@3PAVFontMgr@@A ; fontMgr
  030ae	e8 00 00 00 00	 call	 ?SetFont@FontMgr@@QAEXH@Z ; FontMgr::SetFont

; 1509 : 			pm.acc = fontMgr->PointSize();

  030b3	6a 01		 push	 1
  030b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?fontMgr@@3PAVFontMgr@@A ; fontMgr
  030bb	e8 00 00 00 00	 call	 ?PointSize@FontMgr@@QAEHH@Z ; FontMgr::PointSize
  030c0	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 1510 : 
; 1511 : 			break;

  030c5	eb 31		 jmp	 SHORT $L63302
$L63306:

; 1515 : 		   fontMgr->SetRes(arg(2),arg(3));

  030c7	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  030ca	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  030ce	52		 push	 edx
  030cf	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  030d2	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  030d6	51		 push	 ecx
  030d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?fontMgr@@3PAVFontMgr@@A ; fontMgr
  030dd	e8 00 00 00 00	 call	 ?SetRes@FontMgr@@QAEXHH@Z ; FontMgr::SetRes

; 1516 : 			break;

  030e2	eb 14		 jmp	 SHORT $L63302
$L63307:

; 1518 : 
; 1519 : 		default:
; 1520 : 			msgMgr->Fatal ( "Unknown command in call to KFont." );

  030e4	68 00 00 00 00	 push	 OFFSET FLAT:$SG63308
  030e9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  030ef	52		 push	 edx
  030f0	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  030f5	83 c4 08	 add	 esp, 8
$L63302:

; 1523 : }

  030f8	8b e5		 mov	 esp, ebp
  030fa	5d		 pop	 ebp
  030fb	c3		 ret	 0
?KFont@@YAXPAF@Z ENDP					; KFont
_TEXT	ENDS
PUBLIC	??1CelObj@@UAE@XZ				; CelObj::~CelObj
;	COMDAT ??1CelObjView@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CelObjView@@UAE@XZ PROC NEAR				; CelObjView::~CelObjView, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CelObj@@UAE@XZ	; CelObj::~CelObj
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1CelObjView@@UAE@XZ ENDP				; CelObjView::~CelObjView
_TEXT	ENDS
PUBLIC	??_7CelObj@@6B@					; CelObj::`vftable'
PUBLIC	??_GCelObj@@UAEPAXI@Z				; CelObj::`scalar deleting destructor'
PUBLIC	??_ECelObj@@UAEPAXI@Z				; CelObj::`vector deleting destructor'
EXTRN	__purecall:NEAR
EXTRN	?ReadPix@CelObj@@UAEEHHH@Z:NEAR			; CelObj::ReadPix
;	COMDAT ??_7CelObj@@6B@
; File \\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\celobj.hpp
CONST	SEGMENT
??_7CelObj@@6B@ DD FLAT:??_ECelObj@@UAEPAXI@Z		; CelObj::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?ReadPix@CelObj@@UAEEHHH@Z
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??1CelObj@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CelObj@@UAE@XZ PROC NEAR				; CelObj::~CelObj, COMDAT

; 173  : 	virtual	~CelObj()  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CelObj@@6B@ ; CelObj::`vftable'
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1CelObj@@UAE@XZ ENDP					; CelObj::~CelObj
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
;	COMDAT ??_GCelObj@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GCelObj@@UAEPAXI@Z PROC NEAR				; CelObj::`scalar deleting destructor', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CelObj@@UAE@XZ	; CelObj::~CelObj
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L56001
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L56001:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCelObj@@UAEPAXI@Z ENDP				; CelObj::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0SOL_Point@@QAE@XZ				; SOL_Point::SOL_Point
;	COMDAT ??0SOL_Rect@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0SOL_Rect@@QAE@XZ PROC NEAR				; SOL_Rect::SOL_Rect, COMDAT

; 13   : 	SOL_Rect()  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 08	 add	 ecx, 8
  00015	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0SOL_Rect@@QAE@XZ ENDP				; SOL_Rect::SOL_Rect
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0SOL_Point@@QAE@XZ PROC NEAR				; SOL_Point::SOL_Point, COMDAT

; 20   : 	SOL_Point() : x(DefaultCoord), y(DefaultCoord) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 ef cd ab
	89		 mov	 DWORD PTR [eax], -1985229329 ; 89abcdefH
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 ef cd
	ab 89		 mov	 DWORD PTR [ecx+4], -1985229329 ; 89abcdefH
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0SOL_Point@@QAE@XZ ENDP				; SOL_Point::SOL_Point
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@HHHH@Z
_TEXT	SEGMENT
_xa$ = 8
_ya$ = 12
_xb$ = 16
_yb$ = 20
_this$ = -4
??0SOL_Rect@@QAE@HHHH@Z PROC NEAR			; SOL_Rect::SOL_Rect, COMDAT

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 08	 add	 ecx, 8
  00015	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point

; 56   : 	A.x = xa;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _xa$[ebp]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 57   : 	A.y = ya;

  00022	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00025	8b 45 0c	 mov	 eax, DWORD PTR _ya$[ebp]
  00028	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 58   : 	B.x = xb;

  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8b 55 10	 mov	 edx, DWORD PTR _xb$[ebp]
  00031	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 59   : 	B.y = yb;

  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 4d 14	 mov	 ecx, DWORD PTR _yb$[ebp]
  0003a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 60   : }

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 10 00	 ret	 16			; 00000010H
??0SOL_Rect@@QAE@HHHH@Z ENDP				; SOL_Rect::SOL_Rect
_TEXT	ENDS
;	COMDAT ?IsEmpty@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsEmpty@SOL_Rect@@QBEHXZ PROC NEAR			; SOL_Rect::IsEmpty, COMDAT

; 116  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 117  : 	if (B.x < A.x  ||  B.y < A.y)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00010	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00012	7c 0e		 jl	 SHORT $L56348
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0001d	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00020	7d 07		 jge	 SHORT $L56347
$L56348:

; 118  : 		return True;

  00022	b8 01 00 00 00	 mov	 eax, 1
  00027	eb 02		 jmp	 SHORT $L56346
$L56347:

; 119  : 	return False;

  00029	33 c0		 xor	 eax, eax
$L56346:

; 120  : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?IsEmpty@SOL_Rect@@QBEHXZ ENDP				; SOL_Rect::IsEmpty
_TEXT	ENDS
;	COMDAT ?Xlen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Xlen@SOL_Rect@@QBEHXZ PROC NEAR			; SOL_Rect::Xlen, COMDAT

; 153  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 154  : 	return B.x - A.x + 1;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00010	2b 01		 sub	 eax, DWORD PTR [ecx]
  00012	83 c0 01	 add	 eax, 1

; 155  : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?Xlen@SOL_Rect@@QBEHXZ ENDP				; SOL_Rect::Xlen
_TEXT	ENDS
;	COMDAT ?Ylen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Ylen@SOL_Rect@@QBEHXZ PROC NEAR			; SOL_Rect::Ylen, COMDAT

; 161  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 	return B.y - A.y + 1;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00010	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00013	83 c0 01	 add	 eax, 1

; 163  : }

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?Ylen@SOL_Rect@@QBEHXZ ENDP				; SOL_Rect::Ylen
_TEXT	ENDS
PUBLIC	?Intersect@SOL_Rect@@QBEHABV1@@Z		; SOL_Rect::Intersect
PUBLIC	?MakeEmpty@SOL_Rect@@QAEXXZ			; SOL_Rect::MakeEmpty
;	COMDAT ?Clip@SOL_Rect@@QAEXABV1@@Z
_TEXT	SEGMENT
_r$ = 8
_this$ = -4
?Clip@SOL_Rect@@QAEXABV1@@Z PROC NEAR			; SOL_Rect::Clip, COMDAT

; 224  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 225  : 	if (Intersect(r))  {

  00007	8b 45 08	 mov	 eax, DWORD PTR _r$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?Intersect@SOL_Rect@@QBEHABV1@@Z ; SOL_Rect::Intersect
  00013	85 c0		 test	 eax, eax
  00015	74 66		 je	 SHORT $L56401

; 226  : 		if (A.x < r.A.x)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  0001d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001f	3b 02		 cmp	 eax, DWORD PTR [edx]
  00021	7d 0a		 jge	 SHORT $L56402

; 227  : 			A.x = r.A.x;

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00029	8b 02		 mov	 eax, DWORD PTR [edx]
  0002b	89 01		 mov	 DWORD PTR [ecx], eax
$L56402:

; 228  : 		if (A.y < r.A.y)

  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00033	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00036	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00039	7d 0c		 jge	 SHORT $L56403

; 229  : 			A.y = r.A.y;

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00041	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00044	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$L56403:

; 230  : 		if (B.x > r.B.x)

  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  0004d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00050	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00053	7e 0c		 jle	 SHORT $L56404

; 231  : 			B.x = r.B.x;

  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  0005b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0005e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L56404:

; 232  : 		if (B.y > r.B.y)

  00061	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00067	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0006a	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  0006d	7e 0c		 jle	 SHORT $L56405

; 233  : 			B.y = r.B.y;

  0006f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00075	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00078	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$L56405:

; 235  : 	else

  0007b	eb 08		 jmp	 SHORT $L56406
$L56401:

; 236  : 		MakeEmpty();

  0007d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	e8 00 00 00 00	 call	 ?MakeEmpty@SOL_Rect@@QAEXXZ ; SOL_Rect::MakeEmpty
$L56406:

; 237  : }

  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
?Clip@SOL_Rect@@QAEXABV1@@Z ENDP			; SOL_Rect::Clip
_TEXT	ENDS
;	COMDAT ?MakeEmpty@SOL_Rect@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?MakeEmpty@SOL_Rect@@QAEXXZ PROC NEAR			; SOL_Rect::MakeEmpty, COMDAT

; 142  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 143  : 	B.x = -1;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 08 ff ff
	ff ff		 mov	 DWORD PTR [eax+8], -1

; 144  : 	B.y = -1;

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 0c ff ff
	ff ff		 mov	 DWORD PTR [ecx+12], -1

; 145  : 	A.x = 0;

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 146  : 	A.y = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 147  : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?MakeEmpty@SOL_Rect@@QAEXXZ ENDP			; SOL_Rect::MakeEmpty
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHABV1@@Z
_TEXT	SEGMENT
_r$ = 8
_this$ = -4
?Intersect@SOL_Rect@@QBEHABV1@@Z PROC NEAR		; SOL_Rect::Intersect, COMDAT

; 189  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 190  : 	if (B.x < r.A.x)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  0000d	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00010	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00012	7d 04		 jge	 SHORT $L56384

; 191  : 		return False;

  00014	33 c0		 xor	 eax, eax
  00016	eb 3a		 jmp	 SHORT $L56383
$L56384:

; 192  : 	if (B.y < r.A.y)

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  0001e	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00021	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00024	7d 04		 jge	 SHORT $L56385

; 193  : 		return False;

  00026	33 c0		 xor	 eax, eax
  00028	eb 28		 jmp	 SHORT $L56383
$L56385:

; 194  : 	if (A.x > r.B.x)

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00030	8b 10		 mov	 edx, DWORD PTR [eax]
  00032	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00035	7e 04		 jle	 SHORT $L56386

; 195  : 		return False;

  00037	33 c0		 xor	 eax, eax
  00039	eb 17		 jmp	 SHORT $L56383
$L56386:

; 196  : 	if (A.y > r.B.y)

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00041	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00044	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00047	7e 04		 jle	 SHORT $L56387

; 197  : 		return False;

  00049	33 c0		 xor	 eax, eax
  0004b	eb 05		 jmp	 SHORT $L56383
$L56387:

; 198  : 	return True;

  0004d	b8 01 00 00 00	 mov	 eax, 1
$L56383:

; 199  : }

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?Intersect@SOL_Rect@@QBEHABV1@@Z ENDP			; SOL_Rect::Intersect
_TEXT	ENDS
;	COMDAT ?Inset@SOL_Rect@@QAEXHH@Z
_TEXT	SEGMENT
_dx$ = 8
_dy$ = 12
_this$ = -4
?Inset@SOL_Rect@@QAEXHH@Z PROC NEAR			; SOL_Rect::Inset, COMDAT

; 328  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 329  : 	A.x += dx;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	03 4d 08	 add	 ecx, DWORD PTR _dx$[ebp]
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	89 0a		 mov	 DWORD PTR [edx], ecx

; 330  : 	B.x -= dx;

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001a	2b 4d 08	 sub	 ecx, DWORD PTR _dx$[ebp]
  0001d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00020	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 331  : 	A.y += dy;

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00029	03 4d 0c	 add	 ecx, DWORD PTR _dy$[ebp]
  0002c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 332  : 	B.y -= dy;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00038	2b 4d 0c	 sub	 ecx, DWORD PTR _dy$[ebp]
  0003b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 333  : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 08 00	 ret	 8
?Inset@SOL_Rect@@QAEXHH@Z ENDP				; SOL_Rect::Inset
_TEXT	ENDS
;	COMDAT ?Scale@SOL_Rect@@QAEXHHHH@Z
_TEXT	SEGMENT
_nx$ = 8
_dx$ = 12
_ny$ = 16
_dy$ = 20
_this$ = -4
?Scale@SOL_Rect@@QAEXHHHH@Z PROC NEAR			; SOL_Rect::Scale, COMDAT

; 339  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 340  : 	A.x = A.x * nx / dx;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	0f af 45 08	 imul	 eax, DWORD PTR _nx$[ebp]
  00010	99		 cdq
  00011	f7 7d 0c	 idiv	 DWORD PTR _dx$[ebp]
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	89 01		 mov	 DWORD PTR [ecx], eax

; 341  : 	B.x = B.x * nx / dx;

  00019	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001f	0f af 45 08	 imul	 eax, DWORD PTR _nx$[ebp]
  00023	99		 cdq
  00024	f7 7d 0c	 idiv	 DWORD PTR _dx$[ebp]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 342  : 	A.y = A.y * ny / dy;

  0002d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00030	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00033	0f af 45 10	 imul	 eax, DWORD PTR _ny$[ebp]
  00037	99		 cdq
  00038	f7 7d 14	 idiv	 DWORD PTR _dy$[ebp]
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 343  : 	B.y = B.y * ny / dy;

  00041	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00044	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00047	0f af 45 10	 imul	 eax, DWORD PTR _ny$[ebp]
  0004b	99		 cdq
  0004c	f7 7d 14	 idiv	 DWORD PTR _dy$[ebp]
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 344  : }

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 10 00	 ret	 16			; 00000010H
?Scale@SOL_Rect@@QAEXHHHH@Z ENDP			; SOL_Rect::Scale
_TEXT	ENDS
PUBLIC	??4SOL_Point@@QAEAAV0@ABV0@@Z			; SOL_Point::operator=
;	COMDAT ??4SOL_Rect@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??4SOL_Rect@@QAEAAV0@ABV0@@Z PROC NEAR			; SOL_Rect::operator=, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??4SOL_Point@@QAEAAV0@ABV0@@Z ; SOL_Point::operator=
  00013	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00016	83 c1 08	 add	 ecx, 8
  00019	51		 push	 ecx
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 08	 add	 ecx, 8
  00020	e8 00 00 00 00	 call	 ??4SOL_Point@@QAEAAV0@ABV0@@Z ; SOL_Point::operator=
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??4SOL_Rect@@QAEAAV0@ABV0@@Z ENDP			; SOL_Rect::operator=
_TEXT	ENDS
;	COMDAT ??4SOL_Point@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
??4SOL_Point@@QAEAAV0@ABV0@@Z PROC NEAR			; SOL_Point::operator=, COMDAT

; 117  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 118  : 	x = p.x;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx

; 119  : 	y = p.y;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00017	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001a	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 120  : 	return *this;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 121  : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??4SOL_Point@@QAEAAV0@ABV0@@Z ENDP			; SOL_Point::operator=
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0SOL_Rect@@QAE@ABV0@@Z PROC NEAR			; SOL_Rect::SOL_Rect, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  00013	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00016	83 c1 08	 add	 ecx, 8
  00019	51		 push	 ecx
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 08	 add	 ecx, 8
  00020	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??0SOL_Rect@@QAE@ABV0@@Z ENDP				; SOL_Rect::SOL_Rect
_TEXT	ENDS
PUBLIC	??0MemID@@QAE@XZ				; MemID::MemID
PUBLIC	??0Bitmap@@QAE@XZ				; Bitmap::Bitmap
;	COMDAT ??0FontMgr@@QAE@G@Z
_TEXT	SEGMENT
_theFont$ = 8
_this$ = -4
??0FontMgr@@QAE@G@Z PROC NEAR				; FontMgr::FontMgr, COMDAT

; 45   : 	FontMgr(ushort theFont = systemFont) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 0e	 add	 ecx, 14			; 0000000eH
  0000d	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 14	 add	 ecx, 20			; 00000014H
  00018	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@XZ	; SOL_Rect::SOL_Rect
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	83 c1 24	 add	 ecx, 36			; 00000024H
  00023	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	83 c1 30	 add	 ecx, 48			; 00000030H
  0002e	e8 00 00 00 00	 call	 ??0Bitmap@@QAE@XZ	; Bitmap::Bitmap
  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	83 c1 4e	 add	 ecx, 78			; 0000004eH
  00039	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID

; 46   : 		font = theFont+1;	// if font==theFont BuildFontTable just returns

  0003e	8b 45 08	 mov	 eax, DWORD PTR _theFont$[ebp]
  00041	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00046	83 c0 01	 add	 eax, 1
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	66 89 41 28	 mov	 WORD PTR [ecx+40], ax

; 47   : 		BuildFontTable(theFont);

  00050	8b 55 08	 mov	 edx, DWORD PTR _theFont$[ebp]
  00053	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00059	52		 push	 edx
  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ?BuildFontTable@FontMgr@@IAEXH@Z ; FontMgr::BuildFontTable

; 48   : 	}

  00062	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
??0FontMgr@@QAE@G@Z ENDP				; FontMgr::FontMgr
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0MemID@@QAE@XZ PROC NEAR				; MemID::MemID, COMDAT

; 15   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 16   : 	}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0MemID@@QAE@XZ ENDP					; MemID::MemID
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Bitmap@@QAE@XZ PROC NEAR				; Bitmap::Bitmap, COMDAT

; 130  : 	Bitmap() 													{view = loop = cel = 0; type = tMem;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 10	 add	 ecx, 16			; 00000010H
  0000d	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2
  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??0Bitmap@@QAE@XZ ENDP					; Bitmap::Bitmap
_TEXT	ENDS
;	COMDAT ?PointSize@FontMgr@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4
_scale$ = 8
?PointSize@FontMgr@@QAEHH@Z PROC NEAR			; FontMgr::PointSize, COMDAT

; 110  : 	int 				PointSize(Bool scale = True) {if (scale) return (pointSize * SCIRESY + yRes - 1) / yRes; return pointSize;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	83 7d 08 00	 cmp	 DWORD PTR _scale$[ebp], 0
  0000b	74 22		 je	 SHORT $L58375
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	33 c9		 xor	 ecx, ecx
  00012	66 8b 48 4c	 mov	 cx, WORD PTR [eax+76]
  00016	69 c9 e0 01 00
	00		 imul	 ecx, 480		; 000001e0H
  0001c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?yRes@FontMgr@@1HA ; FontMgr::yRes
  00022	8d 44 11 ff	 lea	 eax, DWORD PTR [ecx+edx-1]
  00026	99		 cdq
  00027	f7 3d 00 00 00
	00		 idiv	 DWORD PTR ?yRes@FontMgr@@1HA ; FontMgr::yRes
  0002d	eb 0b		 jmp	 SHORT $L58374
$L58375:
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	33 c9		 xor	 ecx, ecx
  00034	66 8b 48 4c	 mov	 cx, WORD PTR [eax+76]
  00038	8b c1		 mov	 eax, ecx
$L58374:
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
?PointSize@FontMgr@@QAEHH@Z ENDP			; FontMgr::PointSize
_TEXT	ENDS
;	COMDAT ?SetRes@FontMgr@@QAEXHH@Z
_TEXT	SEGMENT
_this$ = -4
_xres$ = 8
_yres$ = 12
?SetRes@FontMgr@@QAEXHH@Z PROC NEAR			; FontMgr::SetRes, COMDAT

; 117  : 	void				SetRes(int xres, int yres) {xRes = xres; yRes = yres;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _xres$[ebp]
  0000a	a3 00 00 00 00	 mov	 DWORD PTR ?xRes@FontMgr@@1HA, eax ; FontMgr::xRes
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR _yres$[ebp]
  00012	89 0d 00 00 00
	00		 mov	 DWORD PTR ?yRes@FontMgr@@1HA, ecx ; FontMgr::yRes
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
?SetRes@FontMgr@@QAEXHH@Z ENDP				; FontMgr::SetRes
_TEXT	ENDS
;	COMDAT ?SetText@FontMgr@@QAEXVMemID@@@Z
_TEXT	SEGMENT
_this$ = -4
_theText$ = 8
?SetText@FontMgr@@QAEXVMemID@@@Z PROC NEAR		; FontMgr::SetText, COMDAT

; 123  : 	void 				SetText(MemID theText) {text = theText;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 4d 08	 mov	 cx, WORD PTR _theText$[ebp]
  0000e	66 89 48 0e	 mov	 WORD PTR [eax+14], cx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
?SetText@FontMgr@@QAEXVMemID@@@Z ENDP			; FontMgr::SetText
_TEXT	ENDS
EXTRN	?BuildHeader@@YAXPAEHHHHHHHHH@Z:NEAR		; BuildHeader
;	COMDAT ?BuildHeader@@YAXVMemID@@HHHHHHHHH@Z
_TEXT	SEGMENT
_bm$ = 8
_width$ = 12
_height$ = 16
_skip$ = 20
_xHot$ = 24
_yHot$ = 28
_xRes$ = 32
_yRes$ = 36
_palFlag$ = 40
_remap$ = 44
?BuildHeader@@YAXVMemID@@HHHHHHHHH@Z PROC NEAR		; BuildHeader, COMDAT

; 41   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 42   : 	BuildHeader((uchar*) *bm, width, height, skip, xHot, yHot, xRes, yRes, palFlag, remap);

  00003	8b 45 2c	 mov	 eax, DWORD PTR _remap$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 28	 mov	 ecx, DWORD PTR _palFlag$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 24	 mov	 edx, DWORD PTR _yRes$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 20	 mov	 eax, DWORD PTR _xRes$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 1c	 mov	 ecx, DWORD PTR _yHot$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 18	 mov	 edx, DWORD PTR _xHot$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 14	 mov	 eax, DWORD PTR _skip$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR _height$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8d 4d 08	 lea	 ecx, DWORD PTR _bm$[ebp]
  0002a	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ?BuildHeader@@YAXPAEHHHHHHHHH@Z ; BuildHeader
  00035	83 c4 28	 add	 esp, 40			; 00000028H

; 43   : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?BuildHeader@@YAXVMemID@@HHHHHHHHH@Z ENDP		; BuildHeader
_TEXT	ENDS
PUBLIC	??_C@_00A@?$AA@					; `string'
;	COMDAT ??_C@_00A@?$AA@
; File \\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\textid.hpp
_BSS	SEGMENT
??_C@_00A@?$AA@ DB 01H DUP (?)				; `string'
_BSS	ENDS
;	COMDAT ??DTextID@@QAEPADXZ
_TEXT	SEGMENT
_this$ = -4
??DTextID@@QAEPADXZ PROC NEAR				; TextID::operator*, COMDAT

; 24   : 	char	*operator *() { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 25   : 		return handle ? (char *)MemID::operator*() : ""; 

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	33 c9		 xor	 ecx, ecx
  0000e	66 8b 08	 mov	 cx, WORD PTR [eax]
  00011	85 c9		 test	 ecx, ecx
  00013	74 0d		 je	 SHORT $L63670
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0001d	89 45 f8	 mov	 DWORD PTR -8+[ebp], eax
  00020	eb 07		 jmp	 SHORT $L63671
$L63670:
  00022	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
$L63671:
  00029	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]

; 26   : 	}

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??DTextID@@QAEPADXZ ENDP				; TextID::operator*
_TEXT	ENDS
END
