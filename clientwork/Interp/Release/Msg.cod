	TITLE	\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Msg.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_07CCG@ResView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KCEF@?4v56?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06IAEF@ResPic?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04EODC@?4p56?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08OCKJ@ResChunk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PIPI@?4chk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07ICMB@ResHunk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GG@?4scr?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08BLBP@ResSound?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KPDA@?4snd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NNMB@ResVocab?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PGDD@?4voc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FLKK@ResPatch?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CEHK@?4pat?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07MKGC@ResFont?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04IDCK@?4fon?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06DEEM@ResPal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NJLC@?4pal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07HFNL@ResHeap?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GFFD@?4hep?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06HDCC@ResMsg?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JONM@?4msg?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NFDN@ResAudio?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MOHF@?4aud?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BKMJ@ResWave?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MPDF@?4wav?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@IMEI@ResAudio36?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BONB@ResSync?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KFFK@?4syn?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09CBJE@ResSync36?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06MIEL@ResMap?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CFLF@?4map?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@LIAH@ResMsgTranslation?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JFJA@?4trn?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08JLOL@ResRobot?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04LLKI@?4rbt?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06OEMP@ResVMD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04IOID@?4vmd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MemoryMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckValid@MemoryMgr@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GMemoryMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@V1@III@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AMemID@@QBEAADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8MemID@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??7MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetExtension@SOL_ResType@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSupported@SOL_ResType@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAttrs@SOL_ResType@@UBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResView@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPic@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResChunk@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResScript@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSound@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResVocab@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPatch@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResFont@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPal@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResHeap@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMsg@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResAudio@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResWave@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResAudio36@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSync@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSync36@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMap@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMsgTranslation@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileType@ResMsgTranslation@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResRobot@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResVMD@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@NN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SOL_Point@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeEmpty@SOL_Rect@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Xlen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ylen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8SOL_Rect@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeArrayID@@QBEPAUArrayHeader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ArrayID@@QAE@HW4ArrayType@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@ArrayID@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAE?AVMemID@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAEXVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_List@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@SOL_List@@QAEAAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeDispatchTblID@@QBEPAUDispatchTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeScriptEntryID@@QBEPAUScriptEntry@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntry@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeVariableID@@QBEPAUVariable@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Script@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Object@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGraphicsUpdate@Object@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?selectorDict@Object@@QAEPAVSelectorDict@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AObject@@QAEAAFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddr@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedPropAddr@Object@@QAEPBFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedProperty@Object@@QAEFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddrCheck@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@Object@@QAEFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropOffset@Object@@QAEIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetIndexedProperty@Object@@QAEXHF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetProperty@Object@@QAEXGF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssureValid@ObjectID@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsObject@ObjectID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@ObjectID@@QBEFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Name@ObjectID@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeClassTblID@@QBEPAUClassTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DTextID@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TextID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7ResPic@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResView@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResPal@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResHeap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResWave@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResRobot@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResPatch@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMsgTranslation@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResScript@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSync36@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMsg@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResAudio36@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResAudio@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResFont@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7MemoryMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResVMD@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResChunk@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSync@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResVocab@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7MsgMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?msgMgr@@3PAVMsgMgr@@A				; msgMgr
_BSS	SEGMENT
?msgMgr@@3PAVMsgMgr@@A DD 01H DUP (?)			; msgMgr
_?doit@?1??FatalOutput@MsgMgr@@MAEXPAD@Z@4HA DD 01H DUP (?)
_BSS	ENDS
PUBLIC	??0MsgMgr@@QAE@XZ				; MsgMgr::MsgMgr
PUBLIC	?Init@MsgMgr@@UAEXXZ				; MsgMgr::Init
PUBLIC	?Get@MsgMgr@@UAEPADHPAD@Z			; MsgMgr::Get
PUBLIC	?AlertOutput@MsgMgr@@MAEHPAD@Z			; MsgMgr::AlertOutput
PUBLIC	?FatalOutput@MsgMgr@@MAEXPAD@Z			; MsgMgr::FatalOutput
PUBLIC	??_7MsgMgr@@6B@					; MsgMgr::`vftable'
EXTRN	__purecall:NEAR
;	COMDAT ??_7MsgMgr@@6B@
; File \\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Msg.cpp
CONST	SEGMENT
??_7MsgMgr@@6B@ DD FLAT:?Init@MsgMgr@@UAEXXZ		; MsgMgr::`vftable'
	DD	FLAT:?Get@MsgMgr@@UAEPADHPAD@Z
	DD	FLAT:__purecall
	DD	FLAT:?AlertOutput@MsgMgr@@MAEHPAD@Z
	DD	FLAT:?FatalOutput@MsgMgr@@MAEXPAD@Z
	DD	FLAT:__purecall
CONST	ENDS
_DATA	SEGMENT
$SG63141 DB	'Error.dat', 00H
_DATA	ENDS
_TEXT	SEGMENT
_this$ = -4
??0MsgMgr@@QAE@XZ PROC NEAR				; MsgMgr::MsgMgr

; 36   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 80 f0 07 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2032], OFFSET FLAT:$SG63141
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7MsgMgr@@6B@ ; MsgMgr::`vftable'

; 37   : 	*quitStr    = 0;

  0001d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00020	c6 82 ca 10 00
	00 00		 mov	 BYTE PTR [edx+4298], 0

; 38   : 	*fatalStrs  = 0;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c6 80 05 04 00
	00 00		 mov	 BYTE PTR [eax+1029], 0

; 39   : 	*sciFatalStr= 0;

  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	c6 81 cb 14 00
	00 00		 mov	 BYTE PTR [ecx+5323], 0

; 40   : }

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??0MsgMgr@@QAE@XZ ENDP					; MsgMgr::MsgMgr
_TEXT	ENDS
PUBLIC	?Fatal@MsgMgr@@QAAXPADZZ			; MsgMgr::Fatal
PUBLIC	?OpenFile@MsgMgr@@IAEHXZ			; MsgMgr::OpenFile
PUBLIC	?Read@MsgMgr@@IAEPADHPADH@Z			; MsgMgr::Read
EXTRN	?LSeek@@YAJHJH@Z:NEAR				; LSeek
EXTRN	?Close@@YAHH@Z:NEAR				; Close
EXTRN	_strlen:NEAR
_DATA	SEGMENT
	ORG $+2
$SG63147 DB	'Can''t find %s', 00H
_DATA	ENDS
_TEXT	SEGMENT
_this$ = -16
_fd$ = -4
_tmpBuf$ = -12
_i$ = -8
?Init@MsgMgr@@UAEXXZ PROC NEAR				; MsgMgr::Init

; 44   : {

  00042	55		 push	 ebp
  00043	8b ec		 mov	 ebp, esp
  00045	83 ec 10	 sub	 esp, 16			; 00000010H
  00048	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 45   : 	// make sure file can be found and preload messages that can't be loaded
; 46   : 	// later
; 47   : 	
; 48   : 	int fd;
; 49   : 	if ((fd = OpenFile()) == -1)

  0004b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	e8 00 00 00 00	 call	 ?OpenFile@MsgMgr@@IAEHXZ ; MsgMgr::OpenFile
  00053	89 45 fc	 mov	 DWORD PTR _fd$[ebp], eax
  00056	83 7d fc ff	 cmp	 DWORD PTR _fd$[ebp], -1
  0005a	75 1b		 jne	 SHORT $L63146

; 50   : 		Fatal("Can't find %s", fileName);

  0005c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 88 f0 07 00
	00		 mov	 ecx, DWORD PTR [eax+2032]
  00065	51		 push	 ecx
  00066	68 00 00 00 00	 push	 OFFSET FLAT:$SG63147
  0006b	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0006e	52		 push	 edx
  0006f	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH
$L63146:

; 51   : 
; 52   : 	// Pre-load error messages that cannot be loaded later 
; 53   : 	char* tmpBuf = preloadedMsgs;

  00077	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	05 f9 08 00 00	 add	 eax, 2297		; 000008f9H
  0007f	89 45 f4	 mov	 DWORD PTR _tmpBuf$[ebp], eax

; 54   : 	for (int i = 1; i <= Msg_LastPreload; i++){

  00082	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00089	eb 09		 jmp	 SHORT $L63150
$L63151:
  0008b	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0008e	83 c1 01	 add	 ecx, 1
  00091	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
$L63150:
  00094	83 7d f8 18	 cmp	 DWORD PTR _i$[ebp], 24	; 00000018H
  00098	7f 42		 jg	 SHORT $L63152

; 55   : 		if (!Read(i, tmpBuf, fd))

  0009a	8b 55 fc	 mov	 edx, DWORD PTR _fd$[ebp]
  0009d	52		 push	 edx
  0009e	8b 45 f4	 mov	 eax, DWORD PTR _tmpBuf$[ebp]
  000a1	50		 push	 eax
  000a2	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000a5	51		 push	 ecx
  000a6	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	e8 00 00 00 00	 call	 ?Read@MsgMgr@@IAEPADHPADH@Z ; MsgMgr::Read
  000ae	85 c0		 test	 eax, eax
  000b0	75 02		 jne	 SHORT $L63153

; 56   : 			break;

  000b2	eb 28		 jmp	 SHORT $L63152
$L63153:

; 57   : 		tmpBuf += strlen(tmpBuf) + 1;

  000b4	8b 55 f4	 mov	 edx, DWORD PTR _tmpBuf$[ebp]
  000b7	52		 push	 edx
  000b8	e8 00 00 00 00	 call	 _strlen
  000bd	83 c4 04	 add	 esp, 4
  000c0	8b 4d f4	 mov	 ecx, DWORD PTR _tmpBuf$[ebp]
  000c3	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  000c7	89 55 f4	 mov	 DWORD PTR _tmpBuf$[ebp], edx

; 58   : 		LSeek(fd, 0L, SEEK_SET);      // Messages not necessarily in order

  000ca	6a 00		 push	 0
  000cc	6a 00		 push	 0
  000ce	8b 45 fc	 mov	 eax, DWORD PTR _fd$[ebp]
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 ?LSeek@@YAJHJH@Z	; LSeek
  000d7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 59   : 	}

  000da	eb af		 jmp	 SHORT $L63151
$L63152:

; 60   : 	Close(fd);

  000dc	8b 4d fc	 mov	 ecx, DWORD PTR _fd$[ebp]
  000df	51		 push	 ecx
  000e0	e8 00 00 00 00	 call	 ?Close@@YAHH@Z		; Close
  000e5	83 c4 04	 add	 esp, 4

; 61   : }

  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c3		 ret	 0
?Init@MsgMgr@@UAEXXZ ENDP				; MsgMgr::Init
_TEXT	ENDS
PUBLIC	?AddFatalStr@MsgMgr@@QAEXPAD@Z			; MsgMgr::AddFatalStr
EXTRN	_strcat:NEAR
_DATA	SEGMENT
	ORG $+2
$SG63161 DB	0aH, 00H
_DATA	ENDS
_TEXT	SEGMENT
_str$ = 8
_this$ = -8
_roomLeft$ = -4
?AddFatalStr@MsgMgr@@QAEXPAD@Z PROC NEAR		; MsgMgr::AddFatalStr

; 65   : {

  000ec	55		 push	 ebp
  000ed	8b ec		 mov	 ebp, esp
  000ef	83 ec 08	 sub	 esp, 8
  000f2	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 66   : 	int roomLeft = MaxFatalBuf - strlen(fatalStrs);

  000f5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	05 05 04 00 00	 add	 eax, 1029		; 00000405H
  000fd	50		 push	 eax
  000fe	e8 00 00 00 00	 call	 _strlen
  00103	83 c4 04	 add	 esp, 4
  00106	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  0010b	2b c8		 sub	 ecx, eax
  0010d	89 4d fc	 mov	 DWORD PTR _roomLeft$[ebp], ecx

; 67   : 	if (roomLeft) {

  00110	83 7d fc 00	 cmp	 DWORD PTR _roomLeft$[ebp], 0
  00114	74 72		 je	 SHORT $L63163

; 68   : 		if (roomLeft > 1)

  00116	83 7d fc 01	 cmp	 DWORD PTR _roomLeft$[ebp], 1
  0011a	7e 17		 jle	 SHORT $L63160

; 69   : 			strcat(fatalStrs, "\n");

  0011c	68 00 00 00 00	 push	 OFFSET FLAT:$SG63161
  00121	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00124	81 c2 05 04 00
	00		 add	 edx, 1029		; 00000405H
  0012a	52		 push	 edx
  0012b	e8 00 00 00 00	 call	 _strcat
  00130	83 c4 08	 add	 esp, 8
$L63160:

; 70   : 		if (roomLeft < strlen(str) + 1)

  00133	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00136	50		 push	 eax
  00137	e8 00 00 00 00	 call	 _strlen
  0013c	83 c4 04	 add	 esp, 4
  0013f	83 c0 01	 add	 eax, 1
  00142	39 45 fc	 cmp	 DWORD PTR _roomLeft$[ebp], eax
  00145	73 2b		 jae	 SHORT $L63162

; 71   : 			//	fit as much of the string as possible, truncating the beginning
; 72   : 			strcat(fatalStrs, str + strlen(str) - roomLeft + 1);

  00147	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  0014a	51		 push	 ecx
  0014b	e8 00 00 00 00	 call	 _strlen
  00150	83 c4 04	 add	 esp, 4
  00153	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00156	03 d0		 add	 edx, eax
  00158	2b 55 fc	 sub	 edx, DWORD PTR _roomLeft$[ebp]
  0015b	83 c2 01	 add	 edx, 1
  0015e	52		 push	 edx
  0015f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00162	05 05 04 00 00	 add	 eax, 1029		; 00000405H
  00167	50		 push	 eax
  00168	e8 00 00 00 00	 call	 _strcat
  0016d	83 c4 08	 add	 esp, 8

; 73   : 		else

  00170	eb 16		 jmp	 SHORT $L63163
$L63162:

; 74   : 			strcat(fatalStrs, str);

  00172	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00175	51		 push	 ecx
  00176	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00179	81 c2 05 04 00
	00		 add	 edx, 1029		; 00000405H
  0017f	52		 push	 edx
  00180	e8 00 00 00 00	 call	 _strcat
  00185	83 c4 08	 add	 esp, 8
$L63163:

; 76   : }

  00188	8b e5		 mov	 esp, ebp
  0018a	5d		 pop	 ebp
  0018b	c2 04 00	 ret	 4
?AddFatalStr@MsgMgr@@QAEXPAD@Z ENDP			; MsgMgr::AddFatalStr
_TEXT	ENDS
PUBLIC	?AddPMIP@MsgMgr@@QAEXPAD@Z			; MsgMgr::AddPMIP
EXTRN	__imp__sprintf:NEAR
EXTRN	?pm@@3VPMachine@@A:BYTE				; pm
_DATA	SEGMENT
	ORG $+2
$SG63172 DB	0aH, 'script %u, ip 0x%x', 00H
_DATA	ENDS
_TEXT	SEGMENT
_msg$ = 8
_this$ = -4
?AddPMIP@MsgMgr@@QAEXPAD@Z PROC NEAR			; MsgMgr::AddPMIP

; 80   : {

  0018e	55		 push	 ebp
  0018f	8b ec		 mov	 ebp, esp
  00191	51		 push	 ecx
  00192	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 81   : 	if ((int) pm.game) 

  00195	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?pm@@3VPMachine@@A
  0019c	85 c0		 test	 eax, eax
  0019e	74 3d		 je	 SHORT $L63169

; 82   : 		sprintf(msg + strlen(msg), "\nscript %u, ip 0x%x", (ushort)pm.curScriptNum, (ushort)(pm.debugIP - pm.ip) );

  001a0	8b 0d f0 05 00
	00		 mov	 ecx, DWORD PTR ?pm@@3VPMachine@@A+1520
  001a6	2b 0d 38 01 00
	00		 sub	 ecx, DWORD PTR ?pm@@3VPMachine@@A+312
  001ac	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  001b2	51		 push	 ecx
  001b3	33 d2		 xor	 edx, edx
  001b5	66 8b 15 24 00
	00 00		 mov	 dx, WORD PTR ?pm@@3VPMachine@@A+36
  001bc	52		 push	 edx
  001bd	68 00 00 00 00	 push	 OFFSET FLAT:$SG63172
  001c2	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  001c5	50		 push	 eax
  001c6	e8 00 00 00 00	 call	 _strlen
  001cb	83 c4 04	 add	 esp, 4
  001ce	8b 4d 08	 mov	 ecx, DWORD PTR _msg$[ebp]
  001d1	03 c8		 add	 ecx, eax
  001d3	51		 push	 ecx
  001d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  001da	83 c4 10	 add	 esp, 16			; 00000010H
$L63169:

; 83   : }

  001dd	8b e5		 mov	 esp, ebp
  001df	5d		 pop	 ebp
  001e0	c2 04 00	 ret	 4
?AddPMIP@MsgMgr@@QAEXPAD@Z ENDP				; MsgMgr::AddPMIP
_TEXT	ENDS
PUBLIC	?AddSrcLoc@MsgMgr@@IAEXPAD0H@Z			; MsgMgr::AddSrcLoc
_DATA	SEGMENT
$SG63179 DB	0aH, '%s(%d)', 00H
_DATA	ENDS
_TEXT	SEGMENT
_msg$ = 8
_fileName$ = 12
_lineNum$ = 16
_this$ = -4
?AddSrcLoc@MsgMgr@@IAEXPAD0H@Z PROC NEAR		; MsgMgr::AddSrcLoc

; 87   : {

  001e3	55		 push	 ebp
  001e4	8b ec		 mov	 ebp, esp
  001e6	51		 push	 ecx
  001e7	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 88   : 	sprintf(msg + strlen(msg), "\n%s(%d)", fileName, lineNum);

  001ea	8b 45 10	 mov	 eax, DWORD PTR _lineNum$[ebp]
  001ed	50		 push	 eax
  001ee	8b 4d 0c	 mov	 ecx, DWORD PTR _fileName$[ebp]
  001f1	51		 push	 ecx
  001f2	68 00 00 00 00	 push	 OFFSET FLAT:$SG63179
  001f7	8b 55 08	 mov	 edx, DWORD PTR _msg$[ebp]
  001fa	52		 push	 edx
  001fb	e8 00 00 00 00	 call	 _strlen
  00200	83 c4 04	 add	 esp, 4
  00203	8b 4d 08	 mov	 ecx, DWORD PTR _msg$[ebp]
  00206	03 c8		 add	 ecx, eax
  00208	51		 push	 ecx
  00209	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  0020f	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : }

  00212	8b e5		 mov	 esp, ebp
  00214	5d		 pop	 ebp
  00215	c2 0c 00	 ret	 12			; 0000000cH
?AddSrcLoc@MsgMgr@@IAEXPAD0H@Z ENDP			; MsgMgr::AddSrcLoc
_TEXT	ENDS
PUBLIC	?Alert@MsgMgr@@QAAHHZZ				; MsgMgr::Alert
PUBLIC	?Make@MsgMgr@@IAEPADHPAD@Z			; MsgMgr::Make
_TEXT	SEGMENT
_errNum$ = 12
_this$ = 8
_args$ = -8
_cp$ = -4
?Alert@MsgMgr@@QAAHHZZ PROC NEAR			; MsgMgr::Alert

; 93   : {

  00218	55		 push	 ebp
  00219	8b ec		 mov	 ebp, esp
  0021b	83 ec 08	 sub	 esp, 8

; 94   : 	va_list args;
; 95   : 	va_start(args, errNum);

  0021e	8d 45 10	 lea	 eax, DWORD PTR _errNum$[ebp+4]
  00221	89 45 f8	 mov	 DWORD PTR _args$[ebp], eax

; 96   : 	char* cp = Make(errNum, args);

  00224	8b 4d f8	 mov	 ecx, DWORD PTR _args$[ebp]
  00227	51		 push	 ecx
  00228	8b 55 0c	 mov	 edx, DWORD PTR _errNum$[ebp]
  0022b	52		 push	 edx
  0022c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0022f	e8 00 00 00 00	 call	 ?Make@MsgMgr@@IAEPADHPAD@Z ; MsgMgr::Make
  00234	89 45 fc	 mov	 DWORD PTR _cp$[ebp], eax

; 97   : 	va_end(args);

  00237	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _args$[ebp], 0

; 98   : 
; 99   : 	return AlertOutput(cp);

  0023e	8b 45 fc	 mov	 eax, DWORD PTR _cp$[ebp]
  00241	50		 push	 eax
  00242	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00245	8b 11		 mov	 edx, DWORD PTR [ecx]
  00247	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0024a	ff 52 0c	 call	 DWORD PTR [edx+12]

; 100  : }

  0024d	8b e5		 mov	 esp, ebp
  0024f	5d		 pop	 ebp
  00250	c3		 ret	 0
?Alert@MsgMgr@@QAAHHZZ ENDP				; MsgMgr::Alert
_TEXT	ENDS
PUBLIC	?Alert@MsgMgr@@QAAHPADZZ			; MsgMgr::Alert
PUBLIC	?Make@MsgMgr@@IAEPADPAD0@Z			; MsgMgr::Make
_TEXT	SEGMENT
_fmt$ = 12
_this$ = 8
_args$ = -8
_cp$ = -4
?Alert@MsgMgr@@QAAHPADZZ PROC NEAR			; MsgMgr::Alert

; 104  : {

  00251	55		 push	 ebp
  00252	8b ec		 mov	 ebp, esp
  00254	83 ec 08	 sub	 esp, 8

; 105  : 	va_list args;
; 106  : 	va_start(args, fmt);

  00257	8d 45 10	 lea	 eax, DWORD PTR _fmt$[ebp+4]
  0025a	89 45 f8	 mov	 DWORD PTR _args$[ebp], eax

; 107  : 	char* cp = Make(fmt, args);

  0025d	8b 4d f8	 mov	 ecx, DWORD PTR _args$[ebp]
  00260	51		 push	 ecx
  00261	8b 55 0c	 mov	 edx, DWORD PTR _fmt$[ebp]
  00264	52		 push	 edx
  00265	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00268	e8 00 00 00 00	 call	 ?Make@MsgMgr@@IAEPADPAD0@Z ; MsgMgr::Make
  0026d	89 45 fc	 mov	 DWORD PTR _cp$[ebp], eax

; 108  : 	va_end(args);

  00270	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _args$[ebp], 0

; 109  : 	
; 110  : 	return AlertOutput(cp);

  00277	8b 45 fc	 mov	 eax, DWORD PTR _cp$[ebp]
  0027a	50		 push	 eax
  0027b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0027e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00280	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00283	ff 52 0c	 call	 DWORD PTR [edx+12]

; 111  : }

  00286	8b e5		 mov	 esp, ebp
  00288	5d		 pop	 ebp
  00289	c3		 ret	 0
?Alert@MsgMgr@@QAAHPADZZ ENDP				; MsgMgr::Alert
_TEXT	ENDS
PUBLIC	?Alert@MsgMgr@@QAAHDPADHHZZ			; MsgMgr::Alert
PUBLIC	?Make@MsgMgr@@IAEPADPADHH0@Z			; MsgMgr::Make
_TEXT	SEGMENT
_fileName$ = 16
_lineNum$ = 20
_errNum$ = 24
_this$ = 8
_args$ = -8
_cp$ = -4
?Alert@MsgMgr@@QAAHDPADHHZZ PROC NEAR			; MsgMgr::Alert

; 115  : {

  0028a	55		 push	 ebp
  0028b	8b ec		 mov	 ebp, esp
  0028d	83 ec 08	 sub	 esp, 8

; 116  : 	va_list args;
; 117  : 	va_start(args, errNum);

  00290	8d 45 1c	 lea	 eax, DWORD PTR _errNum$[ebp+4]
  00293	89 45 f8	 mov	 DWORD PTR _args$[ebp], eax

; 118  : 	char* cp = Make(fileName, lineNum, errNum, args);

  00296	8b 4d f8	 mov	 ecx, DWORD PTR _args$[ebp]
  00299	51		 push	 ecx
  0029a	8b 55 18	 mov	 edx, DWORD PTR _errNum$[ebp]
  0029d	52		 push	 edx
  0029e	8b 45 14	 mov	 eax, DWORD PTR _lineNum$[ebp]
  002a1	50		 push	 eax
  002a2	8b 4d 10	 mov	 ecx, DWORD PTR _fileName$[ebp]
  002a5	51		 push	 ecx
  002a6	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002a9	e8 00 00 00 00	 call	 ?Make@MsgMgr@@IAEPADPADHH0@Z ; MsgMgr::Make
  002ae	89 45 fc	 mov	 DWORD PTR _cp$[ebp], eax

; 119  : 	va_end(args);

  002b1	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _args$[ebp], 0

; 120  : 	
; 121  : 	return AlertOutput(cp);

  002b8	8b 55 fc	 mov	 edx, DWORD PTR _cp$[ebp]
  002bb	52		 push	 edx
  002bc	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  002bf	8b 10		 mov	 edx, DWORD PTR [eax]
  002c1	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002c4	ff 52 0c	 call	 DWORD PTR [edx+12]

; 122  : }

  002c7	8b e5		 mov	 esp, ebp
  002c9	5d		 pop	 ebp
  002ca	c3		 ret	 0
?Alert@MsgMgr@@QAAHDPADHHZZ ENDP			; MsgMgr::Alert
_TEXT	ENDS
PUBLIC	?Alert@MsgMgr@@QAAHDPADH0ZZ			; MsgMgr::Alert
PUBLIC	?Make@MsgMgr@@IAEPADPADH00@Z			; MsgMgr::Make
_TEXT	SEGMENT
_fileName$ = 16
_lineNum$ = 20
_fmt$ = 24
_this$ = 8
_args$ = -8
_cp$ = -4
?Alert@MsgMgr@@QAAHDPADH0ZZ PROC NEAR			; MsgMgr::Alert

; 126  : {

  002cb	55		 push	 ebp
  002cc	8b ec		 mov	 ebp, esp
  002ce	83 ec 08	 sub	 esp, 8

; 127  : 	va_list args;
; 128  : 	va_start(args, fmt);

  002d1	8d 45 1c	 lea	 eax, DWORD PTR _fmt$[ebp+4]
  002d4	89 45 f8	 mov	 DWORD PTR _args$[ebp], eax

; 129  : 	char* cp = Make(fileName, lineNum, fmt, args);

  002d7	8b 4d f8	 mov	 ecx, DWORD PTR _args$[ebp]
  002da	51		 push	 ecx
  002db	8b 55 18	 mov	 edx, DWORD PTR _fmt$[ebp]
  002de	52		 push	 edx
  002df	8b 45 14	 mov	 eax, DWORD PTR _lineNum$[ebp]
  002e2	50		 push	 eax
  002e3	8b 4d 10	 mov	 ecx, DWORD PTR _fileName$[ebp]
  002e6	51		 push	 ecx
  002e7	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002ea	e8 00 00 00 00	 call	 ?Make@MsgMgr@@IAEPADPADH00@Z ; MsgMgr::Make
  002ef	89 45 fc	 mov	 DWORD PTR _cp$[ebp], eax

; 130  : 	va_end(args);

  002f2	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _args$[ebp], 0

; 131  : 	
; 132  : 	return AlertOutput(cp);

  002f9	8b 55 fc	 mov	 edx, DWORD PTR _cp$[ebp]
  002fc	52		 push	 edx
  002fd	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00300	8b 10		 mov	 edx, DWORD PTR [eax]
  00302	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00305	ff 52 0c	 call	 DWORD PTR [edx+12]

; 133  : }

  00308	8b e5		 mov	 esp, ebp
  0030a	5d		 pop	 ebp
  0030b	c3		 ret	 0
?Alert@MsgMgr@@QAAHDPADH0ZZ ENDP			; MsgMgr::Alert
_TEXT	ENDS
EXTRN	?MsgBox@@YAHPAD0ZZ:NEAR				; MsgBox
_DATA	SEGMENT
$SG63234 DB	'%s', 00H
	ORG $+1
$SG63235 DB	'Alert', 00H
_DATA	ENDS
_TEXT	SEGMENT
_msg$ = 8
_this$ = -4
?AlertOutput@MsgMgr@@MAEHPAD@Z PROC NEAR		; MsgMgr::AlertOutput

; 137  : {

  0030c	55		 push	 ebp
  0030d	8b ec		 mov	 ebp, esp
  0030f	51		 push	 ecx
  00310	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 138  : 	return MsgBox("Alert", "%s", msg);

  00313	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  00316	50		 push	 eax
  00317	68 00 00 00 00	 push	 OFFSET FLAT:$SG63234
  0031c	68 00 00 00 00	 push	 OFFSET FLAT:$SG63235
  00321	e8 00 00 00 00	 call	 ?MsgBox@@YAHPAD0ZZ	; MsgBox
  00326	83 c4 0c	 add	 esp, 12			; 0000000cH

; 139  : }

  00329	8b e5		 mov	 esp, ebp
  0032b	5d		 pop	 ebp
  0032c	c2 04 00	 ret	 4
?AlertOutput@MsgMgr@@MAEHPAD@Z ENDP			; MsgMgr::AlertOutput
_TEXT	ENDS
PUBLIC	?Dump@MsgMgr@@QAAXPADZZ				; MsgMgr::Dump
EXTRN	?Unlink@@YAHPBD@Z:NEAR				; Unlink
EXTRN	__imp__fclose:NEAR
EXTRN	__imp__fopen:NEAR
EXTRN	__imp__vfprintf:NEAR
_BSS	SEGMENT
_?inited@?1??Dump@MsgMgr@@QAAXPADZZ@4HA DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
	ORG $+2
$SG63244 DB	'C:\DUMP', 00H
$SG63246 DB	'at', 00H
	ORG $+1
$SG63247 DB	'C:\DUMP', 00H
_DATA	ENDS
_TEXT	SEGMENT
_fmt$ = 12
_fp$ = -8
_args$ = -4
?Dump@MsgMgr@@QAAXPADZZ PROC NEAR			; MsgMgr::Dump

; 143  : {

  0032f	55		 push	 ebp
  00330	8b ec		 mov	 ebp, esp
  00332	83 ec 08	 sub	 esp, 8

; 144  : 	// dump information to a file
; 145  : 	
; 146  : 	static Bool inited;
; 147  : 	
; 148  : 	if (!inited) {

  00335	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _?inited@?1??Dump@MsgMgr@@QAAXPADZZ@4HA, 0
  0033c	75 17		 jne	 SHORT $L63243

; 149  : 		Unlink("C:\\DUMP");

  0033e	68 00 00 00 00	 push	 OFFSET FLAT:$SG63244
  00343	e8 00 00 00 00	 call	 ?Unlink@@YAHPBD@Z	; Unlink
  00348	83 c4 04	 add	 esp, 4

; 150  : 		inited = True;

  0034b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _?inited@?1??Dump@MsgMgr@@QAAXPADZZ@4HA, 1
$L63243:

; 152  : 	
; 153  : 	FILE* fp = fopen("C:\\DUMP", "at");

  00355	68 00 00 00 00	 push	 OFFSET FLAT:$SG63246
  0035a	68 00 00 00 00	 push	 OFFSET FLAT:$SG63247
  0035f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00365	83 c4 08	 add	 esp, 8
  00368	89 45 f8	 mov	 DWORD PTR _fp$[ebp], eax

; 154  : 	va_list args;
; 155  : 	va_start(args, fmt);

  0036b	8d 45 10	 lea	 eax, DWORD PTR _fmt$[ebp+4]
  0036e	89 45 fc	 mov	 DWORD PTR _args$[ebp], eax

; 156  : 	vfprintf(fp, fmt, args);

  00371	8b 4d fc	 mov	 ecx, DWORD PTR _args$[ebp]
  00374	51		 push	 ecx
  00375	8b 55 0c	 mov	 edx, DWORD PTR _fmt$[ebp]
  00378	52		 push	 edx
  00379	8b 45 f8	 mov	 eax, DWORD PTR _fp$[ebp]
  0037c	50		 push	 eax
  0037d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__vfprintf
  00383	83 c4 0c	 add	 esp, 12			; 0000000cH

; 157  : 	va_end(args);

  00386	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _args$[ebp], 0

; 158  : 	fclose(fp);

  0038d	8b 4d f8	 mov	 ecx, DWORD PTR _fp$[ebp]
  00390	51		 push	 ecx
  00391	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00397	83 c4 04	 add	 esp, 4

; 159  : }

  0039a	8b e5		 mov	 esp, ebp
  0039c	5d		 pop	 ebp
  0039d	c3		 ret	 0
?Dump@MsgMgr@@QAAXPADZZ ENDP				; MsgMgr::Dump
_TEXT	ENDS
PUBLIC	?Fatal@MsgMgr@@QAAXHZZ				; MsgMgr::Fatal
_TEXT	SEGMENT
_errNum$ = 12
_this$ = 8
_args$ = -8
_cp$ = -4
?Fatal@MsgMgr@@QAAXHZZ PROC NEAR			; MsgMgr::Fatal

; 163  : {

  0039e	55		 push	 ebp
  0039f	8b ec		 mov	 ebp, esp
  003a1	83 ec 08	 sub	 esp, 8

; 164  : 	va_list args;
; 165  : 	va_start(args, errNum);

  003a4	8d 45 10	 lea	 eax, DWORD PTR _errNum$[ebp+4]
  003a7	89 45 f8	 mov	 DWORD PTR _args$[ebp], eax

; 166  : 	char* cp = Make(errNum, args);

  003aa	8b 4d f8	 mov	 ecx, DWORD PTR _args$[ebp]
  003ad	51		 push	 ecx
  003ae	8b 55 0c	 mov	 edx, DWORD PTR _errNum$[ebp]
  003b1	52		 push	 edx
  003b2	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  003b5	e8 00 00 00 00	 call	 ?Make@MsgMgr@@IAEPADHPAD@Z ; MsgMgr::Make
  003ba	89 45 fc	 mov	 DWORD PTR _cp$[ebp], eax

; 167  : 	va_end(args);

  003bd	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _args$[ebp], 0

; 168  : 	
; 169  : 	FatalOutput(cp);

  003c4	8b 45 fc	 mov	 eax, DWORD PTR _cp$[ebp]
  003c7	50		 push	 eax
  003c8	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  003cb	8b 11		 mov	 edx, DWORD PTR [ecx]
  003cd	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  003d0	ff 52 10	 call	 DWORD PTR [edx+16]

; 170  : }

  003d3	8b e5		 mov	 esp, ebp
  003d5	5d		 pop	 ebp
  003d6	c3		 ret	 0
?Fatal@MsgMgr@@QAAXHZZ ENDP				; MsgMgr::Fatal
_fmt$ = 12
_this$ = 8
_args$ = -8
_cp$ = -4
?Fatal@MsgMgr@@QAAXPADZZ PROC NEAR			; MsgMgr::Fatal

; 174  : {

  003d7	55		 push	 ebp
  003d8	8b ec		 mov	 ebp, esp
  003da	83 ec 08	 sub	 esp, 8

; 175  : 	va_list args;
; 176  : 	va_start(args, fmt);

  003dd	8d 45 10	 lea	 eax, DWORD PTR _fmt$[ebp+4]
  003e0	89 45 f8	 mov	 DWORD PTR _args$[ebp], eax

; 177  : 	char* cp = Make(fmt, args);

  003e3	8b 4d f8	 mov	 ecx, DWORD PTR _args$[ebp]
  003e6	51		 push	 ecx
  003e7	8b 55 0c	 mov	 edx, DWORD PTR _fmt$[ebp]
  003ea	52		 push	 edx
  003eb	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  003ee	e8 00 00 00 00	 call	 ?Make@MsgMgr@@IAEPADPAD0@Z ; MsgMgr::Make
  003f3	89 45 fc	 mov	 DWORD PTR _cp$[ebp], eax

; 178  : 	va_end(args);

  003f6	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _args$[ebp], 0

; 179  : 
; 180  : 	FatalOutput(cp);

  003fd	8b 45 fc	 mov	 eax, DWORD PTR _cp$[ebp]
  00400	50		 push	 eax
  00401	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00404	8b 11		 mov	 edx, DWORD PTR [ecx]
  00406	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00409	ff 52 10	 call	 DWORD PTR [edx+16]

; 181  : }

  0040c	8b e5		 mov	 esp, ebp
  0040e	5d		 pop	 ebp
  0040f	c3		 ret	 0
?Fatal@MsgMgr@@QAAXPADZZ ENDP				; MsgMgr::Fatal
_TEXT	ENDS
PUBLIC	?Fatal@MsgMgr@@QAAXDPADHHZZ			; MsgMgr::Fatal
_TEXT	SEGMENT
_fileName$ = 16
_lineNum$ = 20
_errNum$ = 24
_this$ = 8
_args$ = -8
_cp$ = -4
?Fatal@MsgMgr@@QAAXDPADHHZZ PROC NEAR			; MsgMgr::Fatal

; 185  : {

  00410	55		 push	 ebp
  00411	8b ec		 mov	 ebp, esp
  00413	83 ec 08	 sub	 esp, 8

; 186  : 	va_list args;
; 187  : 	va_start(args, errNum);

  00416	8d 45 1c	 lea	 eax, DWORD PTR _errNum$[ebp+4]
  00419	89 45 f8	 mov	 DWORD PTR _args$[ebp], eax

; 188  : 	char* cp = Make(fileName, lineNum, errNum, args);

  0041c	8b 4d f8	 mov	 ecx, DWORD PTR _args$[ebp]
  0041f	51		 push	 ecx
  00420	8b 55 18	 mov	 edx, DWORD PTR _errNum$[ebp]
  00423	52		 push	 edx
  00424	8b 45 14	 mov	 eax, DWORD PTR _lineNum$[ebp]
  00427	50		 push	 eax
  00428	8b 4d 10	 mov	 ecx, DWORD PTR _fileName$[ebp]
  0042b	51		 push	 ecx
  0042c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0042f	e8 00 00 00 00	 call	 ?Make@MsgMgr@@IAEPADPADHH0@Z ; MsgMgr::Make
  00434	89 45 fc	 mov	 DWORD PTR _cp$[ebp], eax

; 189  : 	va_end(args);

  00437	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _args$[ebp], 0

; 190  : 	
; 191  : 	FatalOutput(cp);

  0043e	8b 55 fc	 mov	 edx, DWORD PTR _cp$[ebp]
  00441	52		 push	 edx
  00442	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00445	8b 10		 mov	 edx, DWORD PTR [eax]
  00447	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0044a	ff 52 10	 call	 DWORD PTR [edx+16]

; 192  : }

  0044d	8b e5		 mov	 esp, ebp
  0044f	5d		 pop	 ebp
  00450	c3		 ret	 0
?Fatal@MsgMgr@@QAAXDPADHHZZ ENDP			; MsgMgr::Fatal
_TEXT	ENDS
PUBLIC	?Fatal@MsgMgr@@QAAXDPADH0ZZ			; MsgMgr::Fatal
_TEXT	SEGMENT
_fileName$ = 16
_lineNum$ = 20
_fmt$ = 24
_this$ = 8
_args$ = -8
_cp$ = -4
?Fatal@MsgMgr@@QAAXDPADH0ZZ PROC NEAR			; MsgMgr::Fatal

; 196  : {

  00451	55		 push	 ebp
  00452	8b ec		 mov	 ebp, esp
  00454	83 ec 08	 sub	 esp, 8

; 197  : 	va_list args;
; 198  : 	va_start(args, fmt);

  00457	8d 45 1c	 lea	 eax, DWORD PTR _fmt$[ebp+4]
  0045a	89 45 f8	 mov	 DWORD PTR _args$[ebp], eax

; 199  : 	char* cp = Make(fileName, lineNum, fmt, args);

  0045d	8b 4d f8	 mov	 ecx, DWORD PTR _args$[ebp]
  00460	51		 push	 ecx
  00461	8b 55 18	 mov	 edx, DWORD PTR _fmt$[ebp]
  00464	52		 push	 edx
  00465	8b 45 14	 mov	 eax, DWORD PTR _lineNum$[ebp]
  00468	50		 push	 eax
  00469	8b 4d 10	 mov	 ecx, DWORD PTR _fileName$[ebp]
  0046c	51		 push	 ecx
  0046d	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00470	e8 00 00 00 00	 call	 ?Make@MsgMgr@@IAEPADPADH00@Z ; MsgMgr::Make
  00475	89 45 fc	 mov	 DWORD PTR _cp$[ebp], eax

; 200  : 	va_end(args);

  00478	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _args$[ebp], 0

; 201  : 	
; 202  : 	FatalOutput(cp);

  0047f	8b 55 fc	 mov	 edx, DWORD PTR _cp$[ebp]
  00482	52		 push	 edx
  00483	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00486	8b 10		 mov	 edx, DWORD PTR [eax]
  00488	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0048b	ff 52 10	 call	 DWORD PTR [edx+16]

; 203  : }

  0048e	8b e5		 mov	 esp, ebp
  00490	5d		 pop	 ebp
  00491	c3		 ret	 0
?Fatal@MsgMgr@@QAAXDPADH0ZZ ENDP			; MsgMgr::Fatal
_TEXT	ENDS
PUBLIC	?print@@YAXHPADZZ				; print
EXTRN	__imp__write:NEAR
EXTRN	__imp__vsprintf:NEAR
_TEXT	SEGMENT
_fd$ = 8
_format$ = 12
_output$ = -1028
_args$ = -4
?print@@YAXHPADZZ PROC NEAR				; print

; 206  : {

  00492	55		 push	 ebp
  00493	8b ec		 mov	 ebp, esp
  00495	81 ec 04 04 00
	00		 sub	 esp, 1028		; 00000404H

; 207  : 	char output[1024];
; 208  : 
; 209  : 	va_list args;
; 210  : 	va_start ( args, format );

  0049b	8d 45 10	 lea	 eax, DWORD PTR _format$[ebp+4]
  0049e	89 45 fc	 mov	 DWORD PTR _args$[ebp], eax

; 211  : 	vsprintf ( output, format, args );

  004a1	8b 4d fc	 mov	 ecx, DWORD PTR _args$[ebp]
  004a4	51		 push	 ecx
  004a5	8b 55 0c	 mov	 edx, DWORD PTR _format$[ebp]
  004a8	52		 push	 edx
  004a9	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _output$[ebp]
  004af	50		 push	 eax
  004b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__vsprintf
  004b6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 212  : 	va_end ( args );

  004b9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _args$[ebp], 0

; 213  : 	
; 214  : 	write ( fd, output, strlen ( output ) );

  004c0	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _output$[ebp]
  004c6	51		 push	 ecx
  004c7	e8 00 00 00 00	 call	 _strlen
  004cc	83 c4 04	 add	 esp, 4
  004cf	50		 push	 eax
  004d0	8d 95 fc fb ff
	ff		 lea	 edx, DWORD PTR _output$[ebp]
  004d6	52		 push	 edx
  004d7	8b 45 08	 mov	 eax, DWORD PTR _fd$[ebp]
  004da	50		 push	 eax
  004db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__write
  004e1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 215  : }

  004e4	8b e5		 mov	 esp, ebp
  004e6	5d		 pop	 ebp
  004e7	c3		 ret	 0
?print@@YAXHPADZZ ENDP					; print
_TEXT	ENDS
PUBLIC	??BMemID@@QBEGXZ				; MemID::operator unsigned short
PUBLIC	??0ObjectID@@QAE@ABV0@@Z			; ObjectID::ObjectID
PUBLIC	??0ObjectID@@QAE@G@Z				; ObjectID::ObjectID
PUBLIC	?Name@ObjectID@@QBEPBDXZ			; ObjectID::Name
EXTRN	?GetSelectorName@@YAPBDGPAD@Z:NEAR		; GetSelectorName
EXTRN	_strcpy:NEAR
EXTRN	__imp__exit:NEAR
EXTRN	?g_bFatalMessage@@3_NA:BYTE			; g_bFatalMessage
EXTRN	__imp__fprintf:NEAR
EXTRN	?IsPrintable@@YAHPAD@Z:NEAR			; IsPrintable
EXTRN	?pmStackPtr@@3PAGA:DWORD			; pmStackPtr
EXTRN	?pmStackTop@@3PAGA:DWORD			; pmStackTop
EXTRN	__imp__unlink:NEAR
_DATA	SEGMENT
$SG63321 DB	'fatal.log', 00H
	ORG $+2
$SG63323 DB	'at', 00H
	ORG $+1
$SG63324 DB	'fatal.log', 00H
	ORG $+2
$SG63326 DB	'BETA Version 40', 0aH, 0aH, 00H
	ORG $+2
$SG63328 DB	'No send stack.', 0aH, 00H
$SG63342 DB	'$%04x: (', 00H
	ORG $+3
$SG63349 DB	'<noname> ', 00H
	ORG $+2
$SG63351 DB	'%s ', 00H
$SG63355 DB	'%d', 00H
	ORG $+1
$SG63357 DB	'%s', 00H
	ORG $+1
$SG63358 DB	':)', 0aH, 00H
$SG63359 DB	'%s', 00H
	ORG $+1
$SG63360 DB	0aH, '%s', 0aH, 00H
	ORG $+3
$SG63362 DB	'Unable to open fatal logging file.', 00H
	ORG $+1
$SG63363 DB	'Fatal', 00H
	ORG $+2
$SG63365 DB	'Fatal', 00H
_DATA	ENDS
_TEXT	SEGMENT
$T63744 = -1308
_msg$ = 8
_this$ = -1312
_file$ = -1004
_ptr$63330 = -1008
_selector$63335 = -1096
_obj$63337 = -1204
_lineBuf$63340 = -1200
_name$63343 = -1304
_namePtr$63344 = -1012
_select$63352 = -1092
_msgPtr$63353 = -1100
?FatalOutput@MsgMgr@@MAEXPAD@Z PROC NEAR		; MsgMgr::FatalOutput

; 219  : {

  004e8	55		 push	 ebp
  004e9	8b ec		 mov	 ebp, esp
  004eb	81 ec 20 05 00
	00		 sub	 esp, 1312		; 00000520H
  004f1	89 8d e0 fa ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 220  : 	g_bFatalMessage = true;

  004f7	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?g_bFatalMessage@@3_NA, 1 ; g_bFatalMessage

; 221  : 
; 222  : 	static int doit = 0;
; 223  : 
; 224  : 	if ( doit )

  004fe	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _?doit@?1??FatalOutput@MsgMgr@@MAEXPAD@Z@4HA, 0
  00505	74 05		 je	 SHORT $L63320

; 225  : 		return;

  00507	e9 ee 02 00 00	 jmp	 $L63317
$L63320:

; 226  : 
; 227  : 	doit = 1;

  0050c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _?doit@?1??FatalOutput@MsgMgr@@MAEXPAD@Z@4HA, 1

; 228  : 
; 229  : 	AddPMIP(msg);

  00516	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  00519	50		 push	 eax
  0051a	8b 8d e0 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00520	e8 00 00 00 00	 call	 ?AddPMIP@MsgMgr@@QAEXPAD@Z ; MsgMgr::AddPMIP

; 230  : 
; 231  : 	unlink ( "fatal.log" );

  00525	68 00 00 00 00	 push	 OFFSET FLAT:$SG63321
  0052a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__unlink
  00530	83 c4 04	 add	 esp, 4

; 232  : 
; 233  : 	FILE *file = fopen ( "fatal.log", "at" );

  00533	68 00 00 00 00	 push	 OFFSET FLAT:$SG63323
  00538	68 00 00 00 00	 push	 OFFSET FLAT:$SG63324
  0053d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00543	83 c4 08	 add	 esp, 8
  00546	89 85 14 fc ff
	ff		 mov	 DWORD PTR _file$[ebp], eax

; 234  : 
; 235  : 	if ( file ) {

  0054c	83 bd 14 fc ff
	ff 00		 cmp	 DWORD PTR _file$[ebp], 0
  00553	0f 84 73 02 00
	00		 je	 $L63325

; 236  : 		fprintf ( file, "BETA Version 40\n\n" );

  00559	68 00 00 00 00	 push	 OFFSET FLAT:$SG63326
  0055e	8b 8d 14 fc ff
	ff		 mov	 ecx, DWORD PTR _file$[ebp]
  00564	51		 push	 ecx
  00565	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0056b	83 c4 08	 add	 esp, 8

; 237  : 		
; 238  : 		if ( pmStackPtr == pmStackTop ) {

  0056e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?pmStackPtr@@3PAGA ; pmStackPtr
  00574	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?pmStackTop@@3PAGA ; pmStackTop
  0057a	75 1a		 jne	 SHORT $L63327

; 239  : 			fprintf ( file, "No send stack.\n" );

  0057c	68 00 00 00 00	 push	 OFFSET FLAT:$SG63328
  00581	8b 85 14 fc ff
	ff		 mov	 eax, DWORD PTR _file$[ebp]
  00587	50		 push	 eax
  00588	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0058e	83 c4 08	 add	 esp, 8

; 240  : 		} else {

  00591	e9 0b 02 00 00	 jmp	 $L63334
$L63327:

; 241  : 			SCIUWord *ptr = (SCIUWord *)pmStackPtr;

  00596	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pmStackPtr@@3PAGA ; pmStackPtr
  0059c	89 8d 10 fc ff
	ff		 mov	 DWORD PTR _ptr$63330[ebp], ecx

; 242  : 			ptr--;

  005a2	8b 95 10 fc ff
	ff		 mov	 edx, DWORD PTR _ptr$63330[ebp]
  005a8	83 ea 02	 sub	 edx, 2
  005ab	89 95 10 fc ff
	ff		 mov	 DWORD PTR _ptr$63330[ebp], edx
$L63333:

; 243  : 
; 244  : 			while ( ptr > pmStackTop ) {

  005b1	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _ptr$63330[ebp]
  005b7	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?pmStackTop@@3PAGA ; pmStackTop
  005bd	0f 86 de 01 00
	00		 jbe	 $L63334

; 245  : 				Selector selector = (Selector)*ptr;

  005c3	8b 8d 10 fc ff
	ff		 mov	 ecx, DWORD PTR _ptr$63330[ebp]
  005c9	66 8b 11	 mov	 dx, WORD PTR [ecx]
  005cc	66 89 95 b8 fb
	ff ff		 mov	 WORD PTR _selector$63335[ebp], dx

; 246  : 				ptr--;

  005d3	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _ptr$63330[ebp]
  005d9	83 e8 02	 sub	 eax, 2
  005dc	89 85 10 fc ff
	ff		 mov	 DWORD PTR _ptr$63330[ebp], eax

; 247  : 
; 248  : 				ObjectID obj = (ObjectID)*ptr;

  005e2	8b 8d 10 fc ff
	ff		 mov	 ecx, DWORD PTR _ptr$63330[ebp]
  005e8	66 8b 11	 mov	 dx, WORD PTR [ecx]
  005eb	52		 push	 edx
  005ec	8d 8d e4 fa ff
	ff		 lea	 ecx, DWORD PTR $T63744[ebp]
  005f2	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  005f7	50		 push	 eax
  005f8	8d 8d 4c fb ff
	ff		 lea	 ecx, DWORD PTR _obj$63337[ebp]
  005fe	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID

; 249  : 				ptr--;

  00603	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _ptr$63330[ebp]
  00609	83 e8 02	 sub	 eax, 2
  0060c	89 85 10 fc ff
	ff		 mov	 DWORD PTR _ptr$63330[ebp], eax

; 250  : 
; 251  : 				char	lineBuf[100];
; 252  : 				sprintf (lineBuf, "$%04x: (", (int)obj);

  00612	8d 8d 4c fb ff
	ff		 lea	 ecx, DWORD PTR _obj$63337[ebp]
  00618	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  0061d	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00622	50		 push	 eax
  00623	68 00 00 00 00	 push	 OFFSET FLAT:$SG63342
  00628	8d 8d 50 fb ff
	ff		 lea	 ecx, DWORD PTR _lineBuf$63340[ebp]
  0062e	51		 push	 ecx
  0062f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  00635	83 c4 0c	 add	 esp, 12			; 0000000cH

; 253  : 
; 254  : 				char name[100];
; 255  : 				char* namePtr;
; 256  : 				if (*obj.Name()) {

  00638	8d 8d 4c fb ff
	ff		 lea	 ecx, DWORD PTR _obj$63337[ebp]
  0063e	e8 00 00 00 00	 call	 ?Name@ObjectID@@QBEPBDXZ ; ObjectID::Name
  00643	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00646	85 d2		 test	 edx, edx
  00648	74 29		 je	 SHORT $L63345

; 257  : 					strcpy(name, obj.Name());

  0064a	8d 8d 4c fb ff
	ff		 lea	 ecx, DWORD PTR _obj$63337[ebp]
  00650	e8 00 00 00 00	 call	 ?Name@ObjectID@@QBEPBDXZ ; ObjectID::Name
  00655	50		 push	 eax
  00656	8d 85 e8 fa ff
	ff		 lea	 eax, DWORD PTR _name$63343[ebp]
  0065c	50		 push	 eax
  0065d	e8 00 00 00 00	 call	 _strcpy
  00662	83 c4 08	 add	 esp, 8

; 258  : 					namePtr = name;

  00665	8d 8d e8 fa ff
	ff		 lea	 ecx, DWORD PTR _name$63343[ebp]
  0066b	89 8d 0c fc ff
	ff		 mov	 DWORD PTR _namePtr$63344[ebp], ecx

; 259  : 				} else

  00671	eb 0a		 jmp	 SHORT $L63346
$L63345:

; 260  : 					namePtr = 0;

  00673	c7 85 0c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _namePtr$63344[ebp], 0
$L63346:

; 261  : 
; 262  : 				if (!namePtr || !IsPrintable(namePtr))

  0067d	83 bd 0c fc ff
	ff 00		 cmp	 DWORD PTR _namePtr$63344[ebp], 0
  00684	74 13		 je	 SHORT $L63348
  00686	8b 95 0c fc ff
	ff		 mov	 edx, DWORD PTR _namePtr$63344[ebp]
  0068c	52		 push	 edx
  0068d	e8 00 00 00 00	 call	 ?IsPrintable@@YAHPAD@Z	; IsPrintable
  00692	83 c4 04	 add	 esp, 4
  00695	85 c0		 test	 eax, eax
  00697	75 27		 jne	 SHORT $L63347
$L63348:

; 263  : 					sprintf(lineBuf + strlen(lineBuf), "<noname> " );

  00699	68 00 00 00 00	 push	 OFFSET FLAT:$SG63349
  0069e	8d 85 50 fb ff
	ff		 lea	 eax, DWORD PTR _lineBuf$63340[ebp]
  006a4	50		 push	 eax
  006a5	e8 00 00 00 00	 call	 _strlen
  006aa	83 c4 04	 add	 esp, 4
  006ad	8d 8c 05 50 fb
	ff ff		 lea	 ecx, DWORD PTR _lineBuf$63340[ebp+eax]
  006b4	51		 push	 ecx
  006b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  006bb	83 c4 08	 add	 esp, 8

; 264  : 				else

  006be	eb 2c		 jmp	 SHORT $L63350
$L63347:

; 265  : 					sprintf(lineBuf + strlen(lineBuf), "%s ", namePtr );

  006c0	8b 95 0c fc ff
	ff		 mov	 edx, DWORD PTR _namePtr$63344[ebp]
  006c6	52		 push	 edx
  006c7	68 00 00 00 00	 push	 OFFSET FLAT:$SG63351
  006cc	8d 85 50 fb ff
	ff		 lea	 eax, DWORD PTR _lineBuf$63340[ebp]
  006d2	50		 push	 eax
  006d3	e8 00 00 00 00	 call	 _strlen
  006d8	83 c4 04	 add	 esp, 4
  006db	8d 8c 05 50 fb
	ff ff		 lea	 ecx, DWORD PTR _lineBuf$63340[ebp+eax]
  006e2	51		 push	 ecx
  006e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  006e9	83 c4 0c	 add	 esp, 12			; 0000000cH
$L63350:

; 266  : 				char select[80];
; 267  : 				const char* msgPtr = GetSelectorName ( selector, select);

  006ec	8d 95 bc fb ff
	ff		 lea	 edx, DWORD PTR _select$63352[ebp]
  006f2	52		 push	 edx
  006f3	66 8b 85 b8 fb
	ff ff		 mov	 ax, WORD PTR _selector$63335[ebp]
  006fa	50		 push	 eax
  006fb	e8 00 00 00 00	 call	 ?GetSelectorName@@YAPBDGPAD@Z ; GetSelectorName
  00700	83 c4 08	 add	 esp, 8
  00703	89 85 b4 fb ff
	ff		 mov	 DWORD PTR _msgPtr$63353[ebp], eax

; 268  : 				if (!msgPtr)

  00709	83 bd b4 fb ff
	ff 00		 cmp	 DWORD PTR _msgPtr$63353[ebp], 0
  00710	75 2e		 jne	 SHORT $L63354

; 269  : 					sprintf(lineBuf + strlen(lineBuf), "%d", select);

  00712	8d 8d bc fb ff
	ff		 lea	 ecx, DWORD PTR _select$63352[ebp]
  00718	51		 push	 ecx
  00719	68 00 00 00 00	 push	 OFFSET FLAT:$SG63355
  0071e	8d 95 50 fb ff
	ff		 lea	 edx, DWORD PTR _lineBuf$63340[ebp]
  00724	52		 push	 edx
  00725	e8 00 00 00 00	 call	 _strlen
  0072a	83 c4 04	 add	 esp, 4
  0072d	8d 84 05 50 fb
	ff ff		 lea	 eax, DWORD PTR _lineBuf$63340[ebp+eax]
  00734	50		 push	 eax
  00735	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  0073b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 270  : 				else

  0073e	eb 2c		 jmp	 SHORT $L63356
$L63354:

; 271  : 					sprintf(lineBuf + strlen(lineBuf), "%s", msgPtr);

  00740	8b 8d b4 fb ff
	ff		 mov	 ecx, DWORD PTR _msgPtr$63353[ebp]
  00746	51		 push	 ecx
  00747	68 00 00 00 00	 push	 OFFSET FLAT:$SG63357
  0074c	8d 95 50 fb ff
	ff		 lea	 edx, DWORD PTR _lineBuf$63340[ebp]
  00752	52		 push	 edx
  00753	e8 00 00 00 00	 call	 _strlen
  00758	83 c4 04	 add	 esp, 4
  0075b	8d 84 05 50 fb
	ff ff		 lea	 eax, DWORD PTR _lineBuf$63340[ebp+eax]
  00762	50		 push	 eax
  00763	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  00769	83 c4 0c	 add	 esp, 12			; 0000000cH
$L63356:

; 272  : 
; 273  : 				strcat(lineBuf, ":)\n");

  0076c	68 00 00 00 00	 push	 OFFSET FLAT:$SG63358
  00771	8d 8d 50 fb ff
	ff		 lea	 ecx, DWORD PTR _lineBuf$63340[ebp]
  00777	51		 push	 ecx
  00778	e8 00 00 00 00	 call	 _strcat
  0077d	83 c4 08	 add	 esp, 8

; 274  : 
; 275  : 				fprintf ( file, "%s", lineBuf );

  00780	8d 95 50 fb ff
	ff		 lea	 edx, DWORD PTR _lineBuf$63340[ebp]
  00786	52		 push	 edx
  00787	68 00 00 00 00	 push	 OFFSET FLAT:$SG63359
  0078c	8b 85 14 fc ff
	ff		 mov	 eax, DWORD PTR _file$[ebp]
  00792	50		 push	 eax
  00793	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00799	83 c4 0c	 add	 esp, 12			; 0000000cH

; 276  : 			}

  0079c	e9 10 fe ff ff	 jmp	 $L63333
$L63334:

; 278  : 
; 279  : 		fprintf ( file, "\n%s\n", msg );

  007a1	8b 4d 08	 mov	 ecx, DWORD PTR _msg$[ebp]
  007a4	51		 push	 ecx
  007a5	68 00 00 00 00	 push	 OFFSET FLAT:$SG63360
  007aa	8b 95 14 fc ff
	ff		 mov	 edx, DWORD PTR _file$[ebp]
  007b0	52		 push	 edx
  007b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  007b7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 280  : 		fclose ( file );

  007ba	8b 85 14 fc ff
	ff		 mov	 eax, DWORD PTR _file$[ebp]
  007c0	50		 push	 eax
  007c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  007c7	83 c4 04	 add	 esp, 4

; 281  : 	} else {

  007ca	eb 12		 jmp	 SHORT $L63361
$L63325:

; 282  : 		MsgBox ( "Fatal", "Unable to open fatal logging file." );

  007cc	68 00 00 00 00	 push	 OFFSET FLAT:$SG63362
  007d1	68 00 00 00 00	 push	 OFFSET FLAT:$SG63363
  007d6	e8 00 00 00 00	 call	 ?MsgBox@@YAHPAD0ZZ	; MsgBox
  007db	83 c4 08	 add	 esp, 8
$L63361:

; 284  : 
; 285  : #ifdef DEBUG
; 286  : 	if (pm.game)
; 287  :            strcat(msg, "\nEnter-debug Esc-exit");
; 288  :         if ( MsgBox("Fatal", msg) )
; 289  :                 ExitThroughDebug();
; 290  : #else
; 291  : 	char buf[MaxFatalBuf];
; 292  : 	MsgBox("Fatal", msg);

  007de	8b 4d 08	 mov	 ecx, DWORD PTR _msg$[ebp]
  007e1	51		 push	 ecx
  007e2	68 00 00 00 00	 push	 OFFSET FLAT:$SG63365
  007e7	e8 00 00 00 00	 call	 ?MsgBox@@YAHPAD0ZZ	; MsgBox
  007ec	83 c4 08	 add	 esp, 8

; 293  : #endif
; 294  : 
; 295  : 	exit(255);

  007ef	68 ff 00 00 00	 push	 255			; 000000ffH
  007f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
$L63317:

; 296  : }

  007fa	8b e5		 mov	 esp, ebp
  007fc	5d		 pop	 ebp
  007fd	c2 04 00	 ret	 4
?FatalOutput@MsgMgr@@MAEXPAD@Z ENDP			; MsgMgr::FatalOutput
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4
??BMemID@@QBEGXZ PROC NEAR				; MemID::operator unsigned short, COMDAT

; 93   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   : 		return handle;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 00	 mov	 ax, WORD PTR [eax]

; 95   : 	}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??BMemID@@QBEGXZ ENDP					; MemID::operator unsigned short
_TEXT	ENDS
PUBLIC	??0FakeObjectID@@QAE@ABVMemID@@@Z		; FakeObjectID::FakeObjectID
;	COMDAT ??0ObjectID@@QAE@ABV0@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0ObjectID@@QAE@ABV0@@Z PROC NEAR			; ObjectID::ObjectID, COMDAT

; 229  : 	ObjectID(const ObjectID& id) : FakeObjectID((MemID&) id) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0FakeObjectID@@QAE@ABVMemID@@@Z ; FakeObjectID::FakeObjectID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0ObjectID@@QAE@ABV0@@Z ENDP				; ObjectID::ObjectID
_TEXT	ENDS
PUBLIC	??0MemID@@QAE@ABV0@@Z				; MemID::MemID
;	COMDAT ??0FakeObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0FakeObjectID@@QAE@ABVMemID@@@Z PROC NEAR		; FakeObjectID::FakeObjectID, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0FakeObjectID@@QAE@ABVMemID@@@Z ENDP			; FakeObjectID::FakeObjectID
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0MemID@@QAE@ABV0@@Z PROC NEAR				; MemID::MemID, COMDAT

; 19   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  0000d	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00010	66 89 10	 mov	 WORD PTR [eax], dx

; 20   : 	}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0MemID@@QAE@ABV0@@Z ENDP				; MemID::MemID
_TEXT	ENDS
PUBLIC	??0FakeObjectID@@QAE@G@Z			; FakeObjectID::FakeObjectID
;	COMDAT ??0ObjectID@@QAE@G@Z
_TEXT	SEGMENT
_this$ = -4
_h$ = 8
??0ObjectID@@QAE@G@Z PROC NEAR				; ObjectID::ObjectID, COMDAT

; 230  : 	ObjectID(SOL_Handle h) : FakeObjectID(h) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	66 8b 45 08	 mov	 ax, WORD PTR _h$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0FakeObjectID@@QAE@G@Z ; FakeObjectID::FakeObjectID
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0ObjectID@@QAE@G@Z ENDP				; ObjectID::ObjectID
_TEXT	ENDS
PUBLIC	??0MemID@@QAE@G@Z				; MemID::MemID
;	COMDAT ??0FakeObjectID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0FakeObjectID@@QAE@G@Z PROC NEAR			; FakeObjectID::FakeObjectID, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	66 8b 45 08	 mov	 ax, WORD PTR _h$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0FakeObjectID@@QAE@G@Z ENDP				; FakeObjectID::FakeObjectID
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0MemID@@QAE@G@Z PROC NEAR				; MemID::MemID, COMDAT

; 23   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 4d 08	 mov	 cx, WORD PTR _h$[ebp]
  0000e	66 89 08	 mov	 WORD PTR [eax], cx

; 24   : 	}

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??0MemID@@QAE@G@Z ENDP					; MemID::MemID
_TEXT	ENDS
PUBLIC	??_C@_00A@?$AA@					; `string'
PUBLIC	??CFakeObjectID@@QBEPAUObject@@XZ		; FakeObjectID::operator->
PUBLIC	?IsObject@ObjectID@@QBEHXZ			; ObjectID::IsObject
EXTRN	?Name@Object@@QAEPBDXZ:NEAR			; Object::Name
;	COMDAT ??_C@_00A@?$AA@
; File \\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\object.hpp
_BSS	SEGMENT
??_C@_00A@?$AA@ DB 01H DUP (?)				; `string'
_BSS	ENDS
;	COMDAT ?Name@ObjectID@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?Name@ObjectID@@QBEPBDXZ PROC NEAR			; ObjectID::Name, COMDAT

; 306  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 307  : 		//	return object's name, or "" if invalid object
; 308  : 		if (!IsObject())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?IsObject@ObjectID@@QBEHXZ ; ObjectID::IsObject
  0000f	85 c0		 test	 eax, eax
  00011	75 07		 jne	 SHORT $L59414

; 309  : 			return "";

  00013	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
  00018	eb 0f		 jmp	 SHORT $L59413
$L59414:

; 310  : 		return (*this)->Name();

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  00022	8b c8		 mov	 ecx, eax
  00024	e8 00 00 00 00	 call	 ?Name@Object@@QAEPBDXZ	; Object::Name
$L59413:

; 311  : 	}

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?Name@ObjectID@@QBEPBDXZ ENDP				; ObjectID::Name
_TEXT	ENDS
PUBLIC	??DMemID@@QBEPAXXZ				; MemID::operator*
;	COMDAT ??CFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT
_this$ = -4
??CFakeObjectID@@QBEPAUObject@@XZ PROC NEAR		; FakeObjectID::operator->, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??CFakeObjectID@@QBEPAUObject@@XZ ENDP			; FakeObjectID::operator->
_TEXT	ENDS
PUBLIC	?GetAddr@MemoryMgr@@QAEPAXG@Z			; MemoryMgr::GetAddr
EXTRN	_memMgr:DWORD
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT
_this$ = -4
??DMemID@@QBEPAXXZ PROC NEAR				; MemID::operator*, COMDAT

; 98   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 99   : 		return memMgr->GetAddr(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr

; 100  : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??DMemID@@QBEPAXXZ ENDP					; MemID::operator*
_TEXT	ENDS
EXTRN	__descPtrTable:BYTE
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -4
?GetAddr@MemoryMgr@@QAEPAXG@Z PROC NEAR			; MemoryMgr::GetAddr, COMDAT

; 462  : 	inline void* MemoryMgr::GetAddr(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : //		CheckValid(theID);
; 464  : 		return _descPtrTable[(unsigned int)((unsigned short)theID)];

  00007	8b 45 08	 mov	 eax, DWORD PTR _theID$[ebp]
  0000a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0000f	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR __descPtrTable[eax*4]

; 465  : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?GetAddr@MemoryMgr@@QAEPAXG@Z ENDP			; MemoryMgr::GetAddr
_TEXT	ENDS
PUBLIC	?IsValid@MemID@@QBEHXZ				; MemID::IsValid
EXTRN	?GetMemType@MemID@@QBE?AW4MemType@@XZ:NEAR	; MemID::GetMemType
;	COMDAT ?IsObject@ObjectID@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsObject@ObjectID@@QBEHXZ PROC NEAR			; ObjectID::IsObject, COMDAT

; 247  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 248  : 		return IsValid() && GetMemType() == MemObject;

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  00011	85 c0		 test	 eax, eax
  00013	74 16		 je	 SHORT $L63758
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  0001d	83 f8 34	 cmp	 eax, 52			; 00000034H
  00020	75 09		 jne	 SHORT $L63758
  00022	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR -8+[ebp], 1
  00029	eb 07		 jmp	 SHORT $L63759
$L63758:
  0002b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], 0
$L63759:
  00032	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]

; 249  : 	}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?IsObject@ObjectID@@QBEHXZ ENDP				; ObjectID::IsObject
_TEXT	ENDS
PUBLIC	?IsValid@MemoryMgr@@QAEHG@Z			; MemoryMgr::IsValid
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsValid@MemID@@QBEHXZ PROC NEAR			; MemID::IsValid, COMDAT

; 62   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 63   : 		return memMgr->IsValid(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?IsValid@MemoryMgr@@QAEHG@Z ; MemoryMgr::IsValid

; 64   : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?IsValid@MemID@@QBEHXZ ENDP				; MemID::IsValid
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -8
_tempID$ = -4
?IsValid@MemoryMgr@@QAEHG@Z PROC NEAR			; MemoryMgr::IsValid, COMDAT

; 475  : 	inline Bool MemoryMgr::IsValid(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 476  : 		unsigned short tempID = (unsigned short)theID;

  00009	66 8b 45 08	 mov	 ax, WORD PTR _theID$[ebp]
  0000d	66 89 45 fc	 mov	 WORD PTR _tempID$[ebp], ax

; 477  : 
; 478  : 		return(
; 479  : 				(tempID)															&&
; 480  : 				(tempID < maxDescriptors)									&&
; 481  : 				(desc[tempID].memInfo.bits.freeDescriptor == False)	&&
; 482  : 				(desc[tempID].memInfo.bits.freeMemory == False)
; 483  : 				);

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _tempID$[ebp]
  00014	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 58		 je	 SHORT $L63762
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _tempID$[ebp]
  00021	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  0002d	73 47		 jae	 SHORT $L63762
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _tempID$[ebp]
  00032	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00038	c1 e1 04	 shl	 ecx, 4
  0003b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00041	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00044	c1 e1 0e	 shl	 ecx, 14			; 0000000eH
  00047	c1 f9 1f	 sar	 ecx, 31			; 0000001fH
  0004a	85 c9		 test	 ecx, ecx
  0004c	75 28		 jne	 SHORT $L63762
  0004e	8b 55 fc	 mov	 edx, DWORD PTR _tempID$[ebp]
  00051	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00057	c1 e2 04	 shl	 edx, 4
  0005a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00060	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00063	c1 e2 14	 shl	 edx, 20			; 00000014H
  00066	c1 fa 1f	 sar	 edx, 31			; 0000001fH
  00069	85 d2		 test	 edx, edx
  0006b	75 09		 jne	 SHORT $L63762
  0006d	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR -12+[ebp], 1
  00074	eb 07		 jmp	 SHORT $L63763
$L63762:
  00076	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR -12+[ebp], 0
$L63763:
  0007d	8b 45 f4	 mov	 eax, DWORD PTR -12+[ebp]

; 484  : 	}

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 04 00	 ret	 4
?IsValid@MemoryMgr@@QAEHG@Z ENDP			; MemoryMgr::IsValid
_TEXT	ENDS
_DATA	SEGMENT
	ORG $+2
$SG63384 DB	'Error #%d not found in file %s', 00H
_DATA	ENDS
_TEXT	SEGMENT
_errNum$ = 8
_textBuf$ = 12
_this$ = -16
_tmpBuf$63372 = -4
_j$63373 = -8
_fd$63381 = -12
?Get@MsgMgr@@UAEPADHPAD@Z PROC NEAR			; MsgMgr::Get

; 300  : {

  00800	55		 push	 ebp
  00801	8b ec		 mov	 ebp, esp
  00803	83 ec 10	 sub	 esp, 16			; 00000010H
  00806	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 301  : 	*textBuf = 0;

  00809	8b 45 0c	 mov	 eax, DWORD PTR _textBuf$[ebp]
  0080c	c6 00 00	 mov	 BYTE PTR [eax], 0

; 302  : 
; 303  : 	if (errNum <= Msg_LastPreload) {

  0080f	83 7d 08 18	 cmp	 DWORD PTR _errNum$[ebp], 24 ; 00000018H
  00813	7f 4f		 jg	 SHORT $L63371

; 304  : 		char* tmpBuf = preloadedMsgs;

  00815	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00818	81 c1 f9 08 00
	00		 add	 ecx, 2297		; 000008f9H
  0081e	89 4d fc	 mov	 DWORD PTR _tmpBuf$63372[ebp], ecx

; 305  : 		for (int j = 1; j < errNum; j++)

  00821	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _j$63373[ebp], 1
  00828	eb 09		 jmp	 SHORT $L63374
$L63375:
  0082a	8b 55 f8	 mov	 edx, DWORD PTR _j$63373[ebp]
  0082d	83 c2 01	 add	 edx, 1
  00830	89 55 f8	 mov	 DWORD PTR _j$63373[ebp], edx
$L63374:
  00833	8b 45 f8	 mov	 eax, DWORD PTR _j$63373[ebp]
  00836	3b 45 08	 cmp	 eax, DWORD PTR _errNum$[ebp]
  00839	7d 17		 jge	 SHORT $L63376
$L63378:

; 306  : 			while (*tmpBuf++)

  0083b	8b 4d fc	 mov	 ecx, DWORD PTR _tmpBuf$63372[ebp]
  0083e	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00841	8b 45 fc	 mov	 eax, DWORD PTR _tmpBuf$63372[ebp]
  00844	83 c0 01	 add	 eax, 1
  00847	89 45 fc	 mov	 DWORD PTR _tmpBuf$63372[ebp], eax
  0084a	85 d2		 test	 edx, edx
  0084c	74 02		 je	 SHORT $L63379

; 307  : 				;

  0084e	eb eb		 jmp	 SHORT $L63378
$L63379:
  00850	eb d8		 jmp	 SHORT $L63375
$L63376:

; 308  : 		strcpy(textBuf, tmpBuf);

  00852	8b 4d fc	 mov	 ecx, DWORD PTR _tmpBuf$63372[ebp]
  00855	51		 push	 ecx
  00856	8b 55 0c	 mov	 edx, DWORD PTR _textBuf$[ebp]
  00859	52		 push	 edx
  0085a	e8 00 00 00 00	 call	 _strcpy
  0085f	83 c4 08	 add	 esp, 8

; 309  : 
; 310  : 	} else {

  00862	eb 54		 jmp	 SHORT $L63382
$L63371:

; 311  : 		int fd;
; 312  : 		if ((fd = OpenFile()) != -1) {

  00864	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00867	e8 00 00 00 00	 call	 ?OpenFile@MsgMgr@@IAEHXZ ; MsgMgr::OpenFile
  0086c	89 45 f4	 mov	 DWORD PTR _fd$63381[ebp], eax
  0086f	83 7d f4 ff	 cmp	 DWORD PTR _fd$63381[ebp], -1
  00873	74 43		 je	 SHORT $L63382

; 313  : 			if (!Read(errNum, textBuf, fd))

  00875	8b 45 f4	 mov	 eax, DWORD PTR _fd$63381[ebp]
  00878	50		 push	 eax
  00879	8b 4d 0c	 mov	 ecx, DWORD PTR _textBuf$[ebp]
  0087c	51		 push	 ecx
  0087d	8b 55 08	 mov	 edx, DWORD PTR _errNum$[ebp]
  00880	52		 push	 edx
  00881	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00884	e8 00 00 00 00	 call	 ?Read@MsgMgr@@IAEPADHPADH@Z ; MsgMgr::Read
  00889	85 c0		 test	 eax, eax
  0088b	75 1f		 jne	 SHORT $L63383

; 315  : 					fullFileName);

  0088d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00890	05 f4 07 00 00	 add	 eax, 2036		; 000007f4H
  00895	50		 push	 eax
  00896	8b 4d 08	 mov	 ecx, DWORD PTR _errNum$[ebp]
  00899	51		 push	 ecx
  0089a	68 00 00 00 00	 push	 OFFSET FLAT:$SG63384
  0089f	8b 55 0c	 mov	 edx, DWORD PTR _textBuf$[ebp]
  008a2	52		 push	 edx
  008a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  008a9	83 c4 10	 add	 esp, 16			; 00000010H
$L63383:

; 316  : 			Close(fd);

  008ac	8b 45 f4	 mov	 eax, DWORD PTR _fd$63381[ebp]
  008af	50		 push	 eax
  008b0	e8 00 00 00 00	 call	 ?Close@@YAHH@Z		; Close
  008b5	83 c4 04	 add	 esp, 4
$L63382:

; 319  : 
; 320  : 	return textBuf;

  008b8	8b 45 0c	 mov	 eax, DWORD PTR _textBuf$[ebp]

; 321  : }

  008bb	8b e5		 mov	 esp, ebp
  008bd	5d		 pop	 ebp
  008be	c2 08 00	 ret	 8
?Get@MsgMgr@@UAEPADHPAD@Z ENDP				; MsgMgr::Get
_TEXT	ENDS
_DATA	SEGMENT
	ORG $+1
$SG63392 DB	'Error %d: ', 00H
_DATA	ENDS
_TEXT	SEGMENT
_fileName$ = 8
_lineNum$ = 12
_errNum$ = 16
_args$ = 20
_this$ = -1032
_msg$ = -1028
?Make@MsgMgr@@IAEPADPADHH0@Z PROC NEAR			; MsgMgr::Make

; 325  : {

  008c1	55		 push	 ebp
  008c2	8b ec		 mov	 ebp, esp
  008c4	81 ec 08 04 00
	00		 sub	 esp, 1032		; 00000408H
  008ca	89 8d f8 fb ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 326  : 	*buf = 0;

  008d0	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  008d6	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 327  : #ifndef DEBUG
; 328  : 	sprintf(buf, "Error %d: ", errNum);

  008da	8b 4d 10	 mov	 ecx, DWORD PTR _errNum$[ebp]
  008dd	51		 push	 ecx
  008de	68 00 00 00 00	 push	 OFFSET FLAT:$SG63392
  008e3	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  008e9	83 c2 04	 add	 edx, 4
  008ec	52		 push	 edx
  008ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  008f3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 329  : #endif
; 330  : 	char msg[MaxStr + 1];
; 331  : 	vsprintf(buf + strlen(buf), Get(errNum, msg), args);

  008f6	8b 45 14	 mov	 eax, DWORD PTR _args$[ebp]
  008f9	50		 push	 eax
  008fa	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _msg$[ebp]
  00900	51		 push	 ecx
  00901	8b 55 10	 mov	 edx, DWORD PTR _errNum$[ebp]
  00904	52		 push	 edx
  00905	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0090b	8b 10		 mov	 edx, DWORD PTR [eax]
  0090d	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00913	ff 52 04	 call	 DWORD PTR [edx+4]
  00916	50		 push	 eax
  00917	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0091d	83 c0 04	 add	 eax, 4
  00920	50		 push	 eax
  00921	e8 00 00 00 00	 call	 _strlen
  00926	83 c4 04	 add	 esp, 4
  00929	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0092f	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00933	52		 push	 edx
  00934	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__vsprintf
  0093a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 332  : 	AddSrcLoc(buf, fileName, lineNum);

  0093d	8b 45 0c	 mov	 eax, DWORD PTR _lineNum$[ebp]
  00940	50		 push	 eax
  00941	8b 4d 08	 mov	 ecx, DWORD PTR _fileName$[ebp]
  00944	51		 push	 ecx
  00945	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0094b	83 c2 04	 add	 edx, 4
  0094e	52		 push	 edx
  0094f	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00955	e8 00 00 00 00	 call	 ?AddSrcLoc@MsgMgr@@IAEXPAD0H@Z ; MsgMgr::AddSrcLoc

; 333  : 	return buf;

  0095a	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00960	83 c0 04	 add	 eax, 4

; 334  : }

  00963	8b e5		 mov	 esp, ebp
  00965	5d		 pop	 ebp
  00966	c2 10 00	 ret	 16			; 00000010H
?Make@MsgMgr@@IAEPADPADHH0@Z ENDP			; MsgMgr::Make
_TEXT	ENDS
_DATA	SEGMENT
	ORG $+1
$SG63399 DB	'Error %d: ', 00H
_DATA	ENDS
_TEXT	SEGMENT
_errNum$ = 8
_args$ = 12
_this$ = -1032
_msg$ = -1028
?Make@MsgMgr@@IAEPADHPAD@Z PROC NEAR			; MsgMgr::Make

; 338  : {

  00969	55		 push	 ebp
  0096a	8b ec		 mov	 ebp, esp
  0096c	81 ec 08 04 00
	00		 sub	 esp, 1032		; 00000408H
  00972	89 8d f8 fb ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 339  : 	*buf = 0;

  00978	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0097e	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 340  : #ifndef DEBUG
; 341  : 	sprintf(buf, "Error %d: ", errNum);

  00982	8b 4d 08	 mov	 ecx, DWORD PTR _errNum$[ebp]
  00985	51		 push	 ecx
  00986	68 00 00 00 00	 push	 OFFSET FLAT:$SG63399
  0098b	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00991	83 c2 04	 add	 edx, 4
  00994	52		 push	 edx
  00995	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  0099b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 342  : #endif
; 343  : 	char msg[MaxStr + 1];
; 344  : 	vsprintf(buf + strlen(buf), Get(errNum, msg), args);

  0099e	8b 45 0c	 mov	 eax, DWORD PTR _args$[ebp]
  009a1	50		 push	 eax
  009a2	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _msg$[ebp]
  009a8	51		 push	 ecx
  009a9	8b 55 08	 mov	 edx, DWORD PTR _errNum$[ebp]
  009ac	52		 push	 edx
  009ad	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  009b3	8b 10		 mov	 edx, DWORD PTR [eax]
  009b5	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  009bb	ff 52 04	 call	 DWORD PTR [edx+4]
  009be	50		 push	 eax
  009bf	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  009c5	83 c0 04	 add	 eax, 4
  009c8	50		 push	 eax
  009c9	e8 00 00 00 00	 call	 _strlen
  009ce	83 c4 04	 add	 esp, 4
  009d1	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  009d7	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  009db	52		 push	 edx
  009dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__vsprintf
  009e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 345  : 	return buf;

  009e5	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  009eb	83 c0 04	 add	 eax, 4

; 346  : }

  009ee	8b e5		 mov	 esp, ebp
  009f0	5d		 pop	 ebp
  009f1	c2 08 00	 ret	 8
?Make@MsgMgr@@IAEPADHPAD@Z ENDP				; MsgMgr::Make
_fileName$ = 8
_lineNum$ = 12
_fmt$ = 16
_args$ = 20
_this$ = -4
?Make@MsgMgr@@IAEPADPADH00@Z PROC NEAR			; MsgMgr::Make

; 350  : {

  009f4	55		 push	 ebp
  009f5	8b ec		 mov	 ebp, esp
  009f7	51		 push	 ecx
  009f8	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 351  : 	vsprintf(buf, fmt, args);

  009fb	8b 45 14	 mov	 eax, DWORD PTR _args$[ebp]
  009fe	50		 push	 eax
  009ff	8b 4d 10	 mov	 ecx, DWORD PTR _fmt$[ebp]
  00a02	51		 push	 ecx
  00a03	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00a06	83 c2 04	 add	 edx, 4
  00a09	52		 push	 edx
  00a0a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__vsprintf
  00a10	83 c4 0c	 add	 esp, 12			; 0000000cH

; 352  : 	AddSrcLoc(buf, fileName, lineNum);

  00a13	8b 45 0c	 mov	 eax, DWORD PTR _lineNum$[ebp]
  00a16	50		 push	 eax
  00a17	8b 4d 08	 mov	 ecx, DWORD PTR _fileName$[ebp]
  00a1a	51		 push	 ecx
  00a1b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00a1e	83 c2 04	 add	 edx, 4
  00a21	52		 push	 edx
  00a22	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a25	e8 00 00 00 00	 call	 ?AddSrcLoc@MsgMgr@@IAEXPAD0H@Z ; MsgMgr::AddSrcLoc

; 353  : 	return buf;

  00a2a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a2d	83 c0 04	 add	 eax, 4

; 354  : }

  00a30	8b e5		 mov	 esp, ebp
  00a32	5d		 pop	 ebp
  00a33	c2 10 00	 ret	 16			; 00000010H
?Make@MsgMgr@@IAEPADPADH00@Z ENDP			; MsgMgr::Make
_fmt$ = 8
_args$ = 12
_this$ = -4
?Make@MsgMgr@@IAEPADPAD0@Z PROC NEAR			; MsgMgr::Make

; 358  : {

  00a36	55		 push	 ebp
  00a37	8b ec		 mov	 ebp, esp
  00a39	51		 push	 ecx
  00a3a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 359  : 	vsprintf(buf, fmt, args);

  00a3d	8b 45 0c	 mov	 eax, DWORD PTR _args$[ebp]
  00a40	50		 push	 eax
  00a41	8b 4d 08	 mov	 ecx, DWORD PTR _fmt$[ebp]
  00a44	51		 push	 ecx
  00a45	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00a48	83 c2 04	 add	 edx, 4
  00a4b	52		 push	 edx
  00a4c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__vsprintf
  00a52	83 c4 0c	 add	 esp, 12			; 0000000cH

; 360  : 	return buf;

  00a55	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a58	83 c0 04	 add	 eax, 4

; 361  : }

  00a5b	8b e5		 mov	 esp, ebp
  00a5d	5d		 pop	 ebp
  00a5e	c2 08 00	 ret	 8
?Make@MsgMgr@@IAEPADPAD0@Z ENDP				; MsgMgr::Make
_TEXT	ENDS
PUBLIC	?Mono@MsgMgr@@QAAXPADZZ				; MsgMgr::Mono
PUBLIC	?MonoArgs@MsgMgr@@QAEXPAD0@Z			; MsgMgr::MonoArgs
_TEXT	SEGMENT
_fmt$ = 12
_this$ = 8
_args$ = -4
?Mono@MsgMgr@@QAAXPADZZ PROC NEAR			; MsgMgr::Mono

; 365  : {

  00a61	55		 push	 ebp
  00a62	8b ec		 mov	 ebp, esp
  00a64	51		 push	 ecx

; 366  : //#ifdef DEBUG
; 367  : 	va_list args;
; 368  : 	va_start(args, fmt);

  00a65	8d 45 10	 lea	 eax, DWORD PTR _fmt$[ebp+4]
  00a68	89 45 fc	 mov	 DWORD PTR _args$[ebp], eax

; 369  : 	MonoArgs(fmt, args);

  00a6b	8b 4d fc	 mov	 ecx, DWORD PTR _args$[ebp]
  00a6e	51		 push	 ecx
  00a6f	8b 55 0c	 mov	 edx, DWORD PTR _fmt$[ebp]
  00a72	52		 push	 edx
  00a73	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00a76	e8 00 00 00 00	 call	 ?MonoArgs@MsgMgr@@QAEXPAD0@Z ; MsgMgr::MonoArgs

; 370  : //#endif
; 371  : }

  00a7b	8b e5		 mov	 esp, ebp
  00a7d	5d		 pop	 ebp
  00a7e	c3		 ret	 0
?Mono@MsgMgr@@QAAXPADZZ ENDP				; MsgMgr::Mono
_fmt$ = 8
_args$ = 12
_this$ = -4
?MonoArgs@MsgMgr@@QAEXPAD0@Z PROC NEAR			; MsgMgr::MonoArgs

; 375  : {

  00a7f	55		 push	 ebp
  00a80	8b ec		 mov	 ebp, esp
  00a82	51		 push	 ecx
  00a83	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 376  : 	vsprintf(buf, fmt, args);

  00a86	8b 45 0c	 mov	 eax, DWORD PTR _args$[ebp]
  00a89	50		 push	 eax
  00a8a	8b 4d 08	 mov	 ecx, DWORD PTR _fmt$[ebp]
  00a8d	51		 push	 ecx
  00a8e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00a91	83 c2 04	 add	 edx, 4
  00a94	52		 push	 edx
  00a95	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__vsprintf
  00a9b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 377  : 	MonoOutput(buf);

  00a9e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00aa1	83 c0 04	 add	 eax, 4
  00aa4	50		 push	 eax
  00aa5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00aa8	8b 11		 mov	 edx, DWORD PTR [ecx]
  00aaa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00aad	ff 52 14	 call	 DWORD PTR [edx+20]

; 378  : }

  00ab0	8b e5		 mov	 esp, ebp
  00ab2	5d		 pop	 ebp
  00ab3	c2 08 00	 ret	 8
?MonoArgs@MsgMgr@@QAEXPAD0@Z ENDP			; MsgMgr::MonoArgs
_TEXT	ENDS
PUBLIC	?MonoPause@MsgMgr@@QAAXPADZZ			; MsgMgr::MonoPause
EXTRN	??0SOL_Event@@QAE@ABV0@@Z:NEAR			; SOL_Event::SOL_Event
EXTRN	?eventMgr@@3PAUEventMgr@@A:DWORD		; eventMgr
_TEXT	SEGMENT
$T63772 = -84
_fmt$ = 12
_this$ = 8
_args$ = -4
_event$63437 = -44
?MonoPause@MsgMgr@@QAAXPADZZ PROC NEAR			; MsgMgr::MonoPause

; 382  : {

  00ab6	55		 push	 ebp
  00ab7	8b ec		 mov	 ebp, esp
  00ab9	83 ec 54	 sub	 esp, 84			; 00000054H

; 383  : 	va_list args;
; 384  : 	va_start(args, fmt);

  00abc	8d 45 10	 lea	 eax, DWORD PTR _fmt$[ebp+4]
  00abf	89 45 fc	 mov	 DWORD PTR _args$[ebp], eax

; 385  : 	MonoArgs(fmt, args);

  00ac2	8b 4d fc	 mov	 ecx, DWORD PTR _args$[ebp]
  00ac5	51		 push	 ecx
  00ac6	8b 55 0c	 mov	 edx, DWORD PTR _fmt$[ebp]
  00ac9	52		 push	 edx
  00aca	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00acd	e8 00 00 00 00	 call	 ?MonoArgs@MsgMgr@@QAEXPAD0@Z ; MsgMgr::MonoArgs

; 386  : 	if (eventMgr) {

  00ad2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?eventMgr@@3PAUEventMgr@@A, 0 ; eventMgr
  00ad9	74 2e		 je	 SHORT $L63439

; 387  : 		SOL_Event event = eventMgr->Wait();

  00adb	6a 04		 push	 4
  00add	8d 45 ac	 lea	 eax, DWORD PTR $T63772[ebp]
  00ae0	50		 push	 eax
  00ae1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?eventMgr@@3PAUEventMgr@@A ; eventMgr
  00ae7	8b 11		 mov	 edx, DWORD PTR [ecx]
  00ae9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?eventMgr@@3PAUEventMgr@@A ; eventMgr
  00aef	ff 52 28	 call	 DWORD PTR [edx+40]
  00af2	50		 push	 eax
  00af3	8d 4d d4	 lea	 ecx, DWORD PTR _event$63437[ebp]
  00af6	e8 00 00 00 00	 call	 ??0SOL_Event@@QAE@ABV0@@Z ; SOL_Event::SOL_Event

; 388  : 		if (event.message == Kbd::Esc)

  00afb	83 7d d8 1b	 cmp	 DWORD PTR _event$63437[ebp+4], 27 ; 0000001bH
  00aff	75 08		 jne	 SHORT $L63439

; 389  : 			exit(2);

  00b01	6a 02		 push	 2
  00b03	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
$L63439:
$L63431:

; 391  : }

  00b09	8b e5		 mov	 esp, ebp
  00b0b	5d		 pop	 ebp
  00b0c	c3		 ret	 0
?MonoPause@MsgMgr@@QAAXPADZZ ENDP			; MsgMgr::MonoPause
_TEXT	ENDS
PUBLIC	?MonoStr@MsgMgr@@QAEXPAD@Z			; MsgMgr::MonoStr
_TEXT	SEGMENT
_str$ = 8
_this$ = -4
?MonoStr@MsgMgr@@QAEXPAD@Z PROC NEAR			; MsgMgr::MonoStr

; 395  : {

  00b0d	55		 push	 ebp
  00b0e	8b ec		 mov	 ebp, esp
  00b10	51		 push	 ecx
  00b11	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 396  : //#ifdef DEBUG
; 397  : 	MonoOutput(str);

  00b14	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00b17	50		 push	 eax
  00b18	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b1b	8b 11		 mov	 edx, DWORD PTR [ecx]
  00b1d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b20	ff 52 14	 call	 DWORD PTR [edx+20]

; 398  : //#endif
; 399  : }

  00b23	8b e5		 mov	 esp, ebp
  00b25	5d		 pop	 ebp
  00b26	c2 04 00	 ret	 4
?MonoStr@MsgMgr@@QAEXPAD@Z ENDP				; MsgMgr::MonoStr
_TEXT	ENDS
EXTRN	?OpenFileInPath@@YAHPADI0@Z:NEAR		; OpenFileInPath
_TEXT	SEGMENT
_this$ = -4
?OpenFile@MsgMgr@@IAEHXZ PROC NEAR			; MsgMgr::OpenFile

; 403  : {

  00b29	55		 push	 ebp
  00b2a	8b ec		 mov	 ebp, esp
  00b2c	51		 push	 ecx
  00b2d	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 404  : 	return OpenFileInPath(fileName, O_TEXT, fullFileName);

  00b30	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b33	05 f4 07 00 00	 add	 eax, 2036		; 000007f4H
  00b38	50		 push	 eax
  00b39	68 00 40 00 00	 push	 16384			; 00004000H
  00b3e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b41	8b 91 f0 07 00
	00		 mov	 edx, DWORD PTR [ecx+2032]
  00b47	52		 push	 edx
  00b48	e8 00 00 00 00	 call	 ?OpenFileInPath@@YAHPADI0@Z ; OpenFileInPath
  00b4d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 405  : }

  00b50	8b e5		 mov	 esp, ebp
  00b52	5d		 pop	 ebp
  00b53	c3		 ret	 0
?OpenFile@MsgMgr@@IAEHXZ ENDP				; MsgMgr::OpenFile
_TEXT	ENDS
EXTRN	?Read@@YAHHPAXH@Z:NEAR				; Read
EXTRN	__imp__strncmp:NEAR
_DATA	SEGMENT
	ORG $+1
$SG63463 DB	'\\', 00H
	ORG $+1
$SG63481 DB	'\\', 00H
_DATA	ENDS
_TEXT	SEGMENT
_errNum$ = 8
_textBuf$ = 12
_msgfile$ = 16
_this$ = -2024
_num$ = -2020
_fileBuf$ = -2004
_filePtr$ = -4
_linePtr$ = -2016
_textPtr$ = -2008
_count$ = -2012
?Read@MsgMgr@@IAEPADHPADH@Z PROC NEAR			; MsgMgr::Read

; 409  : {

  00b54	55		 push	 ebp
  00b55	8b ec		 mov	 ebp, esp
  00b57	81 ec e8 07 00
	00		 sub	 esp, 2024		; 000007e8H
  00b5d	89 8d 18 f8 ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 410  : 	int   num;
; 411  : 	char  fileBuf[2000];
; 412  : 	char*	filePtr = fileBuf;

  00b63	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _fileBuf$[ebp]
  00b69	89 45 fc	 mov	 DWORD PTR _filePtr$[ebp], eax

; 413  : 	char*	linePtr = fileBuf;

  00b6c	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _fileBuf$[ebp]
  00b72	89 8d 20 f8 ff
	ff		 mov	 DWORD PTR _linePtr$[ebp], ecx

; 414  : 	char*	textPtr = textBuf;

  00b78	8b 55 0c	 mov	 edx, DWORD PTR _textBuf$[ebp]
  00b7b	89 95 28 f8 ff
	ff		 mov	 DWORD PTR _textPtr$[ebp], edx

; 415  : 	int   count;
; 416  : 	
; 417  : 	*textPtr = 0;

  00b81	8b 85 28 f8 ff
	ff		 mov	 eax, DWORD PTR _textPtr$[ebp]
  00b87	c6 00 00	 mov	 BYTE PTR [eax], 0

; 418  : 	count = ::Read(msgfile, fileBuf, sizeof fileBuf);

  00b8a	68 d0 07 00 00	 push	 2000			; 000007d0H
  00b8f	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _fileBuf$[ebp]
  00b95	51		 push	 ecx
  00b96	8b 55 10	 mov	 edx, DWORD PTR _msgfile$[ebp]
  00b99	52		 push	 edx
  00b9a	e8 00 00 00 00	 call	 ?Read@@YAHHPAXH@Z	; Read
  00b9f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00ba2	89 85 24 f8 ff
	ff		 mov	 DWORD PTR _count$[ebp], eax
$L63460:

; 419  : 	while (count) {

  00ba8	83 bd 24 f8 ff
	ff 00		 cmp	 DWORD PTR _count$[ebp], 0
  00baf	0f 84 5b 02 00
	00		 je	 $L63461

; 420  : 		if (!strncmp(linePtr, "\\\\", 2)) {

  00bb5	6a 02		 push	 2
  00bb7	68 00 00 00 00	 push	 OFFSET FLAT:$SG63463
  00bbc	8b 85 20 f8 ff
	ff		 mov	 eax, DWORD PTR _linePtr$[ebp]
  00bc2	50		 push	 eax
  00bc3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncmp
  00bc9	83 c4 0c	 add	 esp, 12			; 0000000cH
  00bcc	85 c0		 test	 eax, eax
  00bce	0f 85 d1 01 00
	00		 jne	 $L63479

; 421  : 			// found '\\', so read message #
; 422  : 			linePtr += 2;

  00bd4	8b 8d 20 f8 ff
	ff		 mov	 ecx, DWORD PTR _linePtr$[ebp]
  00bda	83 c1 02	 add	 ecx, 2
  00bdd	89 8d 20 f8 ff
	ff		 mov	 DWORD PTR _linePtr$[ebp], ecx
$L63465:

; 423  : 			// skip over whitespace
; 424  : 			while (*linePtr == '\t' || *linePtr == ' ')

  00be3	8b 95 20 f8 ff
	ff		 mov	 edx, DWORD PTR _linePtr$[ebp]
  00be9	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00bec	83 f8 09	 cmp	 eax, 9
  00bef	74 0e		 je	 SHORT $L63467
  00bf1	8b 8d 20 f8 ff
	ff		 mov	 ecx, DWORD PTR _linePtr$[ebp]
  00bf7	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00bfa	83 fa 20	 cmp	 edx, 32			; 00000020H
  00bfd	75 11		 jne	 SHORT $L63466
$L63467:

; 425  : 				++linePtr;

  00bff	8b 85 20 f8 ff
	ff		 mov	 eax, DWORD PTR _linePtr$[ebp]
  00c05	83 c0 01	 add	 eax, 1
  00c08	89 85 20 f8 ff
	ff		 mov	 DWORD PTR _linePtr$[ebp], eax
  00c0e	eb d3		 jmp	 SHORT $L63465
$L63466:

; 426  : 			num = 0;

  00c10	c7 85 1c f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR _num$[ebp], 0
$L63469:

; 427  : 			while (*linePtr >= '0' && *linePtr <= '9') {

  00c1a	8b 8d 20 f8 ff
	ff		 mov	 ecx, DWORD PTR _linePtr$[ebp]
  00c20	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00c23	83 fa 30	 cmp	 edx, 48			; 00000030H
  00c26	7c 47		 jl	 SHORT $L63470
  00c28	8b 85 20 f8 ff
	ff		 mov	 eax, DWORD PTR _linePtr$[ebp]
  00c2e	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00c31	83 f9 39	 cmp	 ecx, 57			; 00000039H
  00c34	7f 39		 jg	 SHORT $L63470

; 428  : 				num *= 10;

  00c36	8b 95 1c f8 ff
	ff		 mov	 edx, DWORD PTR _num$[ebp]
  00c3c	6b d2 0a	 imul	 edx, 10			; 0000000aH
  00c3f	89 95 1c f8 ff
	ff		 mov	 DWORD PTR _num$[ebp], edx

; 429  : 				num += *linePtr++ - '0';

  00c45	8b 85 20 f8 ff
	ff		 mov	 eax, DWORD PTR _linePtr$[ebp]
  00c4b	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00c4e	8b 95 1c f8 ff
	ff		 mov	 edx, DWORD PTR _num$[ebp]
  00c54	8d 44 0a d0	 lea	 eax, DWORD PTR [edx+ecx-48]
  00c58	89 85 1c f8 ff
	ff		 mov	 DWORD PTR _num$[ebp], eax
  00c5e	8b 8d 20 f8 ff
	ff		 mov	 ecx, DWORD PTR _linePtr$[ebp]
  00c64	83 c1 01	 add	 ecx, 1
  00c67	89 8d 20 f8 ff
	ff		 mov	 DWORD PTR _linePtr$[ebp], ecx

; 430  : 			}

  00c6d	eb ab		 jmp	 SHORT $L63469
$L63470:

; 431  : 
; 432  : 			// found error message 
; 433  : 			if (num == errNum) {

  00c6f	8b 95 1c f8 ff
	ff		 mov	 edx, DWORD PTR _num$[ebp]
  00c75	3b 55 08	 cmp	 edx, DWORD PTR _errNum$[ebp]
  00c78	0f 85 27 01 00
	00		 jne	 $L63479
$L63473:

; 434  : 				// advance to next line 
; 435  : 				while (count) {

  00c7e	83 bd 24 f8 ff
	ff 00		 cmp	 DWORD PTR _count$[ebp], 0
  00c85	74 54		 je	 SHORT $L63474

; 436  : 					if (!--count)

  00c87	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _count$[ebp]
  00c8d	83 e8 01	 sub	 eax, 1
  00c90	89 85 24 f8 ff
	ff		 mov	 DWORD PTR _count$[ebp], eax
  00c96	83 bd 24 f8 ff
	ff 00		 cmp	 DWORD PTR _count$[ebp], 0
  00c9d	75 24		 jne	 SHORT $L63475

; 437  : 						count = ::Read(msgfile, filePtr = fileBuf, sizeof(fileBuf));

  00c9f	68 d0 07 00 00	 push	 2000			; 000007d0H
  00ca4	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _fileBuf$[ebp]
  00caa	89 4d fc	 mov	 DWORD PTR _filePtr$[ebp], ecx
  00cad	8b 55 fc	 mov	 edx, DWORD PTR _filePtr$[ebp]
  00cb0	52		 push	 edx
  00cb1	8b 45 10	 mov	 eax, DWORD PTR _msgfile$[ebp]
  00cb4	50		 push	 eax
  00cb5	e8 00 00 00 00	 call	 ?Read@@YAHHPAXH@Z	; Read
  00cba	83 c4 0c	 add	 esp, 12			; 0000000cH
  00cbd	89 85 24 f8 ff
	ff		 mov	 DWORD PTR _count$[ebp], eax
$L63475:

; 438  : 					if (*filePtr++ == '\n')

  00cc3	8b 4d fc	 mov	 ecx, DWORD PTR _filePtr$[ebp]
  00cc6	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00cc9	8b 45 fc	 mov	 eax, DWORD PTR _filePtr$[ebp]
  00ccc	83 c0 01	 add	 eax, 1
  00ccf	89 45 fc	 mov	 DWORD PTR _filePtr$[ebp], eax
  00cd2	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00cd5	75 02		 jne	 SHORT $L63476

; 439  : 						break;

  00cd7	eb 02		 jmp	 SHORT $L63474
$L63476:

; 440  : 				}

  00cd9	eb a3		 jmp	 SHORT $L63473
$L63474:

; 441  : 				linePtr = filePtr;

  00cdb	8b 4d fc	 mov	 ecx, DWORD PTR _filePtr$[ebp]
  00cde	89 8d 20 f8 ff
	ff		 mov	 DWORD PTR _linePtr$[ebp], ecx
$L63478:

; 442  : 
; 443  : 				while (count) {

  00ce4	83 bd 24 f8 ff
	ff 00		 cmp	 DWORD PTR _count$[ebp], 0
  00ceb	0f 84 b4 00 00
	00		 je	 $L63479

; 444  : 					// if terminating '\\' is found return error message
; 445  : 					if (!strncmp(linePtr, "\\\\", 2)) {

  00cf1	6a 02		 push	 2
  00cf3	68 00 00 00 00	 push	 OFFSET FLAT:$SG63481
  00cf8	8b 95 20 f8 ff
	ff		 mov	 edx, DWORD PTR _linePtr$[ebp]
  00cfe	52		 push	 edx
  00cff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncmp
  00d05	83 c4 0c	 add	 esp, 12			; 0000000cH
  00d08	85 c0		 test	 eax, eax
  00d0a	75 12		 jne	 SHORT $L63480

; 446  : 						// terminate the string 
; 447  : 						textPtr[-1] = 0;

  00d0c	8b 85 28 f8 ff
	ff		 mov	 eax, DWORD PTR _textPtr$[ebp]
  00d12	c6 40 ff 00	 mov	 BYTE PTR [eax-1], 0

; 448  : 						return textBuf;

  00d16	8b 45 0c	 mov	 eax, DWORD PTR _textBuf$[ebp]
  00d19	e9 f4 00 00 00	 jmp	 $L63452
$L63480:

; 450  : 
; 451  : 					// advance to next line while copying to textBuf
; 452  : 					while (count) {

  00d1e	83 bd 24 f8 ff
	ff 00		 cmp	 DWORD PTR _count$[ebp], 0
  00d25	74 70		 je	 SHORT $L63484

; 453  : 						if (!--count)

  00d27	8b 8d 24 f8 ff
	ff		 mov	 ecx, DWORD PTR _count$[ebp]
  00d2d	83 e9 01	 sub	 ecx, 1
  00d30	89 8d 24 f8 ff
	ff		 mov	 DWORD PTR _count$[ebp], ecx
  00d36	83 bd 24 f8 ff
	ff 00		 cmp	 DWORD PTR _count$[ebp], 0
  00d3d	75 24		 jne	 SHORT $L63485

; 454  : 							count = ::Read(msgfile, filePtr = fileBuf,sizeof(fileBuf));

  00d3f	68 d0 07 00 00	 push	 2000			; 000007d0H
  00d44	8d 95 2c f8 ff
	ff		 lea	 edx, DWORD PTR _fileBuf$[ebp]
  00d4a	89 55 fc	 mov	 DWORD PTR _filePtr$[ebp], edx
  00d4d	8b 45 fc	 mov	 eax, DWORD PTR _filePtr$[ebp]
  00d50	50		 push	 eax
  00d51	8b 4d 10	 mov	 ecx, DWORD PTR _msgfile$[ebp]
  00d54	51		 push	 ecx
  00d55	e8 00 00 00 00	 call	 ?Read@@YAHHPAXH@Z	; Read
  00d5a	83 c4 0c	 add	 esp, 12			; 0000000cH
  00d5d	89 85 24 f8 ff
	ff		 mov	 DWORD PTR _count$[ebp], eax
$L63485:

; 455  : 						*textPtr++ = *filePtr;

  00d63	8b 95 28 f8 ff
	ff		 mov	 edx, DWORD PTR _textPtr$[ebp]
  00d69	8b 45 fc	 mov	 eax, DWORD PTR _filePtr$[ebp]
  00d6c	8a 08		 mov	 cl, BYTE PTR [eax]
  00d6e	88 0a		 mov	 BYTE PTR [edx], cl
  00d70	8b 95 28 f8 ff
	ff		 mov	 edx, DWORD PTR _textPtr$[ebp]
  00d76	83 c2 01	 add	 edx, 1
  00d79	89 95 28 f8 ff
	ff		 mov	 DWORD PTR _textPtr$[ebp], edx

; 456  : 						if (*filePtr++ == '\n')

  00d7f	8b 45 fc	 mov	 eax, DWORD PTR _filePtr$[ebp]
  00d82	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00d85	8b 55 fc	 mov	 edx, DWORD PTR _filePtr$[ebp]
  00d88	83 c2 01	 add	 edx, 1
  00d8b	89 55 fc	 mov	 DWORD PTR _filePtr$[ebp], edx
  00d8e	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00d91	75 02		 jne	 SHORT $L63486

; 457  : 							break;

  00d93	eb 02		 jmp	 SHORT $L63484
$L63486:

; 458  : 					}

  00d95	eb 87		 jmp	 SHORT $L63480
$L63484:

; 459  : 					linePtr = filePtr;

  00d97	8b 45 fc	 mov	 eax, DWORD PTR _filePtr$[ebp]
  00d9a	89 85 20 f8 ff
	ff		 mov	 DWORD PTR _linePtr$[ebp], eax

; 460  : 				}

  00da0	e9 3f ff ff ff	 jmp	 $L63478
$L63479:

; 463  : 
; 464  : 		// advance to next line
; 465  : 		while (count) {

  00da5	83 bd 24 f8 ff
	ff 00		 cmp	 DWORD PTR _count$[ebp], 0
  00dac	74 54		 je	 SHORT $L63489

; 466  : 			if (!--count)

  00dae	8b 8d 24 f8 ff
	ff		 mov	 ecx, DWORD PTR _count$[ebp]
  00db4	83 e9 01	 sub	 ecx, 1
  00db7	89 8d 24 f8 ff
	ff		 mov	 DWORD PTR _count$[ebp], ecx
  00dbd	83 bd 24 f8 ff
	ff 00		 cmp	 DWORD PTR _count$[ebp], 0
  00dc4	75 24		 jne	 SHORT $L63490

; 467  : 				count = ::Read(msgfile, filePtr = fileBuf, sizeof(fileBuf));

  00dc6	68 d0 07 00 00	 push	 2000			; 000007d0H
  00dcb	8d 95 2c f8 ff
	ff		 lea	 edx, DWORD PTR _fileBuf$[ebp]
  00dd1	89 55 fc	 mov	 DWORD PTR _filePtr$[ebp], edx
  00dd4	8b 45 fc	 mov	 eax, DWORD PTR _filePtr$[ebp]
  00dd7	50		 push	 eax
  00dd8	8b 4d 10	 mov	 ecx, DWORD PTR _msgfile$[ebp]
  00ddb	51		 push	 ecx
  00ddc	e8 00 00 00 00	 call	 ?Read@@YAHHPAXH@Z	; Read
  00de1	83 c4 0c	 add	 esp, 12			; 0000000cH
  00de4	89 85 24 f8 ff
	ff		 mov	 DWORD PTR _count$[ebp], eax
$L63490:

; 468  : 			if (*filePtr++ == '\n')

  00dea	8b 55 fc	 mov	 edx, DWORD PTR _filePtr$[ebp]
  00ded	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00df0	8b 4d fc	 mov	 ecx, DWORD PTR _filePtr$[ebp]
  00df3	83 c1 01	 add	 ecx, 1
  00df6	89 4d fc	 mov	 DWORD PTR _filePtr$[ebp], ecx
  00df9	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00dfc	75 02		 jne	 SHORT $L63491

; 469  : 				break;

  00dfe	eb 02		 jmp	 SHORT $L63489
$L63491:

; 470  : 		}

  00e00	eb a3		 jmp	 SHORT $L63479
$L63489:

; 471  : 		linePtr = filePtr;

  00e02	8b 55 fc	 mov	 edx, DWORD PTR _filePtr$[ebp]
  00e05	89 95 20 f8 ff
	ff		 mov	 DWORD PTR _linePtr$[ebp], edx

; 472  : 	}

  00e0b	e9 98 fd ff ff	 jmp	 $L63460
$L63461:

; 473  : 
; 474  : 	return 0;

  00e10	33 c0		 xor	 eax, eax
$L63452:

; 475  : }

  00e12	8b e5		 mov	 esp, ebp
  00e14	5d		 pop	 ebp
  00e15	c2 0c 00	 ret	 12			; 0000000cH
?Read@MsgMgr@@IAEPADHPADH@Z ENDP			; MsgMgr::Read
_TEXT	ENDS
PUBLIC	?SetQuitStr@MsgMgr@@QAEXPAD@Z			; MsgMgr::SetQuitStr
_TEXT	SEGMENT
_text$ = 8
_this$ = -4
?SetQuitStr@MsgMgr@@QAEXPAD@Z PROC NEAR			; MsgMgr::SetQuitStr

; 479  : {

  00e18	55		 push	 ebp
  00e19	8b ec		 mov	 ebp, esp
  00e1b	51		 push	 ecx
  00e1c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 480  : 	assert(strlen(text) < MaxStr);
; 481  : 	strcpy(quitStr, text);

  00e1f	8b 45 08	 mov	 eax, DWORD PTR _text$[ebp]
  00e22	50		 push	 eax
  00e23	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e26	81 c1 ca 10 00
	00		 add	 ecx, 4298		; 000010caH
  00e2c	51		 push	 ecx
  00e2d	e8 00 00 00 00	 call	 _strcpy
  00e32	83 c4 08	 add	 esp, 8

; 482  : }

  00e35	8b e5		 mov	 esp, ebp
  00e37	5d		 pop	 ebp
  00e38	c2 04 00	 ret	 4
?SetQuitStr@MsgMgr@@QAEXPAD@Z ENDP			; MsgMgr::SetQuitStr
_TEXT	ENDS
PUBLIC	?SetSCIFatalStr@MsgMgr@@QAEXPAD@Z		; MsgMgr::SetSCIFatalStr
_TEXT	SEGMENT
_text$ = 8
_this$ = -4
?SetSCIFatalStr@MsgMgr@@QAEXPAD@Z PROC NEAR		; MsgMgr::SetSCIFatalStr

; 486  : {

  00e3b	55		 push	 ebp
  00e3c	8b ec		 mov	 ebp, esp
  00e3e	51		 push	 ecx
  00e3f	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 487  : 	assert(strlen(text) < MaxStr);
; 488  : 	strcpy(sciFatalStr, text);

  00e42	8b 45 08	 mov	 eax, DWORD PTR _text$[ebp]
  00e45	50		 push	 eax
  00e46	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e49	81 c1 cb 14 00
	00		 add	 ecx, 5323		; 000014cbH
  00e4f	51		 push	 ecx
  00e50	e8 00 00 00 00	 call	 _strcpy
  00e55	83 c4 08	 add	 esp, 8

; 489  : }

  00e58	8b e5		 mov	 esp, ebp
  00e5a	5d		 pop	 ebp
  00e5b	c2 04 00	 ret	 4
?SetSCIFatalStr@MsgMgr@@QAEXPAD@Z ENDP			; MsgMgr::SetSCIFatalStr
_TEXT	ENDS
PUBLIC	?AssertFail@@YAHPADH0@Z				; AssertFail
EXTRN	__imp__abort:NEAR
EXTRN	__imp__printf:NEAR
_DATA	SEGMENT
	ORG $+1
$SG63508 DB	'Assertion failed in %s(%d): %s', 00H
	ORG $+1
$SG63510 DB	'Assertion failed in %s(%d): %s', 0aH, 00H
_DATA	ENDS
_TEXT	SEGMENT
_file$ = 8
_line$ = 12
_expression$ = 16
?AssertFail@@YAHPADH0@Z PROC NEAR			; AssertFail

; 495  : {

  00e5e	55		 push	 ebp
  00e5f	8b ec		 mov	 ebp, esp

; 496  : 	// return value only useful for the way this function is used in
; 497  : 	// assert() macro
; 498  : 
; 499  : 	if (msgMgr)

  00e61	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?msgMgr@@3PAVMsgMgr@@A, 0 ; msgMgr
  00e68	74 21		 je	 SHORT $L63507

; 500  : 		msgMgr->Fatal("Assertion failed in %s(%d): %s", file, line, expression);

  00e6a	8b 45 10	 mov	 eax, DWORD PTR _expression$[ebp]
  00e6d	50		 push	 eax
  00e6e	8b 4d 0c	 mov	 ecx, DWORD PTR _line$[ebp]
  00e71	51		 push	 ecx
  00e72	8b 55 08	 mov	 edx, DWORD PTR _file$[ebp]
  00e75	52		 push	 edx
  00e76	68 00 00 00 00	 push	 OFFSET FLAT:$SG63508
  00e7b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00e80	50		 push	 eax
  00e81	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00e86	83 c4 14	 add	 esp, 20			; 00000014H

; 501  : 	else {

  00e89	eb 20		 jmp	 SHORT $L63509
$L63507:

; 502  : 		printf("Assertion failed in %s(%d): %s\n", file, line, expression);

  00e8b	8b 4d 10	 mov	 ecx, DWORD PTR _expression$[ebp]
  00e8e	51		 push	 ecx
  00e8f	8b 55 0c	 mov	 edx, DWORD PTR _line$[ebp]
  00e92	52		 push	 edx
  00e93	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00e96	50		 push	 eax
  00e97	68 00 00 00 00	 push	 OFFSET FLAT:$SG63510
  00e9c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00ea2	83 c4 10	 add	 esp, 16			; 00000010H

; 503  : 		abort();

  00ea5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__abort
$L63509:

; 505  : 	return 0;

  00eab	33 c0		 xor	 eax, eax
$L63506:

; 506  : }

  00ead	5d		 pop	 ebp
  00eae	c3		 ret	 0
?AssertFail@@YAHPADH0@Z ENDP				; AssertFail
_TEXT	ENDS
PUBLIC	??DTextID@@QAEPADXZ				; TextID::operator*
PUBLIC	?KSetQuitStr@@YAXPAF@Z				; KSetQuitStr
EXTRN	??0TextID@@QAE@G@Z:NEAR				; TextID::TextID
_TEXT	SEGMENT
_args$ = 8
$T63780 = -4
?KSetQuitStr@@YAXPAF@Z PROC NEAR			; KSetQuitStr

; 512  : {

  00eaf	55		 push	 ebp
  00eb0	8b ec		 mov	 ebp, esp
  00eb2	51		 push	 ecx

; 513  : 	msgMgr->SetQuitStr(*(TextID) arg(1));

  00eb3	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00eb6	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  00eba	51		 push	 ecx
  00ebb	8d 4d fc	 lea	 ecx, DWORD PTR $T63780[ebp]
  00ebe	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  00ec3	8b c8		 mov	 ecx, eax
  00ec5	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  00eca	50		 push	 eax
  00ecb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00ed1	e8 00 00 00 00	 call	 ?SetQuitStr@MsgMgr@@QAEXPAD@Z ; MsgMgr::SetQuitStr

; 514  : }

  00ed6	8b e5		 mov	 esp, ebp
  00ed8	5d		 pop	 ebp
  00ed9	c3		 ret	 0
?KSetQuitStr@@YAXPAF@Z ENDP				; KSetQuitStr
_TEXT	ENDS
;	COMDAT ??DTextID@@QAEPADXZ
_TEXT	SEGMENT
_this$ = -4
??DTextID@@QAEPADXZ PROC NEAR				; TextID::operator*, COMDAT

; 24   : 	char	*operator *() { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 25   : 		return handle ? (char *)MemID::operator*() : ""; 

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	33 c9		 xor	 ecx, ecx
  0000e	66 8b 08	 mov	 cx, WORD PTR [eax]
  00011	85 c9		 test	 ecx, ecx
  00013	74 0d		 je	 SHORT $L63782
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0001d	89 45 f8	 mov	 DWORD PTR -8+[ebp], eax
  00020	eb 07		 jmp	 SHORT $L63783
$L63782:
  00022	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
$L63783:
  00029	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]

; 26   : 	}

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??DTextID@@QAEPADXZ ENDP				; TextID::operator*
_TEXT	ENDS
PUBLIC	?KSetFatalStr@@YAXPAF@Z				; KSetFatalStr
EXTRN	?MakeVprintfArgs@@YAPAPADPADPAF@Z:NEAR		; MakeVprintfArgs
_DATA	SEGMENT
$SG63521 DB	'%s', 00H
_DATA	ENDS
_TEXT	SEGMENT
_args$ = 8
_text$ = -1024
_formatID$ = -1028
?KSetFatalStr@@YAXPAF@Z PROC NEAR			; KSetFatalStr

; 518  : {

  00eda	55		 push	 ebp
  00edb	8b ec		 mov	 ebp, esp
  00edd	81 ec 04 04 00
	00		 sub	 esp, 1028		; 00000404H

; 519  : 	char text[1024];
; 520  : 
; 521  : 	TextID formatID = arg(1);

  00ee3	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00ee6	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  00eea	51		 push	 ecx
  00eeb	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _formatID$[ebp]
  00ef1	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID

; 522  : 	vsprintf ( text, *formatID, *MakeVprintfArgs(*formatID, &arg(2)));

  00ef6	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00ef9	83 c2 04	 add	 edx, 4
  00efc	52		 push	 edx
  00efd	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _formatID$[ebp]
  00f03	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  00f08	50		 push	 eax
  00f09	e8 00 00 00 00	 call	 ?MakeVprintfArgs@@YAPAPADPADPAF@Z ; MakeVprintfArgs
  00f0e	83 c4 08	 add	 esp, 8
  00f11	8b 00		 mov	 eax, DWORD PTR [eax]
  00f13	50		 push	 eax
  00f14	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _formatID$[ebp]
  00f1a	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  00f1f	50		 push	 eax
  00f20	8d 8d 00 fc ff
	ff		 lea	 ecx, DWORD PTR _text$[ebp]
  00f26	51		 push	 ecx
  00f27	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__vsprintf
  00f2d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 523  : 
; 524  : 	msgMgr->Fatal ( "%s", text );

  00f30	8d 95 00 fc ff
	ff		 lea	 edx, DWORD PTR _text$[ebp]
  00f36	52		 push	 edx
  00f37	68 00 00 00 00	 push	 OFFSET FLAT:$SG63521
  00f3c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00f41	50		 push	 eax
  00f42	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00f47	83 c4 0c	 add	 esp, 12			; 0000000cH

; 525  : }

  00f4a	8b e5		 mov	 esp, ebp
  00f4c	5d		 pop	 ebp
  00f4d	c3		 ret	 0
?KSetFatalStr@@YAXPAF@Z ENDP				; KSetFatalStr
_TEXT	ENDS
PUBLIC	?KMonoOut@@YAXPAF@Z				; KMonoOut
_TEXT	SEGMENT
_args$ = 8
_formatID$ = -4
?KMonoOut@@YAXPAF@Z PROC NEAR				; KMonoOut

; 530  : {

  00f4e	55		 push	 ebp
  00f4f	8b ec		 mov	 ebp, esp
  00f51	51		 push	 ecx

; 531  : 	TextID formatID = arg(1);

  00f52	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00f55	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  00f59	51		 push	 ecx
  00f5a	8d 4d fc	 lea	 ecx, DWORD PTR _formatID$[ebp]
  00f5d	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID

; 532  : 	msgMgr->MonoArgs(*formatID, *MakeVprintfArgs(*formatID, &arg(2)));

  00f62	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00f65	83 c2 04	 add	 edx, 4
  00f68	52		 push	 edx
  00f69	8d 4d fc	 lea	 ecx, DWORD PTR _formatID$[ebp]
  00f6c	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  00f71	50		 push	 eax
  00f72	e8 00 00 00 00	 call	 ?MakeVprintfArgs@@YAPAPADPADPAF@Z ; MakeVprintfArgs
  00f77	83 c4 08	 add	 esp, 8
  00f7a	8b 00		 mov	 eax, DWORD PTR [eax]
  00f7c	50		 push	 eax
  00f7d	8d 4d fc	 lea	 ecx, DWORD PTR _formatID$[ebp]
  00f80	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  00f85	50		 push	 eax
  00f86	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00f8c	e8 00 00 00 00	 call	 ?MonoArgs@MsgMgr@@QAEXPAD0@Z ; MsgMgr::MonoArgs

; 533  : 	pm.acc = 1;

  00f91	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, 1

; 534  : }

  00f9b	8b e5		 mov	 esp, ebp
  00f9d	5d		 pop	 ebp
  00f9e	c3		 ret	 0
?KMonoOut@@YAXPAF@Z ENDP				; KMonoOut
_TEXT	ENDS
PUBLIC	?Printf@@YAHPADZZ				; Printf
EXTRN	?SciDisplay@@YAXPADHHHHH@Z:NEAR			; SciDisplay
_TEXT	SEGMENT
_fmt$ = 8
_buf$ = -1032
_args$ = -4
?Printf@@YAHPADZZ PROC NEAR				; Printf

; 539  : {

  00f9f	55		 push	 ebp
  00fa0	8b ec		 mov	 ebp, esp
  00fa2	81 ec 08 04 00
	00		 sub	 esp, 1032		; 00000408H

; 540  : 	char	buf[MsgMgr::MaxStr+1];
; 541  : 
; 542  : 	va_list args;
; 543  : 	va_start(args, fmt);

  00fa8	8d 45 0c	 lea	 eax, DWORD PTR _fmt$[ebp+4]
  00fab	89 45 fc	 mov	 DWORD PTR _args$[ebp], eax

; 544  : 	vsprintf(buf, fmt, args);

  00fae	8b 4d fc	 mov	 ecx, DWORD PTR _args$[ebp]
  00fb1	51		 push	 ecx
  00fb2	8b 55 08	 mov	 edx, DWORD PTR _fmt$[ebp]
  00fb5	52		 push	 edx
  00fb6	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00fbc	50		 push	 eax
  00fbd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__vsprintf
  00fc3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 545  : #ifdef WINDOWS
; 546  : 	SciDisplay(buf);

  00fc6	6a 32		 push	 50			; 00000032H
  00fc8	68 c8 00 00 00	 push	 200			; 000000c8H
  00fcd	68 8c 00 00 00	 push	 140			; 0000008cH
  00fd2	68 90 01 00 00	 push	 400			; 00000190H
  00fd7	68 6c 02 00 00	 push	 620			; 0000026cH
  00fdc	8d 8d f8 fb ff
	ff		 lea	 ecx, DWORD PTR _buf$[ebp]
  00fe2	51		 push	 ecx
  00fe3	e8 00 00 00 00	 call	 ?SciDisplay@@YAXPADHHHHH@Z ; SciDisplay
  00fe8	83 c4 18	 add	 esp, 24			; 00000018H

; 547  : #else
; 548  : 	printf(buf);
; 549  : #endif
; 550  : 	return strlen(buf);

  00feb	8d 95 f8 fb ff
	ff		 lea	 edx, DWORD PTR _buf$[ebp]
  00ff1	52		 push	 edx
  00ff2	e8 00 00 00 00	 call	 _strlen
  00ff7	83 c4 04	 add	 esp, 4

; 551  : }

  00ffa	8b e5		 mov	 esp, ebp
  00ffc	5d		 pop	 ebp
  00ffd	c3		 ret	 0
?Printf@@YAHPADZZ ENDP					; Printf
_TEXT	ENDS
END
