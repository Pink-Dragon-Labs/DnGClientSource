	TITLE	\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Moview.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@LHED@Instructed?5to?5scale?5to?5zero?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07CCG@ResView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KCEF@?4v56?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06IAEF@ResPic?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04EODC@?4p56?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08OCKJ@ResChunk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PIPI@?4chk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07ICMB@ResHunk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GG@?4scr?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08BLBP@ResSound?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KPDA@?4snd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NNMB@ResVocab?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PGDD@?4voc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FLKK@ResPatch?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CEHK@?4pat?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07MKGC@ResFont?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04IDCK@?4fon?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06DEEM@ResPal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NJLC@?4pal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07HFNL@ResHeap?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GFFD@?4hep?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06HDCC@ResMsg?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JONM@?4msg?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NFDN@ResAudio?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MOHF@?4aud?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BKMJ@ResWave?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MPDF@?4wav?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@IMEI@ResAudio36?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BONB@ResSync?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KFFK@?4syn?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09CBJE@ResSync36?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06MIEL@ResMap?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CFLF@?4map?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@LIAH@ResMsgTranslation?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JFJA@?4trn?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08JLOL@ResRobot?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04LLKI@?4rbt?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06OEMP@ResVMD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04IOID@?4vmd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MemoryMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckValid@MemoryMgr@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GMemoryMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@V1@III@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AMemID@@QBEAADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8MemID@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??7MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeArrayID@@QBEPAUArrayHeader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ArrayID@@QAE@HW4ArrayType@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@ArrayID@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAE?AVMemID@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAEXVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_List@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@SOL_List@@QAEAAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeDispatchTblID@@QBEPAUDispatchTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeScriptEntryID@@QBEPAUScriptEntry@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntry@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeVariableID@@QBEPAUVariable@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Script@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Object@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGraphicsUpdate@Object@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?selectorDict@Object@@QAEPAVSelectorDict@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AObject@@QAEAAFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddr@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedPropAddr@Object@@QAEPBFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedProperty@Object@@QAEFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddrCheck@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@Object@@QAEFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropOffset@Object@@QAEIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetIndexedProperty@Object@@QAEXHF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetProperty@Object@@QAEXGF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssureValid@ObjectID@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsObject@ObjectID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeClassTblID@@QBEPAUClassTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DTextID@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@NN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SOL_Point@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@HHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@AAVSOL_Point@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Set@SOL_Rect@@QAEXHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeEmpty@SOL_Rect@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Xlen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ylen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8SOL_Rect@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Ratio@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Ratio@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D@YAHHABVRatio@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Rgb24@@QAE@EEE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Rgb24@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Rgb24F@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@HHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@VMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Type@Bitmap@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObj@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Skip@CelObj@@QBEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemapState@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Mirrored@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObj@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjView@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjView@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjView@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjView@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjMem@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjMem@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjMem@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjMem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjColor@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjColor@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjColor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjColor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Draw@ScreenItem@@QAEXABVBuffer@@ABVSOL_Rect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SOL_Rect@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TopPlane@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TopSCIPlane@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Xdim@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ydim@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPlane@GraphicsMgr@@QAEXPAVSOL_Plane@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1TimeMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reset@TimeMgr@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GTimeMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1PaletteMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GPaletteMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetExtension@SOL_ResType@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSupported@SOL_ResType@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAttrs@SOL_ResType@@UBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResView@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPic@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResChunk@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResScript@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSound@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResVocab@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPatch@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResFont@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPal@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResHeap@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMsg@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResAudio@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResWave@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResAudio36@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSync@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSync36@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMap@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMsgTranslation@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileType@ResMsgTranslation@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResRobot@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResVMD@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1SOL_Cursor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GSOL_Cursor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7ResPic@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7PaletteMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResView@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResPal@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObj@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResHeap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResWave@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResRobot@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResPatch@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMsgTranslation@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7Buffer@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResScript@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjColor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSync36@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMsg@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7SOL_Cursor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjView@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResAudio36@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResAudio@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResFont@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7MemoryMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7TimeMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResVMD@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResChunk@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSync@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjMem@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResVocab@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
_BSS	SEGMENT
_movieInit DD	01H DUP (?)
_BSS	ENDS
PUBLIC	?KSetVideoMode@@YAXPAF@Z			; KSetVideoMode
_TEXT	SEGMENT
_args$ = 8
_mode$ = -4
?KSetVideoMode@@YAXPAF@Z PROC NEAR			; KSetVideoMode

; 51   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 52   : 	int short mode = (int short) arg(1);

  00004	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00007	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  0000b	66 89 4d fc	 mov	 WORD PTR _mode$[ebp], cx

; 53   : }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?KSetVideoMode@@YAXPAF@Z ENDP				; KSetVideoMode
_TEXT	ENDS
PUBLIC	_AviOpen
PUBLIC	_AviClose
PUBLIC	_AviPut
PUBLIC	_AviPutDouble
PUBLIC	?KShowMovie@@YAXPAF@Z				; KShowMovie
PUBLIC	_AviPlay
PUBLIC	_AviStop
PUBLIC	_AviPause
PUBLIC	_AviResume
PUBLIC	_AviSetPalette
PUBLIC	_AviGetLength
PUBLIC	_AviGetPosition
PUBLIC	_AviGetStatus
PUBLIC	_AviCue
PUBLIC	_AviSeek
PUBLIC	_AviGetFramesSkipped
PUBLIC	_AviWaitEvent
PUBLIC	?InitMovie@@YAXXZ				; InitMovie
PUBLIC	??DTextID@@QAEPADXZ				; TextID::operator*
EXTRN	?pm@@3VPMachine@@A:BYTE				; pm
EXTRN	??0TextID@@QAE@G@Z:NEAR				; TextID::TextID
_TEXT	SEGMENT
_args$ = 8
_movieNo$ = -4
$T62301 = -8
?KShowMovie@@YAXPAF@Z PROC NEAR				; KShowMovie

; 57   : {

  00013	55		 push	 ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 10	 sub	 esp, 16			; 00000010H

; 58   : 	if (!movieInit)

  00019	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _movieInit, 0
  00020	75 05		 jne	 SHORT $L61770

; 59   : 		InitMovie();

  00022	e8 00 00 00 00	 call	 ?InitMovie@@YAXXZ	; InitMovie
$L61770:

; 60   : 
; 61   : 	int movieNo = arg(1);

  00027	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  0002a	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  0002e	89 4d fc	 mov	 DWORD PTR _movieNo$[ebp], ecx

; 62   :    switch(arg(2)) {

  00031	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00034	0f bf 42 04	 movsx	 eax, WORD PTR [edx+4]
  00038	89 45 f4	 mov	 DWORD PTR -12+[ebp], eax
  0003b	83 7d f4 0f	 cmp	 DWORD PTR -12+[ebp], 15	; 0000000fH
  0003f	0f 87 d9 02 00
	00		 ja	 $L61773
  00045	8b 4d f4	 mov	 ecx, DWORD PTR -12+[ebp]
  00048	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L62302[ecx*4]
$L61776:

; 63   : 
; 64   : 		case AVI_OPEN:
; 65   : 			 pm.acc = AviOpen(movieNo,(*(TextID)arg(3)));

  0004f	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00052	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  00056	50		 push	 eax
  00057	8d 4d f8	 lea	 ecx, DWORD PTR $T62301[ebp]
  0005a	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  0005f	8b c8		 mov	 ecx, eax
  00061	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  00066	50		 push	 eax
  00067	8b 4d fc	 mov	 ecx, DWORD PTR _movieNo$[ebp]
  0006a	51		 push	 ecx
  0006b	e8 00 00 00 00	 call	 _AviOpen
  00070	83 c4 08	 add	 esp, 8
  00073	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 66   : 	 		break;

  00078	e9 a1 02 00 00	 jmp	 $L61773
$L61779:

; 67   : 
; 68   : 		case AVI_PUT:
; 69   : 
; 70   : 	 		if(arg(0) > 4) {

  0007d	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00080	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00083	83 f8 04	 cmp	 eax, 4
  00086	7e 33		 jle	 SHORT $L61780

; 71   : 	    		pm.acc = AviPut(movieNo,arg(3), arg(4), arg(5), arg(6));

  00088	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  0008b	0f bf 51 0c	 movsx	 edx, WORD PTR [ecx+12]
  0008f	52		 push	 edx
  00090	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00093	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  00097	51		 push	 ecx
  00098	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  0009b	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  0009f	50		 push	 eax
  000a0	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  000a3	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  000a7	52		 push	 edx
  000a8	8b 45 fc	 mov	 eax, DWORD PTR _movieNo$[ebp]
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 _AviPut
  000b1	83 c4 14	 add	 esp, 20			; 00000014H
  000b4	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 72   : 	 		} else {

  000b9	eb 25		 jmp	 SHORT $L61781
$L61780:

; 73   : 	    		pm.acc = AviPut(movieNo,arg(3), arg(4), NULL, NULL);

  000bb	6a 00		 push	 0
  000bd	6a 00		 push	 0
  000bf	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  000c2	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  000c6	52		 push	 edx
  000c7	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  000ca	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  000ce	51		 push	 ecx
  000cf	8b 55 fc	 mov	 edx, DWORD PTR _movieNo$[ebp]
  000d2	52		 push	 edx
  000d3	e8 00 00 00 00	 call	 _AviPut
  000d8	83 c4 14	 add	 esp, 20			; 00000014H
  000db	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax
$L61781:

; 75   : 	 		break;

  000e0	e9 39 02 00 00	 jmp	 $L61773
$L61782:

; 76   : 
; 77   : 		case AVI_PUT_DOUBLE:
; 78   : 			AviPutDouble(movieNo,arg(3),arg(4));

  000e5	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  000e8	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  000ec	51		 push	 ecx
  000ed	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  000f0	0f bf 42 06	 movsx	 eax, WORD PTR [edx+6]
  000f4	50		 push	 eax
  000f5	8b 4d fc	 mov	 ecx, DWORD PTR _movieNo$[ebp]
  000f8	51		 push	 ecx
  000f9	e8 00 00 00 00	 call	 _AviPutDouble
  000fe	83 c4 0c	 add	 esp, 12			; 0000000cH

; 79   : 			break;

  00101	e9 18 02 00 00	 jmp	 $L61773
$L61783:

; 80   : 
; 81   : 		case AVI_PLAY:
; 82   : 
; 83   : 	 		switch (arg(0)) {

  00106	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00109	0f bf 02	 movsx	 eax, WORD PTR [edx]
  0010c	89 45 f0	 mov	 DWORD PTR -16+[ebp], eax
  0010f	8b 4d f0	 mov	 ecx, DWORD PTR -16+[ebp]
  00112	83 e9 03	 sub	 ecx, 3
  00115	89 4d f0	 mov	 DWORD PTR -16+[ebp], ecx
  00118	83 7d f0 03	 cmp	 DWORD PTR -16+[ebp], 3
  0011c	0f 87 af 00 00
	00		 ja	 $L61792
  00122	8b 55 f0	 mov	 edx, DWORD PTR -16+[ebp]
  00125	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L62303[edx*4]
$L61788:

; 84   : 	    		case 6:
; 85   : 	       			pm.acc = AviPlay(movieNo,arg(3), arg(4), arg(5), arg(6));

  0012c	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  0012f	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  00133	51		 push	 ecx
  00134	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00137	0f bf 42 0a	 movsx	 eax, WORD PTR [edx+10]
  0013b	50		 push	 eax
  0013c	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  0013f	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  00143	52		 push	 edx
  00144	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00147	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0014b	51		 push	 ecx
  0014c	8b 55 fc	 mov	 edx, DWORD PTR _movieNo$[ebp]
  0014f	52		 push	 edx
  00150	e8 00 00 00 00	 call	 _AviPlay
  00155	83 c4 14	 add	 esp, 20			; 00000014H
  00158	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 86   : 	       			break;

  0015d	e9 88 00 00 00	 jmp	 $L61785
$L61789:

; 87   : 
; 88   : 	    		case 5:
; 89   : 	       			pm.acc = AviPlay(movieNo,arg(3), arg(4), arg(5), NULL);

  00162	6a 00		 push	 0
  00164	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00167	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  0016b	51		 push	 ecx
  0016c	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  0016f	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  00173	50		 push	 eax
  00174	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00177	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  0017b	52		 push	 edx
  0017c	8b 45 fc	 mov	 eax, DWORD PTR _movieNo$[ebp]
  0017f	50		 push	 eax
  00180	e8 00 00 00 00	 call	 _AviPlay
  00185	83 c4 14	 add	 esp, 20			; 00000014H
  00188	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 90   : 	       			break;

  0018d	eb 5b		 jmp	 SHORT $L61785
$L61790:

; 91   : 
; 92   : 	    		case 4:
; 93   : 	       			pm.acc = AviPlay(movieNo,arg(3), arg(4), SCI_WINDOW, NULL);

  0018f	6a 00		 push	 0
  00191	6a 02		 push	 2
  00193	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00196	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  0019a	52		 push	 edx
  0019b	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  0019e	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  001a2	51		 push	 ecx
  001a3	8b 55 fc	 mov	 edx, DWORD PTR _movieNo$[ebp]
  001a6	52		 push	 edx
  001a7	e8 00 00 00 00	 call	 _AviPlay
  001ac	83 c4 14	 add	 esp, 20			; 00000014H
  001af	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 94   : 	       			break;

  001b4	eb 34		 jmp	 SHORT $L61785
$L61791:

; 95   : 
; 96   : 	    		case 3:
; 97   : 	       			pm.acc = AviPlay(movieNo,NULL, NULL, SCI_WINDOW, NULL);	// must have from AND to

  001b6	6a 00		 push	 0
  001b8	6a 02		 push	 2
  001ba	6a 00		 push	 0
  001bc	6a 00		 push	 0
  001be	8b 45 fc	 mov	 eax, DWORD PTR _movieNo$[ebp]
  001c1	50		 push	 eax
  001c2	e8 00 00 00 00	 call	 _AviPlay
  001c7	83 c4 14	 add	 esp, 20			; 00000014H
  001ca	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 98   : 	       			break;

  001cf	eb 19		 jmp	 SHORT $L61785
$L61792:

; 99   : 
; 100  : 	    		default:
; 101  : 	       			pm.acc = AviPlay(movieNo,NULL, NULL, SCI_WINDOW, NULL);

  001d1	6a 00		 push	 0
  001d3	6a 02		 push	 2
  001d5	6a 00		 push	 0
  001d7	6a 00		 push	 0
  001d9	8b 4d fc	 mov	 ecx, DWORD PTR _movieNo$[ebp]
  001dc	51		 push	 ecx
  001dd	e8 00 00 00 00	 call	 _AviPlay
  001e2	83 c4 14	 add	 esp, 20			; 00000014H
  001e5	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax
$L61785:

; 104  : 
; 105  : 	 		break;

  001ea	e9 2f 01 00 00	 jmp	 $L61773
$L61793:

; 106  : 
; 107  : 		case AVI_STOP:
; 108  : 	 		pm.acc = AviStop(movieNo);

  001ef	8b 55 fc	 mov	 edx, DWORD PTR _movieNo$[ebp]
  001f2	52		 push	 edx
  001f3	e8 00 00 00 00	 call	 _AviStop
  001f8	83 c4 04	 add	 esp, 4
  001fb	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 109  : 	 		break;

  00200	e9 19 01 00 00	 jmp	 $L61773
$L61794:

; 110  : 
; 111  : 		case AVI_PAUSE:
; 112  : 	 		pm.acc = AviPause(movieNo);

  00205	8b 45 fc	 mov	 eax, DWORD PTR _movieNo$[ebp]
  00208	50		 push	 eax
  00209	e8 00 00 00 00	 call	 _AviPause
  0020e	83 c4 04	 add	 esp, 4
  00211	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 113  : 	 		break;

  00216	e9 03 01 00 00	 jmp	 $L61773
$L61795:

; 114  : 
; 115  : 		case AVI_CUE:
; 116  : 			pm.acc = AviCue(movieNo,arg(3));

  0021b	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  0021e	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00222	52		 push	 edx
  00223	8b 45 fc	 mov	 eax, DWORD PTR _movieNo$[ebp]
  00226	50		 push	 eax
  00227	e8 00 00 00 00	 call	 _AviCue
  0022c	83 c4 08	 add	 esp, 8
  0022f	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 117  : 			break;

  00234	e9 e5 00 00 00	 jmp	 $L61773
$L61796:

; 118  : 
; 119  : 		case AVI_SEEK:
; 120  : 			pm.acc = AviSeek(movieNo,arg(3));

  00239	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  0023c	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00240	52		 push	 edx
  00241	8b 45 fc	 mov	 eax, DWORD PTR _movieNo$[ebp]
  00244	50		 push	 eax
  00245	e8 00 00 00 00	 call	 _AviSeek
  0024a	83 c4 08	 add	 esp, 8
  0024d	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 121  : 			break;

  00252	e9 c7 00 00 00	 jmp	 $L61773
$L61797:

; 122  : 
; 123  : 		case AVI_RESUME:
; 124  : 	 		pm.acc = AviResume(movieNo);

  00257	8b 4d fc	 mov	 ecx, DWORD PTR _movieNo$[ebp]
  0025a	51		 push	 ecx
  0025b	e8 00 00 00 00	 call	 _AviResume
  00260	83 c4 04	 add	 esp, 4
  00263	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 125  : 	 		break;

  00268	e9 b1 00 00 00	 jmp	 $L61773
$L61798:

; 126  : 
; 127  : 		case AVI_CLOSE:
; 128  : 	 		pm.acc = AviClose(movieNo);

  0026d	8b 55 fc	 mov	 edx, DWORD PTR _movieNo$[ebp]
  00270	52		 push	 edx
  00271	e8 00 00 00 00	 call	 _AviClose
  00276	83 c4 04	 add	 esp, 4
  00279	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 129  : 			break;

  0027e	e9 9b 00 00 00	 jmp	 $L61773
$L61799:

; 130  : 
; 131  : 		case AVI_SETPALETTE:
; 132  : 			pm.acc = AviSetPalette(movieNo);

  00283	8b 45 fc	 mov	 eax, DWORD PTR _movieNo$[ebp]
  00286	50		 push	 eax
  00287	e8 00 00 00 00	 call	 _AviSetPalette
  0028c	83 c4 04	 add	 esp, 4
  0028f	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 133  : 			break;

  00294	e9 85 00 00 00	 jmp	 $L61773
$L61800:

; 134  : 
; 135  : 		case AVI_GET_LENGTH:
; 136  : 			pm.acc = AviGetLength(movieNo);

  00299	8b 4d fc	 mov	 ecx, DWORD PTR _movieNo$[ebp]
  0029c	51		 push	 ecx
  0029d	e8 00 00 00 00	 call	 _AviGetLength
  002a2	83 c4 04	 add	 esp, 4
  002a5	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 137  : 			break;

  002aa	eb 72		 jmp	 SHORT $L61773
$L61801:

; 138  : 
; 139  : 		case AVI_GET_POSITION:
; 140  : 			pm.acc = AviGetPosition(movieNo);

  002ac	8b 55 fc	 mov	 edx, DWORD PTR _movieNo$[ebp]
  002af	52		 push	 edx
  002b0	e8 00 00 00 00	 call	 _AviGetPosition
  002b5	83 c4 04	 add	 esp, 4
  002b8	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 141  : 			break;

  002bd	eb 5f		 jmp	 SHORT $L61773
$L61802:

; 142  : 
; 143  : 		case AVI_GET_STATUS:
; 144  : 			pm.acc = AviGetStatus(movieNo);

  002bf	8b 45 fc	 mov	 eax, DWORD PTR _movieNo$[ebp]
  002c2	50		 push	 eax
  002c3	e8 00 00 00 00	 call	 _AviGetStatus
  002c8	83 c4 04	 add	 esp, 4
  002cb	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 145  : 			break;

  002d0	eb 4c		 jmp	 SHORT $L61773
$L61803:

; 146  : 
; 147  : 		case AVI_FRAMES_SKIPPED:
; 148  : 			pm.acc = AviGetFramesSkipped(movieNo);

  002d2	8b 4d fc	 mov	 ecx, DWORD PTR _movieNo$[ebp]
  002d5	51		 push	 ecx
  002d6	e8 00 00 00 00	 call	 _AviGetFramesSkipped
  002db	83 c4 04	 add	 esp, 4
  002de	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 149  : 			break;

  002e3	eb 39		 jmp	 SHORT $L61773
$L61804:

; 150  : 
; 151  : 		case AVI_WAIT_EVENT:
; 152  : 			if(arg(0) == 3)

  002e5	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  002e8	0f bf 02	 movsx	 eax, WORD PTR [edx]
  002eb	83 f8 03	 cmp	 eax, 3
  002ee	75 1b		 jne	 SHORT $L61805

; 153  : 				pm.acc = AviWaitEvent(movieNo,arg(3));

  002f0	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  002f3	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  002f7	52		 push	 edx
  002f8	8b 45 fc	 mov	 eax, DWORD PTR _movieNo$[ebp]
  002fb	50		 push	 eax
  002fc	e8 00 00 00 00	 call	 _AviWaitEvent
  00301	83 c4 08	 add	 esp, 8
  00304	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 154  : 			else

  00309	eb 13		 jmp	 SHORT $L61806
$L61805:

; 155  : 				pm.acc = AviWaitEvent(movieNo,3);

  0030b	6a 03		 push	 3
  0030d	8b 4d fc	 mov	 ecx, DWORD PTR _movieNo$[ebp]
  00310	51		 push	 ecx
  00311	e8 00 00 00 00	 call	 _AviWaitEvent
  00316	83 c4 08	 add	 esp, 8
  00319	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax
$L61806:
$L61773:

; 159  : }

  0031e	8b e5		 mov	 esp, ebp
  00320	5d		 pop	 ebp
  00321	c3		 ret	 0
$L62302:
  00322	00 00 00 00	 DD	 $L61776
  00326	00 00 00 00	 DD	 $L61779
  0032a	00 00 00 00	 DD	 $L61783
  0032e	00 00 00 00	 DD	 $L61793
  00332	00 00 00 00	 DD	 $L61794
  00336	00 00 00 00	 DD	 $L61797
  0033a	00 00 00 00	 DD	 $L61798
  0033e	00 00 00 00	 DD	 $L61799
  00342	00 00 00 00	 DD	 $L61800
  00346	00 00 00 00	 DD	 $L61801
  0034a	00 00 00 00	 DD	 $L61802
  0034e	00 00 00 00	 DD	 $L61795
  00352	00 00 00 00	 DD	 $L61796
  00356	00 00 00 00	 DD	 $L61803
  0035a	00 00 00 00	 DD	 $L61804
  0035e	00 00 00 00	 DD	 $L61782
$L62303:
  00362	00 00 00 00	 DD	 $L61791
  00366	00 00 00 00	 DD	 $L61790
  0036a	00 00 00 00	 DD	 $L61789
  0036e	00 00 00 00	 DD	 $L61788
?KShowMovie@@YAXPAF@Z ENDP				; KShowMovie
_TEXT	ENDS
PUBLIC	??DMemID@@QBEPAXXZ				; MemID::operator*
PUBLIC	??_C@_00A@?$AA@					; `string'
;	COMDAT ??_C@_00A@?$AA@
; File \\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\textid.hpp
_BSS	SEGMENT
??_C@_00A@?$AA@ DB 01H DUP (?)				; `string'
_BSS	ENDS
;	COMDAT ??DTextID@@QAEPADXZ
_TEXT	SEGMENT
_this$ = -4
??DTextID@@QAEPADXZ PROC NEAR				; TextID::operator*, COMDAT

; 24   : 	char	*operator *() { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 25   : 		return handle ? (char *)MemID::operator*() : ""; 

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	33 c9		 xor	 ecx, ecx
  0000e	66 8b 08	 mov	 cx, WORD PTR [eax]
  00011	85 c9		 test	 ecx, ecx
  00013	74 0d		 je	 SHORT $L62305
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0001d	89 45 f8	 mov	 DWORD PTR -8+[ebp], eax
  00020	eb 07		 jmp	 SHORT $L62306
$L62305:
  00022	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
$L62306:
  00029	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]

; 26   : 	}

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??DTextID@@QAEPADXZ ENDP				; TextID::operator*
_TEXT	ENDS
PUBLIC	?GetAddr@MemoryMgr@@QAEPAXG@Z			; MemoryMgr::GetAddr
EXTRN	_memMgr:DWORD
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT
_this$ = -4
??DMemID@@QBEPAXXZ PROC NEAR				; MemID::operator*, COMDAT

; 98   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 99   : 		return memMgr->GetAddr(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr

; 100  : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??DMemID@@QBEPAXXZ ENDP					; MemID::operator*
_TEXT	ENDS
EXTRN	__descPtrTable:BYTE
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -4
?GetAddr@MemoryMgr@@QAEPAXG@Z PROC NEAR			; MemoryMgr::GetAddr, COMDAT

; 462  : 	inline void* MemoryMgr::GetAddr(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : //		CheckValid(theID);
; 464  : 		return _descPtrTable[(unsigned int)((unsigned short)theID)];

  00007	8b 45 08	 mov	 eax, DWORD PTR _theID$[ebp]
  0000a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0000f	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR __descPtrTable[eax*4]

; 465  : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?GetAddr@MemoryMgr@@QAEPAXG@Z ENDP			; MemoryMgr::GetAddr
_TEXT	ENDS
EXTRN	__imp__sprintf:NEAR
EXTRN	__imp___splitpath:NEAR
EXTRN	__imp__mciSendStringA@16:NEAR
EXTRN	__imp__access:NEAR
EXTRN	?Get@ConfigMgr@@QAEPADPADH@Z:NEAR		; ConfigMgr::Get
EXTRN	__imp__GetVolumeInformationA@32:NEAR
EXTRN	?GetNTokens@ConfigMgr@@QAEHPAD@Z:NEAR		; ConfigMgr::GetNTokens
EXTRN	_strcpy:NEAR
EXTRN	?configMgr@@3PAVConfigMgr@@A:DWORD		; configMgr
EXTRN	_strlen:NEAR
_BSS	SEGMENT
_movieName DB	0104H DUP (?)
_aviStatus DD	0aH DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG61816 DB	'MovieDir', 00H
	ORG $+3
$SG61818 DB	'MovieDir', 00H
	ORG $+3
$SG61821 DB	'%s\%s', 00H
	ORG $+2
$SG61827 DB	'open %s alias sciMovie%-1d wait', 00H
_DATA	ENDS
_TEXT	SEGMENT
_movieNo$ = 8
_filename$ = 12
_i$ = -264
_movieFound$ = -268
_movieDir$61817 = -528
_drive$61820 = -540
_str$ = -256
_resultStr$ = -524
_errorCode$ = -260
_AviOpen PROC NEAR

; 162  : {

  00372	55		 push	 ebp
  00373	8b ec		 mov	 ebp, esp
  00375	81 ec 1c 02 00
	00		 sub	 esp, 540		; 0000021cH

; 163  : 	int i;
; 164  : 	int movieFound = 0;

  0037b	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _movieFound$[ebp], 0

; 165  : 
; 166  : 	for(i = 0; i < configMgr->GetNTokens("MovieDir"); i++) {

  00385	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  0038f	eb 0f		 jmp	 SHORT $L61813
$L61814:
  00391	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00397	83 c0 01	 add	 eax, 1
  0039a	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$L61813:
  003a0	68 00 00 00 00	 push	 OFFSET FLAT:$SG61816
  003a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?configMgr@@3PAVConfigMgr@@A ; configMgr
  003ab	e8 00 00 00 00	 call	 ?GetNTokens@ConfigMgr@@QAEHPAD@Z ; ConfigMgr::GetNTokens
  003b0	39 85 f8 fe ff
	ff		 cmp	 DWORD PTR _i$[ebp], eax
  003b6	0f 8d c7 00 00
	00		 jge	 $L61815

; 167  : 		char * movieDir = configMgr->Get("MovieDir",i);

  003bc	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  003c2	51		 push	 ecx
  003c3	68 00 00 00 00	 push	 OFFSET FLAT:$SG61818
  003c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?configMgr@@3PAVConfigMgr@@A ; configMgr
  003ce	e8 00 00 00 00	 call	 ?Get@ConfigMgr@@QAEPADPADH@Z ; ConfigMgr::Get
  003d3	89 85 f0 fd ff
	ff		 mov	 DWORD PTR _movieDir$61817[ebp], eax

; 168  : 
; 169  : 		if(movieDir && strlen(movieDir)) {

  003d9	83 bd f0 fd ff
	ff 00		 cmp	 DWORD PTR _movieDir$61817[ebp], 0
  003e0	74 6b		 je	 SHORT $L61819
  003e2	8b 95 f0 fd ff
	ff		 mov	 edx, DWORD PTR _movieDir$61817[ebp]
  003e8	52		 push	 edx
  003e9	e8 00 00 00 00	 call	 _strlen
  003ee	83 c4 04	 add	 esp, 4
  003f1	85 c0		 test	 eax, eax
  003f3	74 58		 je	 SHORT $L61819

; 170  : 			char drive[10];
; 171  : 			_splitpath(movieDir,drive,0,0,0);

  003f5	6a 00		 push	 0
  003f7	6a 00		 push	 0
  003f9	6a 00		 push	 0
  003fb	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _drive$61820[ebp]
  00401	50		 push	 eax
  00402	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR _movieDir$61817[ebp]
  00408	51		 push	 ecx
  00409	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___splitpath
  0040f	83 c4 14	 add	 esp, 20			; 00000014H

; 172  : 
; 173  : 			// The following findfirst is done to ensure that MSCDEX
; 174  : 			// knows which CD is in the drive
; 175  : #ifndef WIN32S
; 176  : 			find_t buffer;
; 177  : 			strcat(drive,"\\*.*");
; 178  : 			int result =_dos_findfirst(drive,_A_VOLID,&buffer);
; 179  : #else
; 180  : 			GetVolumeInformation(drive,NULL,0,NULL,NULL,0,NULL,0);

  00412	6a 00		 push	 0
  00414	6a 00		 push	 0
  00416	6a 00		 push	 0
  00418	6a 00		 push	 0
  0041a	6a 00		 push	 0
  0041c	6a 00		 push	 0
  0041e	6a 00		 push	 0
  00420	8d 95 e4 fd ff
	ff		 lea	 edx, DWORD PTR _drive$61820[ebp]
  00426	52		 push	 edx
  00427	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVolumeInformationA@32

; 181  : #endif
; 182  : 			sprintf(movieName,"%s\\%s",movieDir,filename);

  0042d	8b 45 0c	 mov	 eax, DWORD PTR _filename$[ebp]
  00430	50		 push	 eax
  00431	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR _movieDir$61817[ebp]
  00437	51		 push	 ecx
  00438	68 00 00 00 00	 push	 OFFSET FLAT:$SG61821
  0043d	68 00 00 00 00	 push	 OFFSET FLAT:_movieName
  00442	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  00448	83 c4 10	 add	 esp, 16			; 00000010H

; 184  : 		else

  0044b	eb 11		 jmp	 SHORT $L61822
$L61819:

; 185  : 			strcpy(movieName,filename);

  0044d	8b 55 0c	 mov	 edx, DWORD PTR _filename$[ebp]
  00450	52		 push	 edx
  00451	68 00 00 00 00	 push	 OFFSET FLAT:_movieName
  00456	e8 00 00 00 00	 call	 _strcpy
  0045b	83 c4 08	 add	 esp, 8
$L61822:

; 186  : 		
; 187  : 		if (!access(movieName, 0)) {

  0045e	6a 00		 push	 0
  00460	68 00 00 00 00	 push	 OFFSET FLAT:_movieName
  00465	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__access
  0046b	83 c4 08	 add	 esp, 8
  0046e	85 c0		 test	 eax, eax
  00470	75 0c		 jne	 SHORT $L61823

; 188  : 			movieFound = TRUE;

  00472	c7 85 f4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _movieFound$[ebp], 1

; 189  : 			break;	// file was found

  0047c	eb 05		 jmp	 SHORT $L61815
$L61823:

; 191  : 	}

  0047e	e9 0e ff ff ff	 jmp	 $L61814
$L61815:

; 192  : 	
; 193  : 	if(!movieFound) {

  00483	83 bd f4 fe ff
	ff 00		 cmp	 DWORD PTR _movieFound$[ebp], 0
  0048a	75 07		 jne	 SHORT $L61824

; 194  : #ifdef DEBUG
; 195  : 	   msgMgr->Alert(SrcLoc, "AVI: %s Not Found ", movieName);
; 196  : #endif
; 197  : 		return AVI_OPEN_FAIL;

  0048c	b8 02 00 00 00	 mov	 eax, 2
  00491	eb 5c		 jmp	 SHORT $L61810
$L61824:

; 202  : 	char resultStr[255];
; 203  : 
; 204  : 	sprintf(str,"open %s alias sciMovie%-1d wait",movieName,movieNo);

  00493	8b 45 08	 mov	 eax, DWORD PTR _movieNo$[ebp]
  00496	50		 push	 eax
  00497	68 00 00 00 00	 push	 OFFSET FLAT:_movieName
  0049c	68 00 00 00 00	 push	 OFFSET FLAT:$SG61827
  004a1	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _str$[ebp]
  004a7	51		 push	 ecx
  004a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  004ae	83 c4 10	 add	 esp, 16			; 00000010H

; 205  : 	DWORD errorCode = mciSendString(str,resultStr,80,0L);

  004b1	6a 00		 push	 0
  004b3	6a 50		 push	 80			; 00000050H
  004b5	8d 95 f4 fd ff
	ff		 lea	 edx, DWORD PTR _resultStr$[ebp]
  004bb	52		 push	 edx
  004bc	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _str$[ebp]
  004c2	50		 push	 eax
  004c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendStringA@16
  004c9	89 85 fc fe ff
	ff		 mov	 DWORD PTR _errorCode$[ebp], eax

; 206  : 
; 207  : 	if(errorCode) {

  004cf	83 bd fc fe ff
	ff 00		 cmp	 DWORD PTR _errorCode$[ebp], 0
  004d6	74 07		 je	 SHORT $L61829

; 208  : #ifdef DEBUG
; 209  : 		mciGetErrorString(errorCode,str,200);
; 210  : 		msgMgr->Fatal(SrcLoc, "AVI Open Failed.  Return Value: %s", str);
; 211  : #endif
; 212  : //		msgMgr->Fatal(SrcLoc,Msg_AVIOpen);
; 213  : 		return AVI_OPEN_FAIL;

  004d8	b8 02 00 00 00	 mov	 eax, 2
  004dd	eb 10		 jmp	 SHORT $L61810
$L61829:

; 215  : 	aviStatus[movieNo] = statusOpen;

  004df	8b 4d 08	 mov	 ecx, DWORD PTR _movieNo$[ebp]
  004e2	c7 04 8d 00 00
	00 00 01 00 00
	00		 mov	 DWORD PTR _aviStatus[ecx*4], 1

; 216  : 	return AVI_NO_ERROR;

  004ed	33 c0		 xor	 eax, eax
$L61810:

; 217  : }

  004ef	8b e5		 mov	 esp, ebp
  004f1	5d		 pop	 ebp
  004f2	c3		 ret	 0
_AviOpen ENDP
_TEXT	ENDS
EXTRN	?graphMgr@@3PAVGraphicsMgr@@A:DWORD		; graphMgr
EXTRN	?Fatal@MsgMgr@@QAAXDPADHHZZ:NEAR		; MsgMgr::Fatal
EXTRN	?msgMgr@@3PAVMsgMgr@@A:DWORD			; msgMgr
EXTRN	?hPal@@3PAUHPALETTE__@@A:DWORD			; hPal
_DATA	SEGMENT
$SG61835 DB	'setvideo sciMovie%-1d palette handle to %u wait', 00H
$SG61838 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Movi'
	DB	'ew.cpp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_movieNo$ = 8
_str$ = -80
_resultStr$ = -164
_errorCode$ = -84
_AviSetPalette PROC NEAR

; 220  : {

  004f3	55		 push	 ebp
  004f4	8b ec		 mov	 ebp, esp
  004f6	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH

; 221  : 	char str[80];
; 222  : 	char resultStr[80];
; 223  : 	
; 224  : 	graphMgr->GPalette().UpdateForFrame();

  004fc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  00501	8b 10		 mov	 edx, DWORD PTR [eax]
  00503	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  00509	ff 52 1c	 call	 DWORD PTR [edx+28]
  0050c	89 85 58 ff ff
	ff		 mov	 DWORD PTR -168+[ebp], eax
  00512	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR -168+[ebp]
  00518	8b 10		 mov	 edx, DWORD PTR [eax]
  0051a	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR -168+[ebp]
  00520	ff 52 1c	 call	 DWORD PTR [edx+28]

; 225  : 	graphMgr->GPalette().UpdateHardware();

  00523	a1 00 00 00 00	 mov	 eax, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  00528	8b 10		 mov	 edx, DWORD PTR [eax]
  0052a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  00530	ff 52 1c	 call	 DWORD PTR [edx+28]
  00533	89 85 54 ff ff
	ff		 mov	 DWORD PTR -172+[ebp], eax
  00539	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR -172+[ebp]
  0053f	8b 10		 mov	 edx, DWORD PTR [eax]
  00541	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR -172+[ebp]
  00547	ff 92 80 00 00
	00		 call	 DWORD PTR [edx+128]

; 226  :   	sprintf(str,"setvideo sciMovie%-1d palette handle to %u wait",movieNo,hPal);

  0054d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hPal@@3PAUHPALETTE__@@A ; hPal
  00552	50		 push	 eax
  00553	8b 4d 08	 mov	 ecx, DWORD PTR _movieNo$[ebp]
  00556	51		 push	 ecx
  00557	68 00 00 00 00	 push	 OFFSET FLAT:$SG61835
  0055c	8d 55 b0	 lea	 edx, DWORD PTR _str$[ebp]
  0055f	52		 push	 edx
  00560	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  00566	83 c4 10	 add	 esp, 16			; 00000010H

; 227  : 	DWORD errorCode = mciSendString(str,resultStr,80,0L);

  00569	6a 00		 push	 0
  0056b	6a 50		 push	 80			; 00000050H
  0056d	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR _resultStr$[ebp]
  00573	50		 push	 eax
  00574	8d 4d b0	 lea	 ecx, DWORD PTR _str$[ebp]
  00577	51		 push	 ecx
  00578	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendStringA@16
  0057e	89 45 ac	 mov	 DWORD PTR _errorCode$[ebp], eax

; 228  : 	if(errorCode) {

  00581	83 7d ac 00	 cmp	 DWORD PTR _errorCode$[ebp], 0
  00585	74 27		 je	 SHORT $L61837

; 229  : #ifdef DEBUG
; 230  : 	   msgMgr->Alert(SrcLoc, "AVI Set Palette Failed.  Return Value: %d", errorCode);
; 231  : #endif
; 232  : 		msgMgr->Fatal(SrcLoc,Msg_AVISetPalette);

  00587	68 91 00 00 00	 push	 145			; 00000091H
  0058c	68 e8 00 00 00	 push	 232			; 000000e8H
  00591	68 00 00 00 00	 push	 OFFSET FLAT:$SG61838
  00596	6a 61		 push	 97			; 00000061H
  00598	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  0059e	52		 push	 edx
  0059f	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXDPADHHZZ ; MsgMgr::Fatal
  005a4	83 c4 14	 add	 esp, 20			; 00000014H

; 233  : 
; 234  : 		return AVI_PALETTE_FAIL;

  005a7	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  005ac	eb 02		 jmp	 SHORT $L61832
$L61837:

; 236  : 
; 237  : 	return AVI_NO_ERROR;

  005ae	33 c0		 xor	 eax, eax
$L61832:

; 238  : }

  005b0	8b e5		 mov	 esp, ebp
  005b2	5d		 pop	 ebp
  005b3	c3		 ret	 0
_AviSetPalette ENDP
_TEXT	ENDS
EXTRN	__imp__RealizePalette@4:NEAR
EXTRN	__imp__SelectPalette@12:NEAR
EXTRN	?DeletePlane@GraphicsMgr@@QAEXPAVSOL_Plane@@@Z:NEAR ; GraphicsMgr::DeletePlane
EXTRN	?hMyDC@@3PAUHDC__@@A:DWORD			; hMyDC
EXTRN	?hOldPal@@3PAUHPALETTE__@@A:DWORD		; hOldPal
_BSS	SEGMENT
_moviePlane DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
	ORG $+1
$SG61844 DB	'close sciMovie%-1d', 00H
_DATA	ENDS
_TEXT	SEGMENT
_movieNo$ = 8
_str$ = -32
_AviClose PROC NEAR

; 242  : {

  005b4	55		 push	 ebp
  005b5	8b ec		 mov	 ebp, esp
  005b7	83 ec 20	 sub	 esp, 32			; 00000020H

; 243  : 	char str[30];
; 244  : 
; 245  : 	if(aviStatus[movieNo] == statusNotOpen)

  005ba	8b 45 08	 mov	 eax, DWORD PTR _movieNo$[ebp]
  005bd	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _aviStatus[eax*4], 0
  005c5	75 04		 jne	 SHORT $L61843

; 246  : 		return 0;

  005c7	33 c0		 xor	 eax, eax
  005c9	eb 6f		 jmp	 SHORT $L61841
$L61843:

; 247  : 
; 248  : 	sprintf(str,"close sciMovie%-1d",movieNo);

  005cb	8b 4d 08	 mov	 ecx, DWORD PTR _movieNo$[ebp]
  005ce	51		 push	 ecx
  005cf	68 00 00 00 00	 push	 OFFSET FLAT:$SG61844
  005d4	8d 55 e0	 lea	 edx, DWORD PTR _str$[ebp]
  005d7	52		 push	 edx
  005d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  005de	83 c4 0c	 add	 esp, 12			; 0000000cH

; 249  : 	mciSendString(str,NULL,0,0);

  005e1	6a 00		 push	 0
  005e3	6a 00		 push	 0
  005e5	6a 00		 push	 0
  005e7	8d 45 e0	 lea	 eax, DWORD PTR _str$[ebp]
  005ea	50		 push	 eax
  005eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendStringA@16

; 250  : 
; 251  : 	hOldPal = SelectPalette (hMyDC, hPal, 0);

  005f1	6a 00		 push	 0
  005f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hPal@@3PAUHPALETTE__@@A ; hPal
  005f9	51		 push	 ecx
  005fa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hMyDC@@3PAUHDC__@@A ; hMyDC
  00600	52		 push	 edx
  00601	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectPalette@12
  00607	a3 00 00 00 00	 mov	 DWORD PTR ?hOldPal@@3PAUHPALETTE__@@A, eax ; hOldPal

; 252  : 	RealizePalette (hMyDC);

  0060c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hMyDC@@3PAUHDC__@@A ; hMyDC
  00611	50		 push	 eax
  00612	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RealizePalette@4

; 253  : 
; 254  : 	aviStatus[movieNo] = statusNotOpen;	

  00618	8b 4d 08	 mov	 ecx, DWORD PTR _movieNo$[ebp]
  0061b	c7 04 8d 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _aviStatus[ecx*4], 0

; 255  : 	graphMgr->DeletePlane(moviePlane);

  00626	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _moviePlane
  0062c	52		 push	 edx
  0062d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  00633	e8 00 00 00 00	 call	 ?DeletePlane@GraphicsMgr@@QAEXPAVSOL_Plane@@@Z ; GraphicsMgr::DeletePlane

; 256  : 
; 257  : 	return AVI_NO_ERROR;

  00638	33 c0		 xor	 eax, eax
$L61841:

; 258  : }

  0063a	8b e5		 mov	 esp, ebp
  0063c	5d		 pop	 ebp
  0063d	c3		 ret	 0
_AviClose ENDP
_TEXT	ENDS
PUBLIC	??0SOL_Rect@@QAE@XZ				; SOL_Rect::SOL_Rect
PUBLIC	??0SOL_Rect@@QAE@HHHH@Z				; SOL_Rect::SOL_Rect
PUBLIC	?Set@SOL_Rect@@QAEXHHHH@Z			; SOL_Rect::Set
PUBLIC	??0SOL_Rect@@QAE@ABV0@@Z			; SOL_Rect::SOL_Rect
PUBLIC	??0Ratio@@QAE@HH@Z				; Ratio::Ratio
PUBLIC	??D@YAHHABVRatio@@@Z				; operator*
PUBLIC	?AddPlane@GraphicsMgr@@QAEXPAVSOL_Plane@@@Z	; GraphicsMgr::AddPlane
EXTRN	__imp__atoi:NEAR
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??0SOL_Plane@@QAE@ABVSOL_Rect@@@Z:NEAR		; SOL_Plane::SOL_Plane
EXTRN	?gameWidth@@3HA:DWORD				; gameWidth
EXTRN	?gameHeight@@3HA:DWORD				; gameHeight
EXTRN	?gameBorderX@@3HA:DWORD				; gameBorderX
EXTRN	?gameBorderY@@3HA:DWORD				; gameBorderY
_DATA	SEGMENT
	ORG $+1
$SG61858 DB	'where sciMovie%-1d source max wait', 00H
	ORG $+1
$SG61860 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Movi'
	DB	'ew.cpp', 00H
	ORG $+1
$SG61882 DB	'put sciMovie%-1d destination at %u %u %u %u wait', 00H
	ORG $+3
$SG61884 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Movi'
	DB	'ew.cpp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_movieNo$ = 8
_x$ = 12
_y$ = 16
_width$ = 20
_height$ = 24
_rect$ = -20
_str$ = -276
_retStr$ = -532
_errorCode$ = -544
_aviWidth$ = -540
_aviHeight$ = -536
_start$ = -568
_ptr$ = -4
_sRect$ = -564
_sRight$ = -548
_sBottom$ = -572
$T62314 = -580
$T62315 = -588
$T62316 = -596
$T62317 = -604
$T62318 = -612
$T62319 = -620
$T62320 = -628
$T62321 = -636
$T62322 = -640
$T62323 = -644
$T62326 = -648
$T62327 = -664
_AviPut	PROC NEAR

; 261  : { 

  0063e	55		 push	 ebp
  0063f	8b ec		 mov	 ebp, esp
  00641	81 ec 9c 02 00
	00		 sub	 esp, 668		; 0000029cH

; 262  : 
; 263  : 	// This may need some beefing up in cases where the user does not
; 264  : 	// wish to play to the SCI window, but a seperate child window.
; 265  : 
; 266  : 	RECT rect;
; 267  : 	// BOOL mciRet;
; 268  : 	char str[255];				  
; 269  : 	char retStr[255];
; 270  : 	DWORD errorCode;
; 271  : 	int aviWidth,aviHeight;
; 272  : 
; 273  : 	// Get the AVIs actual width and height;
; 274  : 		/* get the original size of the movie */
; 275  : 
; 276  : 	sprintf(str,"where sciMovie%-1d source max wait",movieNo);

  00647	8b 45 08	 mov	 eax, DWORD PTR _movieNo$[ebp]
  0064a	50		 push	 eax
  0064b	68 00 00 00 00	 push	 OFFSET FLAT:$SG61858
  00650	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _str$[ebp]
  00656	51		 push	 ecx
  00657	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  0065d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 277  : 	errorCode = mciSendString(str,retStr,255,0L);

  00660	6a 00		 push	 0
  00662	68 ff 00 00 00	 push	 255			; 000000ffH
  00667	8d 95 ec fd ff
	ff		 lea	 edx, DWORD PTR _retStr$[ebp]
  0066d	52		 push	 edx
  0066e	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _str$[ebp]
  00674	50		 push	 eax
  00675	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendStringA@16
  0067b	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _errorCode$[ebp], eax

; 278  : 	if(errorCode) {

  00681	83 bd e0 fd ff
	ff 00		 cmp	 DWORD PTR _errorCode$[ebp], 0
  00688	74 2a		 je	 SHORT $L61859

; 279  : #ifdef DEBUG
; 280  :    msgMgr->Alert(SrcLoc, "AVI Where Failed.  Return Value: %d", errorCode);
; 281  : #endif
; 282  : 
; 283  : 		msgMgr->Fatal(SrcLoc,Msg_AVIPut);

  0068a	68 90 00 00 00	 push	 144			; 00000090H
  0068f	68 1b 01 00 00	 push	 283			; 0000011bH
  00694	68 00 00 00 00	 push	 OFFSET FLAT:$SG61860
  00699	6a 61		 push	 97			; 00000061H
  0069b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  006a1	51		 push	 ecx
  006a2	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXDPADHHZZ ; MsgMgr::Fatal
  006a7	83 c4 14	 add	 esp, 20			; 00000014H

; 284  : 		return AVI_WHERE_FAIL;

  006aa	b8 04 00 00 00	 mov	 eax, 4
  006af	e9 6c 03 00 00	 jmp	 $L61851
$L61859:

; 289  : 	char * ptr = retStr;

  006b4	8d 95 ec fd ff
	ff		 lea	 edx, DWORD PTR _retStr$[ebp]
  006ba	89 55 fc	 mov	 DWORD PTR _ptr$[ebp], edx
$L61864:

; 290  : 	// get the left - always 0
; 291  : 	while(*ptr++ != ' ');

  006bd	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  006c0	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  006c3	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  006c6	83 c2 01	 add	 edx, 1
  006c9	89 55 fc	 mov	 DWORD PTR _ptr$[ebp], edx
  006cc	83 f9 20	 cmp	 ecx, 32			; 00000020H
  006cf	74 02		 je	 SHORT $L61865
  006d1	eb ea		 jmp	 SHORT $L61864
$L61865:

; 292  : 	// get the top - always 0
; 293  : 	while(*ptr++ != ' ');

  006d3	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  006d6	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  006d9	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  006dc	83 c2 01	 add	 edx, 1
  006df	89 55 fc	 mov	 DWORD PTR _ptr$[ebp], edx
  006e2	83 f9 20	 cmp	 ecx, 32			; 00000020H
  006e5	74 02		 je	 SHORT $L61868
  006e7	eb ea		 jmp	 SHORT $L61865
$L61868:

; 294  : 	
; 295  : 	// get the width
; 296  : 	start = ptr;

  006e9	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  006ec	89 85 c8 fd ff
	ff		 mov	 DWORD PTR _start$[ebp], eax
$L61870:

; 297  : 	while(*ptr != ' ') {

  006f2	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  006f5	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  006f8	83 fa 20	 cmp	 edx, 32			; 00000020H
  006fb	74 0b		 je	 SHORT $L61871

; 298  : 		ptr++;

  006fd	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  00700	83 c0 01	 add	 eax, 1
  00703	89 45 fc	 mov	 DWORD PTR _ptr$[ebp], eax

; 299  : 	}

  00706	eb ea		 jmp	 SHORT $L61870
$L61871:

; 300  : 
; 301  : 	*ptr++ = '\0';

  00708	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  0070b	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0070e	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  00711	83 c2 01	 add	 edx, 1
  00714	89 55 fc	 mov	 DWORD PTR _ptr$[ebp], edx

; 302  : 	aviWidth = atoi(start);

  00717	8b 85 c8 fd ff
	ff		 mov	 eax, DWORD PTR _start$[ebp]
  0071d	50		 push	 eax
  0071e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00724	83 c4 04	 add	 esp, 4
  00727	89 85 e4 fd ff
	ff		 mov	 DWORD PTR _aviWidth$[ebp], eax

; 303  : 	aviHeight = atoi(ptr);

  0072d	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00730	51		 push	 ecx
  00731	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00737	83 c4 04	 add	 esp, 4
  0073a	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _aviHeight$[ebp], eax

; 304  : 
; 305  : 
; 306  : 	if (width && height) {

  00740	83 7d 14 00	 cmp	 DWORD PTR _width$[ebp], 0
  00744	0f 84 b6 00 00
	00		 je	 $L61872
  0074a	83 7d 18 00	 cmp	 DWORD PTR _height$[ebp], 0
  0074e	0f 84 ac 00 00
	00		 je	 $L61872

; 307  : 
; 308  : 		rect.left = x * Ratio(gameWidth, SCIRESX) + gameBorderX;

  00754	68 80 02 00 00	 push	 640			; 00000280H
  00759	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gameWidth@@3HA ; gameWidth
  0075f	52		 push	 edx
  00760	8d 8d bc fd ff
	ff		 lea	 ecx, DWORD PTR $T62314[ebp]
  00766	e8 00 00 00 00	 call	 ??0Ratio@@QAE@HH@Z	; Ratio::Ratio
  0076b	50		 push	 eax
  0076c	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  0076f	50		 push	 eax
  00770	e8 00 00 00 00	 call	 ??D@YAHHABVRatio@@@Z	; operator*
  00775	83 c4 08	 add	 esp, 8
  00778	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gameBorderX@@3HA ; gameBorderX
  0077e	89 45 ec	 mov	 DWORD PTR _rect$[ebp], eax

; 309  : 		rect.top = y * Ratio(gameHeight, SCIRESY) + gameBorderY;

  00781	68 e0 01 00 00	 push	 480			; 000001e0H
  00786	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gameHeight@@3HA ; gameHeight
  0078c	51		 push	 ecx
  0078d	8d 8d b4 fd ff
	ff		 lea	 ecx, DWORD PTR $T62315[ebp]
  00793	e8 00 00 00 00	 call	 ??0Ratio@@QAE@HH@Z	; Ratio::Ratio
  00798	50		 push	 eax
  00799	8b 55 10	 mov	 edx, DWORD PTR _y$[ebp]
  0079c	52		 push	 edx
  0079d	e8 00 00 00 00	 call	 ??D@YAHHABVRatio@@@Z	; operator*
  007a2	83 c4 08	 add	 esp, 8
  007a5	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gameBorderY@@3HA ; gameBorderY
  007ab	89 45 f0	 mov	 DWORD PTR _rect$[ebp+4], eax

; 310  : 		rect.right = width * Ratio(gameWidth, SCIRESX);

  007ae	68 80 02 00 00	 push	 640			; 00000280H
  007b3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gameWidth@@3HA ; gameWidth
  007b8	50		 push	 eax
  007b9	8d 8d ac fd ff
	ff		 lea	 ecx, DWORD PTR $T62316[ebp]
  007bf	e8 00 00 00 00	 call	 ??0Ratio@@QAE@HH@Z	; Ratio::Ratio
  007c4	50		 push	 eax
  007c5	8b 4d 14	 mov	 ecx, DWORD PTR _width$[ebp]
  007c8	51		 push	 ecx
  007c9	e8 00 00 00 00	 call	 ??D@YAHHABVRatio@@@Z	; operator*
  007ce	83 c4 08	 add	 esp, 8
  007d1	89 45 f4	 mov	 DWORD PTR _rect$[ebp+8], eax

; 311  : 		rect.bottom = height * Ratio(gameHeight, SCIRESY);

  007d4	68 e0 01 00 00	 push	 480			; 000001e0H
  007d9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gameHeight@@3HA ; gameHeight
  007df	52		 push	 edx
  007e0	8d 8d a4 fd ff
	ff		 lea	 ecx, DWORD PTR $T62317[ebp]
  007e6	e8 00 00 00 00	 call	 ??0Ratio@@QAE@HH@Z	; Ratio::Ratio
  007eb	50		 push	 eax
  007ec	8b 45 18	 mov	 eax, DWORD PTR _height$[ebp]
  007ef	50		 push	 eax
  007f0	e8 00 00 00 00	 call	 ??D@YAHHABVRatio@@@Z	; operator*
  007f5	83 c4 08	 add	 esp, 8
  007f8	89 45 f8	 mov	 DWORD PTR _rect$[ebp+12], eax

; 312  : 
; 313  : #ifdef DEBUG
; 314  : 		if(rect.right != aviWidth || rect.bottom != aviHeight) {
; 315  : 			if(rect.right == aviWidth * 2 && rect.bottom == aviHeight * 2){}
; 316  : 			else 
; 317  : 				msgMgr->Alert("Your AVI width and/or height do not match the AVI");
; 318  : 		}
; 319  : #endif
; 320  :    } else {

  007fb	e9 b8 00 00 00	 jmp	 $L61877
$L61872:

; 321  : 		rect.left = x * Ratio(gameWidth, SCIRESX) + gameBorderX;

  00800	68 80 02 00 00	 push	 640			; 00000280H
  00805	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gameWidth@@3HA ; gameWidth
  0080b	51		 push	 ecx
  0080c	8d 8d 9c fd ff
	ff		 lea	 ecx, DWORD PTR $T62318[ebp]
  00812	e8 00 00 00 00	 call	 ??0Ratio@@QAE@HH@Z	; Ratio::Ratio
  00817	50		 push	 eax
  00818	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  0081b	52		 push	 edx
  0081c	e8 00 00 00 00	 call	 ??D@YAHHABVRatio@@@Z	; operator*
  00821	83 c4 08	 add	 esp, 8
  00824	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gameBorderX@@3HA ; gameBorderX
  0082a	89 45 ec	 mov	 DWORD PTR _rect$[ebp], eax

; 322  : 		rect.top = y * Ratio(gameHeight, SCIRESY) + gameBorderY;

  0082d	68 e0 01 00 00	 push	 480			; 000001e0H
  00832	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gameHeight@@3HA ; gameHeight
  00837	50		 push	 eax
  00838	8d 8d 94 fd ff
	ff		 lea	 ecx, DWORD PTR $T62319[ebp]
  0083e	e8 00 00 00 00	 call	 ??0Ratio@@QAE@HH@Z	; Ratio::Ratio
  00843	50		 push	 eax
  00844	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  00847	51		 push	 ecx
  00848	e8 00 00 00 00	 call	 ??D@YAHHABVRatio@@@Z	; operator*
  0084d	83 c4 08	 add	 esp, 8
  00850	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gameBorderY@@3HA ; gameBorderY
  00856	89 45 f0	 mov	 DWORD PTR _rect$[ebp+4], eax

; 323  : 		rect.right = aviWidth;

  00859	8b 95 e4 fd ff
	ff		 mov	 edx, DWORD PTR _aviWidth$[ebp]
  0085f	89 55 f4	 mov	 DWORD PTR _rect$[ebp+8], edx

; 324  : 		rect.bottom = aviHeight;

  00862	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _aviHeight$[ebp]
  00868	89 45 f8	 mov	 DWORD PTR _rect$[ebp+12], eax

; 325  : 		// setup width and height for the plane creation
; 326  : 		width = rect.right * Ratio(SCIRESX,gameWidth);

  0086b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gameWidth@@3HA ; gameWidth
  00871	51		 push	 ecx
  00872	68 80 02 00 00	 push	 640			; 00000280H
  00877	8d 8d 8c fd ff
	ff		 lea	 ecx, DWORD PTR $T62320[ebp]
  0087d	e8 00 00 00 00	 call	 ??0Ratio@@QAE@HH@Z	; Ratio::Ratio
  00882	50		 push	 eax
  00883	8b 55 f4	 mov	 edx, DWORD PTR _rect$[ebp+8]
  00886	52		 push	 edx
  00887	e8 00 00 00 00	 call	 ??D@YAHHABVRatio@@@Z	; operator*
  0088c	83 c4 08	 add	 esp, 8
  0088f	89 45 14	 mov	 DWORD PTR _width$[ebp], eax

; 327  : 		height = rect.bottom * Ratio(SCIRESY,gameHeight);

  00892	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gameHeight@@3HA ; gameHeight
  00897	50		 push	 eax
  00898	68 e0 01 00 00	 push	 480			; 000001e0H
  0089d	8d 8d 84 fd ff
	ff		 lea	 ecx, DWORD PTR $T62321[ebp]
  008a3	e8 00 00 00 00	 call	 ??0Ratio@@QAE@HH@Z	; Ratio::Ratio
  008a8	50		 push	 eax
  008a9	8b 4d f8	 mov	 ecx, DWORD PTR _rect$[ebp+12]
  008ac	51		 push	 ecx
  008ad	e8 00 00 00 00	 call	 ??D@YAHHABVRatio@@@Z	; operator*
  008b2	83 c4 08	 add	 esp, 8
  008b5	89 45 18	 mov	 DWORD PTR _height$[ebp], eax
$L61877:

; 329  : 
; 330  : 	sprintf(str,"put sciMovie%-1d destination at %u %u %u %u wait",movieNo,rect.left,
; 331  : 		rect.top,rect.right,rect.bottom);

  008b8	8b 55 f8	 mov	 edx, DWORD PTR _rect$[ebp+12]
  008bb	52		 push	 edx
  008bc	8b 45 f4	 mov	 eax, DWORD PTR _rect$[ebp+8]
  008bf	50		 push	 eax
  008c0	8b 4d f0	 mov	 ecx, DWORD PTR _rect$[ebp+4]
  008c3	51		 push	 ecx
  008c4	8b 55 ec	 mov	 edx, DWORD PTR _rect$[ebp]
  008c7	52		 push	 edx
  008c8	8b 45 08	 mov	 eax, DWORD PTR _movieNo$[ebp]
  008cb	50		 push	 eax
  008cc	68 00 00 00 00	 push	 OFFSET FLAT:$SG61882
  008d1	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _str$[ebp]
  008d7	51		 push	 ecx
  008d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  008de	83 c4 1c	 add	 esp, 28			; 0000001cH

; 332  : 
; 333  : 	errorCode = mciSendString(str,retStr,80,0L);

  008e1	6a 00		 push	 0
  008e3	6a 50		 push	 80			; 00000050H
  008e5	8d 95 ec fd ff
	ff		 lea	 edx, DWORD PTR _retStr$[ebp]
  008eb	52		 push	 edx
  008ec	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _str$[ebp]
  008f2	50		 push	 eax
  008f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendStringA@16
  008f9	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _errorCode$[ebp], eax

; 334  : 	if(errorCode) {

  008ff	83 bd e0 fd ff
	ff 00		 cmp	 DWORD PTR _errorCode$[ebp], 0
  00906	74 2a		 je	 SHORT $L61883

; 335  : #ifdef DEBUG
; 336  : 	   msgMgr->Alert(SrcLoc, "AVI Put Failed.  Return Value: %d", errorCode);
; 337  : #endif
; 338  : 
; 339  : 		msgMgr->Fatal(SrcLoc,Msg_AVIPut);

  00908	68 90 00 00 00	 push	 144			; 00000090H
  0090d	68 53 01 00 00	 push	 339			; 00000153H
  00912	68 00 00 00 00	 push	 OFFSET FLAT:$SG61884
  00917	6a 61		 push	 97			; 00000061H
  00919	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  0091f	51		 push	 ecx
  00920	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXDPADHHZZ ; MsgMgr::Fatal
  00925	83 c4 14	 add	 esp, 20			; 00000014H

; 340  : 		return AVI_PUT_FAIL;

  00928	b8 05 00 00 00	 mov	 eax, 5
  0092d	e9 ee 00 00 00	 jmp	 $L61851
$L61883:

; 342  : 
; 343  : 	// create a plane for the movie to play in (protect it from SCI)
; 344  : 	// First, create an SOL_RECT with lo-res coordinates and offset by top/left
; 345  : 	SOL_Rect sRect;

  00932	8d 8d cc fd ff
	ff		 lea	 ecx, DWORD PTR _sRect$[ebp]
  00938	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@XZ	; SOL_Rect::SOL_Rect

; 346  : 	int sRight = x + width - 1;

  0093d	8b 55 14	 mov	 edx, DWORD PTR _width$[ebp]
  00940	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  00943	8d 4c 10 ff	 lea	 ecx, DWORD PTR [eax+edx-1]
  00947	89 8d dc fd ff
	ff		 mov	 DWORD PTR _sRight$[ebp], ecx

; 347  : 	int sBottom = y + height - 1;

  0094d	8b 55 18	 mov	 edx, DWORD PTR _height$[ebp]
  00950	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  00953	8d 4c 10 ff	 lea	 ecx, DWORD PTR [eax+edx-1]
  00957	89 8d c4 fd ff
	ff		 mov	 DWORD PTR _sBottom$[ebp], ecx

; 348  : 	sRect.Set(x,y,sRight,sBottom);

  0095d	8b 95 c4 fd ff
	ff		 mov	 edx, DWORD PTR _sBottom$[ebp]
  00963	52		 push	 edx
  00964	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _sRight$[ebp]
  0096a	50		 push	 eax
  0096b	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  0096e	51		 push	 ecx
  0096f	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  00972	52		 push	 edx
  00973	8d 8d cc fd ff
	ff		 lea	 ecx, DWORD PTR _sRect$[ebp]
  00979	e8 00 00 00 00	 call	 ?Set@SOL_Rect@@QAEXHHHH@Z ; SOL_Rect::Set

; 349  : 	moviePlane = New SOL_Plane(sRect);

  0097e	68 c8 9c 00 00	 push	 40136			; 00009cc8H
  00983	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00988	83 c4 04	 add	 esp, 4
  0098b	89 85 7c fd ff
	ff		 mov	 DWORD PTR $T62323[ebp], eax
  00991	83 bd 7c fd ff
	ff 00		 cmp	 DWORD PTR $T62323[ebp], 0
  00998	74 1a		 je	 SHORT $L62324
  0099a	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _sRect$[ebp]
  009a0	50		 push	 eax
  009a1	8b 8d 7c fd ff
	ff		 mov	 ecx, DWORD PTR $T62323[ebp]
  009a7	e8 00 00 00 00	 call	 ??0SOL_Plane@@QAE@ABVSOL_Rect@@@Z ; SOL_Plane::SOL_Plane
  009ac	89 85 64 fd ff
	ff		 mov	 DWORD PTR -668+[ebp], eax
  009b2	eb 0a		 jmp	 SHORT $L62325
$L62324:
  009b4	c7 85 64 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR -668+[ebp], 0
$L62325:
  009be	8b 8d 64 fd ff
	ff		 mov	 ecx, DWORD PTR -668+[ebp]
  009c4	89 8d 80 fd ff
	ff		 mov	 DWORD PTR $T62322[ebp], ecx
  009ca	8b 95 80 fd ff
	ff		 mov	 edx, DWORD PTR $T62322[ebp]
  009d0	89 15 00 00 00
	00		 mov	 DWORD PTR _moviePlane, edx

; 350  : 	graphMgr->AddPlane(moviePlane);

  009d6	a1 00 00 00 00	 mov	 eax, DWORD PTR _moviePlane
  009db	50		 push	 eax
  009dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  009e2	e8 00 00 00 00	 call	 ?AddPlane@GraphicsMgr@@QAEXPAVSOL_Plane@@@Z ; GraphicsMgr::AddPlane

; 351  : 	graphMgr->FrameOut(TRUE);

  009e7	6a ff		 push	 -1
  009e9	6a ff		 push	 -1
  009eb	6a 00		 push	 0
  009ed	6a 00		 push	 0
  009ef	8d 8d 68 fd ff
	ff		 lea	 ecx, DWORD PTR $T62327[ebp]
  009f5	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@HHHH@Z	; SOL_Rect::SOL_Rect
  009fa	83 ec 10	 sub	 esp, 16			; 00000010H
  009fd	8b cc		 mov	 ecx, esp
  009ff	89 a5 78 fd ff
	ff		 mov	 DWORD PTR $T62326[ebp], esp
  00a05	50		 push	 eax
  00a06	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@ABV0@@Z ; SOL_Rect::SOL_Rect
  00a0b	6a 01		 push	 1
  00a0d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  00a13	8b 11		 mov	 edx, DWORD PTR [ecx]
  00a15	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  00a1b	ff 52 14	 call	 DWORD PTR [edx+20]

; 352  : 
; 353  : 	return AVI_NO_ERROR;

  00a1e	33 c0		 xor	 eax, eax
$L61851:

; 354  : }

  00a20	8b e5		 mov	 esp, ebp
  00a22	5d		 pop	 ebp
  00a23	c3		 ret	 0
_AviPut	ENDP
_TEXT	ENDS
PUBLIC	??0SOL_Point@@QAE@XZ				; SOL_Point::SOL_Point
;	COMDAT ??0SOL_Rect@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0SOL_Rect@@QAE@XZ PROC NEAR				; SOL_Rect::SOL_Rect, COMDAT

; 13   : 	SOL_Rect()  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 08	 add	 ecx, 8
  00015	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0SOL_Rect@@QAE@XZ ENDP				; SOL_Rect::SOL_Rect
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0SOL_Point@@QAE@XZ PROC NEAR				; SOL_Point::SOL_Point, COMDAT

; 20   : 	SOL_Point() : x(DefaultCoord), y(DefaultCoord) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 ef cd ab
	89		 mov	 DWORD PTR [eax], -1985229329 ; 89abcdefH
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 ef cd
	ab 89		 mov	 DWORD PTR [ecx+4], -1985229329 ; 89abcdefH
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0SOL_Point@@QAE@XZ ENDP				; SOL_Point::SOL_Point
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@HHHH@Z
_TEXT	SEGMENT
_xa$ = 8
_ya$ = 12
_xb$ = 16
_yb$ = 20
_this$ = -4
??0SOL_Rect@@QAE@HHHH@Z PROC NEAR			; SOL_Rect::SOL_Rect, COMDAT

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 08	 add	 ecx, 8
  00015	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point

; 56   : 	A.x = xa;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _xa$[ebp]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 57   : 	A.y = ya;

  00022	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00025	8b 45 0c	 mov	 eax, DWORD PTR _ya$[ebp]
  00028	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 58   : 	B.x = xb;

  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8b 55 10	 mov	 edx, DWORD PTR _xb$[ebp]
  00031	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 59   : 	B.y = yb;

  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 4d 14	 mov	 ecx, DWORD PTR _yb$[ebp]
  0003a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 60   : }

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 10 00	 ret	 16			; 00000010H
??0SOL_Rect@@QAE@HHHH@Z ENDP				; SOL_Rect::SOL_Rect
_TEXT	ENDS
;	COMDAT ?Set@SOL_Rect@@QAEXHHHH@Z
_TEXT	SEGMENT
_xa$ = 8
_ya$ = 12
_xb$ = 16
_yb$ = 20
_this$ = -4
?Set@SOL_Rect@@QAEXHHHH@Z PROC NEAR			; SOL_Rect::Set, COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 	A.x = xa;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _xa$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 75   : 	A.y = ya;

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _ya$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 76   : 	B.x = xb;

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 55 10	 mov	 edx, DWORD PTR _xb$[ebp]
  0001e	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 77   : 	B.y = yb;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 4d 14	 mov	 ecx, DWORD PTR _yb$[ebp]
  00027	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 78   : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 10 00	 ret	 16			; 00000010H
?Set@SOL_Rect@@QAEXHHHH@Z ENDP				; SOL_Rect::Set
_TEXT	ENDS
;	COMDAT ??0Ratio@@QAE@HH@Z
_TEXT	SEGMENT
_num$ = 8
_denom$ = 12
_this$ = -4
??0Ratio@@QAE@HH@Z PROC NEAR				; Ratio::Ratio, COMDAT

; 9    : 	Ratio(int num, int denom)	:	numer(num), denom(denom) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _num$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _denom$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0Ratio@@QAE@HH@Z ENDP					; Ratio::Ratio
_TEXT	ENDS
;	COMDAT ??D@YAHHABVRatio@@@Z
_TEXT	SEGMENT
_i$ = 8
_ratio$ = 12
_total$ = -8
_val$ = -4
??D@YAHHABVRatio@@@Z PROC NEAR				; operator*, COMDAT

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 54   : 	int total = i * ratio.numer;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _ratio$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  0000c	0f af 08	 imul	 ecx, DWORD PTR [eax]
  0000f	89 4d f8	 mov	 DWORD PTR _total$[ebp], ecx

; 55   : 	int val = total / ratio.denom;

  00012	8b 4d 0c	 mov	 ecx, DWORD PTR _ratio$[ebp]
  00015	8b 45 f8	 mov	 eax, DWORD PTR _total$[ebp]
  00018	99		 cdq
  00019	f7 79 04	 idiv	 DWORD PTR [ecx+4]
  0001c	89 45 fc	 mov	 DWORD PTR _val$[ebp], eax

; 56   : 	if (total > ratio.denom  &&  total % ratio.denom)

  0001f	8b 55 0c	 mov	 edx, DWORD PTR _ratio$[ebp]
  00022	8b 45 f8	 mov	 eax, DWORD PTR _total$[ebp]
  00025	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00028	7e 17		 jle	 SHORT $L57714
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _ratio$[ebp]
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _total$[ebp]
  00030	99		 cdq
  00031	f7 79 04	 idiv	 DWORD PTR [ecx+4]
  00034	85 d2		 test	 edx, edx
  00036	74 09		 je	 SHORT $L57714

; 57   : 		val++;

  00038	8b 55 fc	 mov	 edx, DWORD PTR _val$[ebp]
  0003b	83 c2 01	 add	 edx, 1
  0003e	89 55 fc	 mov	 DWORD PTR _val$[ebp], edx
$L57714:

; 58   : 	return val;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _val$[ebp]

; 59   : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
??D@YAHHABVRatio@@@Z ENDP				; operator*
_TEXT	ENDS
EXTRN	?AddPlane@Screen@@QAEXPAVSOL_Plane@@@Z:NEAR	; Screen::AddPlane
;	COMDAT ?AddPlane@GraphicsMgr@@QAEXPAVSOL_Plane@@@Z
_TEXT	SEGMENT
_plane$ = 8
_this$ = -4
?AddPlane@GraphicsMgr@@QAEXPAVSOL_Plane@@@Z PROC NEAR	; GraphicsMgr::AddPlane, COMDAT

; 59   : 	void		AddPlane(SOL_Plane* plane)				{next.AddPlane(plane);}	// cant be const

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _plane$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 14	 add	 ecx, 20			; 00000014H
  00011	e8 00 00 00 00	 call	 ?AddPlane@Screen@@QAEXPAVSOL_Plane@@@Z ; Screen::AddPlane
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?AddPlane@GraphicsMgr@@QAEXPAVSOL_Plane@@@Z ENDP	; GraphicsMgr::AddPlane
_TEXT	ENDS
PUBLIC	??0SOL_Point@@QAE@ABV0@@Z			; SOL_Point::SOL_Point
;	COMDAT ??0SOL_Rect@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0SOL_Rect@@QAE@ABV0@@Z PROC NEAR			; SOL_Rect::SOL_Rect, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  00013	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00016	83 c1 08	 add	 ecx, 8
  00019	51		 push	 ecx
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 08	 add	 ecx, 8
  00020	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??0SOL_Rect@@QAE@ABV0@@Z ENDP				; SOL_Rect::SOL_Rect
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@ABV0@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
??0SOL_Point@@QAE@ABV0@@Z PROC NEAR			; SOL_Point::SOL_Point, COMDAT

; 22   : 	SOL_Point(const SOL_Point& p) : x(p.x), y(p.y) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00017	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001a	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??0SOL_Point@@QAE@ABV0@@Z ENDP				; SOL_Point::SOL_Point
_TEXT	ENDS
_DATA	SEGMENT
	ORG $+1
$SG61905 DB	'where sciMovie%-1d source max wait', 00H
	ORG $+1
$SG61907 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Movi'
	DB	'ew.cpp', 00H
	ORG $+1
$SG61921 DB	'put sciMovie%-1d destination at %u %u %u %u wait', 00H
	ORG $+3
$SG61923 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Movi'
	DB	'ew.cpp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_movieNo$ = 8
_x$ = 12
_y$ = 16
_rect$ = -20
_str$ = -280
_retStr$ = -536
_errorCode$ = -548
_aviWidth$ = -544
_aviHeight$ = -540
_start$ = -576
_ptr$ = -4
_sRect$ = -568
_width$ = -24
_height$ = -572
_sRight$ = -552
_sBottom$ = -580
$T62338 = -588
$T62339 = -596
$T62340 = -604
$T62341 = -612
$T62342 = -616
$T62343 = -620
$T62346 = -624
$T62347 = -640
_AviPutDouble PROC NEAR

; 357  : { 

  00a24	55		 push	 ebp
  00a25	8b ec		 mov	 ebp, esp
  00a27	81 ec 84 02 00
	00		 sub	 esp, 644		; 00000284H

; 358  : 
; 359  : 	RECT rect;
; 360  : 	// BOOL mciRet;
; 361  : 	char str[255];				  
; 362  : 	char retStr[255];
; 363  : 	DWORD errorCode;
; 364  : 	int aviWidth,aviHeight;
; 365  : 
; 366  : 	// Get the AVIs actual width and height;
; 367  : 		/* get the original size of the movie */
; 368  : 
; 369  : 	sprintf(str,"where sciMovie%-1d source max wait",movieNo);

  00a2d	8b 45 08	 mov	 eax, DWORD PTR _movieNo$[ebp]
  00a30	50		 push	 eax
  00a31	68 00 00 00 00	 push	 OFFSET FLAT:$SG61905
  00a36	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _str$[ebp]
  00a3c	51		 push	 ecx
  00a3d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  00a43	83 c4 0c	 add	 esp, 12			; 0000000cH

; 370  : 	errorCode = mciSendString(str,retStr,255,0L);

  00a46	6a 00		 push	 0
  00a48	68 ff 00 00 00	 push	 255			; 000000ffH
  00a4d	8d 95 e8 fd ff
	ff		 lea	 edx, DWORD PTR _retStr$[ebp]
  00a53	52		 push	 edx
  00a54	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _str$[ebp]
  00a5a	50		 push	 eax
  00a5b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendStringA@16
  00a61	89 85 dc fd ff
	ff		 mov	 DWORD PTR _errorCode$[ebp], eax

; 371  : 	if(errorCode) {

  00a67	83 bd dc fd ff
	ff 00		 cmp	 DWORD PTR _errorCode$[ebp], 0
  00a6e	74 2a		 je	 SHORT $L61906

; 372  : #ifdef DEBUG
; 373  :    msgMgr->Alert(SrcLoc, "AVI Where Failed.  Return Value: %d", errorCode);
; 374  : #endif
; 375  : 
; 376  : 		msgMgr->Fatal(SrcLoc,Msg_AVIPut);

  00a70	68 90 00 00 00	 push	 144			; 00000090H
  00a75	68 78 01 00 00	 push	 376			; 00000178H
  00a7a	68 00 00 00 00	 push	 OFFSET FLAT:$SG61907
  00a7f	6a 61		 push	 97			; 00000061H
  00a81	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00a87	51		 push	 ecx
  00a88	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXDPADHHZZ ; MsgMgr::Fatal
  00a8d	83 c4 14	 add	 esp, 20			; 00000014H

; 377  : 		return AVI_WHERE_FAIL;

  00a90	b8 04 00 00 00	 mov	 eax, 4
  00a95	e9 b8 02 00 00	 jmp	 $L61898
$L61906:

; 382  : 	char * ptr = retStr;

  00a9a	8d 95 e8 fd ff
	ff		 lea	 edx, DWORD PTR _retStr$[ebp]
  00aa0	89 55 fc	 mov	 DWORD PTR _ptr$[ebp], edx
$L61911:

; 383  : 	// get the left - always 0
; 384  : 	while(*ptr++ != ' ');

  00aa3	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  00aa6	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00aa9	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  00aac	83 c2 01	 add	 edx, 1
  00aaf	89 55 fc	 mov	 DWORD PTR _ptr$[ebp], edx
  00ab2	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00ab5	74 02		 je	 SHORT $L61912
  00ab7	eb ea		 jmp	 SHORT $L61911
$L61912:

; 385  : 	// get the top - always 0
; 386  : 	while(*ptr++ != ' ');

  00ab9	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  00abc	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00abf	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  00ac2	83 c2 01	 add	 edx, 1
  00ac5	89 55 fc	 mov	 DWORD PTR _ptr$[ebp], edx
  00ac8	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00acb	74 02		 je	 SHORT $L61915
  00acd	eb ea		 jmp	 SHORT $L61912
$L61915:

; 387  : 	
; 388  : 	// get the width
; 389  : 	start = ptr;

  00acf	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  00ad2	89 85 c0 fd ff
	ff		 mov	 DWORD PTR _start$[ebp], eax
$L61917:

; 390  : 	while(*ptr != ' ') {

  00ad8	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00adb	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00ade	83 fa 20	 cmp	 edx, 32			; 00000020H
  00ae1	74 0b		 je	 SHORT $L61918

; 391  : 		ptr++;

  00ae3	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  00ae6	83 c0 01	 add	 eax, 1
  00ae9	89 45 fc	 mov	 DWORD PTR _ptr$[ebp], eax

; 392  : 	}

  00aec	eb ea		 jmp	 SHORT $L61917
$L61918:

; 393  : 
; 394  : 	*ptr++ = '\0';

  00aee	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00af1	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00af4	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  00af7	83 c2 01	 add	 edx, 1
  00afa	89 55 fc	 mov	 DWORD PTR _ptr$[ebp], edx

; 395  : 	aviWidth = atoi(start);

  00afd	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _start$[ebp]
  00b03	50		 push	 eax
  00b04	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00b0a	83 c4 04	 add	 esp, 4
  00b0d	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _aviWidth$[ebp], eax

; 396  : 	aviHeight = atoi(ptr);

  00b13	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00b16	51		 push	 ecx
  00b17	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00b1d	83 c4 04	 add	 esp, 4
  00b20	89 85 e4 fd ff
	ff		 mov	 DWORD PTR _aviHeight$[ebp], eax

; 397  : 
; 398  : 
; 399  : 	rect.left = x * Ratio(gameWidth, SCIRESX) + gameBorderX;

  00b26	68 80 02 00 00	 push	 640			; 00000280H
  00b2b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gameWidth@@3HA ; gameWidth
  00b31	52		 push	 edx
  00b32	8d 8d b4 fd ff
	ff		 lea	 ecx, DWORD PTR $T62338[ebp]
  00b38	e8 00 00 00 00	 call	 ??0Ratio@@QAE@HH@Z	; Ratio::Ratio
  00b3d	50		 push	 eax
  00b3e	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  00b41	50		 push	 eax
  00b42	e8 00 00 00 00	 call	 ??D@YAHHABVRatio@@@Z	; operator*
  00b47	83 c4 08	 add	 esp, 8
  00b4a	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gameBorderX@@3HA ; gameBorderX
  00b50	89 45 ec	 mov	 DWORD PTR _rect$[ebp], eax

; 400  : 	rect.top = y * Ratio(gameHeight, SCIRESY) + gameBorderY;

  00b53	68 e0 01 00 00	 push	 480			; 000001e0H
  00b58	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gameHeight@@3HA ; gameHeight
  00b5e	51		 push	 ecx
  00b5f	8d 8d ac fd ff
	ff		 lea	 ecx, DWORD PTR $T62339[ebp]
  00b65	e8 00 00 00 00	 call	 ??0Ratio@@QAE@HH@Z	; Ratio::Ratio
  00b6a	50		 push	 eax
  00b6b	8b 55 10	 mov	 edx, DWORD PTR _y$[ebp]
  00b6e	52		 push	 edx
  00b6f	e8 00 00 00 00	 call	 ??D@YAHHABVRatio@@@Z	; operator*
  00b74	83 c4 08	 add	 esp, 8
  00b77	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gameBorderY@@3HA ; gameBorderY
  00b7d	89 45 f0	 mov	 DWORD PTR _rect$[ebp+4], eax

; 401  : 	rect.right = aviWidth * 2;

  00b80	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR _aviWidth$[ebp]
  00b86	d1 e0		 shl	 eax, 1
  00b88	89 45 f4	 mov	 DWORD PTR _rect$[ebp+8], eax

; 402  : 	rect.bottom = aviHeight * 2;

  00b8b	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR _aviHeight$[ebp]
  00b91	d1 e1		 shl	 ecx, 1
  00b93	89 4d f8	 mov	 DWORD PTR _rect$[ebp+12], ecx

; 403  : 
; 404  : 	sprintf(str,"put sciMovie%-1d destination at %u %u %u %u wait",movieNo,rect.left,
; 405  : 		rect.top,rect.right,rect.bottom);

  00b96	8b 55 f8	 mov	 edx, DWORD PTR _rect$[ebp+12]
  00b99	52		 push	 edx
  00b9a	8b 45 f4	 mov	 eax, DWORD PTR _rect$[ebp+8]
  00b9d	50		 push	 eax
  00b9e	8b 4d f0	 mov	 ecx, DWORD PTR _rect$[ebp+4]
  00ba1	51		 push	 ecx
  00ba2	8b 55 ec	 mov	 edx, DWORD PTR _rect$[ebp]
  00ba5	52		 push	 edx
  00ba6	8b 45 08	 mov	 eax, DWORD PTR _movieNo$[ebp]
  00ba9	50		 push	 eax
  00baa	68 00 00 00 00	 push	 OFFSET FLAT:$SG61921
  00baf	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _str$[ebp]
  00bb5	51		 push	 ecx
  00bb6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  00bbc	83 c4 1c	 add	 esp, 28			; 0000001cH

; 406  : 
; 407  : 	errorCode = mciSendString(str,retStr,80,0L);

  00bbf	6a 00		 push	 0
  00bc1	6a 50		 push	 80			; 00000050H
  00bc3	8d 95 e8 fd ff
	ff		 lea	 edx, DWORD PTR _retStr$[ebp]
  00bc9	52		 push	 edx
  00bca	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _str$[ebp]
  00bd0	50		 push	 eax
  00bd1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendStringA@16
  00bd7	89 85 dc fd ff
	ff		 mov	 DWORD PTR _errorCode$[ebp], eax

; 408  : 	if(errorCode) {

  00bdd	83 bd dc fd ff
	ff 00		 cmp	 DWORD PTR _errorCode$[ebp], 0
  00be4	74 2a		 je	 SHORT $L61922

; 409  : #ifdef DEBUG
; 410  : 	   msgMgr->Alert(SrcLoc, "AVI Put Failed.  Return Value: %d", errorCode);
; 411  : #else
; 412  : 		msgMgr->Fatal(SrcLoc,Msg_AVIPut);

  00be6	68 90 00 00 00	 push	 144			; 00000090H
  00beb	68 9c 01 00 00	 push	 412			; 0000019cH
  00bf0	68 00 00 00 00	 push	 OFFSET FLAT:$SG61923
  00bf5	6a 61		 push	 97			; 00000061H
  00bf7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00bfd	51		 push	 ecx
  00bfe	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXDPADHHZZ ; MsgMgr::Fatal
  00c03	83 c4 14	 add	 esp, 20			; 00000014H

; 413  : 		return AVI_PUT_FAIL;

  00c06	b8 05 00 00 00	 mov	 eax, 5
  00c0b	e9 42 01 00 00	 jmp	 $L61898
$L61922:

; 417  : 
; 418  : 	// create a plane for the movie to play in (protect it from SCI)
; 419  : 	// First, create an SOL_RECT with lo-res coordinates and offset by top/left
; 420  : 	SOL_Rect sRect;

  00c10	8d 8d c8 fd ff
	ff		 lea	 ecx, DWORD PTR _sRect$[ebp]
  00c16	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@XZ	; SOL_Rect::SOL_Rect

; 421  : 	int width = rect.right * Ratio(SCIRESX,gameWidth);

  00c1b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gameWidth@@3HA ; gameWidth
  00c21	52		 push	 edx
  00c22	68 80 02 00 00	 push	 640			; 00000280H
  00c27	8d 8d a4 fd ff
	ff		 lea	 ecx, DWORD PTR $T62340[ebp]
  00c2d	e8 00 00 00 00	 call	 ??0Ratio@@QAE@HH@Z	; Ratio::Ratio
  00c32	50		 push	 eax
  00c33	8b 45 f4	 mov	 eax, DWORD PTR _rect$[ebp+8]
  00c36	50		 push	 eax
  00c37	e8 00 00 00 00	 call	 ??D@YAHHABVRatio@@@Z	; operator*
  00c3c	83 c4 08	 add	 esp, 8
  00c3f	89 45 e8	 mov	 DWORD PTR _width$[ebp], eax

; 422  : 	int height = rect.bottom * Ratio(SCIRESY,gameHeight);

  00c42	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gameHeight@@3HA ; gameHeight
  00c48	51		 push	 ecx
  00c49	68 e0 01 00 00	 push	 480			; 000001e0H
  00c4e	8d 8d 9c fd ff
	ff		 lea	 ecx, DWORD PTR $T62341[ebp]
  00c54	e8 00 00 00 00	 call	 ??0Ratio@@QAE@HH@Z	; Ratio::Ratio
  00c59	50		 push	 eax
  00c5a	8b 55 f8	 mov	 edx, DWORD PTR _rect$[ebp+12]
  00c5d	52		 push	 edx
  00c5e	e8 00 00 00 00	 call	 ??D@YAHHABVRatio@@@Z	; operator*
  00c63	83 c4 08	 add	 esp, 8
  00c66	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _height$[ebp], eax

; 423  : 	int sRight = x + width - 1;

  00c6c	8b 45 e8	 mov	 eax, DWORD PTR _width$[ebp]
  00c6f	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  00c72	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  00c76	89 95 d8 fd ff
	ff		 mov	 DWORD PTR _sRight$[ebp], edx

; 424  : 	int sBottom = y + height - 1;

  00c7c	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR _height$[ebp]
  00c82	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  00c85	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  00c89	89 95 bc fd ff
	ff		 mov	 DWORD PTR _sBottom$[ebp], edx

; 425  : 	sRect.Set(x,y,sRight,sBottom);

  00c8f	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR _sBottom$[ebp]
  00c95	50		 push	 eax
  00c96	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _sRight$[ebp]
  00c9c	51		 push	 ecx
  00c9d	8b 55 10	 mov	 edx, DWORD PTR _y$[ebp]
  00ca0	52		 push	 edx
  00ca1	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  00ca4	50		 push	 eax
  00ca5	8d 8d c8 fd ff
	ff		 lea	 ecx, DWORD PTR _sRect$[ebp]
  00cab	e8 00 00 00 00	 call	 ?Set@SOL_Rect@@QAEXHHHH@Z ; SOL_Rect::Set

; 426  : 	moviePlane = New SOL_Plane(sRect);

  00cb0	68 c8 9c 00 00	 push	 40136			; 00009cc8H
  00cb5	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00cba	83 c4 04	 add	 esp, 4
  00cbd	89 85 94 fd ff
	ff		 mov	 DWORD PTR $T62343[ebp], eax
  00cc3	83 bd 94 fd ff
	ff 00		 cmp	 DWORD PTR $T62343[ebp], 0
  00cca	74 1a		 je	 SHORT $L62344
  00ccc	8d 8d c8 fd ff
	ff		 lea	 ecx, DWORD PTR _sRect$[ebp]
  00cd2	51		 push	 ecx
  00cd3	8b 8d 94 fd ff
	ff		 mov	 ecx, DWORD PTR $T62343[ebp]
  00cd9	e8 00 00 00 00	 call	 ??0SOL_Plane@@QAE@ABVSOL_Rect@@@Z ; SOL_Plane::SOL_Plane
  00cde	89 85 7c fd ff
	ff		 mov	 DWORD PTR -644+[ebp], eax
  00ce4	eb 0a		 jmp	 SHORT $L62345
$L62344:
  00ce6	c7 85 7c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR -644+[ebp], 0
$L62345:
  00cf0	8b 95 7c fd ff
	ff		 mov	 edx, DWORD PTR -644+[ebp]
  00cf6	89 95 98 fd ff
	ff		 mov	 DWORD PTR $T62342[ebp], edx
  00cfc	8b 85 98 fd ff
	ff		 mov	 eax, DWORD PTR $T62342[ebp]
  00d02	a3 00 00 00 00	 mov	 DWORD PTR _moviePlane, eax

; 427  : 	graphMgr->AddPlane(moviePlane);

  00d07	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _moviePlane
  00d0d	51		 push	 ecx
  00d0e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  00d14	e8 00 00 00 00	 call	 ?AddPlane@GraphicsMgr@@QAEXPAVSOL_Plane@@@Z ; GraphicsMgr::AddPlane

; 428  : 	graphMgr->FrameOut(TRUE);

  00d19	6a ff		 push	 -1
  00d1b	6a ff		 push	 -1
  00d1d	6a 00		 push	 0
  00d1f	6a 00		 push	 0
  00d21	8d 8d 80 fd ff
	ff		 lea	 ecx, DWORD PTR $T62347[ebp]
  00d27	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@HHHH@Z	; SOL_Rect::SOL_Rect
  00d2c	83 ec 10	 sub	 esp, 16			; 00000010H
  00d2f	8b cc		 mov	 ecx, esp
  00d31	89 a5 90 fd ff
	ff		 mov	 DWORD PTR $T62346[ebp], esp
  00d37	50		 push	 eax
  00d38	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@ABV0@@Z ; SOL_Rect::SOL_Rect
  00d3d	6a 01		 push	 1
  00d3f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  00d45	8b 02		 mov	 eax, DWORD PTR [edx]
  00d47	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  00d4d	ff 50 14	 call	 DWORD PTR [eax+20]

; 429  : 
; 430  : 	return AVI_NO_ERROR;

  00d50	33 c0		 xor	 eax, eax
$L61898:

; 431  : }

  00d52	8b e5		 mov	 esp, ebp
  00d54	5d		 pop	 ebp
  00d55	c3		 ret	 0
_AviPutDouble ENDP
_TEXT	ENDS
EXTRN	?timeMgr@@3PAVTimeMgr@@A:DWORD			; timeMgr
EXTRN	?EnableTimer@TimeMgrWin@@QAEXXZ:NEAR		; TimeMgrWin::EnableTimer
EXTRN	?DisableTimer@TimeMgrWin@@QAEXXZ:NEAR		; TimeMgrWin::DisableTimer
EXTRN	?hMyWnd@@3PAUHWND__@@A:DWORD			; hMyWnd
_BSS	SEGMENT
_currentlyPlayingMovie DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
	ORG $+1
$SG61948 DB	'Movie: %d  From: %d  To: %d  ShowStyle: %d', 0aH, 00H
$SG61950 DB	'window sciMovie%-1d handle %u wait', 00H
	ORG $+1
$SG61952 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Movi'
	DB	'ew.cpp', 00H
	ORG $+1
$SG61954 DB	'play sciMovie%-1d from %d to %d', 00H
$SG61956 DB	'play sciMovie%-1d', 00H
	ORG $+2
$SG61958 DB	'%s notify', 00H
	ORG $+2
$SG61960 DB	'%s wait', 00H
$SG61964 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Movi'
	DB	'ew.cpp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_movieNo$ = 8
_from$ = 12
_to$ = 16
_showStyle$ = 20
_cue$ = 24
_dwPlayFlags$ = -4
_errorCode$ = -168
_str$ = -84
_retStr$ = -164
_AviPlay PROC NEAR

; 434  : {

  00d56	55		 push	 ebp
  00d57	8b ec		 mov	 ebp, esp
  00d59	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H

; 435  : 	DWORD dwPlayFlags = 0;

  00d5f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwPlayFlags$[ebp], 0

; 436  : 	DWORD errorCode;
; 437  : 	// BOOL mciRet;
; 438  : 
; 439  : 	char str[80];
; 440  : 	char retStr[80];
; 441  : 
; 442  : 	sprintf(str,"Movie: %d  From: %d  To: %d  ShowStyle: %d\n",movieNo,from,to,showStyle);

  00d66	8b 45 14	 mov	 eax, DWORD PTR _showStyle$[ebp]
  00d69	50		 push	 eax
  00d6a	8b 4d 10	 mov	 ecx, DWORD PTR _to$[ebp]
  00d6d	51		 push	 ecx
  00d6e	8b 55 0c	 mov	 edx, DWORD PTR _from$[ebp]
  00d71	52		 push	 edx
  00d72	8b 45 08	 mov	 eax, DWORD PTR _movieNo$[ebp]
  00d75	50		 push	 eax
  00d76	68 00 00 00 00	 push	 OFFSET FLAT:$SG61948
  00d7b	8d 4d ac	 lea	 ecx, DWORD PTR _str$[ebp]
  00d7e	51		 push	 ecx
  00d7f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  00d85	83 c4 18	 add	 esp, 24			; 00000018H

; 443  : 	if(showStyle == SCI_WINDOW) {

  00d88	83 7d 14 02	 cmp	 DWORD PTR _showStyle$[ebp], 2
  00d8c	75 61		 jne	 SHORT $L61951

; 444  : 		sprintf(str,"window sciMovie%-1d handle %u wait",movieNo,hMyWnd);

  00d8e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hMyWnd@@3PAUHWND__@@A ; hMyWnd
  00d94	52		 push	 edx
  00d95	8b 45 08	 mov	 eax, DWORD PTR _movieNo$[ebp]
  00d98	50		 push	 eax
  00d99	68 00 00 00 00	 push	 OFFSET FLAT:$SG61950
  00d9e	8d 4d ac	 lea	 ecx, DWORD PTR _str$[ebp]
  00da1	51		 push	 ecx
  00da2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  00da8	83 c4 10	 add	 esp, 16			; 00000010H

; 445  : 		errorCode = mciSendString(str,retStr,80,0);

  00dab	6a 00		 push	 0
  00dad	6a 50		 push	 80			; 00000050H
  00daf	8d 95 5c ff ff
	ff		 lea	 edx, DWORD PTR _retStr$[ebp]
  00db5	52		 push	 edx
  00db6	8d 45 ac	 lea	 eax, DWORD PTR _str$[ebp]
  00db9	50		 push	 eax
  00dba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendStringA@16
  00dc0	89 85 58 ff ff
	ff		 mov	 DWORD PTR _errorCode$[ebp], eax

; 446  : 		if(errorCode) {

  00dc6	83 bd 58 ff ff
	ff 00		 cmp	 DWORD PTR _errorCode$[ebp], 0
  00dcd	74 20		 je	 SHORT $L61951

; 447  : #ifdef DEBUG
; 448  : 	   msgMgr->Alert(SrcLoc, "AVI Window Command Failed.  Return Value: %d", errorCode);
; 449  : #endif
; 450  : 
; 451  : 			msgMgr->Fatal(SrcLoc,Msg_AVIPlay);

  00dcf	68 92 00 00 00	 push	 146			; 00000092H
  00dd4	68 c3 01 00 00	 push	 451			; 000001c3H
  00dd9	68 00 00 00 00	 push	 OFFSET FLAT:$SG61952
  00dde	6a 61		 push	 97			; 00000061H
  00de0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00de6	51		 push	 ecx
  00de7	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXDPADHHZZ ; MsgMgr::Fatal
  00dec	83 c4 14	 add	 esp, 20			; 00000014H
$L61951:

; 454  : 
; 455  : 	// Turn off the SCI Timer interupts
; 456  : 
; 457  : 	if(to && from >= 0 && from <= to) {

  00def	83 7d 10 00	 cmp	 DWORD PTR _to$[ebp], 0
  00df3	74 31		 je	 SHORT $L61953
  00df5	83 7d 0c 00	 cmp	 DWORD PTR _from$[ebp], 0
  00df9	7c 2b		 jl	 SHORT $L61953
  00dfb	8b 55 0c	 mov	 edx, DWORD PTR _from$[ebp]
  00dfe	3b 55 10	 cmp	 edx, DWORD PTR _to$[ebp]
  00e01	7f 23		 jg	 SHORT $L61953

; 458  : 		sprintf(retStr,"play sciMovie%-1d from %d to %d",movieNo,from,to);

  00e03	8b 45 10	 mov	 eax, DWORD PTR _to$[ebp]
  00e06	50		 push	 eax
  00e07	8b 4d 0c	 mov	 ecx, DWORD PTR _from$[ebp]
  00e0a	51		 push	 ecx
  00e0b	8b 55 08	 mov	 edx, DWORD PTR _movieNo$[ebp]
  00e0e	52		 push	 edx
  00e0f	68 00 00 00 00	 push	 OFFSET FLAT:$SG61954
  00e14	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR _retStr$[ebp]
  00e1a	50		 push	 eax
  00e1b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  00e21	83 c4 14	 add	 esp, 20			; 00000014H

; 460  : 	else {

  00e24	eb 29		 jmp	 SHORT $L61955
$L61953:

; 461  : 		sprintf(str,"play sciMovie%-1d",movieNo);

  00e26	8b 4d 08	 mov	 ecx, DWORD PTR _movieNo$[ebp]
  00e29	51		 push	 ecx
  00e2a	68 00 00 00 00	 push	 OFFSET FLAT:$SG61956
  00e2f	8d 55 ac	 lea	 edx, DWORD PTR _str$[ebp]
  00e32	52		 push	 edx
  00e33	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  00e39	83 c4 0c	 add	 esp, 12			; 0000000cH

; 462  : 		strcpy(retStr,str);

  00e3c	8d 45 ac	 lea	 eax, DWORD PTR _str$[ebp]
  00e3f	50		 push	 eax
  00e40	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _retStr$[ebp]
  00e46	51		 push	 ecx
  00e47	e8 00 00 00 00	 call	 _strcpy
  00e4c	83 c4 08	 add	 esp, 8
$L61955:

; 464  : 
; 465  : 	if(cue)	{

  00e4f	83 7d 18 00	 cmp	 DWORD PTR _cue$[ebp], 0
  00e53	74 44		 je	 SHORT $L61957

; 466  : 		sprintf(str,"%s notify",retStr);

  00e55	8d 95 5c ff ff
	ff		 lea	 edx, DWORD PTR _retStr$[ebp]
  00e5b	52		 push	 edx
  00e5c	68 00 00 00 00	 push	 OFFSET FLAT:$SG61958
  00e61	8d 45 ac	 lea	 eax, DWORD PTR _str$[ebp]
  00e64	50		 push	 eax
  00e65	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  00e6b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 467  : 		currentlyPlayingMovie = movieNo;

  00e6e	8b 4d 08	 mov	 ecx, DWORD PTR _movieNo$[ebp]
  00e71	89 0d 00 00 00
	00		 mov	 DWORD PTR _currentlyPlayingMovie, ecx

; 468  : 
; 469  : #ifndef WIN32S
; 470  : 		errorCode = mciSendString(str,retStr,80,hMyWnd);
; 471  : #else
; 472  : 		errorCode = mciSendString(str,retStr,80,hMyWnd);

  00e77	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hMyWnd@@3PAUHWND__@@A ; hMyWnd
  00e7d	52		 push	 edx
  00e7e	6a 50		 push	 80			; 00000050H
  00e80	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR _retStr$[ebp]
  00e86	50		 push	 eax
  00e87	8d 4d ac	 lea	 ecx, DWORD PTR _str$[ebp]
  00e8a	51		 push	 ecx
  00e8b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendStringA@16
  00e91	89 85 58 ff ff
	ff		 mov	 DWORD PTR _errorCode$[ebp], eax

; 479  : 	else {

  00e97	eb 4a		 jmp	 SHORT $L61959
$L61957:

; 480  : 		sprintf(str,"%s wait",retStr);

  00e99	8d 95 5c ff ff
	ff		 lea	 edx, DWORD PTR _retStr$[ebp]
  00e9f	52		 push	 edx
  00ea0	68 00 00 00 00	 push	 OFFSET FLAT:$SG61960
  00ea5	8d 45 ac	 lea	 eax, DWORD PTR _str$[ebp]
  00ea8	50		 push	 eax
  00ea9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  00eaf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 481  : 		((TimeMgrWin*)timeMgr)->DisableTimer();

  00eb2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?timeMgr@@3PAVTimeMgr@@A ; timeMgr
  00eb8	e8 00 00 00 00	 call	 ?DisableTimer@TimeMgrWin@@QAEXXZ ; TimeMgrWin::DisableTimer

; 482  : 		errorCode = mciSendString(str,retStr,80,0L);

  00ebd	6a 00		 push	 0
  00ebf	6a 50		 push	 80			; 00000050H
  00ec1	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _retStr$[ebp]
  00ec7	51		 push	 ecx
  00ec8	8d 55 ac	 lea	 edx, DWORD PTR _str$[ebp]
  00ecb	52		 push	 edx
  00ecc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendStringA@16
  00ed2	89 85 58 ff ff
	ff		 mov	 DWORD PTR _errorCode$[ebp], eax

; 483  : 		((TimeMgrWin*)timeMgr)->EnableTimer();

  00ed8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?timeMgr@@3PAVTimeMgr@@A ; timeMgr
  00ede	e8 00 00 00 00	 call	 ?EnableTimer@TimeMgrWin@@QAEXXZ ; TimeMgrWin::EnableTimer
$L61959:

; 485  : 
; 486  : 	if(errorCode) {

  00ee3	83 bd 58 ff ff
	ff 00		 cmp	 DWORD PTR _errorCode$[ebp], 0
  00eea	74 26		 je	 SHORT $L61963

; 487  : #ifdef DEBUG
; 488  : 	   msgMgr->Alert(SrcLoc, "AVI Play Failed.  Return Value: %d", errorCode);
; 489  : #endif
; 490  : 
; 491  : 		msgMgr->Fatal(SrcLoc,Msg_AVIPlay);

  00eec	68 92 00 00 00	 push	 146			; 00000092H
  00ef1	68 eb 01 00 00	 push	 491			; 000001ebH
  00ef6	68 00 00 00 00	 push	 OFFSET FLAT:$SG61964
  00efb	6a 61		 push	 97			; 00000061H
  00efd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00f02	50		 push	 eax
  00f03	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXDPADHHZZ ; MsgMgr::Fatal
  00f08	83 c4 14	 add	 esp, 20			; 00000014H

; 492  : 		return AVI_PLAY_FAIL;

  00f0b	b8 06 00 00 00	 mov	 eax, 6
  00f10	eb 10		 jmp	 SHORT $L61943
$L61963:

; 494  : 
; 495  : 	aviStatus[movieNo] = statusPlaying;

  00f12	8b 4d 08	 mov	 ecx, DWORD PTR _movieNo$[ebp]
  00f15	c7 04 8d 00 00
	00 00 02 00 00
	00		 mov	 DWORD PTR _aviStatus[ecx*4], 2

; 496  : 	return AVI_NO_ERROR;

  00f20	33 c0		 xor	 eax, eax
$L61943:

; 497  : }

  00f22	8b e5		 mov	 esp, ebp
  00f24	5d		 pop	 ebp
  00f25	c3		 ret	 0
_AviPlay ENDP
_TEXT	ENDS
EXTRN	__imp__PeekMessageA@20:NEAR
EXTRN	?eventMgr@@3PAUEventMgr@@A:DWORD		; eventMgr
_TEXT	SEGMENT
_flags$ = 12
_msg$ = -32
_retValue$ = -4
_AviWaitEvent PROC NEAR

; 499  : {

  00f26	55		 push	 ebp
  00f27	8b ec		 mov	 ebp, esp
  00f29	83 ec 20	 sub	 esp, 32			; 00000020H
$L61972:

; 500  : 	MSG msg; 
; 501  : 	WORD retValue;
; 502  : 
; 503  : 	while (1) {

  00f2c	b8 01 00 00 00	 mov	 eax, 1
  00f31	85 c0		 test	 eax, eax
  00f33	0f 84 e1 00 00
	00		 je	 $L61973

; 507  : 			PeekMessage(&msg, hMyWnd, MM_MCINOTIFY, MM_MCINOTIFY, PM_NOREMOVE))) {

  00f39	8b 4d 0c	 mov	 ecx, DWORD PTR _flags$[ebp]
  00f3c	83 e1 01	 and	 ecx, 1
  00f3f	85 c9		 test	 ecx, ecx
  00f41	74 3b		 je	 SHORT $L61974
  00f43	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _currentlyPlayingMovie
  00f49	83 3c 95 00 00
	00 00 05	 cmp	 DWORD PTR _aviStatus[edx*4], 5
  00f51	74 20		 je	 SHORT $L61975
  00f53	6a 00		 push	 0
  00f55	68 b9 03 00 00	 push	 953			; 000003b9H
  00f5a	68 b9 03 00 00	 push	 953			; 000003b9H
  00f5f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hMyWnd@@3PAUHWND__@@A ; hMyWnd
  00f64	50		 push	 eax
  00f65	8d 4d e0	 lea	 ecx, DWORD PTR _msg$[ebp]
  00f68	51		 push	 ecx
  00f69	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PeekMessageA@20
  00f6f	85 c0		 test	 eax, eax
  00f71	74 0b		 je	 SHORT $L61974
$L61975:

; 508  : 			retValue = AVI_COMPLETED;

  00f73	66 c7 45 fc 01
	00		 mov	 WORD PTR _retValue$[ebp], 1

; 509  : 			break;

  00f79	e9 9c 00 00 00	 jmp	 $L61973
$L61974:

; 511  : 
; 512  : 		if(flags & AVI_ESC_PRESSED && PeekMessage(&msg,hMyWnd,WM_KEYUP,WM_KEYUP,PM_NOREMOVE)) {

  00f7e	8b 55 0c	 mov	 edx, DWORD PTR _flags$[ebp]
  00f81	83 e2 02	 and	 edx, 2
  00f84	85 d2		 test	 edx, edx
  00f86	74 2e		 je	 SHORT $L61977
  00f88	6a 00		 push	 0
  00f8a	68 01 01 00 00	 push	 257			; 00000101H
  00f8f	68 01 01 00 00	 push	 257			; 00000101H
  00f94	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hMyWnd@@3PAUHWND__@@A ; hMyWnd
  00f99	50		 push	 eax
  00f9a	8d 4d e0	 lea	 ecx, DWORD PTR _msg$[ebp]
  00f9d	51		 push	 ecx
  00f9e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PeekMessageA@20
  00fa4	85 c0		 test	 eax, eax
  00fa6	74 0e		 je	 SHORT $L61977

; 513  : 			if(msg.wParam == VK_ESCAPE) {

  00fa8	83 7d e8 1b	 cmp	 DWORD PTR _msg$[ebp+8], 27 ; 0000001bH
  00fac	75 08		 jne	 SHORT $L61977

; 514  : 				retValue = AVI_ESC_PRESSED;

  00fae	66 c7 45 fc 02
	00		 mov	 WORD PTR _retValue$[ebp], 2

; 515  : 				break;

  00fb4	eb 64		 jmp	 SHORT $L61973
$L61977:

; 518  : 
; 519  : 		if(flags & AVI_MOUSE_DOWN && PeekMessage(&msg,hMyWnd,WM_LBUTTONDOWN,WM_LBUTTONDOWN,PM_NOREMOVE)) {

  00fb6	8b 55 0c	 mov	 edx, DWORD PTR _flags$[ebp]
  00fb9	83 e2 04	 and	 edx, 4
  00fbc	85 d2		 test	 edx, edx
  00fbe	74 28		 je	 SHORT $L61978
  00fc0	6a 00		 push	 0
  00fc2	68 01 02 00 00	 push	 513			; 00000201H
  00fc7	68 01 02 00 00	 push	 513			; 00000201H
  00fcc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hMyWnd@@3PAUHWND__@@A ; hMyWnd
  00fd1	50		 push	 eax
  00fd2	8d 4d e0	 lea	 ecx, DWORD PTR _msg$[ebp]
  00fd5	51		 push	 ecx
  00fd6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PeekMessageA@20
  00fdc	85 c0		 test	 eax, eax
  00fde	74 08		 je	 SHORT $L61978

; 520  : 			retValue = AVI_MOUSE_DOWN;

  00fe0	66 c7 45 fc 04
	00		 mov	 WORD PTR _retValue$[ebp], 4

; 521  : 			break;

  00fe6	eb 32		 jmp	 SHORT $L61973
$L61978:

; 523  : 
; 524  : 		if(flags & AVI_HOT_RECTANGLE) {

  00fe8	8b 55 0c	 mov	 edx, DWORD PTR _flags$[ebp]
  00feb	83 e2 08	 and	 edx, 8
  00fee	85 d2		 test	 edx, edx
  00ff0	74 23		 je	 SHORT $L61980

; 525  : 			if(eventMgr->IsAvail(NULL, 0x400)) {

  00ff2	68 00 04 00 00	 push	 1024			; 00000400H
  00ff7	6a 00		 push	 0
  00ff9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?eventMgr@@3PAUEventMgr@@A ; eventMgr
  00ffe	8b 10		 mov	 edx, DWORD PTR [eax]
  01000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?eventMgr@@3PAUEventMgr@@A ; eventMgr
  01006	ff 52 14	 call	 DWORD PTR [edx+20]
  01009	85 c0		 test	 eax, eax
  0100b	74 08		 je	 SHORT $L61980

; 526  : 				retValue = AVI_HOT_RECTANGLE;

  0100d	66 c7 45 fc 08
	00		 mov	 WORD PTR _retValue$[ebp], 8

; 527  : 				break;

  01013	eb 05		 jmp	 SHORT $L61973
$L61980:

; 530  : 
; 531  : 	}

  01015	e9 12 ff ff ff	 jmp	 $L61972
$L61973:

; 532  : 
; 533  : 	return retValue;

  0101a	8b 45 fc	 mov	 eax, DWORD PTR _retValue$[ebp]
  0101d	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH

; 534  : }

  01022	8b e5		 mov	 esp, ebp
  01024	5d		 pop	 ebp
  01025	c3		 ret	 0
_AviWaitEvent ENDP
_TEXT	ENDS
EXTRN	__imp__mciGetErrorStringA@12:NEAR
_DATA	SEGMENT
	ORG $+1
$SG61985 DB	'stop sciMovie%-1d', 00H
_DATA	ENDS
_TEXT	SEGMENT
_movieNo$ = 8
_str$ = -32
_errorCode$ = -36
_str$61988 = -116
_AviStop PROC NEAR

; 537  : {

  01026	55		 push	 ebp
  01027	8b ec		 mov	 ebp, esp
  01029	83 ec 74	 sub	 esp, 116		; 00000074H

; 538  : 	char str[30];
; 539  : 	sprintf(str,"stop sciMovie%-1d",movieNo);

  0102c	8b 45 08	 mov	 eax, DWORD PTR _movieNo$[ebp]
  0102f	50		 push	 eax
  01030	68 00 00 00 00	 push	 OFFSET FLAT:$SG61985
  01035	8d 4d e0	 lea	 ecx, DWORD PTR _str$[ebp]
  01038	51		 push	 ecx
  01039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  0103f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 540  : 	DWORD errorCode = mciSendString(str,NULL,0,0);

  01042	6a 00		 push	 0
  01044	6a 00		 push	 0
  01046	6a 00		 push	 0
  01048	8d 55 e0	 lea	 edx, DWORD PTR _str$[ebp]
  0104b	52		 push	 edx
  0104c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendStringA@16
  01052	89 45 dc	 mov	 DWORD PTR _errorCode$[ebp], eax

; 541  : 	if(errorCode) {

  01055	83 7d dc 00	 cmp	 DWORD PTR _errorCode$[ebp], 0
  01059	74 17		 je	 SHORT $L61987

; 542  : 		char str[80];
; 543  : 		mciGetErrorString(errorCode,str,80);

  0105b	6a 50		 push	 80			; 00000050H
  0105d	8d 45 8c	 lea	 eax, DWORD PTR _str$61988[ebp]
  01060	50		 push	 eax
  01061	8b 4d dc	 mov	 ecx, DWORD PTR _errorCode$[ebp]
  01064	51		 push	 ecx
  01065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciGetErrorStringA@12

; 544  : 		return AVI_STOP_FAIL;

  0106b	b8 07 00 00 00	 mov	 eax, 7
  01070	eb 10		 jmp	 SHORT $L61983
$L61987:

; 546  : 
; 547  : 	aviStatus[movieNo] = statusStopped;

  01072	8b 55 08	 mov	 edx, DWORD PTR _movieNo$[ebp]
  01075	c7 04 95 00 00
	00 00 04 00 00
	00		 mov	 DWORD PTR _aviStatus[edx*4], 4

; 548  : 	return AVI_NO_ERROR;

  01080	33 c0		 xor	 eax, eax
$L61983:

; 549  : }

  01082	8b e5		 mov	 esp, ebp
  01084	5d		 pop	 ebp
  01085	c3		 ret	 0
_AviStop ENDP
_TEXT	ENDS
_DATA	SEGMENT
	ORG $+2
$SG61994 DB	'pause sciMovie%-1d', 00H
_DATA	ENDS
_TEXT	SEGMENT
_movieNo$ = 8
_str$ = -32
_errorCode$ = -36
_AviPause PROC NEAR

; 552  : {

  01086	55		 push	 ebp
  01087	8b ec		 mov	 ebp, esp
  01089	83 ec 24	 sub	 esp, 36			; 00000024H

; 553  : 
; 554  : 	if(aviStatus[movieNo] != statusPlaying)

  0108c	8b 45 08	 mov	 eax, DWORD PTR _movieNo$[ebp]
  0108f	83 3c 85 00 00
	00 00 02	 cmp	 DWORD PTR _aviStatus[eax*4], 2
  01097	74 07		 je	 SHORT $L61992

; 555  : 		return AVI_PAUSE_FAIL;

  01099	b8 08 00 00 00	 mov	 eax, 8
  0109e	eb 46		 jmp	 SHORT $L61991
$L61992:

; 558  : 	sprintf(str,"pause sciMovie%-1d",movieNo);

  010a0	8b 4d 08	 mov	 ecx, DWORD PTR _movieNo$[ebp]
  010a3	51		 push	 ecx
  010a4	68 00 00 00 00	 push	 OFFSET FLAT:$SG61994
  010a9	8d 55 e0	 lea	 edx, DWORD PTR _str$[ebp]
  010ac	52		 push	 edx
  010ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  010b3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 559  : 	DWORD errorCode = mciSendString(str,NULL,0,0);

  010b6	6a 00		 push	 0
  010b8	6a 00		 push	 0
  010ba	6a 00		 push	 0
  010bc	8d 45 e0	 lea	 eax, DWORD PTR _str$[ebp]
  010bf	50		 push	 eax
  010c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendStringA@16
  010c6	89 45 dc	 mov	 DWORD PTR _errorCode$[ebp], eax

; 560  : 	if(errorCode) {

  010c9	83 7d dc 00	 cmp	 DWORD PTR _errorCode$[ebp], 0
  010cd	74 07		 je	 SHORT $L61996

; 561  : 		return AVI_PAUSE_FAIL;

  010cf	b8 08 00 00 00	 mov	 eax, 8
  010d4	eb 10		 jmp	 SHORT $L61991
$L61996:

; 563  : 
; 564  : 	aviStatus[movieNo] = statusPaused;

  010d6	8b 4d 08	 mov	 ecx, DWORD PTR _movieNo$[ebp]
  010d9	c7 04 8d 00 00
	00 00 03 00 00
	00		 mov	 DWORD PTR _aviStatus[ecx*4], 3

; 565  : 	return AVI_NO_ERROR;

  010e4	33 c0		 xor	 eax, eax
$L61991:

; 566  : 
; 567  : }

  010e6	8b e5		 mov	 esp, ebp
  010e8	5d		 pop	 ebp
  010e9	c3		 ret	 0
_AviPause ENDP
_TEXT	ENDS
_DATA	SEGMENT
	ORG $+1
$SG62002 DB	'cue sciMovie%-1d output to %d', 00H
_DATA	ENDS
_TEXT	SEGMENT
_movieNo$ = 8
_frameNo$ = 12
_str$ = -32
_errorCode$ = -36
_AviCue	PROC NEAR

; 570  : {

  010ea	55		 push	 ebp
  010eb	8b ec		 mov	 ebp, esp
  010ed	83 ec 24	 sub	 esp, 36			; 00000024H

; 571  : 
; 572  : 	char str[30];
; 573  : 	sprintf(str,"cue sciMovie%-1d output to %d",movieNo,frameNo);

  010f0	8b 45 0c	 mov	 eax, DWORD PTR _frameNo$[ebp]
  010f3	50		 push	 eax
  010f4	8b 4d 08	 mov	 ecx, DWORD PTR _movieNo$[ebp]
  010f7	51		 push	 ecx
  010f8	68 00 00 00 00	 push	 OFFSET FLAT:$SG62002
  010fd	8d 55 e0	 lea	 edx, DWORD PTR _str$[ebp]
  01100	52		 push	 edx
  01101	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  01107	83 c4 10	 add	 esp, 16			; 00000010H

; 574  : 	DWORD errorCode = mciSendString(str,NULL,0,0);

  0110a	6a 00		 push	 0
  0110c	6a 00		 push	 0
  0110e	6a 00		 push	 0
  01110	8d 45 e0	 lea	 eax, DWORD PTR _str$[ebp]
  01113	50		 push	 eax
  01114	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendStringA@16
  0111a	89 45 dc	 mov	 DWORD PTR _errorCode$[ebp], eax

; 575  : 	if(errorCode) {

  0111d	83 7d dc 00	 cmp	 DWORD PTR _errorCode$[ebp], 0
  01121	74 07		 je	 SHORT $L62004

; 576  : 		return AVI_CUE_FAIL;

  01123	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  01128	eb 10		 jmp	 SHORT $L62000
$L62004:

; 578  : 
; 579  : 	aviStatus[movieNo] = statusPaused;

  0112a	8b 4d 08	 mov	 ecx, DWORD PTR _movieNo$[ebp]
  0112d	c7 04 8d 00 00
	00 00 03 00 00
	00		 mov	 DWORD PTR _aviStatus[ecx*4], 3

; 580  : 	return AVI_NO_ERROR;

  01138	33 c0		 xor	 eax, eax
$L62000:

; 581  : 
; 582  : }

  0113a	8b e5		 mov	 esp, ebp
  0113c	5d		 pop	 ebp
  0113d	c3		 ret	 0
_AviCue	ENDP
_TEXT	ENDS
_DATA	SEGMENT
	ORG $+2
$SG62011 DB	'seek sciMovie%-1d  to %d', 00H
_DATA	ENDS
_TEXT	SEGMENT
_movieNo$ = 8
_frameNo$ = 12
_str$ = -32
_errorCode$ = -36
_AviSeek PROC NEAR

; 584  : {

  0113e	55		 push	 ebp
  0113f	8b ec		 mov	 ebp, esp
  01141	83 ec 24	 sub	 esp, 36			; 00000024H

; 585  : 	if(aviStatus[movieNo] == statusNotOpen)

  01144	8b 45 08	 mov	 eax, DWORD PTR _movieNo$[ebp]
  01147	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _aviStatus[eax*4], 0
  0114f	75 07		 jne	 SHORT $L62009

; 586  : 		return AVI_PAUSE_FAIL;

  01151	b8 08 00 00 00	 mov	 eax, 8
  01156	eb 4a		 jmp	 SHORT $L62008
$L62009:

; 589  : 	sprintf(str,"seek sciMovie%-1d  to %d",movieNo,frameNo);

  01158	8b 4d 0c	 mov	 ecx, DWORD PTR _frameNo$[ebp]
  0115b	51		 push	 ecx
  0115c	8b 55 08	 mov	 edx, DWORD PTR _movieNo$[ebp]
  0115f	52		 push	 edx
  01160	68 00 00 00 00	 push	 OFFSET FLAT:$SG62011
  01165	8d 45 e0	 lea	 eax, DWORD PTR _str$[ebp]
  01168	50		 push	 eax
  01169	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  0116f	83 c4 10	 add	 esp, 16			; 00000010H

; 590  : 	DWORD errorCode = mciSendString(str,NULL,0,0);

  01172	6a 00		 push	 0
  01174	6a 00		 push	 0
  01176	6a 00		 push	 0
  01178	8d 4d e0	 lea	 ecx, DWORD PTR _str$[ebp]
  0117b	51		 push	 ecx
  0117c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendStringA@16
  01182	89 45 dc	 mov	 DWORD PTR _errorCode$[ebp], eax

; 591  : 	if(errorCode) {

  01185	83 7d dc 00	 cmp	 DWORD PTR _errorCode$[ebp], 0
  01189	74 07		 je	 SHORT $L62013

; 592  : 		return AVI_CUE_FAIL;

  0118b	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  01190	eb 10		 jmp	 SHORT $L62008
$L62013:

; 594  : 
; 595  : 	aviStatus[movieNo] = statusPaused;

  01192	8b 55 08	 mov	 edx, DWORD PTR _movieNo$[ebp]
  01195	c7 04 95 00 00
	00 00 03 00 00
	00		 mov	 DWORD PTR _aviStatus[edx*4], 3

; 596  : 	return AVI_NO_ERROR;

  011a0	33 c0		 xor	 eax, eax
$L62008:

; 597  : 
; 598  : }

  011a2	8b e5		 mov	 esp, ebp
  011a4	5d		 pop	 ebp
  011a5	c3		 ret	 0
_AviSeek ENDP
_TEXT	ENDS
PUBLIC	_AviNotify
_TEXT	SEGMENT
_AviNotify PROC NEAR

; 603  : {

  011a6	55		 push	 ebp
  011a7	8b ec		 mov	 ebp, esp

; 604  : 	// Notify is used only for AviPlay with cue, so
; 605  : 	// the only notify we should be getting is from a play
; 606  : 	// which has been completed. The only problem is that I
; 607  : 	// can't get (I think) which movie it was if more than one
; 608  : 	// is open.  I'm storing the playing movie number in a static variable
; 609  : 
; 610  : 	aviStatus[currentlyPlayingMovie] = statusDone;

  011a9	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentlyPlayingMovie
  011ae	c7 04 85 00 00
	00 00 05 00 00
	00		 mov	 DWORD PTR _aviStatus[eax*4], 5

; 611  : 
; 612  : }

  011b9	5d		 pop	 ebp
  011ba	c3		 ret	 0
_AviNotify ENDP
_TEXT	ENDS
_DATA	SEGMENT
	ORG $+3
$SG62023 DB	'resume sciMovie%-1d', 00H
_DATA	ENDS
_TEXT	SEGMENT
_movieNo$ = 8
_str$ = -32
_errorCode$ = -36
_AviResume PROC NEAR

; 616  : {

  011bb	55		 push	 ebp
  011bc	8b ec		 mov	 ebp, esp
  011be	83 ec 24	 sub	 esp, 36			; 00000024H

; 617  : 	if(aviStatus[movieNo] != statusPaused)

  011c1	8b 45 08	 mov	 eax, DWORD PTR _movieNo$[ebp]
  011c4	83 3c 85 00 00
	00 00 03	 cmp	 DWORD PTR _aviStatus[eax*4], 3
  011cc	74 07		 je	 SHORT $L62021

; 618  : 		return AVI_RESUME_FAIL;

  011ce	b8 09 00 00 00	 mov	 eax, 9
  011d3	eb 46		 jmp	 SHORT $L62020
$L62021:

; 621  : 	sprintf(str,"resume sciMovie%-1d",movieNo);

  011d5	8b 4d 08	 mov	 ecx, DWORD PTR _movieNo$[ebp]
  011d8	51		 push	 ecx
  011d9	68 00 00 00 00	 push	 OFFSET FLAT:$SG62023
  011de	8d 55 e0	 lea	 edx, DWORD PTR _str$[ebp]
  011e1	52		 push	 edx
  011e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  011e8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 622  : 	DWORD errorCode = mciSendString(str,NULL,0,0);

  011eb	6a 00		 push	 0
  011ed	6a 00		 push	 0
  011ef	6a 00		 push	 0
  011f1	8d 45 e0	 lea	 eax, DWORD PTR _str$[ebp]
  011f4	50		 push	 eax
  011f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendStringA@16
  011fb	89 45 dc	 mov	 DWORD PTR _errorCode$[ebp], eax

; 623  : 	if(errorCode) {

  011fe	83 7d dc 00	 cmp	 DWORD PTR _errorCode$[ebp], 0
  01202	74 07		 je	 SHORT $L62025

; 624  : 		return AVI_RESUME_FAIL;

  01204	b8 09 00 00 00	 mov	 eax, 9
  01209	eb 10		 jmp	 SHORT $L62020
$L62025:

; 626  : 
; 627  : 	aviStatus[movieNo] = statusPlaying;

  0120b	8b 4d 08	 mov	 ecx, DWORD PTR _movieNo$[ebp]
  0120e	c7 04 8d 00 00
	00 00 02 00 00
	00		 mov	 DWORD PTR _aviStatus[ecx*4], 2

; 628  : 	return AVI_NO_ERROR;

  01219	33 c0		 xor	 eax, eax
$L62020:

; 629  : 
; 630  : }

  0121b	8b e5		 mov	 esp, ebp
  0121d	5d		 pop	 ebp
  0121e	c3		 ret	 0
_AviResume ENDP
?InitMovie@@YAXXZ PROC NEAR				; InitMovie

; 633  : {

  0121f	55		 push	 ebp
  01220	8b ec		 mov	 ebp, esp

; 634  : 	// No longer necessary, but...
; 635  : }

  01222	5d		 pop	 ebp
  01223	c3		 ret	 0
?InitMovie@@YAXXZ ENDP					; InitMovie
_TEXT	ENDS
PUBLIC	?TermMovie@@YAXXZ				; TermMovie
_TEXT	SEGMENT
?TermMovie@@YAXXZ PROC NEAR				; TermMovie

; 638  : {

  01224	55		 push	 ebp
  01225	8b ec		 mov	 ebp, esp

; 639  : 	// No longer necessary, but...
; 640  : }

  01227	5d		 pop	 ebp
  01228	c3		 ret	 0
?TermMovie@@YAXXZ ENDP					; TermMovie
_TEXT	ENDS
_DATA	SEGMENT
$SG62038 DB	'status sciMovie%-1d length wait', 00H
_DATA	ENDS
_TEXT	SEGMENT
_movieNo$ = 8
_str$ = -80
_resultStr$ = -164
_errorCode$ = -84
_AviGetLength PROC NEAR

; 643  : {

  01229	55		 push	 ebp
  0122a	8b ec		 mov	 ebp, esp
  0122c	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H

; 644  : 	if(aviStatus[movieNo] == statusNotOpen)

  01232	8b 45 08	 mov	 eax, DWORD PTR _movieNo$[ebp]
  01235	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _aviStatus[eax*4], 0
  0123d	75 04		 jne	 SHORT $L62035

; 645  : 		return 0;

  0123f	33 c0		 xor	 eax, eax
  01241	eb 48		 jmp	 SHORT $L62041
$L62035:

; 648  : 	char resultStr[80];
; 649  : 	sprintf(str,"status sciMovie%-1d length wait",movieNo);

  01243	8b 4d 08	 mov	 ecx, DWORD PTR _movieNo$[ebp]
  01246	51		 push	 ecx
  01247	68 00 00 00 00	 push	 OFFSET FLAT:$SG62038
  0124c	8d 55 b0	 lea	 edx, DWORD PTR _str$[ebp]
  0124f	52		 push	 edx
  01250	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  01256	83 c4 0c	 add	 esp, 12			; 0000000cH

; 650  : 	DWORD errorCode = mciSendString(str,resultStr,80,0L);

  01259	6a 00		 push	 0
  0125b	6a 50		 push	 80			; 00000050H
  0125d	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR _resultStr$[ebp]
  01263	50		 push	 eax
  01264	8d 4d b0	 lea	 ecx, DWORD PTR _str$[ebp]
  01267	51		 push	 ecx
  01268	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendStringA@16
  0126e	89 45 ac	 mov	 DWORD PTR _errorCode$[ebp], eax

; 651  : 	if(!errorCode)

  01271	83 7d ac 00	 cmp	 DWORD PTR _errorCode$[ebp], 0
  01275	75 12		 jne	 SHORT $L62040

; 652  : 		return atoi(resultStr);

  01277	8d 95 5c ff ff
	ff		 lea	 edx, DWORD PTR _resultStr$[ebp]
  0127d	52		 push	 edx
  0127e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  01284	83 c4 04	 add	 esp, 4
  01287	eb 02		 jmp	 SHORT $L62041
$L62040:

; 654  : 		return 0;

  01289	33 c0		 xor	 eax, eax
$L62041:

; 655  : }

  0128b	8b e5		 mov	 esp, ebp
  0128d	5d		 pop	 ebp
  0128e	c3		 ret	 0
_AviGetLength ENDP
_TEXT	ENDS
_DATA	SEGMENT
$SG62047 DB	'status sciMovie%-1d position wait', 00H
_DATA	ENDS
_TEXT	SEGMENT
_movieNo$ = 8
_str$ = -80
_resultStr$ = -164
_errorCode$ = -84
_AviGetPosition PROC NEAR

; 658  : {

  0128f	55		 push	 ebp
  01290	8b ec		 mov	 ebp, esp
  01292	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H

; 659  : 
; 660  : 	char str[80];
; 661  : 	char resultStr[80];
; 662  : 	sprintf(str,"status sciMovie%-1d position wait",movieNo);

  01298	8b 45 08	 mov	 eax, DWORD PTR _movieNo$[ebp]
  0129b	50		 push	 eax
  0129c	68 00 00 00 00	 push	 OFFSET FLAT:$SG62047
  012a1	8d 4d b0	 lea	 ecx, DWORD PTR _str$[ebp]
  012a4	51		 push	 ecx
  012a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  012ab	83 c4 0c	 add	 esp, 12			; 0000000cH

; 663  : 	DWORD errorCode = mciSendString(str,resultStr,80,0L);

  012ae	6a 00		 push	 0
  012b0	6a 50		 push	 80			; 00000050H
  012b2	8d 95 5c ff ff
	ff		 lea	 edx, DWORD PTR _resultStr$[ebp]
  012b8	52		 push	 edx
  012b9	8d 45 b0	 lea	 eax, DWORD PTR _str$[ebp]
  012bc	50		 push	 eax
  012bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendStringA@16
  012c3	89 45 ac	 mov	 DWORD PTR _errorCode$[ebp], eax

; 664  : 	return atoi(resultStr);

  012c6	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _resultStr$[ebp]
  012cc	51		 push	 ecx
  012cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  012d3	83 c4 04	 add	 esp, 4

; 665  : 
; 666  : }

  012d6	8b e5		 mov	 esp, ebp
  012d8	5d		 pop	 ebp
  012d9	c3		 ret	 0
_AviGetPosition ENDP
_TEXT	ENDS
_DATA	SEGMENT
	ORG $+2
$SG62054 DB	'status sciMovie%-1d frames skipped wait', 00H
_DATA	ENDS
_TEXT	SEGMENT
_movieNo$ = 8
_str$ = -80
_resultStr$ = -164
_errorCode$ = -84
_AviGetFramesSkipped PROC NEAR

; 668  : {

  012da	55		 push	 ebp
  012db	8b ec		 mov	 ebp, esp
  012dd	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H

; 669  : 
; 670  : 	char str[80];
; 671  : 	char resultStr[80];
; 672  : 	sprintf(str,"status sciMovie%-1d frames skipped wait",movieNo);

  012e3	8b 45 08	 mov	 eax, DWORD PTR _movieNo$[ebp]
  012e6	50		 push	 eax
  012e7	68 00 00 00 00	 push	 OFFSET FLAT:$SG62054
  012ec	8d 4d b0	 lea	 ecx, DWORD PTR _str$[ebp]
  012ef	51		 push	 ecx
  012f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  012f6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 673  : 	DWORD errorCode = mciSendString(str,resultStr,80,0L);

  012f9	6a 00		 push	 0
  012fb	6a 50		 push	 80			; 00000050H
  012fd	8d 95 5c ff ff
	ff		 lea	 edx, DWORD PTR _resultStr$[ebp]
  01303	52		 push	 edx
  01304	8d 45 b0	 lea	 eax, DWORD PTR _str$[ebp]
  01307	50		 push	 eax
  01308	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendStringA@16
  0130e	89 45 ac	 mov	 DWORD PTR _errorCode$[ebp], eax

; 674  : 	return atoi(resultStr);

  01311	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _resultStr$[ebp]
  01317	51		 push	 ecx
  01318	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0131e	83 c4 04	 add	 esp, 4

; 675  : 
; 676  : }

  01321	8b e5		 mov	 esp, ebp
  01323	5d		 pop	 ebp
  01324	c3		 ret	 0
_AviGetFramesSkipped ENDP
_movieNo$ = 8
_AviGetStatus PROC NEAR

; 679  : {

  01325	55		 push	 ebp
  01326	8b ec		 mov	 ebp, esp

; 680  : 	return aviStatus[movieNo];

  01328	8b 45 08	 mov	 eax, DWORD PTR _movieNo$[ebp]
  0132b	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _aviStatus[eax*4]

; 681  : }

  01332	5d		 pop	 ebp
  01333	c3		 ret	 0
_AviGetStatus ENDP
_TEXT	ENDS
END
