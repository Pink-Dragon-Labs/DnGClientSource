	TITLE	\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Textid.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MemoryMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckValid@MemoryMgr@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GMemoryMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@V1@III@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AMemID@@QBEAADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8MemID@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??7MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeArrayID@@QBEPAUArrayHeader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ArrayID@@QAE@HW4ArrayType@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@ArrayID@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAE?AVMemID@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAEXVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_List@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@SOL_List@@QAEAAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeDispatchTblID@@QBEPAUDispatchTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeScriptEntryID@@QBEPAUScriptEntry@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntry@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeVariableID@@QBEPAUVariable@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Script@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Object@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGraphicsUpdate@Object@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?selectorDict@Object@@QAEPAVSelectorDict@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AObject@@QAEAAFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddr@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedPropAddr@Object@@QAEPBFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedProperty@Object@@QAEFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddrCheck@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@Object@@QAEFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropOffset@Object@@QAEIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetIndexedProperty@Object@@QAEXHF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetProperty@Object@@QAEXGF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssureValid@ObjectID@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsObject@ObjectID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeClassTblID@@QBEPAUClassTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DTextID@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@TextID@@QAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7MemoryMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	??0MemID@@QAE@XZ				; MemID::MemID
PUBLIC	??0TextID@@QAE@XZ				; TextID::TextID
_TEXT	SEGMENT
_this$ = -4
??0TextID@@QAE@XZ PROC NEAR				; TextID::TextID

; 12   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID

; 13   : }

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0TextID@@QAE@XZ ENDP					; TextID::TextID
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0MemID@@QAE@XZ PROC NEAR				; MemID::MemID, COMDAT

; 15   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 16   : 	}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0MemID@@QAE@XZ ENDP					; MemID::MemID
_TEXT	ENDS
PUBLIC	??0MemID@@QAE@ABV0@@Z				; MemID::MemID
PUBLIC	??0TextID@@QAE@ABVMemID@@@Z			; TextID::TextID
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0TextID@@QAE@ABVMemID@@@Z PROC NEAR			; TextID::TextID

; 16   : {

  00016	55		 push	 ebp
  00017	8b ec		 mov	 ebp, esp
  00019	51		 push	 ecx
  0001a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  00020	50		 push	 eax
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID

; 17   : }

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
??0TextID@@QAE@ABVMemID@@@Z ENDP			; TextID::TextID
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0MemID@@QAE@ABV0@@Z PROC NEAR				; MemID::MemID, COMDAT

; 19   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  0000d	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00010	66 89 10	 mov	 WORD PTR [eax], dx

; 20   : 	}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0MemID@@QAE@ABV0@@Z ENDP				; MemID::MemID
_TEXT	ENDS
PUBLIC	??0MemID@@QAE@G@Z				; MemID::MemID
PUBLIC	??0TextID@@QAE@G@Z				; TextID::TextID
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0TextID@@QAE@G@Z PROC NEAR				; TextID::TextID

; 20   : {

  00032	55		 push	 ebp
  00033	8b ec		 mov	 ebp, esp
  00035	51		 push	 ecx
  00036	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00039	66 8b 45 08	 mov	 ax, WORD PTR _h$[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID

; 21   : }

  00046	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
??0TextID@@QAE@G@Z ENDP					; TextID::TextID
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0MemID@@QAE@G@Z PROC NEAR				; MemID::MemID, COMDAT

; 23   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 4d 08	 mov	 cx, WORD PTR _h$[ebp]
  0000e	66 89 08	 mov	 WORD PTR [eax], cx

; 24   : 	}

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??0MemID@@QAE@G@Z ENDP					; MemID::MemID
_TEXT	ENDS
PUBLIC	??4TextID@@QAEAAV0@PBD@Z			; TextID::operator=
PUBLIC	??DTextID@@QAEPADXZ				; TextID::operator*
PUBLIC	?Get@TextID@@QAEXII@Z				; TextID::Get
EXTRN	?Realloc@MemID@@QBEPAXI@Z:NEAR			; MemID::Realloc
EXTRN	_strcpy:NEAR
EXTRN	_strlen:NEAR
_TEXT	SEGMENT
_str$ = 8
_this$ = -8
_size$ = -4
??4TextID@@QAEAAV0@PBD@Z PROC NEAR			; TextID::operator=

; 25   : {

  0004f	55		 push	 ebp
  00050	8b ec		 mov	 ebp, esp
  00052	83 ec 08	 sub	 esp, 8
  00055	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 26   : 	size_t size = strlen(str) + 1;

  00058	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _strlen
  00061	83 c4 04	 add	 esp, 4
  00064	83 c0 01	 add	 eax, 1
  00067	89 45 fc	 mov	 DWORD PTR _size$[ebp], eax

; 27   : 	if (!handle)

  0006a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	33 d2		 xor	 edx, edx
  0006f	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00072	85 d2		 test	 edx, edx
  00074	75 13		 jne	 SHORT $L58167

; 28   : 		Get(size);

  00076	68 00 02 01 00	 push	 66048			; 00010200H
  0007b	8b 45 fc	 mov	 eax, DWORD PTR _size$[ebp]
  0007e	50		 push	 eax
  0007f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	e8 00 00 00 00	 call	 ?Get@TextID@@QAEXII@Z	; TextID::Get

; 29   : 	else

  00087	eb 0c		 jmp	 SHORT $L58168
$L58167:

; 30   : 		Realloc(size);

  00089	8b 4d fc	 mov	 ecx, DWORD PTR _size$[ebp]
  0008c	51		 push	 ecx
  0008d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	e8 00 00 00 00	 call	 ?Realloc@MemID@@QBEPAXI@Z ; MemID::Realloc
$L58168:

; 31   : 	strcpy(**this, str);

  00095	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00098	52		 push	 edx
  00099	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 _strcpy
  000a7	83 c4 08	 add	 esp, 8

; 32   : 	
; 33   : 	return *this;

  000aa	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 34   : }

  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c2 04 00	 ret	 4
??4TextID@@QAEAAV0@PBD@Z ENDP				; TextID::operator=
_TEXT	ENDS
PUBLIC	??DMemID@@QBEPAXXZ				; MemID::operator*
PUBLIC	??_C@_00A@?$AA@					; `string'
;	COMDAT ??_C@_00A@?$AA@
; File \\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\textid.hpp
_BSS	SEGMENT
??_C@_00A@?$AA@ DB 01H DUP (?)				; `string'
_BSS	ENDS
;	COMDAT ??DTextID@@QAEPADXZ
_TEXT	SEGMENT
_this$ = -4
??DTextID@@QAEPADXZ PROC NEAR				; TextID::operator*, COMDAT

; 24   : 	char	*operator *() { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 25   : 		return handle ? (char *)MemID::operator*() : ""; 

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	33 c9		 xor	 ecx, ecx
  0000e	66 8b 08	 mov	 cx, WORD PTR [eax]
  00011	85 c9		 test	 ecx, ecx
  00013	74 0d		 je	 SHORT $L58304
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0001d	89 45 f8	 mov	 DWORD PTR -8+[ebp], eax
  00020	eb 07		 jmp	 SHORT $L58305
$L58304:
  00022	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
$L58305:
  00029	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]

; 26   : 	}

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??DTextID@@QAEPADXZ ENDP				; TextID::operator*
_TEXT	ENDS
PUBLIC	?GetAddr@MemoryMgr@@QAEPAXG@Z			; MemoryMgr::GetAddr
EXTRN	_memMgr:DWORD
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT
_this$ = -4
??DMemID@@QBEPAXXZ PROC NEAR				; MemID::operator*, COMDAT

; 98   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 99   : 		return memMgr->GetAddr(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr

; 100  : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??DMemID@@QBEPAXXZ ENDP					; MemID::operator*
_TEXT	ENDS
EXTRN	__descPtrTable:BYTE
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -4
?GetAddr@MemoryMgr@@QAEPAXG@Z PROC NEAR			; MemoryMgr::GetAddr, COMDAT

; 462  : 	inline void* MemoryMgr::GetAddr(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : //		CheckValid(theID);
; 464  : 		return _descPtrTable[(unsigned int)((unsigned short)theID)];

  00007	8b 45 08	 mov	 eax, DWORD PTR _theID$[ebp]
  0000a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0000f	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR __descPtrTable[eax*4]

; 465  : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?GetAddr@MemoryMgr@@QAEPAXG@Z ENDP			; MemoryMgr::GetAddr
_TEXT	ENDS
PUBLIC	?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get
;	COMDAT ?Get@TextID@@QAEXII@Z
_TEXT	SEGMENT
_size$ = 8
_attrs$ = 12
_this$ = -4
?Get@TextID@@QAEXII@Z PROC NEAR				; TextID::Get, COMDAT

; 34   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 35   : 		MemID::Get(MemText, size, attrs);

  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 00		 push	 0
  0000f	8b 45 0c	 mov	 eax, DWORD PTR _attrs$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  00016	51		 push	 ecx
  00017	6a 33		 push	 51			; 00000033H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get

; 36   : 	}

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?Get@TextID@@QAEXII@Z ENDP				; TextID::Get
_TEXT	ENDS
EXTRN	?Alloc@MemoryMgr@@QAEGIIIPAUMemClient@@DW4ReservedHandle@@@Z:NEAR ; MemoryMgr::Alloc
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT
_type$ = 8
_size$ = 12
_a$ = 16
_num$ = 20
_client$ = 24
_initChar$ = 28
_h$ = 32
_this$ = -4
?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z PROC NEAR ; MemID::Get, COMDAT

; 42   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 43   : 		handle = memMgr->Alloc(type | a, size, num, client, initChar, h);

  00007	8b 45 20	 mov	 eax, DWORD PTR _h$[ebp]
  0000a	50		 push	 eax
  0000b	8a 4d 1c	 mov	 cl, BYTE PTR _initChar$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 18	 mov	 edx, DWORD PTR _client$[ebp]
  00012	52		 push	 edx
  00013	8b 45 14	 mov	 eax, DWORD PTR _num$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 55 08	 mov	 edx, DWORD PTR _type$[ebp]
  0001e	0b 55 10	 or	 edx, DWORD PTR _a$[ebp]
  00021	52		 push	 edx
  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00028	e8 00 00 00 00	 call	 ?Alloc@MemoryMgr@@QAEGIIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemoryMgr::Alloc
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	66 89 01	 mov	 WORD PTR [ecx], ax

; 44   : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 1c 00	 ret	 28			; 0000001cH
?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ENDP ; MemID::Get
_TEXT	ENDS
PUBLIC	?Add@TextID@@QAEXD@Z				; TextID::Add
PUBLIC	?Add@TextID@@QAEXPBD@Z				; TextID::Add
_TEXT	SEGMENT
_c$ = 8
_this$ = -8
_buf$ = -4
?Add@TextID@@QAEXD@Z PROC NEAR				; TextID::Add

; 38   : {

  000b3	55		 push	 ebp
  000b4	8b ec		 mov	 ebp, esp
  000b6	83 ec 08	 sub	 esp, 8
  000b9	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 39   : 	//	add character
; 40   : 	
; 41   : 	char buf[] = { c, 0 };

  000bc	8a 45 08	 mov	 al, BYTE PTR _c$[ebp]
  000bf	88 45 fc	 mov	 BYTE PTR _buf$[ebp], al
  000c2	c6 45 fd 00	 mov	 BYTE PTR _buf$[ebp+1], 0

; 42   : 	Add(buf);

  000c6	8d 4d fc	 lea	 ecx, DWORD PTR _buf$[ebp]
  000c9	51		 push	 ecx
  000ca	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000cd	e8 00 00 00 00	 call	 ?Add@TextID@@QAEXPBD@Z	; TextID::Add

; 43   : }

  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c2 04 00	 ret	 4
?Add@TextID@@QAEXD@Z ENDP				; TextID::Add
_TEXT	ENDS
PUBLIC	?AddSize@TextID@@IAEXI@Z			; TextID::AddSize
EXTRN	_strcat:NEAR
_TEXT	SEGMENT
_str$ = 8
_this$ = -4
?Add@TextID@@QAEXPBD@Z PROC NEAR			; TextID::Add

; 47   : {

  000d8	55		 push	 ebp
  000d9	8b ec		 mov	 ebp, esp
  000db	51		 push	 ecx
  000dc	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 48   : 	//	add text, which should not be a dereferenced TextID itself
; 49   : 	
; 50   : 	AddSize(strlen(str));

  000df	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  000e2	50		 push	 eax
  000e3	e8 00 00 00 00	 call	 _strlen
  000e8	83 c4 04	 add	 esp, 4
  000eb	50		 push	 eax
  000ec	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ef	e8 00 00 00 00	 call	 ?AddSize@TextID@@IAEXI@Z ; TextID::AddSize

; 51   : 	strcat(**this, str);

  000f4	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  000f7	51		 push	 ecx
  000f8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fb	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  00100	50		 push	 eax
  00101	e8 00 00 00 00	 call	 _strcat
  00106	83 c4 08	 add	 esp, 8

; 52   : }

  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c2 04 00	 ret	 4
?Add@TextID@@QAEXPBD@Z ENDP				; TextID::Add
_TEXT	ENDS
PUBLIC	?Add@TextID@@QAEXV1@@Z				; TextID::Add
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
?Add@TextID@@QAEXV1@@Z PROC NEAR			; TextID::Add

; 56   : {

  0010f	55		 push	 ebp
  00110	8b ec		 mov	 ebp, esp
  00112	51		 push	 ecx
  00113	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 57   : 	//	add text from id
; 58   : 	
; 59   : 	AddSize(strlen(*id));

  00116	8d 4d 08	 lea	 ecx, DWORD PTR _id$[ebp]
  00119	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 _strlen
  00124	83 c4 04	 add	 esp, 4
  00127	50		 push	 eax
  00128	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012b	e8 00 00 00 00	 call	 ?AddSize@TextID@@IAEXI@Z ; TextID::AddSize

; 60   : 	strcat(**this, *id);

  00130	8d 4d 08	 lea	 ecx, DWORD PTR _id$[ebp]
  00133	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  00138	50		 push	 eax
  00139	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0013c	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  00141	50		 push	 eax
  00142	e8 00 00 00 00	 call	 _strcat
  00147	83 c4 08	 add	 esp, 8

; 61   : }

  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	c2 04 00	 ret	 4
?Add@TextID@@QAEXV1@@Z ENDP				; TextID::Add
_TEXT	ENDS
PUBLIC	?AddF@TextID@@QAAXPBDZZ				; TextID::AddF
EXTRN	__imp__vsprintf:NEAR
_TEXT	SEGMENT
_fmt$ = 12
_this$ = 8
_buf$ = -244
_args$ = -4
?AddF@TextID@@QAAXPBDZZ PROC NEAR			; TextID::AddF

; 65   : {

  00150	55		 push	 ebp
  00151	8b ec		 mov	 ebp, esp
  00153	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H

; 66   : 	//	add formatted text
; 67   : 	
; 68   : 	char buf[240];
; 69   : 	va_list	args;
; 70   : 	va_start(args, fmt);

  00159	8d 45 10	 lea	 eax, DWORD PTR _fmt$[ebp+4]
  0015c	89 45 fc	 mov	 DWORD PTR _args$[ebp], eax

; 71   : 	vsprintf(buf, fmt, args);

  0015f	8b 4d fc	 mov	 ecx, DWORD PTR _args$[ebp]
  00162	51		 push	 ecx
  00163	8b 55 0c	 mov	 edx, DWORD PTR _fmt$[ebp]
  00166	52		 push	 edx
  00167	8d 85 0c ff ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  0016d	50		 push	 eax
  0016e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__vsprintf
  00174	83 c4 0c	 add	 esp, 12			; 0000000cH

; 72   : 	va_end(args);

  00177	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _args$[ebp], 0

; 73   : 	
; 74   : 	Add(buf);

  0017e	8d 8d 0c ff ff
	ff		 lea	 ecx, DWORD PTR _buf$[ebp]
  00184	51		 push	 ecx
  00185	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00188	e8 00 00 00 00	 call	 ?Add@TextID@@QAEXPBD@Z	; TextID::Add

; 75   : }

  0018d	8b e5		 mov	 esp, ebp
  0018f	5d		 pop	 ebp
  00190	c3		 ret	 0
?AddF@TextID@@QAAXPBDZZ ENDP				; TextID::AddF
_additionalSize$ = 8
_this$ = -4
?AddSize@TextID@@IAEXI@Z PROC NEAR			; TextID::AddSize

; 79   : {

  00191	55		 push	 ebp
  00192	8b ec		 mov	 ebp, esp
  00194	51		 push	 ecx
  00195	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 80   : 	//	increase the size
; 81   : 
; 82   : 	if (!handle) {

  00198	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0019b	33 c9		 xor	 ecx, ecx
  0019d	66 8b 08	 mov	 cx, WORD PTR [eax]
  001a0	85 c9		 test	 ecx, ecx
  001a2	75 21		 jne	 SHORT $L58197

; 83   : 		Get(additionalSize + 1);

  001a4	68 00 02 01 00	 push	 66048			; 00010200H
  001a9	8b 55 08	 mov	 edx, DWORD PTR _additionalSize$[ebp]
  001ac	83 c2 01	 add	 edx, 1
  001af	52		 push	 edx
  001b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001b3	e8 00 00 00 00	 call	 ?Get@TextID@@QAEXII@Z	; TextID::Get

; 84   : 		***this = 0;

  001b8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001bb	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  001c0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 85   : 	} else

  001c3	eb 21		 jmp	 SHORT $L58198
$L58197:

; 86   : 		Realloc(strlen(**this) + additionalSize + 1);

  001c5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001c8	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  001cd	50		 push	 eax
  001ce	e8 00 00 00 00	 call	 _strlen
  001d3	83 c4 04	 add	 esp, 4
  001d6	8b 4d 08	 mov	 ecx, DWORD PTR _additionalSize$[ebp]
  001d9	8d 54 08 01	 lea	 edx, DWORD PTR [eax+ecx+1]
  001dd	52		 push	 edx
  001de	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001e1	e8 00 00 00 00	 call	 ?Realloc@MemID@@QBEPAXI@Z ; MemID::Realloc
$L58198:

; 87   : }

  001e6	8b e5		 mov	 esp, ebp
  001e8	5d		 pop	 ebp
  001e9	c2 04 00	 ret	 4
?AddSize@TextID@@IAEXI@Z ENDP				; TextID::AddSize
_TEXT	ENDS
PUBLIC	?Lock@TextID@@QAEPADXZ				; TextID::Lock
EXTRN	?Lock@MemID@@QBEPAXXZ:NEAR			; MemID::Lock
_TEXT	SEGMENT
_this$ = -4
?Lock@TextID@@QAEPADXZ PROC NEAR			; TextID::Lock

; 91   : {

  001ec	55		 push	 ebp
  001ed	8b ec		 mov	 ebp, esp
  001ef	51		 push	 ecx
  001f0	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 92   : 	return (char*) MemID::Lock();

  001f3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001f6	e8 00 00 00 00	 call	 ?Lock@MemID@@QBEPAXXZ	; MemID::Lock

; 93   : }

  001fb	8b e5		 mov	 esp, ebp
  001fd	5d		 pop	 ebp
  001fe	c3		 ret	 0
?Lock@TextID@@QAEPADXZ ENDP				; TextID::Lock
_TEXT	ENDS
PUBLIC	?Snug@TextID@@QAEXXZ				; TextID::Snug
_TEXT	SEGMENT
_this$ = -4
?Snug@TextID@@QAEXXZ PROC NEAR				; TextID::Snug

; 97   : {

  001ff	55		 push	 ebp
  00200	8b ec		 mov	 ebp, esp
  00202	51		 push	 ecx
  00203	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 98   : 	//	realloc to just the right size
; 99   : 	
; 100  : 	if (handle)

  00206	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00209	33 c9		 xor	 ecx, ecx
  0020b	66 8b 08	 mov	 cx, WORD PTR [eax]
  0020e	85 c9		 test	 ecx, ecx
  00210	74 1d		 je	 SHORT $L58206

; 101  : 		Realloc(strlen(**this) + 1);

  00212	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00215	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  0021a	50		 push	 eax
  0021b	e8 00 00 00 00	 call	 _strlen
  00220	83 c4 04	 add	 esp, 4
  00223	83 c0 01	 add	 eax, 1
  00226	50		 push	 eax
  00227	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0022a	e8 00 00 00 00	 call	 ?Realloc@MemID@@QBEPAXI@Z ; MemID::Realloc
$L58206:

; 102  : }

  0022f	8b e5		 mov	 esp, ebp
  00231	5d		 pop	 ebp
  00232	c3		 ret	 0
?Snug@TextID@@QAEXXZ ENDP				; TextID::Snug
_TEXT	ENDS
PUBLIC	?GetProperty@Object@@QAEFG@Z			; Object::GetProperty
PUBLIC	??CFakeObjectID@@QBEPAUObject@@XZ		; FakeObjectID::operator->
PUBLIC	??0ObjectID@@QAE@G@Z				; ObjectID::ObjectID
PUBLIC	?IsObject@ObjectID@@QBEHXZ			; ObjectID::IsObject
PUBLIC	??4StringID@@QAEAAV0@PBD@Z			; StringID::operator=
_TEXT	SEGMENT
_str$ = 8
_this$ = -20
_size$ = -4
_obj$ = -8
_pText$58214 = -12
_pText$58216 = -16
??4StringID@@QAEAAV0@PBD@Z PROC NEAR			; StringID::operator=

; 106  : {

  00233	55		 push	 ebp
  00234	8b ec		 mov	 ebp, esp
  00236	83 ec 14	 sub	 esp, 20			; 00000014H
  00239	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 107  : 	size_t size = strlen(str) + 1;

  0023c	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  0023f	50		 push	 eax
  00240	e8 00 00 00 00	 call	 _strlen
  00245	83 c4 04	 add	 esp, 4
  00248	83 c0 01	 add	 eax, 1
  0024b	89 45 fc	 mov	 DWORD PTR _size$[ebp], eax

; 108  : 
; 109  : 	ObjectID obj ( handle );

  0024e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00251	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00254	52		 push	 edx
  00255	8d 4d f8	 lea	 ecx, DWORD PTR _obj$[ebp]
  00258	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID

; 110  : 
; 111  : 	if ( obj.IsObject() ) {

  0025d	8d 4d f8	 lea	 ecx, DWORD PTR _obj$[ebp]
  00260	e8 00 00 00 00	 call	 ?IsObject@ObjectID@@QBEHXZ ; ObjectID::IsObject
  00265	85 c0		 test	 eax, eax
  00267	74 28		 je	 SHORT $L58213

; 112  : 		TextID pText ( obj->GetProperty ( s_data ) );

  00269	6a 71		 push	 113			; 00000071H
  0026b	8d 4d f8	 lea	 ecx, DWORD PTR _obj$[ebp]
  0026e	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  00273	8b c8		 mov	 ecx, eax
  00275	e8 00 00 00 00	 call	 ?GetProperty@Object@@QAEFG@Z ; Object::GetProperty
  0027a	50		 push	 eax
  0027b	8d 4d f4	 lea	 ecx, DWORD PTR _pText$58214[ebp]
  0027e	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID

; 113  : 		pText = str;

  00283	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00286	50		 push	 eax
  00287	8d 4d f4	 lea	 ecx, DWORD PTR _pText$58214[ebp]
  0028a	e8 00 00 00 00	 call	 ??4TextID@@QAEAAV0@PBD@Z ; TextID::operator=

; 114  : 	} else {

  0028f	eb 1b		 jmp	 SHORT $L58215
$L58213:

; 115  : 		TextID pText ( handle );

  00291	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00294	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00297	52		 push	 edx
  00298	8d 4d f0	 lea	 ecx, DWORD PTR _pText$58216[ebp]
  0029b	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID

; 116  : 		pText = str;

  002a0	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  002a3	50		 push	 eax
  002a4	8d 4d f0	 lea	 ecx, DWORD PTR _pText$58216[ebp]
  002a7	e8 00 00 00 00	 call	 ??4TextID@@QAEAAV0@PBD@Z ; TextID::operator=
$L58215:

; 118  : 	
; 119  : 	return *this;

  002ac	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]

; 120  : }

  002af	8b e5		 mov	 esp, ebp
  002b1	5d		 pop	 ebp
  002b2	c2 04 00	 ret	 4
??4StringID@@QAEAAV0@PBD@Z ENDP				; StringID::operator=
_TEXT	ENDS
PUBLIC	?GetPropAddrCheck@Object@@QAEPAFG@Z		; Object::GetPropAddrCheck
;	COMDAT ?GetProperty@Object@@QAEFG@Z
_TEXT	SEGMENT
_selector$ = 8
_this$ = -4
?GetProperty@Object@@QAEFG@Z PROC NEAR			; Object::GetProperty, COMDAT

; 170  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 171  : 		//	get a property given a selector
; 172  : 		return *GetPropAddrCheck(selector);

  00007	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?GetPropAddrCheck@Object@@QAEPAFG@Z ; Object::GetPropAddrCheck
  00014	66 8b 00	 mov	 ax, WORD PTR [eax]

; 173  : 	}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?GetProperty@Object@@QAEFG@Z ENDP			; Object::GetProperty
_TEXT	ENDS
PUBLIC	?GetPropAddr@Object@@QAEPAFG@Z			; Object::GetPropAddr
EXTRN	?Fatal@MsgMgr@@QAAXHZZ:NEAR			; MsgMgr::Fatal
EXTRN	?msgMgr@@3PAVMsgMgr@@A:DWORD			; msgMgr
;	COMDAT ?GetPropAddrCheck@Object@@QAEPAFG@Z
_TEXT	SEGMENT
_selector$ = 8
_this$ = -8
_property$ = -4
?GetPropAddrCheck@Object@@QAEPAFG@Z PROC NEAR		; Object::GetPropAddrCheck, COMDAT

; 153  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 154  : 		//	get a property's address, checking for valid property
; 155  : 		Property* property = GetPropAddr(selector);

  00009	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?GetPropAddr@Object@@QAEPAFG@Z ; Object::GetPropAddr
  00016	89 45 fc	 mov	 DWORD PTR _property$[ebp], eax

; 156  : 		if (!property)

  00019	83 7d fc 00	 cmp	 DWORD PTR _property$[ebp], 0
  0001d	75 1b		 jne	 SHORT $L57763

; 157  : 			msgMgr->Fatal(Msg_InvalidProperty, selector);

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _selector$[ebp]
  00022	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00028	51		 push	 ecx
  00029	6a 29		 push	 41			; 00000029H
  0002b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXHZZ	; MsgMgr::Fatal
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
$L57763:

; 158  : 		return property;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _property$[ebp]

; 159  : 	}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
?GetPropAddrCheck@Object@@QAEPAFG@Z ENDP		; Object::GetPropAddrCheck
_TEXT	ENDS
PUBLIC	?selectorDict@Object@@QAEPAVSelectorDict@@XZ	; Object::selectorDict
PUBLIC	??AObject@@QAEAAFH@Z				; Object::operator[]
EXTRN	?get@SelectorDict@@QAEHG@Z:NEAR			; SelectorDict::get
;	COMDAT ?GetPropAddr@Object@@QAEPAFG@Z
_TEXT	SEGMENT
_selector$ = 8
_this$ = -8
_index$ = -4
?GetPropAddr@Object@@QAEPAFG@Z PROC NEAR		; Object::GetPropAddr, COMDAT

; 127  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 128  : 		int index = selectorDict()->get ( selector );

  00009	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?selectorDict@Object@@QAEPAVSelectorDict@@XZ ; Object::selectorDict
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 ?get@SelectorDict@@QAEHG@Z ; SelectorDict::get
  0001d	89 45 fc	 mov	 DWORD PTR _index$[ebp], eax

; 129  : 
; 130  : 		if ( index != -1 && !selectorDict()->script )

  00020	83 7d fc ff	 cmp	 DWORD PTR _index$[ebp], -1
  00024	74 2b		 je	 SHORT $L57754
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?selectorDict@Object@@QAEPAVSelectorDict@@XZ ; Object::selectorDict
  0002e	33 c9		 xor	 ecx, ecx
  00030	66 8b 48 16	 mov	 cx, WORD PTR [eax+22]
  00034	85 c9		 test	 ecx, ecx
  00036	75 19		 jne	 SHORT $L57754

; 131  : 			return &(*this)[selectorDict()->offset]; 

  00038	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?selectorDict@Object@@QAEPAVSelectorDict@@XZ ; Object::selectorDict
  00040	33 d2		 xor	 edx, edx
  00042	66 8b 50 14	 mov	 dx, WORD PTR [eax+20]
  00046	52		 push	 edx
  00047	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ??AObject@@QAEAAFH@Z	; Object::operator[]
  0004f	eb 02		 jmp	 SHORT $L57752
$L57754:

; 132  : 
; 133  : 		return 0;

  00051	33 c0		 xor	 eax, eax
$L57752:

; 134  : 	}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
?GetPropAddr@Object@@QAEPAFG@Z ENDP			; Object::GetPropAddr
_TEXT	ENDS
;	COMDAT ?selectorDict@Object@@QAEPAVSelectorDict@@XZ
_TEXT	SEGMENT
_this$ = -4
?selectorDict@Object@@QAEPAVSelectorDict@@XZ PROC NEAR	; Object::selectorDict, COMDAT

; 102  : 	SelectorDict *selectorDict ( void ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 103  : 		return _selectorDict;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 104  : 	};

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?selectorDict@Object@@QAEPAVSelectorDict@@XZ ENDP	; Object::selectorDict
_TEXT	ENDS
;	COMDAT ??AObject@@QAEAAFH@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
??AObject@@QAEAAFH@Z PROC NEAR				; Object::operator[], COMDAT

; 117  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 118  : 		//	get a reference to a property given the number of the property
; 119  : 		return ((Property*) this)[index];

  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]

; 120  : 	}

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??AObject@@QAEAAFH@Z ENDP				; Object::operator[]
_TEXT	ENDS
;	COMDAT ??CFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT
_this$ = -4
??CFakeObjectID@@QBEPAUObject@@XZ PROC NEAR		; FakeObjectID::operator->, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??CFakeObjectID@@QBEPAUObject@@XZ ENDP			; FakeObjectID::operator->
_TEXT	ENDS
PUBLIC	??0FakeObjectID@@QAE@G@Z			; FakeObjectID::FakeObjectID
;	COMDAT ??0ObjectID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0ObjectID@@QAE@G@Z PROC NEAR				; ObjectID::ObjectID, COMDAT

; 230  : 	ObjectID(SOL_Handle h) : FakeObjectID(h) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	66 8b 45 08	 mov	 ax, WORD PTR _h$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0FakeObjectID@@QAE@G@Z ; FakeObjectID::FakeObjectID
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0ObjectID@@QAE@G@Z ENDP				; ObjectID::ObjectID
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0FakeObjectID@@QAE@G@Z PROC NEAR			; FakeObjectID::FakeObjectID, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	66 8b 45 08	 mov	 ax, WORD PTR _h$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0FakeObjectID@@QAE@G@Z ENDP				; FakeObjectID::FakeObjectID
_TEXT	ENDS
PUBLIC	?IsValid@MemID@@QBEHXZ				; MemID::IsValid
EXTRN	?GetMemType@MemID@@QBE?AW4MemType@@XZ:NEAR	; MemID::GetMemType
;	COMDAT ?IsObject@ObjectID@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsObject@ObjectID@@QBEHXZ PROC NEAR			; ObjectID::IsObject, COMDAT

; 247  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 248  : 		return IsValid() && GetMemType() == MemObject;

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  00011	85 c0		 test	 eax, eax
  00013	74 16		 je	 SHORT $L58328
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  0001d	83 f8 34	 cmp	 eax, 52			; 00000034H
  00020	75 09		 jne	 SHORT $L58328
  00022	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR -8+[ebp], 1
  00029	eb 07		 jmp	 SHORT $L58329
$L58328:
  0002b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], 0
$L58329:
  00032	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]

; 249  : 	}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?IsObject@ObjectID@@QBEHXZ ENDP				; ObjectID::IsObject
_TEXT	ENDS
PUBLIC	?IsValid@MemoryMgr@@QAEHG@Z			; MemoryMgr::IsValid
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsValid@MemID@@QBEHXZ PROC NEAR			; MemID::IsValid, COMDAT

; 62   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 63   : 		return memMgr->IsValid(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?IsValid@MemoryMgr@@QAEHG@Z ; MemoryMgr::IsValid

; 64   : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?IsValid@MemID@@QBEHXZ ENDP				; MemID::IsValid
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -8
_tempID$ = -4
?IsValid@MemoryMgr@@QAEHG@Z PROC NEAR			; MemoryMgr::IsValid, COMDAT

; 475  : 	inline Bool MemoryMgr::IsValid(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 476  : 		unsigned short tempID = (unsigned short)theID;

  00009	66 8b 45 08	 mov	 ax, WORD PTR _theID$[ebp]
  0000d	66 89 45 fc	 mov	 WORD PTR _tempID$[ebp], ax

; 477  : 
; 478  : 		return(
; 479  : 				(tempID)															&&
; 480  : 				(tempID < maxDescriptors)									&&
; 481  : 				(desc[tempID].memInfo.bits.freeDescriptor == False)	&&
; 482  : 				(desc[tempID].memInfo.bits.freeMemory == False)
; 483  : 				);

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _tempID$[ebp]
  00014	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 58		 je	 SHORT $L58332
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _tempID$[ebp]
  00021	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  0002d	73 47		 jae	 SHORT $L58332
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _tempID$[ebp]
  00032	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00038	c1 e1 04	 shl	 ecx, 4
  0003b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00041	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00044	c1 e1 0e	 shl	 ecx, 14			; 0000000eH
  00047	c1 f9 1f	 sar	 ecx, 31			; 0000001fH
  0004a	85 c9		 test	 ecx, ecx
  0004c	75 28		 jne	 SHORT $L58332
  0004e	8b 55 fc	 mov	 edx, DWORD PTR _tempID$[ebp]
  00051	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00057	c1 e2 04	 shl	 edx, 4
  0005a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00060	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00063	c1 e2 14	 shl	 edx, 20			; 00000014H
  00066	c1 fa 1f	 sar	 edx, 31			; 0000001fH
  00069	85 d2		 test	 edx, edx
  0006b	75 09		 jne	 SHORT $L58332
  0006d	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR -12+[ebp], 1
  00074	eb 07		 jmp	 SHORT $L58333
$L58332:
  00076	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR -12+[ebp], 0
$L58333:
  0007d	8b 45 f4	 mov	 eax, DWORD PTR -12+[ebp]

; 484  : 	}

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 04 00	 ret	 4
?IsValid@MemoryMgr@@QAEHG@Z ENDP			; MemoryMgr::IsValid
_TEXT	ENDS
END
