	TITLE	\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Celobj2.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BM@LHED@Instructed?5to?5scale?5to?5zero?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07CCG@ResView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KCEF@?4v56?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06IAEF@ResPic?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04EODC@?4p56?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08OCKJ@ResChunk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PIPI@?4chk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07ICMB@ResHunk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GG@?4scr?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08BLBP@ResSound?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KPDA@?4snd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NNMB@ResVocab?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PGDD@?4voc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FLKK@ResPatch?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CEHK@?4pat?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07MKGC@ResFont?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04IDCK@?4fon?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06DEEM@ResPal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NJLC@?4pal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07HFNL@ResHeap?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GFFD@?4hep?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06HDCC@ResMsg?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JONM@?4msg?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NFDN@ResAudio?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MOHF@?4aud?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BKMJ@ResWave?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MPDF@?4wav?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@IMEI@ResAudio36?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BONB@ResSync?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KFFK@?4syn?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09CBJE@ResSync36?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06MIEL@ResMap?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CFLF@?4map?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@LIAH@ResMsgTranslation?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JFJA@?4trn?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08JLOL@ResRobot?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04LLKI@?4rbt?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06OEMP@ResVMD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04IOID@?4vmd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MemoryMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckValid@MemoryMgr@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GMemoryMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@V1@III@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AMemID@@QBEAADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8MemID@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@NN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SOL_Point@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Rgb24@@QAE@EEE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Rgb24@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Rgb24F@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Ratio@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@HHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@VMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Type@Bitmap@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObj@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Skip@CelObj@@QBEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemapState@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Mirrored@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObj@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjView@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjView@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjView@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjView@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjMem@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjMem@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjMem@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjMem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjColor@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjColor@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjColor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjColor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@AAVSOL_Point@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Set@SOL_Rect@@QAEXHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeEmpty@SOL_Rect@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Xlen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ylen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8SOL_Rect@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Draw@ScreenItem@@QAEXABVBuffer@@ABVSOL_Rect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SOL_Rect@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TopPlane@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TopSCIPlane@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Xdim@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ydim@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?XDim@Buffer@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1PaletteMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GPaletteMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetExtension@SOL_ResType@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSupported@SOL_ResType@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAttrs@SOL_ResType@@UBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResView@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPic@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResChunk@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResScript@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSound@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResVocab@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPatch@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResFont@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPal@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResHeap@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMsg@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResAudio@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResWave@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResAudio36@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSync@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSync36@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMap@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMsgTranslation@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileType@ResMsgTranslation@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResRobot@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResVMD@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7ResPic@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7PaletteMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResView@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResPal@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObj@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResHeap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResWave@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResRobot@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResPatch@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMsgTranslation@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7Buffer@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResScript@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjColor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSync36@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMsg@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjView@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResAudio36@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResAudio@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResFont@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7MemoryMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResVMD@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResChunk@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSync@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjMem@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResVocab@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?DrawHzFlipMap@CelObj@@QAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@@Z ; CelObj::DrawHzFlipMap
PUBLIC	?Xlen@SOL_Rect@@QBEHXZ				; SOL_Rect::Xlen
PUBLIC	?Ylen@SOL_Rect@@QBEHXZ				; SOL_Rect::Ylen
EXTRN	?REMAP_START_COLOR@@3HA:DWORD			; REMAP_START_COLOR
EXTRN	?REMAP_END_COLOR@@3HA:DWORD			; REMAP_END_COLOR
EXTRN	?remapColor@Remap@@2PAY0BAA@EA:BYTE		; Remap::remapColor
EXTRN	?remapOn@Remap@@2PAEA:BYTE			; Remap::remapOn
EXTRN	_memset:NEAR
_TEXT	SEGMENT
_dest$ = 8
_toBuffer$ = 12
_ul$ = 16
_this$ = -96
_rowLen$ = -4
_srcCol$ = -40
_srcRow$ = -32
_hRun$ = -16
_vRun$ = -8
_resBuffer$ = -48
_celPtr$ = -24
_controlData$ = -12
_colorData$ = -44
_controlTable$ = -36
_colorTable$ = -20
_i$ = -28
_target$58647 = -64
_controlPtr$58648 = -56
_colorPtr$58649 = -60
_j$58650 = -52
_control$58654 = -68
_k$58660 = -72
_color$58664 = -76
_color$58681 = -80
_ptr$58684 = -84
_table$58685 = -88
_k$58686 = -92
?DrawHzFlipMap@CelObj@@QAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@@Z PROC NEAR ; CelObj::DrawHzFlipMap

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	56		 push	 esi
  00007	89 4d a0	 mov	 DWORD PTR _this$[ebp], ecx

; 18   : 	assert(dest.Assert());
; 19   : 	assert(toBuffer.IsWithin(dest.XDim(), dest.YDim()));
; 20   : 
; 21   : 	// ***********************************************************************
; 22   : 	// Non scaled drawing mirrored.
; 23   : 	// ***********************************************************************
; 24   : 	// Get a pointer to the drawing area(a static buffer).
; 25   : 
; 26   : 	int rowLen = toBuffer.Xlen();

  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  0000d	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  00012	89 45 fc	 mov	 DWORD PTR _rowLen$[ebp], eax

; 27   : 	int srcCol = width - (toBuffer.A.x - ul.x + toBuffer.Xlen());

  00015	8b 45 0c	 mov	 eax, DWORD PTR _toBuffer$[ebp]
  00018	8b 30		 mov	 esi, DWORD PTR [eax]
  0001a	2b 75 10	 sub	 esi, DWORD PTR _ul$[ebp]
  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  00020	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  00025	03 f0		 add	 esi, eax
  00027	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0002d	2b d6		 sub	 edx, esi
  0002f	89 55 d8	 mov	 DWORD PTR _srcCol$[ebp], edx

; 28   : 	int srcRow = toBuffer.A.y - ul.y;

  00032	8b 45 0c	 mov	 eax, DWORD PTR _toBuffer$[ebp]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	2b 4d 14	 sub	 ecx, DWORD PTR _ul$[ebp+4]
  0003b	89 4d e0	 mov	 DWORD PTR _srcRow$[ebp], ecx

; 29   : 	int hRun = width - toBuffer.A.x + ul.x;

  0003e	8b 55 a0	 mov	 edx, DWORD PTR _this$[ebp]
  00041	8b 45 0c	 mov	 eax, DWORD PTR _toBuffer$[ebp]
  00044	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  00047	2b 08		 sub	 ecx, DWORD PTR [eax]
  00049	03 4d 10	 add	 ecx, DWORD PTR _ul$[ebp]
  0004c	89 4d f0	 mov	 DWORD PTR _hRun$[ebp], ecx

; 30   : 	int vRun = toBuffer.Ylen();

  0004f	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  00052	e8 00 00 00 00	 call	 ?Ylen@SOL_Rect@@QBEHXZ	; SOL_Rect::Ylen
  00057	89 45 f8	 mov	 DWORD PTR _vRun$[ebp], eax

; 31   : 
; 32   : 	// Get a pointer to the cel.
; 33   : 	uchar* resBuffer = ResPointer();

  0005a	8b 55 a0	 mov	 edx, DWORD PTR _this$[ebp]
  0005d	8b 02		 mov	 eax, DWORD PTR [edx]
  0005f	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	ff 50 14	 call	 DWORD PTR [eax+20]
  00065	89 45 d0	 mov	 DWORD PTR _resBuffer$[ebp], eax

; 34   : 	CelHeader* celPtr = (CelHeader*) (resBuffer + celOffset);

  00068	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	8b 55 d0	 mov	 edx, DWORD PTR _resBuffer$[ebp]
  0006e	03 51 18	 add	 edx, DWORD PTR [ecx+24]
  00071	89 55 e8	 mov	 DWORD PTR _celPtr$[ebp], edx

; 35   : 
; 36   : 	uchar* controlData = resBuffer + celPtr->controlOffset;

  00074	8b 45 e8	 mov	 eax, DWORD PTR _celPtr$[ebp]
  00077	8b 4d d0	 mov	 ecx, DWORD PTR _resBuffer$[ebp]
  0007a	03 48 18	 add	 ecx, DWORD PTR [eax+24]
  0007d	89 4d f4	 mov	 DWORD PTR _controlData$[ebp], ecx

; 37   : 	uchar* colorData = resBuffer + celPtr->colorOffset;

  00080	8b 55 e8	 mov	 edx, DWORD PTR _celPtr$[ebp]
  00083	8b 45 d0	 mov	 eax, DWORD PTR _resBuffer$[ebp]
  00086	03 42 1c	 add	 eax, DWORD PTR [edx+28]
  00089	89 45 d4	 mov	 DWORD PTR _colorData$[ebp], eax

; 38   : 
; 39   : 	long* controlTable = (long *) (resBuffer + celPtr->rowTableOffset);

  0008c	8b 4d e8	 mov	 ecx, DWORD PTR _celPtr$[ebp]
  0008f	8b 55 d0	 mov	 edx, DWORD PTR _resBuffer$[ebp]
  00092	03 51 20	 add	 edx, DWORD PTR [ecx+32]
  00095	89 55 dc	 mov	 DWORD PTR _controlTable$[ebp], edx

; 40   : 	long* colorTable = controlTable + height;

  00098	8b 45 a0	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0009e	8b 55 dc	 mov	 edx, DWORD PTR _controlTable$[ebp]
  000a1	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  000a4	89 45 ec	 mov	 DWORD PTR _colorTable$[ebp], eax

; 41   : 
; 42   : 	// Draw the inset rectangle
; 43   : 	for (int i = 0;i < vRun;++i,++srcRow) {

  000a7	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000ae	eb 12		 jmp	 SHORT $L58644
$L58645:
  000b0	8b 4d e4	 mov	 ecx, DWORD PTR _i$[ebp]
  000b3	83 c1 01	 add	 ecx, 1
  000b6	89 4d e4	 mov	 DWORD PTR _i$[ebp], ecx
  000b9	8b 55 e0	 mov	 edx, DWORD PTR _srcRow$[ebp]
  000bc	83 c2 01	 add	 edx, 1
  000bf	89 55 e0	 mov	 DWORD PTR _srcRow$[ebp], edx
$L58644:
  000c2	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  000c5	3b 45 f8	 cmp	 eax, DWORD PTR _vRun$[ebp]
  000c8	0f 8d ab 03 00
	00		 jge	 $L58646

; 44   : 		// Find the row data
; 45   : 		uchar* target = dest.Addr(toBuffer.A.x, toBuffer.A.y + i) + rowLen - 1;

  000ce	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  000d1	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d4	03 55 e4	 add	 edx, DWORD PTR _i$[ebp]
  000d7	52		 push	 edx
  000d8	8b 45 0c	 mov	 eax, DWORD PTR _toBuffer$[ebp]
  000db	8b 08		 mov	 ecx, DWORD PTR [eax]
  000dd	51		 push	 ecx
  000de	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  000e1	8b 02		 mov	 eax, DWORD PTR [edx]
  000e3	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  000e6	ff 10		 call	 DWORD PTR [eax]
  000e8	8b 4d fc	 mov	 ecx, DWORD PTR _rowLen$[ebp]
  000eb	8d 54 08 ff	 lea	 edx, DWORD PTR [eax+ecx-1]
  000ef	89 55 c0	 mov	 DWORD PTR _target$58647[ebp], edx

; 46   : 		uchar* controlPtr = controlData + controlTable[srcRow];

  000f2	8b 45 e0	 mov	 eax, DWORD PTR _srcRow$[ebp]
  000f5	8b 4d dc	 mov	 ecx, DWORD PTR _controlTable$[ebp]
  000f8	8b 55 f4	 mov	 edx, DWORD PTR _controlData$[ebp]
  000fb	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  000fe	89 55 c8	 mov	 DWORD PTR _controlPtr$58648[ebp], edx

; 47   : 		uchar* colorPtr = colorData + colorTable[srcRow];

  00101	8b 45 e0	 mov	 eax, DWORD PTR _srcRow$[ebp]
  00104	8b 4d ec	 mov	 ecx, DWORD PTR _colorTable$[ebp]
  00107	8b 55 d4	 mov	 edx, DWORD PTR _colorData$[ebp]
  0010a	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  0010d	89 55 c4	 mov	 DWORD PTR _colorPtr$58649[ebp], edx

; 48   : 
; 49   : 		// Draw a line
; 50   : 		for (int j = 0;j <hRun;) {

  00110	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _j$58650[ebp], 0
$L58652:
  00117	8b 45 cc	 mov	 eax, DWORD PTR _j$58650[ebp]
  0011a	3b 45 f0	 cmp	 eax, DWORD PTR _hRun$[ebp]
  0011d	0f 8d 51 03 00
	00		 jge	 $L58653

; 51   : 			// Get the control character
; 52   : 			uchar control = *controlPtr++;

  00123	8b 4d c8	 mov	 ecx, DWORD PTR _controlPtr$58648[ebp]
  00126	8a 11		 mov	 dl, BYTE PTR [ecx]
  00128	88 55 bc	 mov	 BYTE PTR _control$58654[ebp], dl
  0012b	8b 45 c8	 mov	 eax, DWORD PTR _controlPtr$58648[ebp]
  0012e	83 c0 01	 add	 eax, 1
  00131	89 45 c8	 mov	 DWORD PTR _controlPtr$58648[ebp], eax

; 53   : 			if (!(control & REPEATC)) {

  00134	8b 4d bc	 mov	 ecx, DWORD PTR _control$58654[ebp]
  00137	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0013d	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00143	85 c9		 test	 ecx, ecx
  00145	0f 85 40 01 00
	00		 jne	 $L58655

; 54   : 				// Do a run of unique bytes
; 55   : 				if ((j + control) < srcCol) {

  0014b	8b 55 bc	 mov	 edx, DWORD PTR _control$58654[ebp]
  0014e	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00154	8b 45 cc	 mov	 eax, DWORD PTR _j$58650[ebp]
  00157	03 c2		 add	 eax, edx
  00159	3b 45 d8	 cmp	 eax, DWORD PTR _srcCol$[ebp]
  0015c	7d 26		 jge	 SHORT $L58656

; 56   : 					j += control;

  0015e	8b 4d bc	 mov	 ecx, DWORD PTR _control$58654[ebp]
  00161	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00167	8b 55 cc	 mov	 edx, DWORD PTR _j$58650[ebp]
  0016a	03 d1		 add	 edx, ecx
  0016c	89 55 cc	 mov	 DWORD PTR _j$58650[ebp], edx

; 57   : 					colorPtr += control;

  0016f	8b 45 bc	 mov	 eax, DWORD PTR _control$58654[ebp]
  00172	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00177	8b 4d c4	 mov	 ecx, DWORD PTR _colorPtr$58649[ebp]
  0017a	03 c8		 add	 ecx, eax
  0017c	89 4d c4	 mov	 DWORD PTR _colorPtr$58649[ebp], ecx

; 59   : 				else {

  0017f	e9 02 01 00 00	 jmp	 $L58663
$L58656:

; 60   : 					if (j < srcCol) {

  00184	8b 55 cc	 mov	 edx, DWORD PTR _j$58650[ebp]
  00187	3b 55 d8	 cmp	 edx, DWORD PTR _srcCol$[ebp]
  0018a	7d 22		 jge	 SHORT $L58658

; 61   : 						control -= srcCol - j;

  0018c	8b 45 d8	 mov	 eax, DWORD PTR _srcCol$[ebp]
  0018f	2b 45 cc	 sub	 eax, DWORD PTR _j$58650[ebp]
  00192	8a 4d bc	 mov	 cl, BYTE PTR _control$58654[ebp]
  00195	2a c8		 sub	 cl, al
  00197	88 4d bc	 mov	 BYTE PTR _control$58654[ebp], cl

; 62   : 						colorPtr += srcCol - j;

  0019a	8b 55 d8	 mov	 edx, DWORD PTR _srcCol$[ebp]
  0019d	2b 55 cc	 sub	 edx, DWORD PTR _j$58650[ebp]
  001a0	8b 45 c4	 mov	 eax, DWORD PTR _colorPtr$58649[ebp]
  001a3	03 c2		 add	 eax, edx
  001a5	89 45 c4	 mov	 DWORD PTR _colorPtr$58649[ebp], eax

; 63   : 						j = srcCol;

  001a8	8b 4d d8	 mov	 ecx, DWORD PTR _srcCol$[ebp]
  001ab	89 4d cc	 mov	 DWORD PTR _j$58650[ebp], ecx
$L58658:

; 65   : 					if (j + control > hRun) {

  001ae	8b 55 bc	 mov	 edx, DWORD PTR _control$58654[ebp]
  001b1	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  001b7	8b 45 cc	 mov	 eax, DWORD PTR _j$58650[ebp]
  001ba	03 c2		 add	 eax, edx
  001bc	3b 45 f0	 cmp	 eax, DWORD PTR _hRun$[ebp]
  001bf	7e 09		 jle	 SHORT $L58659

; 66   : 						control = hRun - j;

  001c1	8b 4d f0	 mov	 ecx, DWORD PTR _hRun$[ebp]
  001c4	2b 4d cc	 sub	 ecx, DWORD PTR _j$58650[ebp]
  001c7	88 4d bc	 mov	 BYTE PTR _control$58654[ebp], cl
$L58659:

; 68   : 					j += control;

  001ca	8b 55 bc	 mov	 edx, DWORD PTR _control$58654[ebp]
  001cd	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  001d3	8b 45 cc	 mov	 eax, DWORD PTR _j$58650[ebp]
  001d6	03 c2		 add	 eax, edx
  001d8	89 45 cc	 mov	 DWORD PTR _j$58650[ebp], eax

; 69   : 					for (int k = 0;k<control;++k) {

  001db	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _k$58660[ebp], 0
  001e2	eb 09		 jmp	 SHORT $L58661
$L58662:
  001e4	8b 4d b8	 mov	 ecx, DWORD PTR _k$58660[ebp]
  001e7	83 c1 01	 add	 ecx, 1
  001ea	89 4d b8	 mov	 DWORD PTR _k$58660[ebp], ecx
$L58661:
  001ed	8b 55 bc	 mov	 edx, DWORD PTR _control$58654[ebp]
  001f0	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  001f6	39 55 b8	 cmp	 DWORD PTR _k$58660[ebp], edx
  001f9	0f 8d 87 00 00
	00		 jge	 $L58663

; 70   : 						uchar color = *colorPtr++;

  001ff	8b 45 c4	 mov	 eax, DWORD PTR _colorPtr$58649[ebp]
  00202	8a 08		 mov	 cl, BYTE PTR [eax]
  00204	88 4d b4	 mov	 BYTE PTR _color$58664[ebp], cl
  00207	8b 55 c4	 mov	 edx, DWORD PTR _colorPtr$58649[ebp]
  0020a	83 c2 01	 add	 edx, 1
  0020d	89 55 c4	 mov	 DWORD PTR _colorPtr$58649[ebp], edx

; 71   : 						if (color != skip)

  00210	8b 45 b4	 mov	 eax, DWORD PTR _color$58664[ebp]
  00213	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00218	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  0021b	33 d2		 xor	 edx, edx
  0021d	8a 51 38	 mov	 dl, BYTE PTR [ecx+56]
  00220	3b c2		 cmp	 eax, edx
  00222	74 54		 je	 SHORT $L58668

; 72   : 							if (color < REMAP_START_COLOR)

  00224	8b 45 b4	 mov	 eax, DWORD PTR _color$58664[ebp]
  00227	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0022c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?REMAP_START_COLOR@@3HA ; REMAP_START_COLOR
  00232	7d 0a		 jge	 SHORT $L58666

; 73   : 								*target = color;

  00234	8b 4d c0	 mov	 ecx, DWORD PTR _target$58647[ebp]
  00237	8a 55 b4	 mov	 dl, BYTE PTR _color$58664[ebp]
  0023a	88 11		 mov	 BYTE PTR [ecx], dl

; 74   : 							else

  0023c	eb 3a		 jmp	 SHORT $L58668
$L58666:

; 75   : 								if (Remap::remapOn[color])

  0023e	8b 45 b4	 mov	 eax, DWORD PTR _color$58664[ebp]
  00241	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00246	33 c9		 xor	 ecx, ecx
  00248	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR ?remapOn@Remap@@2PAEA[eax]
  0024e	85 c9		 test	 ecx, ecx
  00250	74 26		 je	 SHORT $L58668

; 76   : 									*target = Remap::remapColor[REMAP_END_COLOR - color][*target];

  00252	8b 55 b4	 mov	 edx, DWORD PTR _color$58664[ebp]
  00255	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0025b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?REMAP_END_COLOR@@3HA ; REMAP_END_COLOR
  00260	2b c2		 sub	 eax, edx
  00262	c1 e0 08	 shl	 eax, 8
  00265	8b 4d c0	 mov	 ecx, DWORD PTR _target$58647[ebp]
  00268	33 d2		 xor	 edx, edx
  0026a	8a 11		 mov	 dl, BYTE PTR [ecx]
  0026c	8b 4d c0	 mov	 ecx, DWORD PTR _target$58647[ebp]
  0026f	8a 94 10 00 00
	00 00		 mov	 dl, BYTE PTR ?remapColor@Remap@@2PAY0BAA@EA[eax+edx]
  00276	88 11		 mov	 BYTE PTR [ecx], dl
$L58668:

; 77   : 
; 78   : 						target--;

  00278	8b 45 c0	 mov	 eax, DWORD PTR _target$58647[ebp]
  0027b	83 e8 01	 sub	 eax, 1
  0027e	89 45 c0	 mov	 DWORD PTR _target$58647[ebp], eax

; 79   : 					}

  00281	e9 5e ff ff ff	 jmp	 $L58662
$L58663:

; 82   : 			else {

  00286	e9 e4 01 00 00	 jmp	 $L58678
$L58655:

; 83   : 				if (control & REPSKIP) {

  0028b	8b 4d bc	 mov	 ecx, DWORD PTR _control$58654[ebp]
  0028e	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00294	83 e1 40	 and	 ecx, 64			; 00000040H
  00297	85 c9		 test	 ecx, ecx
  00299	0f 84 8d 00 00
	00		 je	 $L58670

; 84   : 					// Do a run of repeated skip
; 85   : 					control &= 0x3f;

  0029f	8a 55 bc	 mov	 dl, BYTE PTR _control$58654[ebp]
  002a2	80 e2 3f	 and	 dl, 63			; 0000003fH
  002a5	88 55 bc	 mov	 BYTE PTR _control$58654[ebp], dl

; 86   : 					if ((j + (int) control) < srcCol) {

  002a8	8b 45 bc	 mov	 eax, DWORD PTR _control$58654[ebp]
  002ab	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002b0	8b 4d cc	 mov	 ecx, DWORD PTR _j$58650[ebp]
  002b3	03 c8		 add	 ecx, eax
  002b5	3b 4d d8	 cmp	 ecx, DWORD PTR _srcCol$[ebp]
  002b8	7d 13		 jge	 SHORT $L58672

; 87   : 						j += control;

  002ba	8b 55 bc	 mov	 edx, DWORD PTR _control$58654[ebp]
  002bd	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  002c3	8b 45 cc	 mov	 eax, DWORD PTR _j$58650[ebp]
  002c6	03 c2		 add	 eax, edx
  002c8	89 45 cc	 mov	 DWORD PTR _j$58650[ebp], eax

; 89   : 					else {

  002cb	eb 5a		 jmp	 SHORT $L58673
$L58672:

; 90   : 						if (j < srcCol) {

  002cd	8b 4d cc	 mov	 ecx, DWORD PTR _j$58650[ebp]
  002d0	3b 4d d8	 cmp	 ecx, DWORD PTR _srcCol$[ebp]
  002d3	7d 14		 jge	 SHORT $L58674

; 91   : 							control -= srcCol - j;

  002d5	8b 55 d8	 mov	 edx, DWORD PTR _srcCol$[ebp]
  002d8	2b 55 cc	 sub	 edx, DWORD PTR _j$58650[ebp]
  002db	8a 45 bc	 mov	 al, BYTE PTR _control$58654[ebp]
  002de	2a c2		 sub	 al, dl
  002e0	88 45 bc	 mov	 BYTE PTR _control$58654[ebp], al

; 92   : 							j = srcCol;

  002e3	8b 4d d8	 mov	 ecx, DWORD PTR _srcCol$[ebp]
  002e6	89 4d cc	 mov	 DWORD PTR _j$58650[ebp], ecx
$L58674:

; 94   : 						if (j + control > hRun) {

  002e9	8b 55 bc	 mov	 edx, DWORD PTR _control$58654[ebp]
  002ec	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  002f2	8b 45 cc	 mov	 eax, DWORD PTR _j$58650[ebp]
  002f5	03 c2		 add	 eax, edx
  002f7	3b 45 f0	 cmp	 eax, DWORD PTR _hRun$[ebp]
  002fa	7e 09		 jle	 SHORT $L58675

; 95   : 							control = hRun - j;

  002fc	8b 4d f0	 mov	 ecx, DWORD PTR _hRun$[ebp]
  002ff	2b 4d cc	 sub	 ecx, DWORD PTR _j$58650[ebp]
  00302	88 4d bc	 mov	 BYTE PTR _control$58654[ebp], cl
$L58675:

; 97   : 						j += control;

  00305	8b 55 bc	 mov	 edx, DWORD PTR _control$58654[ebp]
  00308	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0030e	8b 45 cc	 mov	 eax, DWORD PTR _j$58650[ebp]
  00311	03 c2		 add	 eax, edx
  00313	89 45 cc	 mov	 DWORD PTR _j$58650[ebp], eax

; 98   : 						target -= control;

  00316	8b 4d bc	 mov	 ecx, DWORD PTR _control$58654[ebp]
  00319	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0031f	8b 55 c0	 mov	 edx, DWORD PTR _target$58647[ebp]
  00322	2b d1		 sub	 edx, ecx
  00324	89 55 c0	 mov	 DWORD PTR _target$58647[ebp], edx
$L58673:

; 101  : 				else {

  00327	e9 43 01 00 00	 jmp	 $L58678
$L58670:

; 102  : 					// Do a run of repeated color
; 103  : 					control &= 0x3f;

  0032c	8a 45 bc	 mov	 al, BYTE PTR _control$58654[ebp]
  0032f	24 3f		 and	 al, 63			; 0000003fH
  00331	88 45 bc	 mov	 BYTE PTR _control$58654[ebp], al

; 104  : 					if ((j + control) < srcCol) {

  00334	8b 4d bc	 mov	 ecx, DWORD PTR _control$58654[ebp]
  00337	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0033d	8b 55 cc	 mov	 edx, DWORD PTR _j$58650[ebp]
  00340	03 d1		 add	 edx, ecx
  00342	3b 55 d8	 cmp	 edx, DWORD PTR _srcCol$[ebp]
  00345	7d 1e		 jge	 SHORT $L58677

; 105  : 						j += control;

  00347	8b 45 bc	 mov	 eax, DWORD PTR _control$58654[ebp]
  0034a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0034f	8b 4d cc	 mov	 ecx, DWORD PTR _j$58650[ebp]
  00352	03 c8		 add	 ecx, eax
  00354	89 4d cc	 mov	 DWORD PTR _j$58650[ebp], ecx

; 106  : 						colorPtr++;

  00357	8b 55 c4	 mov	 edx, DWORD PTR _colorPtr$58649[ebp]
  0035a	83 c2 01	 add	 edx, 1
  0035d	89 55 c4	 mov	 DWORD PTR _colorPtr$58649[ebp], edx

; 108  : 					else {

  00360	e9 0a 01 00 00	 jmp	 $L58678
$L58677:

; 109  : 						if (j < srcCol) {

  00365	8b 45 cc	 mov	 eax, DWORD PTR _j$58650[ebp]
  00368	3b 45 d8	 cmp	 eax, DWORD PTR _srcCol$[ebp]
  0036b	7d 14		 jge	 SHORT $L58679

; 110  : 							control -= srcCol - j;

  0036d	8b 4d d8	 mov	 ecx, DWORD PTR _srcCol$[ebp]
  00370	2b 4d cc	 sub	 ecx, DWORD PTR _j$58650[ebp]
  00373	8a 55 bc	 mov	 dl, BYTE PTR _control$58654[ebp]
  00376	2a d1		 sub	 dl, cl
  00378	88 55 bc	 mov	 BYTE PTR _control$58654[ebp], dl

; 111  : 							j = srcCol;

  0037b	8b 45 d8	 mov	 eax, DWORD PTR _srcCol$[ebp]
  0037e	89 45 cc	 mov	 DWORD PTR _j$58650[ebp], eax
$L58679:

; 113  : 						if (j + control > hRun) {

  00381	8b 4d bc	 mov	 ecx, DWORD PTR _control$58654[ebp]
  00384	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0038a	8b 55 cc	 mov	 edx, DWORD PTR _j$58650[ebp]
  0038d	03 d1		 add	 edx, ecx
  0038f	3b 55 f0	 cmp	 edx, DWORD PTR _hRun$[ebp]
  00392	7e 09		 jle	 SHORT $L58680

; 114  : 							control = hRun - j;

  00394	8b 45 f0	 mov	 eax, DWORD PTR _hRun$[ebp]
  00397	2b 45 cc	 sub	 eax, DWORD PTR _j$58650[ebp]
  0039a	88 45 bc	 mov	 BYTE PTR _control$58654[ebp], al
$L58680:

; 116  : 
; 117  : 						uchar color = *colorPtr++;

  0039d	8b 4d c4	 mov	 ecx, DWORD PTR _colorPtr$58649[ebp]
  003a0	8a 11		 mov	 dl, BYTE PTR [ecx]
  003a2	88 55 b0	 mov	 BYTE PTR _color$58681[ebp], dl
  003a5	8b 45 c4	 mov	 eax, DWORD PTR _colorPtr$58649[ebp]
  003a8	83 c0 01	 add	 eax, 1
  003ab	89 45 c4	 mov	 DWORD PTR _colorPtr$58649[ebp], eax

; 118  : 						target -= control - 1;

  003ae	8b 4d bc	 mov	 ecx, DWORD PTR _control$58654[ebp]
  003b1	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  003b7	83 e9 01	 sub	 ecx, 1
  003ba	8b 55 c0	 mov	 edx, DWORD PTR _target$58647[ebp]
  003bd	2b d1		 sub	 edx, ecx
  003bf	89 55 c0	 mov	 DWORD PTR _target$58647[ebp], edx

; 119  : 						if (!Remap::remapOn[color]) { 

  003c2	8b 45 b0	 mov	 eax, DWORD PTR _color$58681[ebp]
  003c5	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003ca	33 c9		 xor	 ecx, ecx
  003cc	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR ?remapOn@Remap@@2PAEA[eax]
  003d2	85 c9		 test	 ecx, ecx
  003d4	75 21		 jne	 SHORT $L58682

; 120  : 							memset(target,color,control);

  003d6	8b 55 bc	 mov	 edx, DWORD PTR _control$58654[ebp]
  003d9	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  003df	52		 push	 edx
  003e0	8b 45 b0	 mov	 eax, DWORD PTR _color$58681[ebp]
  003e3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003e8	50		 push	 eax
  003e9	8b 4d c0	 mov	 ecx, DWORD PTR _target$58647[ebp]
  003ec	51		 push	 ecx
  003ed	e8 00 00 00 00	 call	 _memset
  003f2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 122  : 						else {

  003f5	eb 5e		 jmp	 SHORT $L58689
$L58682:

; 123  : 							uchar* ptr = target;

  003f7	8b 55 c0	 mov	 edx, DWORD PTR _target$58647[ebp]
  003fa	89 55 ac	 mov	 DWORD PTR _ptr$58684[ebp], edx

; 124  : 							uchar* table = &(Remap::remapColor[REMAP_END_COLOR - color][0]);

  003fd	8b 45 b0	 mov	 eax, DWORD PTR _color$58681[ebp]
  00400	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00405	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?REMAP_END_COLOR@@3HA ; REMAP_END_COLOR
  0040b	2b c8		 sub	 ecx, eax
  0040d	c1 e1 08	 shl	 ecx, 8
  00410	81 c1 00 00 00
	00		 add	 ecx, OFFSET FLAT:?remapColor@Remap@@2PAY0BAA@EA ; Remap::remapColor
  00416	89 4d a8	 mov	 DWORD PTR _table$58685[ebp], ecx

; 125  : 							for (int k = 0; k < control; k++)  {

  00419	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _k$58686[ebp], 0
  00420	eb 09		 jmp	 SHORT $L58687
$L58688:
  00422	8b 55 a4	 mov	 edx, DWORD PTR _k$58686[ebp]
  00425	83 c2 01	 add	 edx, 1
  00428	89 55 a4	 mov	 DWORD PTR _k$58686[ebp], edx
$L58687:
  0042b	8b 45 bc	 mov	 eax, DWORD PTR _control$58654[ebp]
  0042e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00433	39 45 a4	 cmp	 DWORD PTR _k$58686[ebp], eax
  00436	7d 1d		 jge	 SHORT $L58689

; 126  : 								*ptr++ = table[*ptr];

  00438	8b 4d ac	 mov	 ecx, DWORD PTR _ptr$58684[ebp]
  0043b	33 d2		 xor	 edx, edx
  0043d	8a 11		 mov	 dl, BYTE PTR [ecx]
  0043f	8b 45 ac	 mov	 eax, DWORD PTR _ptr$58684[ebp]
  00442	8b 4d a8	 mov	 ecx, DWORD PTR _table$58685[ebp]
  00445	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  00448	88 10		 mov	 BYTE PTR [eax], dl
  0044a	8b 45 ac	 mov	 eax, DWORD PTR _ptr$58684[ebp]
  0044d	83 c0 01	 add	 eax, 1
  00450	89 45 ac	 mov	 DWORD PTR _ptr$58684[ebp], eax

; 127  : 							}

  00453	eb cd		 jmp	 SHORT $L58688
$L58689:

; 129  : 						--target;

  00455	8b 4d c0	 mov	 ecx, DWORD PTR _target$58647[ebp]
  00458	83 e9 01	 sub	 ecx, 1
  0045b	89 4d c0	 mov	 DWORD PTR _target$58647[ebp], ecx

; 130  : 						j += control;

  0045e	8b 55 bc	 mov	 edx, DWORD PTR _control$58654[ebp]
  00461	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00467	8b 45 cc	 mov	 eax, DWORD PTR _j$58650[ebp]
  0046a	03 c2		 add	 eax, edx
  0046c	89 45 cc	 mov	 DWORD PTR _j$58650[ebp], eax
$L58678:

; 134  : 		}

  0046f	e9 a3 fc ff ff	 jmp	 $L58652
$L58653:

; 135  : 	}

  00474	e9 37 fc ff ff	 jmp	 $L58645
$L58646:

; 136  : }

  00479	5e		 pop	 esi
  0047a	8b e5		 mov	 esp, ebp
  0047c	5d		 pop	 ebp
  0047d	c2 10 00	 ret	 16			; 00000010H
?DrawHzFlipMap@CelObj@@QAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@@Z ENDP ; CelObj::DrawHzFlipMap
_TEXT	ENDS
PUBLIC	?DrawNoFlipMap@CelObj@@QAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@@Z ; CelObj::DrawNoFlipMap
_TEXT	SEGMENT
_dest$ = 8
_toBuffer$ = 12
_ul$ = 16
_this$ = -92
_rowLen$ = -4
_srcCol$ = -40
_srcRow$ = -32
_hRun$ = -16
_vRun$ = -8
_resBuffer$ = -48
_celPtr$ = -24
_controlData$ = -12
_colorData$ = -44
_controlTable$ = -36
_colorTable$ = -20
_i$ = -28
_target$58715 = -64
_controlPtr$58716 = -56
_colorPtr$58717 = -60
_j$58718 = -52
_control$58722 = -68
_k$58728 = -72
_color$58732 = -76
_color$58749 = -80
_table$58752 = -84
_k$58753 = -88
?DrawNoFlipMap@CelObj@@QAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@@Z PROC NEAR ; CelObj::DrawNoFlipMap

; 146  : {

  00480	55		 push	 ebp
  00481	8b ec		 mov	 ebp, esp
  00483	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00486	89 4d a4	 mov	 DWORD PTR _this$[ebp], ecx

; 147  : 	// ***********************************************************************
; 148  : 	// Non scaled drawing.
; 149  : 	// ***********************************************************************
; 150  : 	assert(dest.Assert());
; 151  : 	assert(toBuffer.IsWithin(dest.XDim(), dest.YDim()));
; 152  : 
; 153  : 	int rowLen = toBuffer.Xlen();

  00489	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  0048c	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  00491	89 45 fc	 mov	 DWORD PTR _rowLen$[ebp], eax

; 154  : 	int srcCol = toBuffer.A.x - ul.x;

  00494	8b 45 0c	 mov	 eax, DWORD PTR _toBuffer$[ebp]
  00497	8b 08		 mov	 ecx, DWORD PTR [eax]
  00499	2b 4d 10	 sub	 ecx, DWORD PTR _ul$[ebp]
  0049c	89 4d d8	 mov	 DWORD PTR _srcCol$[ebp], ecx

; 155  : 	int srcRow = toBuffer.A.y - ul.y;

  0049f	8b 55 0c	 mov	 edx, DWORD PTR _toBuffer$[ebp]
  004a2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  004a5	2b 45 14	 sub	 eax, DWORD PTR _ul$[ebp+4]
  004a8	89 45 e0	 mov	 DWORD PTR _srcRow$[ebp], eax

; 156  : 	int hRun = toBuffer.B.x - ul.x + 1;

  004ab	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  004ae	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  004b1	2b 55 10	 sub	 edx, DWORD PTR _ul$[ebp]
  004b4	83 c2 01	 add	 edx, 1
  004b7	89 55 f0	 mov	 DWORD PTR _hRun$[ebp], edx

; 157  : 	int vRun = toBuffer.Ylen();

  004ba	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  004bd	e8 00 00 00 00	 call	 ?Ylen@SOL_Rect@@QBEHXZ	; SOL_Rect::Ylen
  004c2	89 45 f8	 mov	 DWORD PTR _vRun$[ebp], eax

; 158  : 
; 159  : 	// The view can't move until the draw is done!
; 160  : 	// Get a pointer to the cel.
; 161  : 	uchar* resBuffer = ResPointer();

  004c5	8b 45 a4	 mov	 eax, DWORD PTR _this$[ebp]
  004c8	8b 10		 mov	 edx, DWORD PTR [eax]
  004ca	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  004cd	ff 52 14	 call	 DWORD PTR [edx+20]
  004d0	89 45 d0	 mov	 DWORD PTR _resBuffer$[ebp], eax

; 162  : 	CelHeader* celPtr = (CelHeader*) (resBuffer + celOffset);

  004d3	8b 45 a4	 mov	 eax, DWORD PTR _this$[ebp]
  004d6	8b 4d d0	 mov	 ecx, DWORD PTR _resBuffer$[ebp]
  004d9	03 48 18	 add	 ecx, DWORD PTR [eax+24]
  004dc	89 4d e8	 mov	 DWORD PTR _celPtr$[ebp], ecx

; 163  : 
; 164  : 	uchar* controlData = resBuffer + celPtr->controlOffset;

  004df	8b 55 e8	 mov	 edx, DWORD PTR _celPtr$[ebp]
  004e2	8b 45 d0	 mov	 eax, DWORD PTR _resBuffer$[ebp]
  004e5	03 42 18	 add	 eax, DWORD PTR [edx+24]
  004e8	89 45 f4	 mov	 DWORD PTR _controlData$[ebp], eax

; 165  : 	uchar* colorData = resBuffer + celPtr->colorOffset;

  004eb	8b 4d e8	 mov	 ecx, DWORD PTR _celPtr$[ebp]
  004ee	8b 55 d0	 mov	 edx, DWORD PTR _resBuffer$[ebp]
  004f1	03 51 1c	 add	 edx, DWORD PTR [ecx+28]
  004f4	89 55 d4	 mov	 DWORD PTR _colorData$[ebp], edx

; 166  : 
; 167  : 	long* controlTable = (long *) (resBuffer + celPtr->rowTableOffset);

  004f7	8b 45 e8	 mov	 eax, DWORD PTR _celPtr$[ebp]
  004fa	8b 4d d0	 mov	 ecx, DWORD PTR _resBuffer$[ebp]
  004fd	03 48 20	 add	 ecx, DWORD PTR [eax+32]
  00500	89 4d dc	 mov	 DWORD PTR _controlTable$[ebp], ecx

; 168  : 	long* colorTable = controlTable + height;

  00503	8b 55 a4	 mov	 edx, DWORD PTR _this$[ebp]
  00506	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00509	8b 4d dc	 mov	 ecx, DWORD PTR _controlTable$[ebp]
  0050c	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  0050f	89 55 ec	 mov	 DWORD PTR _colorTable$[ebp], edx

; 169  : 
; 170  : 	// Draw the inset rectangle
; 171  : 	for (int i = 0;i < vRun;++i,++srcRow) {

  00512	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00519	eb 12		 jmp	 SHORT $L58712
$L58713:
  0051b	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  0051e	83 c0 01	 add	 eax, 1
  00521	89 45 e4	 mov	 DWORD PTR _i$[ebp], eax
  00524	8b 4d e0	 mov	 ecx, DWORD PTR _srcRow$[ebp]
  00527	83 c1 01	 add	 ecx, 1
  0052a	89 4d e0	 mov	 DWORD PTR _srcRow$[ebp], ecx
$L58712:
  0052d	8b 55 e4	 mov	 edx, DWORD PTR _i$[ebp]
  00530	3b 55 f8	 cmp	 edx, DWORD PTR _vRun$[ebp]
  00533	0f 8d 91 03 00
	00		 jge	 $L58714

; 172  : 		// Find the row data
; 173  : 		uchar* target = dest.Addr(toBuffer.A.x, toBuffer.A.y + i);

  00539	8b 45 0c	 mov	 eax, DWORD PTR _toBuffer$[ebp]
  0053c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0053f	03 4d e4	 add	 ecx, DWORD PTR _i$[ebp]
  00542	51		 push	 ecx
  00543	8b 55 0c	 mov	 edx, DWORD PTR _toBuffer$[ebp]
  00546	8b 02		 mov	 eax, DWORD PTR [edx]
  00548	50		 push	 eax
  00549	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  0054c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0054e	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00551	ff 12		 call	 DWORD PTR [edx]
  00553	89 45 c0	 mov	 DWORD PTR _target$58715[ebp], eax

; 174  : 		uchar* controlPtr = controlData + controlTable[srcRow];

  00556	8b 45 e0	 mov	 eax, DWORD PTR _srcRow$[ebp]
  00559	8b 4d dc	 mov	 ecx, DWORD PTR _controlTable$[ebp]
  0055c	8b 55 f4	 mov	 edx, DWORD PTR _controlData$[ebp]
  0055f	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  00562	89 55 c8	 mov	 DWORD PTR _controlPtr$58716[ebp], edx

; 175  : 		uchar* colorPtr = colorData + colorTable[srcRow];

  00565	8b 45 e0	 mov	 eax, DWORD PTR _srcRow$[ebp]
  00568	8b 4d ec	 mov	 ecx, DWORD PTR _colorTable$[ebp]
  0056b	8b 55 d4	 mov	 edx, DWORD PTR _colorData$[ebp]
  0056e	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  00571	89 55 c4	 mov	 DWORD PTR _colorPtr$58717[ebp], edx

; 176  : 
; 177  : 		// Draw a line
; 178  : 		for (int j = 0;j <hRun;) {

  00574	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _j$58718[ebp], 0
$L58720:
  0057b	8b 45 cc	 mov	 eax, DWORD PTR _j$58718[ebp]
  0057e	3b 45 f0	 cmp	 eax, DWORD PTR _hRun$[ebp]
  00581	0f 8d 3e 03 00
	00		 jge	 $L58721

; 179  : 			// Get the control character
; 180  : 			uchar control = *controlPtr++;

  00587	8b 4d c8	 mov	 ecx, DWORD PTR _controlPtr$58716[ebp]
  0058a	8a 11		 mov	 dl, BYTE PTR [ecx]
  0058c	88 55 bc	 mov	 BYTE PTR _control$58722[ebp], dl
  0058f	8b 45 c8	 mov	 eax, DWORD PTR _controlPtr$58716[ebp]
  00592	83 c0 01	 add	 eax, 1
  00595	89 45 c8	 mov	 DWORD PTR _controlPtr$58716[ebp], eax

; 181  : 			if (!(control & REPEATC)) {

  00598	8b 4d bc	 mov	 ecx, DWORD PTR _control$58722[ebp]
  0059b	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  005a1	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  005a7	85 c9		 test	 ecx, ecx
  005a9	0f 85 40 01 00
	00		 jne	 $L58723

; 182  : 				// Do a run of unique bytes
; 183  : 				if ((j + control) < srcCol) {

  005af	8b 55 bc	 mov	 edx, DWORD PTR _control$58722[ebp]
  005b2	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  005b8	8b 45 cc	 mov	 eax, DWORD PTR _j$58718[ebp]
  005bb	03 c2		 add	 eax, edx
  005bd	3b 45 d8	 cmp	 eax, DWORD PTR _srcCol$[ebp]
  005c0	7d 26		 jge	 SHORT $L58724

; 184  : 					j += control;

  005c2	8b 4d bc	 mov	 ecx, DWORD PTR _control$58722[ebp]
  005c5	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  005cb	8b 55 cc	 mov	 edx, DWORD PTR _j$58718[ebp]
  005ce	03 d1		 add	 edx, ecx
  005d0	89 55 cc	 mov	 DWORD PTR _j$58718[ebp], edx

; 185  : 					colorPtr += control;

  005d3	8b 45 bc	 mov	 eax, DWORD PTR _control$58722[ebp]
  005d6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  005db	8b 4d c4	 mov	 ecx, DWORD PTR _colorPtr$58717[ebp]
  005de	03 c8		 add	 ecx, eax
  005e0	89 4d c4	 mov	 DWORD PTR _colorPtr$58717[ebp], ecx

; 187  : 				else {

  005e3	e9 02 01 00 00	 jmp	 $L58731
$L58724:

; 188  : 					if (j < srcCol) {

  005e8	8b 55 cc	 mov	 edx, DWORD PTR _j$58718[ebp]
  005eb	3b 55 d8	 cmp	 edx, DWORD PTR _srcCol$[ebp]
  005ee	7d 22		 jge	 SHORT $L58726

; 189  : 						control -= srcCol - j;

  005f0	8b 45 d8	 mov	 eax, DWORD PTR _srcCol$[ebp]
  005f3	2b 45 cc	 sub	 eax, DWORD PTR _j$58718[ebp]
  005f6	8a 4d bc	 mov	 cl, BYTE PTR _control$58722[ebp]
  005f9	2a c8		 sub	 cl, al
  005fb	88 4d bc	 mov	 BYTE PTR _control$58722[ebp], cl

; 190  : 						colorPtr += srcCol - j;

  005fe	8b 55 d8	 mov	 edx, DWORD PTR _srcCol$[ebp]
  00601	2b 55 cc	 sub	 edx, DWORD PTR _j$58718[ebp]
  00604	8b 45 c4	 mov	 eax, DWORD PTR _colorPtr$58717[ebp]
  00607	03 c2		 add	 eax, edx
  00609	89 45 c4	 mov	 DWORD PTR _colorPtr$58717[ebp], eax

; 191  : 						j = srcCol;

  0060c	8b 4d d8	 mov	 ecx, DWORD PTR _srcCol$[ebp]
  0060f	89 4d cc	 mov	 DWORD PTR _j$58718[ebp], ecx
$L58726:

; 193  : 					if (j + control > hRun) {

  00612	8b 55 bc	 mov	 edx, DWORD PTR _control$58722[ebp]
  00615	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0061b	8b 45 cc	 mov	 eax, DWORD PTR _j$58718[ebp]
  0061e	03 c2		 add	 eax, edx
  00620	3b 45 f0	 cmp	 eax, DWORD PTR _hRun$[ebp]
  00623	7e 09		 jle	 SHORT $L58727

; 194  : 						control = hRun - j;

  00625	8b 4d f0	 mov	 ecx, DWORD PTR _hRun$[ebp]
  00628	2b 4d cc	 sub	 ecx, DWORD PTR _j$58718[ebp]
  0062b	88 4d bc	 mov	 BYTE PTR _control$58722[ebp], cl
$L58727:

; 196  : 					j += control;

  0062e	8b 55 bc	 mov	 edx, DWORD PTR _control$58722[ebp]
  00631	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00637	8b 45 cc	 mov	 eax, DWORD PTR _j$58718[ebp]
  0063a	03 c2		 add	 eax, edx
  0063c	89 45 cc	 mov	 DWORD PTR _j$58718[ebp], eax

; 197  : 					for (int k = 0;k<control;++k) {

  0063f	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _k$58728[ebp], 0
  00646	eb 09		 jmp	 SHORT $L58729
$L58730:
  00648	8b 4d b8	 mov	 ecx, DWORD PTR _k$58728[ebp]
  0064b	83 c1 01	 add	 ecx, 1
  0064e	89 4d b8	 mov	 DWORD PTR _k$58728[ebp], ecx
$L58729:
  00651	8b 55 bc	 mov	 edx, DWORD PTR _control$58722[ebp]
  00654	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0065a	39 55 b8	 cmp	 DWORD PTR _k$58728[ebp], edx
  0065d	0f 8d 87 00 00
	00		 jge	 $L58731

; 198  : 						uchar color = *colorPtr++;

  00663	8b 45 c4	 mov	 eax, DWORD PTR _colorPtr$58717[ebp]
  00666	8a 08		 mov	 cl, BYTE PTR [eax]
  00668	88 4d b4	 mov	 BYTE PTR _color$58732[ebp], cl
  0066b	8b 55 c4	 mov	 edx, DWORD PTR _colorPtr$58717[ebp]
  0066e	83 c2 01	 add	 edx, 1
  00671	89 55 c4	 mov	 DWORD PTR _colorPtr$58717[ebp], edx

; 199  : 						if (color != skip)

  00674	8b 45 b4	 mov	 eax, DWORD PTR _color$58732[ebp]
  00677	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0067c	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  0067f	33 d2		 xor	 edx, edx
  00681	8a 51 38	 mov	 dl, BYTE PTR [ecx+56]
  00684	3b c2		 cmp	 eax, edx
  00686	74 54		 je	 SHORT $L58736

; 200  : 							if (color < REMAP_START_COLOR)

  00688	8b 45 b4	 mov	 eax, DWORD PTR _color$58732[ebp]
  0068b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00690	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?REMAP_START_COLOR@@3HA ; REMAP_START_COLOR
  00696	7d 0a		 jge	 SHORT $L58734

; 201  : 								*target = color;

  00698	8b 4d c0	 mov	 ecx, DWORD PTR _target$58715[ebp]
  0069b	8a 55 b4	 mov	 dl, BYTE PTR _color$58732[ebp]
  0069e	88 11		 mov	 BYTE PTR [ecx], dl

; 202  : 							else

  006a0	eb 3a		 jmp	 SHORT $L58736
$L58734:

; 203  : 								if (Remap::remapOn[color])

  006a2	8b 45 b4	 mov	 eax, DWORD PTR _color$58732[ebp]
  006a5	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006aa	33 c9		 xor	 ecx, ecx
  006ac	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR ?remapOn@Remap@@2PAEA[eax]
  006b2	85 c9		 test	 ecx, ecx
  006b4	74 26		 je	 SHORT $L58736

; 204  : 									*target = Remap::remapColor[REMAP_END_COLOR - color][*target];

  006b6	8b 55 b4	 mov	 edx, DWORD PTR _color$58732[ebp]
  006b9	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  006bf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?REMAP_END_COLOR@@3HA ; REMAP_END_COLOR
  006c4	2b c2		 sub	 eax, edx
  006c6	c1 e0 08	 shl	 eax, 8
  006c9	8b 4d c0	 mov	 ecx, DWORD PTR _target$58715[ebp]
  006cc	33 d2		 xor	 edx, edx
  006ce	8a 11		 mov	 dl, BYTE PTR [ecx]
  006d0	8b 4d c0	 mov	 ecx, DWORD PTR _target$58715[ebp]
  006d3	8a 94 10 00 00
	00 00		 mov	 dl, BYTE PTR ?remapColor@Remap@@2PAY0BAA@EA[eax+edx]
  006da	88 11		 mov	 BYTE PTR [ecx], dl
$L58736:

; 205  : 
; 206  : 						target++;

  006dc	8b 45 c0	 mov	 eax, DWORD PTR _target$58715[ebp]
  006df	83 c0 01	 add	 eax, 1
  006e2	89 45 c0	 mov	 DWORD PTR _target$58715[ebp], eax

; 207  : 					}

  006e5	e9 5e ff ff ff	 jmp	 $L58730
$L58731:

; 210  : 			else {

  006ea	e9 d1 01 00 00	 jmp	 $L58746
$L58723:

; 211  : 				if (control & REPSKIP) {

  006ef	8b 4d bc	 mov	 ecx, DWORD PTR _control$58722[ebp]
  006f2	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  006f8	83 e1 40	 and	 ecx, 64			; 00000040H
  006fb	85 c9		 test	 ecx, ecx
  006fd	0f 84 8d 00 00
	00		 je	 $L58738

; 212  : 					// Do a run of repeated skip
; 213  : 					control &= 0x3f;

  00703	8a 55 bc	 mov	 dl, BYTE PTR _control$58722[ebp]
  00706	80 e2 3f	 and	 dl, 63			; 0000003fH
  00709	88 55 bc	 mov	 BYTE PTR _control$58722[ebp], dl

; 214  : 					if ((j + (int) control) < srcCol) {

  0070c	8b 45 bc	 mov	 eax, DWORD PTR _control$58722[ebp]
  0070f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00714	8b 4d cc	 mov	 ecx, DWORD PTR _j$58718[ebp]
  00717	03 c8		 add	 ecx, eax
  00719	3b 4d d8	 cmp	 ecx, DWORD PTR _srcCol$[ebp]
  0071c	7d 13		 jge	 SHORT $L58740

; 215  : 						j += control;

  0071e	8b 55 bc	 mov	 edx, DWORD PTR _control$58722[ebp]
  00721	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00727	8b 45 cc	 mov	 eax, DWORD PTR _j$58718[ebp]
  0072a	03 c2		 add	 eax, edx
  0072c	89 45 cc	 mov	 DWORD PTR _j$58718[ebp], eax

; 217  : 					else {

  0072f	eb 5a		 jmp	 SHORT $L58741
$L58740:

; 218  : 						if (j < srcCol) {

  00731	8b 4d cc	 mov	 ecx, DWORD PTR _j$58718[ebp]
  00734	3b 4d d8	 cmp	 ecx, DWORD PTR _srcCol$[ebp]
  00737	7d 14		 jge	 SHORT $L58742

; 219  : 							control -= srcCol - j;

  00739	8b 55 d8	 mov	 edx, DWORD PTR _srcCol$[ebp]
  0073c	2b 55 cc	 sub	 edx, DWORD PTR _j$58718[ebp]
  0073f	8a 45 bc	 mov	 al, BYTE PTR _control$58722[ebp]
  00742	2a c2		 sub	 al, dl
  00744	88 45 bc	 mov	 BYTE PTR _control$58722[ebp], al

; 220  : 							j = srcCol;

  00747	8b 4d d8	 mov	 ecx, DWORD PTR _srcCol$[ebp]
  0074a	89 4d cc	 mov	 DWORD PTR _j$58718[ebp], ecx
$L58742:

; 222  : 						if (j + control > hRun) {

  0074d	8b 55 bc	 mov	 edx, DWORD PTR _control$58722[ebp]
  00750	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00756	8b 45 cc	 mov	 eax, DWORD PTR _j$58718[ebp]
  00759	03 c2		 add	 eax, edx
  0075b	3b 45 f0	 cmp	 eax, DWORD PTR _hRun$[ebp]
  0075e	7e 09		 jle	 SHORT $L58743

; 223  : 							control = hRun - j;

  00760	8b 4d f0	 mov	 ecx, DWORD PTR _hRun$[ebp]
  00763	2b 4d cc	 sub	 ecx, DWORD PTR _j$58718[ebp]
  00766	88 4d bc	 mov	 BYTE PTR _control$58722[ebp], cl
$L58743:

; 225  : 						j += control;

  00769	8b 55 bc	 mov	 edx, DWORD PTR _control$58722[ebp]
  0076c	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00772	8b 45 cc	 mov	 eax, DWORD PTR _j$58718[ebp]
  00775	03 c2		 add	 eax, edx
  00777	89 45 cc	 mov	 DWORD PTR _j$58718[ebp], eax

; 226  : 						target += control;

  0077a	8b 4d bc	 mov	 ecx, DWORD PTR _control$58722[ebp]
  0077d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00783	8b 55 c0	 mov	 edx, DWORD PTR _target$58715[ebp]
  00786	03 d1		 add	 edx, ecx
  00788	89 55 c0	 mov	 DWORD PTR _target$58715[ebp], edx
$L58741:

; 229  : 				else {

  0078b	e9 30 01 00 00	 jmp	 $L58746
$L58738:

; 230  : 					// Do a run of repeated color
; 231  : 					control &= 0x3f;

  00790	8a 45 bc	 mov	 al, BYTE PTR _control$58722[ebp]
  00793	24 3f		 and	 al, 63			; 0000003fH
  00795	88 45 bc	 mov	 BYTE PTR _control$58722[ebp], al

; 232  : 					if ((j + control) < srcCol) {

  00798	8b 4d bc	 mov	 ecx, DWORD PTR _control$58722[ebp]
  0079b	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  007a1	8b 55 cc	 mov	 edx, DWORD PTR _j$58718[ebp]
  007a4	03 d1		 add	 edx, ecx
  007a6	3b 55 d8	 cmp	 edx, DWORD PTR _srcCol$[ebp]
  007a9	7d 1e		 jge	 SHORT $L58745

; 233  : 						j += control;

  007ab	8b 45 bc	 mov	 eax, DWORD PTR _control$58722[ebp]
  007ae	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  007b3	8b 4d cc	 mov	 ecx, DWORD PTR _j$58718[ebp]
  007b6	03 c8		 add	 ecx, eax
  007b8	89 4d cc	 mov	 DWORD PTR _j$58718[ebp], ecx

; 234  : 						colorPtr++;

  007bb	8b 55 c4	 mov	 edx, DWORD PTR _colorPtr$58717[ebp]
  007be	83 c2 01	 add	 edx, 1
  007c1	89 55 c4	 mov	 DWORD PTR _colorPtr$58717[ebp], edx

; 236  : 					else {

  007c4	e9 f7 00 00 00	 jmp	 $L58746
$L58745:

; 237  : 						if (j < srcCol) {

  007c9	8b 45 cc	 mov	 eax, DWORD PTR _j$58718[ebp]
  007cc	3b 45 d8	 cmp	 eax, DWORD PTR _srcCol$[ebp]
  007cf	7d 14		 jge	 SHORT $L58747

; 238  : 							control -= srcCol - j;

  007d1	8b 4d d8	 mov	 ecx, DWORD PTR _srcCol$[ebp]
  007d4	2b 4d cc	 sub	 ecx, DWORD PTR _j$58718[ebp]
  007d7	8a 55 bc	 mov	 dl, BYTE PTR _control$58722[ebp]
  007da	2a d1		 sub	 dl, cl
  007dc	88 55 bc	 mov	 BYTE PTR _control$58722[ebp], dl

; 239  : 							j = srcCol;

  007df	8b 45 d8	 mov	 eax, DWORD PTR _srcCol$[ebp]
  007e2	89 45 cc	 mov	 DWORD PTR _j$58718[ebp], eax
$L58747:

; 241  : 						if (j + control > hRun) {

  007e5	8b 4d bc	 mov	 ecx, DWORD PTR _control$58722[ebp]
  007e8	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  007ee	8b 55 cc	 mov	 edx, DWORD PTR _j$58718[ebp]
  007f1	03 d1		 add	 edx, ecx
  007f3	3b 55 f0	 cmp	 edx, DWORD PTR _hRun$[ebp]
  007f6	7e 09		 jle	 SHORT $L58748

; 242  : 							control = hRun - j;

  007f8	8b 45 f0	 mov	 eax, DWORD PTR _hRun$[ebp]
  007fb	2b 45 cc	 sub	 eax, DWORD PTR _j$58718[ebp]
  007fe	88 45 bc	 mov	 BYTE PTR _control$58722[ebp], al
$L58748:

; 244  : 						uchar color = *colorPtr++;

  00801	8b 4d c4	 mov	 ecx, DWORD PTR _colorPtr$58717[ebp]
  00804	8a 11		 mov	 dl, BYTE PTR [ecx]
  00806	88 55 b0	 mov	 BYTE PTR _color$58749[ebp], dl
  00809	8b 45 c4	 mov	 eax, DWORD PTR _colorPtr$58717[ebp]
  0080c	83 c0 01	 add	 eax, 1
  0080f	89 45 c4	 mov	 DWORD PTR _colorPtr$58717[ebp], eax

; 245  : 						if (!Remap::remapOn[color])  {

  00812	8b 4d b0	 mov	 ecx, DWORD PTR _color$58749[ebp]
  00815	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0081b	33 d2		 xor	 edx, edx
  0081d	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR ?remapOn@Remap@@2PAEA[ecx]
  00823	85 d2		 test	 edx, edx
  00825	75 31		 jne	 SHORT $L58750

; 246  : 							memset(target,color,control);

  00827	8b 45 bc	 mov	 eax, DWORD PTR _control$58722[ebp]
  0082a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0082f	50		 push	 eax
  00830	8b 4d b0	 mov	 ecx, DWORD PTR _color$58749[ebp]
  00833	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00839	51		 push	 ecx
  0083a	8b 55 c0	 mov	 edx, DWORD PTR _target$58715[ebp]
  0083d	52		 push	 edx
  0083e	e8 00 00 00 00	 call	 _memset
  00843	83 c4 0c	 add	 esp, 12			; 0000000cH

; 247  : 							target += control;

  00846	8b 45 bc	 mov	 eax, DWORD PTR _control$58722[ebp]
  00849	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0084e	8b 4d c0	 mov	 ecx, DWORD PTR _target$58715[ebp]
  00851	03 c8		 add	 ecx, eax
  00853	89 4d c0	 mov	 DWORD PTR _target$58715[ebp], ecx

; 249  : 						else {  

  00856	eb 58		 jmp	 SHORT $L58756
$L58750:

; 250  : 							uchar* table = &(Remap::remapColor[REMAP_END_COLOR - color][0]);

  00858	8b 55 b0	 mov	 edx, DWORD PTR _color$58749[ebp]
  0085b	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00861	a1 00 00 00 00	 mov	 eax, DWORD PTR ?REMAP_END_COLOR@@3HA ; REMAP_END_COLOR
  00866	2b c2		 sub	 eax, edx
  00868	c1 e0 08	 shl	 eax, 8
  0086b	05 00 00 00 00	 add	 eax, OFFSET FLAT:?remapColor@Remap@@2PAY0BAA@EA ; Remap::remapColor
  00870	89 45 ac	 mov	 DWORD PTR _table$58752[ebp], eax

; 251  : 							for (int k = 0; k < control; k++)

  00873	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _k$58753[ebp], 0
  0087a	eb 09		 jmp	 SHORT $L58754
$L58755:
  0087c	8b 4d a8	 mov	 ecx, DWORD PTR _k$58753[ebp]
  0087f	83 c1 01	 add	 ecx, 1
  00882	89 4d a8	 mov	 DWORD PTR _k$58753[ebp], ecx
$L58754:
  00885	8b 55 bc	 mov	 edx, DWORD PTR _control$58722[ebp]
  00888	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0088e	39 55 a8	 cmp	 DWORD PTR _k$58753[ebp], edx
  00891	7d 1d		 jge	 SHORT $L58756

; 252  : 								*target++ = table[*target];

  00893	8b 45 c0	 mov	 eax, DWORD PTR _target$58715[ebp]
  00896	33 c9		 xor	 ecx, ecx
  00898	8a 08		 mov	 cl, BYTE PTR [eax]
  0089a	8b 55 c0	 mov	 edx, DWORD PTR _target$58715[ebp]
  0089d	8b 45 ac	 mov	 eax, DWORD PTR _table$58752[ebp]
  008a0	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]
  008a3	88 0a		 mov	 BYTE PTR [edx], cl
  008a5	8b 55 c0	 mov	 edx, DWORD PTR _target$58715[ebp]
  008a8	83 c2 01	 add	 edx, 1
  008ab	89 55 c0	 mov	 DWORD PTR _target$58715[ebp], edx
  008ae	eb cc		 jmp	 SHORT $L58755
$L58756:

; 254  : 
; 255  : 						j += control;

  008b0	8b 45 bc	 mov	 eax, DWORD PTR _control$58722[ebp]
  008b3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  008b8	8b 4d cc	 mov	 ecx, DWORD PTR _j$58718[ebp]
  008bb	03 c8		 add	 ecx, eax
  008bd	89 4d cc	 mov	 DWORD PTR _j$58718[ebp], ecx
$L58746:

; 259  : 		}

  008c0	e9 b6 fc ff ff	 jmp	 $L58720
$L58721:

; 260  : 	}

  008c5	e9 51 fc ff ff	 jmp	 $L58713
$L58714:

; 261  : }

  008ca	8b e5		 mov	 esp, ebp
  008cc	5d		 pop	 ebp
  008cd	c2 10 00	 ret	 16			; 00000010H
?DrawNoFlipMap@CelObj@@QAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@@Z ENDP ; CelObj::DrawNoFlipMap
_TEXT	ENDS
PUBLIC	?DrawUncompNoFlipMap@CelObj@@QAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@@Z ; CelObj::DrawUncompNoFlipMap
_TEXT	SEGMENT
_dest$ = 8
_toBuffer$ = 12
_ul$ = 16
_this$ = -52
_resBuffer$ = -32
_celPtr$ = -12
_hRun$ = -8
_vRun$ = -4
_colorData$ = -28
_srcCol$ = -24
_srcRow$ = -20
_y$ = -16
_dest1$58777 = -44
_src$58778 = -40
_x$58779 = -36
_color$58783 = -48
?DrawUncompNoFlipMap@CelObj@@QAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@@Z PROC NEAR ; CelObj::DrawUncompNoFlipMap

; 265  : {

  008d0	55		 push	 ebp
  008d1	8b ec		 mov	 ebp, esp
  008d3	83 ec 34	 sub	 esp, 52			; 00000034H
  008d6	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx

; 266  : 	// ***********************************************************************
; 267  : 	// Non scaled drawing.
; 268  : 	// ***********************************************************************
; 269  : 	assert(dest.Assert());
; 270  : 	assert(toBuffer.IsWithin(dest.XDim(), dest.YDim()));
; 271  : 
; 272  : 	uchar* resBuffer = ResPointer();

  008d9	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  008dc	8b 10		 mov	 edx, DWORD PTR [eax]
  008de	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  008e1	ff 52 14	 call	 DWORD PTR [edx+20]
  008e4	89 45 e0	 mov	 DWORD PTR _resBuffer$[ebp], eax

; 273  : 	CelHeader* celPtr = (CelHeader*) (resBuffer + celOffset);

  008e7	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  008ea	8b 4d e0	 mov	 ecx, DWORD PTR _resBuffer$[ebp]
  008ed	03 48 18	 add	 ecx, DWORD PTR [eax+24]
  008f0	89 4d f4	 mov	 DWORD PTR _celPtr$[ebp], ecx

; 274  : 	int hRun = toBuffer.Xlen();

  008f3	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  008f6	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  008fb	89 45 f8	 mov	 DWORD PTR _hRun$[ebp], eax

; 275  : 	int vRun = toBuffer.Ylen();

  008fe	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  00901	e8 00 00 00 00	 call	 ?Ylen@SOL_Rect@@QBEHXZ	; SOL_Rect::Ylen
  00906	89 45 fc	 mov	 DWORD PTR _vRun$[ebp], eax

; 276  : 
; 277  : 	uchar* colorData = resBuffer + celPtr->controlOffset;	//  Correct !

  00909	8b 55 f4	 mov	 edx, DWORD PTR _celPtr$[ebp]
  0090c	8b 45 e0	 mov	 eax, DWORD PTR _resBuffer$[ebp]
  0090f	03 42 18	 add	 eax, DWORD PTR [edx+24]
  00912	89 45 e4	 mov	 DWORD PTR _colorData$[ebp], eax

; 278  : 	int srcCol = toBuffer.A.x - ul.x;

  00915	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  00918	8b 11		 mov	 edx, DWORD PTR [ecx]
  0091a	2b 55 10	 sub	 edx, DWORD PTR _ul$[ebp]
  0091d	89 55 e8	 mov	 DWORD PTR _srcCol$[ebp], edx

; 279  : 	int srcRow = toBuffer.A.y - ul.y;

  00920	8b 45 0c	 mov	 eax, DWORD PTR _toBuffer$[ebp]
  00923	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00926	2b 4d 14	 sub	 ecx, DWORD PTR _ul$[ebp+4]
  00929	89 4d ec	 mov	 DWORD PTR _srcRow$[ebp], ecx

; 280  : 	colorData += (srcRow * width) + srcCol;

  0092c	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  0092f	8b 45 ec	 mov	 eax, DWORD PTR _srcRow$[ebp]
  00932	0f af 42 20	 imul	 eax, DWORD PTR [edx+32]
  00936	03 45 e8	 add	 eax, DWORD PTR _srcCol$[ebp]
  00939	8b 4d e4	 mov	 ecx, DWORD PTR _colorData$[ebp]
  0093c	03 c8		 add	 ecx, eax
  0093e	89 4d e4	 mov	 DWORD PTR _colorData$[ebp], ecx

; 281  : 
; 282  : 
; 283  : 	// Draw the inset rectangle
; 284  : 	for (int y = 0; y < vRun; y++)

  00941	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  00948	eb 09		 jmp	 SHORT $L58774
$L58775:
  0094a	8b 55 f0	 mov	 edx, DWORD PTR _y$[ebp]
  0094d	83 c2 01	 add	 edx, 1
  00950	89 55 f0	 mov	 DWORD PTR _y$[ebp], edx
$L58774:
  00953	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  00956	3b 45 fc	 cmp	 eax, DWORD PTR _vRun$[ebp]
  00959	0f 8d dc 00 00
	00		 jge	 $L58776

; 286  : 		uchar* dest1 = dest.Addr(toBuffer.A.x, toBuffer.A.y + y);

  0095f	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  00962	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00965	03 55 f0	 add	 edx, DWORD PTR _y$[ebp]
  00968	52		 push	 edx
  00969	8b 45 0c	 mov	 eax, DWORD PTR _toBuffer$[ebp]
  0096c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0096e	51		 push	 ecx
  0096f	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  00972	8b 02		 mov	 eax, DWORD PTR [edx]
  00974	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00977	ff 10		 call	 DWORD PTR [eax]
  00979	89 45 d4	 mov	 DWORD PTR _dest1$58777[ebp], eax

; 287  : 		uchar* src = colorData;

  0097c	8b 4d e4	 mov	 ecx, DWORD PTR _colorData$[ebp]
  0097f	89 4d d8	 mov	 DWORD PTR _src$58778[ebp], ecx

; 288  : 
; 289  : 		for (int x = 0; x < hRun; x++)

  00982	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _x$58779[ebp], 0
  00989	eb 09		 jmp	 SHORT $L58780
$L58781:
  0098b	8b 55 dc	 mov	 edx, DWORD PTR _x$58779[ebp]
  0098e	83 c2 01	 add	 edx, 1
  00991	89 55 dc	 mov	 DWORD PTR _x$58779[ebp], edx
$L58780:
  00994	8b 45 dc	 mov	 eax, DWORD PTR _x$58779[ebp]
  00997	3b 45 f8	 cmp	 eax, DWORD PTR _hRun$[ebp]
  0099a	0f 8d 8a 00 00
	00		 jge	 $L58782

; 291  : 			uchar color = *src++;

  009a0	8b 4d d8	 mov	 ecx, DWORD PTR _src$58778[ebp]
  009a3	8a 11		 mov	 dl, BYTE PTR [ecx]
  009a5	88 55 d0	 mov	 BYTE PTR _color$58783[ebp], dl
  009a8	8b 45 d8	 mov	 eax, DWORD PTR _src$58778[ebp]
  009ab	83 c0 01	 add	 eax, 1
  009ae	89 45 d8	 mov	 DWORD PTR _src$58778[ebp], eax

; 292  : 			if (color != skip)

  009b1	8b 4d d0	 mov	 ecx, DWORD PTR _color$58783[ebp]
  009b4	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  009ba	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  009bd	33 c0		 xor	 eax, eax
  009bf	8a 42 38	 mov	 al, BYTE PTR [edx+56]
  009c2	3b c8		 cmp	 ecx, eax
  009c4	74 56		 je	 SHORT $L58787

; 293  : 				if (color < REMAP_START_COLOR)

  009c6	8b 4d d0	 mov	 ecx, DWORD PTR _color$58783[ebp]
  009c9	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  009cf	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?REMAP_START_COLOR@@3HA ; REMAP_START_COLOR
  009d5	7d 0a		 jge	 SHORT $L58785

; 294  : 					*dest1 = color;

  009d7	8b 55 d4	 mov	 edx, DWORD PTR _dest1$58777[ebp]
  009da	8a 45 d0	 mov	 al, BYTE PTR _color$58783[ebp]
  009dd	88 02		 mov	 BYTE PTR [edx], al

; 295  : 				else

  009df	eb 3b		 jmp	 SHORT $L58787
$L58785:

; 296  : 					if (Remap::remapOn[color])

  009e1	8b 4d d0	 mov	 ecx, DWORD PTR _color$58783[ebp]
  009e4	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  009ea	33 d2		 xor	 edx, edx
  009ec	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR ?remapOn@Remap@@2PAEA[ecx]
  009f2	85 d2		 test	 edx, edx
  009f4	74 26		 je	 SHORT $L58787

; 297  : 						*dest1 = Remap::remapColor[REMAP_END_COLOR - color][*dest1];

  009f6	8b 45 d0	 mov	 eax, DWORD PTR _color$58783[ebp]
  009f9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  009fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?REMAP_END_COLOR@@3HA ; REMAP_END_COLOR
  00a04	2b c8		 sub	 ecx, eax
  00a06	c1 e1 08	 shl	 ecx, 8
  00a09	8b 55 d4	 mov	 edx, DWORD PTR _dest1$58777[ebp]
  00a0c	33 c0		 xor	 eax, eax
  00a0e	8a 02		 mov	 al, BYTE PTR [edx]
  00a10	8b 55 d4	 mov	 edx, DWORD PTR _dest1$58777[ebp]
  00a13	8a 84 01 00 00
	00 00		 mov	 al, BYTE PTR ?remapColor@Remap@@2PAY0BAA@EA[ecx+eax]
  00a1a	88 02		 mov	 BYTE PTR [edx], al
$L58787:

; 298  : 			dest1++;

  00a1c	8b 4d d4	 mov	 ecx, DWORD PTR _dest1$58777[ebp]
  00a1f	83 c1 01	 add	 ecx, 1
  00a22	89 4d d4	 mov	 DWORD PTR _dest1$58777[ebp], ecx

; 299  : 		}

  00a25	e9 61 ff ff ff	 jmp	 $L58781
$L58782:

; 300  : 		colorData += width;

  00a2a	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00a2d	8b 45 e4	 mov	 eax, DWORD PTR _colorData$[ebp]
  00a30	03 42 20	 add	 eax, DWORD PTR [edx+32]
  00a33	89 45 e4	 mov	 DWORD PTR _colorData$[ebp], eax

; 301  : 	}

  00a36	e9 0f ff ff ff	 jmp	 $L58775
$L58776:

; 302  : }

  00a3b	8b e5		 mov	 esp, ebp
  00a3d	5d		 pop	 ebp
  00a3e	c2 10 00	 ret	 16			; 00000010H
?DrawUncompNoFlipMap@CelObj@@QAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@@Z ENDP ; CelObj::DrawUncompNoFlipMap
_TEXT	ENDS
PUBLIC	?DrawUncompHzFlipMap@CelObj@@QAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@@Z ; CelObj::DrawUncompHzFlipMap
PUBLIC	?XDim@Buffer@@QBEHXZ				; Buffer::XDim
_TEXT	SEGMENT
_dest$ = 8
_toBuffer$ = 12
_ul$ = 16
_this$ = -60
_resBuffer$ = -36
_celPtr$ = -12
_hRun$ = -8
_vRun$ = -4
_xSize$ = -16
_colorData$ = -32
_srcCol$ = -28
_srcRow$ = -24
_y$ = -20
_target$58809 = -52
_dest1$58810 = -48
_src$58811 = -44
_x$58812 = -40
_color$58816 = -56
?DrawUncompHzFlipMap@CelObj@@QAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@@Z PROC NEAR ; CelObj::DrawUncompHzFlipMap

; 307  : {

  00a41	55		 push	 ebp
  00a42	8b ec		 mov	 ebp, esp
  00a44	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00a47	56		 push	 esi
  00a48	89 4d c4	 mov	 DWORD PTR _this$[ebp], ecx

; 308  : 	// ***********************************************************************
; 309  : 	// Non scaled drawing mirrored.
; 310  : 	// ***********************************************************************
; 311  : 	assert(dest.Assert());
; 312  : 	assert(toBuffer.IsWithin(dest.XDim(), dest.YDim()));
; 313  : 
; 314  : 	uchar* resBuffer = ResPointer();

  00a4b	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  00a4e	8b 10		 mov	 edx, DWORD PTR [eax]
  00a50	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  00a53	ff 52 14	 call	 DWORD PTR [edx+20]
  00a56	89 45 dc	 mov	 DWORD PTR _resBuffer$[ebp], eax

; 315  : 	CelHeader* celPtr = (CelHeader*) (resBuffer + celOffset);

  00a59	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  00a5c	8b 4d dc	 mov	 ecx, DWORD PTR _resBuffer$[ebp]
  00a5f	03 48 18	 add	 ecx, DWORD PTR [eax+24]
  00a62	89 4d f4	 mov	 DWORD PTR _celPtr$[ebp], ecx

; 316  : 	int hRun = toBuffer.Xlen();

  00a65	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  00a68	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  00a6d	89 45 f8	 mov	 DWORD PTR _hRun$[ebp], eax

; 317  : 	int vRun = toBuffer.Ylen();

  00a70	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  00a73	e8 00 00 00 00	 call	 ?Ylen@SOL_Rect@@QBEHXZ	; SOL_Rect::Ylen
  00a78	89 45 fc	 mov	 DWORD PTR _vRun$[ebp], eax

; 318  : 	int xSize = dest.XDim();

  00a7b	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00a7e	e8 00 00 00 00	 call	 ?XDim@Buffer@@QBEHXZ	; Buffer::XDim
  00a83	89 45 f0	 mov	 DWORD PTR _xSize$[ebp], eax

; 319  : 
; 320  : 	uchar* colorData = resBuffer + celPtr->controlOffset;	//  Correct !

  00a86	8b 55 f4	 mov	 edx, DWORD PTR _celPtr$[ebp]
  00a89	8b 45 dc	 mov	 eax, DWORD PTR _resBuffer$[ebp]
  00a8c	03 42 18	 add	 eax, DWORD PTR [edx+24]
  00a8f	89 45 e0	 mov	 DWORD PTR _colorData$[ebp], eax

; 321  : //	int srcCol = toBuffer.A.x - ul.x;
; 322  : 	int srcCol = width - (toBuffer.A.x - ul.x + toBuffer.Xlen());

  00a92	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  00a95	8b 31		 mov	 esi, DWORD PTR [ecx]
  00a97	2b 75 10	 sub	 esi, DWORD PTR _ul$[ebp]
  00a9a	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  00a9d	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  00aa2	03 f0		 add	 esi, eax
  00aa4	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  00aa7	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00aaa	2b c6		 sub	 eax, esi
  00aac	89 45 e4	 mov	 DWORD PTR _srcCol$[ebp], eax

; 323  : 	int srcRow = toBuffer.A.y - ul.y;

  00aaf	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  00ab2	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00ab5	2b 55 14	 sub	 edx, DWORD PTR _ul$[ebp+4]
  00ab8	89 55 e8	 mov	 DWORD PTR _srcRow$[ebp], edx

; 324  : 	colorData += (srcRow * width) + srcCol;

  00abb	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  00abe	8b 4d e8	 mov	 ecx, DWORD PTR _srcRow$[ebp]
  00ac1	0f af 48 20	 imul	 ecx, DWORD PTR [eax+32]
  00ac5	03 4d e4	 add	 ecx, DWORD PTR _srcCol$[ebp]
  00ac8	8b 55 e0	 mov	 edx, DWORD PTR _colorData$[ebp]
  00acb	03 d1		 add	 edx, ecx
  00acd	89 55 e0	 mov	 DWORD PTR _colorData$[ebp], edx

; 325  : 
; 326  : 
; 327  : 	// Draw the inset rectangle
; 328  : 	for (int y = 0; y < vRun; y++)

  00ad0	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  00ad7	eb 09		 jmp	 SHORT $L58806
$L58807:
  00ad9	8b 45 ec	 mov	 eax, DWORD PTR _y$[ebp]
  00adc	83 c0 01	 add	 eax, 1
  00adf	89 45 ec	 mov	 DWORD PTR _y$[ebp], eax
$L58806:
  00ae2	8b 4d ec	 mov	 ecx, DWORD PTR _y$[ebp]
  00ae5	3b 4d fc	 cmp	 ecx, DWORD PTR _vRun$[ebp]
  00ae8	0f 8d e6 00 00
	00		 jge	 $L58808

; 330  : 		uchar* target = dest.Addr(toBuffer.A.x, toBuffer.A.y + y);

  00aee	8b 55 0c	 mov	 edx, DWORD PTR _toBuffer$[ebp]
  00af1	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00af4	03 45 ec	 add	 eax, DWORD PTR _y$[ebp]
  00af7	50		 push	 eax
  00af8	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  00afb	8b 11		 mov	 edx, DWORD PTR [ecx]
  00afd	52		 push	 edx
  00afe	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00b01	8b 10		 mov	 edx, DWORD PTR [eax]
  00b03	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00b06	ff 12		 call	 DWORD PTR [edx]
  00b08	89 45 cc	 mov	 DWORD PTR _target$58809[ebp], eax

; 331  : 		uchar* dest1 = target + hRun - 1;

  00b0b	8b 45 f8	 mov	 eax, DWORD PTR _hRun$[ebp]
  00b0e	8b 4d cc	 mov	 ecx, DWORD PTR _target$58809[ebp]
  00b11	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  00b15	89 55 d0	 mov	 DWORD PTR _dest1$58810[ebp], edx

; 332  : 		uchar* src = colorData;

  00b18	8b 45 e0	 mov	 eax, DWORD PTR _colorData$[ebp]
  00b1b	89 45 d4	 mov	 DWORD PTR _src$58811[ebp], eax

; 333  : 
; 334  : 		for (int x = 0; x < hRun; x++)

  00b1e	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _x$58812[ebp], 0
  00b25	eb 09		 jmp	 SHORT $L58813
$L58814:
  00b27	8b 4d d8	 mov	 ecx, DWORD PTR _x$58812[ebp]
  00b2a	83 c1 01	 add	 ecx, 1
  00b2d	89 4d d8	 mov	 DWORD PTR _x$58812[ebp], ecx
$L58813:
  00b30	8b 55 d8	 mov	 edx, DWORD PTR _x$58812[ebp]
  00b33	3b 55 f8	 cmp	 edx, DWORD PTR _hRun$[ebp]
  00b36	0f 8d 87 00 00
	00		 jge	 $L58815

; 336  : 			uchar color = *src++;

  00b3c	8b 45 d4	 mov	 eax, DWORD PTR _src$58811[ebp]
  00b3f	8a 08		 mov	 cl, BYTE PTR [eax]
  00b41	88 4d c8	 mov	 BYTE PTR _color$58816[ebp], cl
  00b44	8b 55 d4	 mov	 edx, DWORD PTR _src$58811[ebp]
  00b47	83 c2 01	 add	 edx, 1
  00b4a	89 55 d4	 mov	 DWORD PTR _src$58811[ebp], edx

; 337  : 			if (color != skip)

  00b4d	8b 45 c8	 mov	 eax, DWORD PTR _color$58816[ebp]
  00b50	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00b55	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  00b58	33 d2		 xor	 edx, edx
  00b5a	8a 51 38	 mov	 dl, BYTE PTR [ecx+56]
  00b5d	3b c2		 cmp	 eax, edx
  00b5f	74 54		 je	 SHORT $L58820

; 338  : 				if (color < REMAP_START_COLOR)

  00b61	8b 45 c8	 mov	 eax, DWORD PTR _color$58816[ebp]
  00b64	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00b69	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?REMAP_START_COLOR@@3HA ; REMAP_START_COLOR
  00b6f	7d 0a		 jge	 SHORT $L58818

; 339  : 					*dest1 = color;

  00b71	8b 4d d0	 mov	 ecx, DWORD PTR _dest1$58810[ebp]
  00b74	8a 55 c8	 mov	 dl, BYTE PTR _color$58816[ebp]
  00b77	88 11		 mov	 BYTE PTR [ecx], dl

; 340  : 				else

  00b79	eb 3a		 jmp	 SHORT $L58820
$L58818:

; 341  : 					if (Remap::remapOn[color])

  00b7b	8b 45 c8	 mov	 eax, DWORD PTR _color$58816[ebp]
  00b7e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00b83	33 c9		 xor	 ecx, ecx
  00b85	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR ?remapOn@Remap@@2PAEA[eax]
  00b8b	85 c9		 test	 ecx, ecx
  00b8d	74 26		 je	 SHORT $L58820

; 342  : 						*dest1 = Remap::remapColor[REMAP_END_COLOR - color][*dest1];

  00b8f	8b 55 c8	 mov	 edx, DWORD PTR _color$58816[ebp]
  00b92	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00b98	a1 00 00 00 00	 mov	 eax, DWORD PTR ?REMAP_END_COLOR@@3HA ; REMAP_END_COLOR
  00b9d	2b c2		 sub	 eax, edx
  00b9f	c1 e0 08	 shl	 eax, 8
  00ba2	8b 4d d0	 mov	 ecx, DWORD PTR _dest1$58810[ebp]
  00ba5	33 d2		 xor	 edx, edx
  00ba7	8a 11		 mov	 dl, BYTE PTR [ecx]
  00ba9	8b 4d d0	 mov	 ecx, DWORD PTR _dest1$58810[ebp]
  00bac	8a 94 10 00 00
	00 00		 mov	 dl, BYTE PTR ?remapColor@Remap@@2PAY0BAA@EA[eax+edx]
  00bb3	88 11		 mov	 BYTE PTR [ecx], dl
$L58820:

; 343  : 			dest1--;

  00bb5	8b 45 d0	 mov	 eax, DWORD PTR _dest1$58810[ebp]
  00bb8	83 e8 01	 sub	 eax, 1
  00bbb	89 45 d0	 mov	 DWORD PTR _dest1$58810[ebp], eax

; 344  : 		}

  00bbe	e9 64 ff ff ff	 jmp	 $L58814
$L58815:

; 345  : 		colorData += width;

  00bc3	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  00bc6	8b 55 e0	 mov	 edx, DWORD PTR _colorData$[ebp]
  00bc9	03 51 20	 add	 edx, DWORD PTR [ecx+32]
  00bcc	89 55 e0	 mov	 DWORD PTR _colorData$[ebp], edx

; 346  : 	}

  00bcf	e9 05 ff ff ff	 jmp	 $L58807
$L58808:

; 347  : }

  00bd4	5e		 pop	 esi
  00bd5	8b e5		 mov	 esp, ebp
  00bd7	5d		 pop	 ebp
  00bd8	c2 10 00	 ret	 16			; 00000010H
?DrawUncompHzFlipMap@CelObj@@QAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@@Z ENDP ; CelObj::DrawUncompHzFlipMap
_TEXT	ENDS
PUBLIC	?ScaleDrawMap@CelObj@@QAEXABVBuffer@@ABVRatio@@1ABVSOL_Rect@@ABVSOL_Point@@@Z ; CelObj::ScaleDrawMap
EXTRN	_memcpy:NEAR
EXTRN	?ScaleTables@CelObj@@QAEXABVRatio@@0@Z:NEAR	; CelObj::ScaleTables
EXTRN	?scaleX1@CelObj@@2PAHA:BYTE			; CelObj::scaleX1
EXTRN	?scaleY1@CelObj@@2PAHA:BYTE			; CelObj::scaleY1
EXTRN	?line@CelObj@@2PAEA:BYTE			; CelObj::line
EXTRN	?scaleX@CelObj@@2PAHA:DWORD			; CelObj::scaleX
EXTRN	?scaleY@CelObj@@2PAHA:DWORD			; CelObj::scaleY
_TEXT	SEGMENT
_dest$ = 8
_ratioX$ = 12
_ratioY$ = 16
_drawRect$ = 20
_pt$ = 24
_this$ = -108
_x1$ = -32
_y1$ = -52
_x2$ = -40
_y2$ = -56
_celX1$ = -4
_celY1$ = -16
_y$ = -36
_hBuild$ = -12
_maxx$58846 = -68
_x$58847 = -64
_x$58854 = -72
_resBuffer$ = -60
_celPtr$ = -24
_controlData$ = -8
_colorData$ = -48
_controlTable$ = -44
_colorTable$ = -20
_lastyi$ = -28
_target$58877 = -80
_controlPtr$58879 = -88
_colorPtr$58880 = -92
_j$58881 = -84
_control$58885 = -96
_color$58890 = -100
_x$58891 = -76
_color$58895 = -104
?ScaleDrawMap@CelObj@@QAEXABVBuffer@@ABVRatio@@1ABVSOL_Rect@@ABVSOL_Point@@@Z PROC NEAR ; CelObj::ScaleDrawMap

; 352  : {

  00bdb	55		 push	 ebp
  00bdc	8b ec		 mov	 ebp, esp
  00bde	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00be1	89 4d 94	 mov	 DWORD PTR _this$[ebp], ecx

; 353  : 	// Calculate the scaling tables
; 354  : 	assert(dest.Assert());
; 355  : 	assert(ratioX.Assert());
; 356  : 	assert(ratioX.Assert());
; 357  : 	assert(drawRect.IsWithin(dest.XDim(), dest.YDim()));
; 358  : 
; 359  : 	ScaleTables(ratioX, ratioY);

  00be4	8b 45 10	 mov	 eax, DWORD PTR _ratioY$[ebp]
  00be7	50		 push	 eax
  00be8	8b 4d 0c	 mov	 ecx, DWORD PTR _ratioX$[ebp]
  00beb	51		 push	 ecx
  00bec	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00bef	e8 00 00 00 00	 call	 ?ScaleTables@CelObj@@QAEXABVRatio@@0@Z ; CelObj::ScaleTables

; 360  : 
; 361  : 	int x1 = drawRect.A.x;

  00bf4	8b 55 14	 mov	 edx, DWORD PTR _drawRect$[ebp]
  00bf7	8b 02		 mov	 eax, DWORD PTR [edx]
  00bf9	89 45 e0	 mov	 DWORD PTR _x1$[ebp], eax

; 362  : 	int y1 = drawRect.A.y;

  00bfc	8b 4d 14	 mov	 ecx, DWORD PTR _drawRect$[ebp]
  00bff	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00c02	89 55 cc	 mov	 DWORD PTR _y1$[ebp], edx

; 363  : 	int x2 = drawRect.B.x;

  00c05	8b 45 14	 mov	 eax, DWORD PTR _drawRect$[ebp]
  00c08	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00c0b	89 4d d8	 mov	 DWORD PTR _x2$[ebp], ecx

; 364  : 	int y2 = drawRect.B.y;

  00c0e	8b 55 14	 mov	 edx, DWORD PTR _drawRect$[ebp]
  00c11	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00c14	89 45 c8	 mov	 DWORD PTR _y2$[ebp], eax

; 365  : 	int celX1 = pt.x;

  00c17	8b 4d 18	 mov	 ecx, DWORD PTR _pt$[ebp]
  00c1a	8b 11		 mov	 edx, DWORD PTR [ecx]
  00c1c	89 55 fc	 mov	 DWORD PTR _celX1$[ebp], edx

; 366  : 	int celY1 = pt.y;

  00c1f	8b 45 18	 mov	 eax, DWORD PTR _pt$[ebp]
  00c22	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00c25	89 4d f0	 mov	 DWORD PTR _celY1$[ebp], ecx

; 367  : 	int y;
; 368  : 
; 369  : 	assert(x1 <= x2);
; 370  : 	assert(y1 <= y2);
; 371  : 	assert(celX1 <= x1);
; 372  : 	assert(celY1 <= y1);
; 373  : 
; 374  : 	int hBuild;
; 375  : 	if (horzFlip)

  00c28	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  00c2b	83 7a 4c 00	 cmp	 DWORD PTR [edx+76], 0
  00c2f	74 51		 je	 SHORT $L58845

; 377  : 		int maxx = width - 1;

  00c31	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  00c34	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00c37	83 e9 01	 sub	 ecx, 1
  00c3a	89 4d bc	 mov	 DWORD PTR _maxx$58846[ebp], ecx

; 378  : 		for (int x = x1; x <= x2; x++)

  00c3d	8b 55 e0	 mov	 edx, DWORD PTR _x1$[ebp]
  00c40	89 55 c0	 mov	 DWORD PTR _x$58847[ebp], edx
  00c43	eb 09		 jmp	 SHORT $L58848
$L58849:
  00c45	8b 45 c0	 mov	 eax, DWORD PTR _x$58847[ebp]
  00c48	83 c0 01	 add	 eax, 1
  00c4b	89 45 c0	 mov	 DWORD PTR _x$58847[ebp], eax
$L58848:
  00c4e	8b 4d c0	 mov	 ecx, DWORD PTR _x$58847[ebp]
  00c51	3b 4d d8	 cmp	 ecx, DWORD PTR _x2$[ebp]
  00c54	7f 1d		 jg	 SHORT $L58850

; 380  : 			scaleX1[x] = maxx - (scaleX[x - celX1]);

  00c56	8b 55 c0	 mov	 edx, DWORD PTR _x$58847[ebp]
  00c59	2b 55 fc	 sub	 edx, DWORD PTR _celX1$[ebp]
  00c5c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?scaleX@CelObj@@2PAHA ; CelObj::scaleX
  00c61	8b 4d bc	 mov	 ecx, DWORD PTR _maxx$58846[ebp]
  00c64	2b 0c 90	 sub	 ecx, DWORD PTR [eax+edx*4]
  00c67	8b 55 c0	 mov	 edx, DWORD PTR _x$58847[ebp]
  00c6a	89 0c 95 00 00
	00 00		 mov	 DWORD PTR ?scaleX1@CelObj@@2PAHA[edx*4], ecx

; 381  : 			assert(scaleX1[x] >= 0);
; 382  : 			assert(scaleX1[x] < width);
; 383  : 		}

  00c71	eb d2		 jmp	 SHORT $L58849
$L58850:

; 384  : 		hBuild = scaleX1[x1];

  00c73	8b 45 e0	 mov	 eax, DWORD PTR _x1$[ebp]
  00c76	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?scaleX1@CelObj@@2PAHA[eax*4]
  00c7d	89 4d f4	 mov	 DWORD PTR _hBuild$[ebp], ecx

; 386  : 	else

  00c80	eb 41		 jmp	 SHORT $L58853
$L58845:

; 388  : 		for (int x = x1; x <= x2; x++)

  00c82	8b 55 e0	 mov	 edx, DWORD PTR _x1$[ebp]
  00c85	89 55 b8	 mov	 DWORD PTR _x$58854[ebp], edx
  00c88	eb 09		 jmp	 SHORT $L58855
$L58856:
  00c8a	8b 45 b8	 mov	 eax, DWORD PTR _x$58854[ebp]
  00c8d	83 c0 01	 add	 eax, 1
  00c90	89 45 b8	 mov	 DWORD PTR _x$58854[ebp], eax
$L58855:
  00c93	8b 4d b8	 mov	 ecx, DWORD PTR _x$58854[ebp]
  00c96	3b 4d d8	 cmp	 ecx, DWORD PTR _x2$[ebp]
  00c99	7f 1b		 jg	 SHORT $L58857

; 390  : 			scaleX1[x] = scaleX[x - celX1];

  00c9b	8b 55 b8	 mov	 edx, DWORD PTR _x$58854[ebp]
  00c9e	2b 55 fc	 sub	 edx, DWORD PTR _celX1$[ebp]
  00ca1	8b 45 b8	 mov	 eax, DWORD PTR _x$58854[ebp]
  00ca4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?scaleX@CelObj@@2PAHA ; CelObj::scaleX
  00caa	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  00cad	89 14 85 00 00
	00 00		 mov	 DWORD PTR ?scaleX1@CelObj@@2PAHA[eax*4], edx

; 391  : 			assert(scaleX1[x] >= 0);
; 392  : 			assert(scaleX1[x] < width);
; 393  : 		}

  00cb4	eb d4		 jmp	 SHORT $L58856
$L58857:

; 394  : 		hBuild = scaleX1[x2];

  00cb6	8b 45 d8	 mov	 eax, DWORD PTR _x2$[ebp]
  00cb9	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?scaleX1@CelObj@@2PAHA[eax*4]
  00cc0	89 4d f4	 mov	 DWORD PTR _hBuild$[ebp], ecx
$L58853:

; 396  : 	hBuild++;

  00cc3	8b 55 f4	 mov	 edx, DWORD PTR _hBuild$[ebp]
  00cc6	83 c2 01	 add	 edx, 1
  00cc9	89 55 f4	 mov	 DWORD PTR _hBuild$[ebp], edx

; 397  : 
; 398  : 	//  Build vertical table
; 399  : 	for (y = y1; y <= y2; y++)

  00ccc	8b 45 cc	 mov	 eax, DWORD PTR _y1$[ebp]
  00ccf	89 45 dc	 mov	 DWORD PTR _y$[ebp], eax
  00cd2	eb 09		 jmp	 SHORT $L58860
$L58861:
  00cd4	8b 4d dc	 mov	 ecx, DWORD PTR _y$[ebp]
  00cd7	83 c1 01	 add	 ecx, 1
  00cda	89 4d dc	 mov	 DWORD PTR _y$[ebp], ecx
$L58860:
  00cdd	8b 55 dc	 mov	 edx, DWORD PTR _y$[ebp]
  00ce0	3b 55 c8	 cmp	 edx, DWORD PTR _y2$[ebp]
  00ce3	7f 1b		 jg	 SHORT $L58862

; 401  : 		scaleY1[y] = scaleY[y - celY1];

  00ce5	8b 45 dc	 mov	 eax, DWORD PTR _y$[ebp]
  00ce8	2b 45 f0	 sub	 eax, DWORD PTR _celY1$[ebp]
  00ceb	8b 4d dc	 mov	 ecx, DWORD PTR _y$[ebp]
  00cee	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?scaleY@CelObj@@2PAHA ; CelObj::scaleY
  00cf4	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  00cf7	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?scaleY1@CelObj@@2PAHA[ecx*4], eax

; 402  : 		assert(scaleY1[y] >= 0);
; 403  : 		assert(scaleY1[y] < height);
; 404  : 	}

  00cfe	eb d4		 jmp	 SHORT $L58861
$L58862:

; 405  : 
; 406  : 	uchar* resBuffer = ResPointer();

  00d00	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00d03	8b 11		 mov	 edx, DWORD PTR [ecx]
  00d05	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00d08	ff 52 14	 call	 DWORD PTR [edx+20]
  00d0b	89 45 c4	 mov	 DWORD PTR _resBuffer$[ebp], eax

; 407  : 	CelHeader* celPtr = (CelHeader*) (resBuffer + celOffset);

  00d0e	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  00d11	8b 4d c4	 mov	 ecx, DWORD PTR _resBuffer$[ebp]
  00d14	03 48 18	 add	 ecx, DWORD PTR [eax+24]
  00d17	89 4d e8	 mov	 DWORD PTR _celPtr$[ebp], ecx

; 408  : 	uchar* controlData = resBuffer + celPtr->controlOffset;

  00d1a	8b 55 e8	 mov	 edx, DWORD PTR _celPtr$[ebp]
  00d1d	8b 45 c4	 mov	 eax, DWORD PTR _resBuffer$[ebp]
  00d20	03 42 18	 add	 eax, DWORD PTR [edx+24]
  00d23	89 45 f8	 mov	 DWORD PTR _controlData$[ebp], eax

; 409  : 	uchar* colorData = resBuffer + celPtr->colorOffset;

  00d26	8b 4d e8	 mov	 ecx, DWORD PTR _celPtr$[ebp]
  00d29	8b 55 c4	 mov	 edx, DWORD PTR _resBuffer$[ebp]
  00d2c	03 51 1c	 add	 edx, DWORD PTR [ecx+28]
  00d2f	89 55 d0	 mov	 DWORD PTR _colorData$[ebp], edx

; 410  : 
; 411  : 	long* controlTable = (long *) (resBuffer + celPtr->rowTableOffset);

  00d32	8b 45 e8	 mov	 eax, DWORD PTR _celPtr$[ebp]
  00d35	8b 4d c4	 mov	 ecx, DWORD PTR _resBuffer$[ebp]
  00d38	03 48 20	 add	 ecx, DWORD PTR [eax+32]
  00d3b	89 4d d4	 mov	 DWORD PTR _controlTable$[ebp], ecx

; 412  : 	long* colorTable = controlTable + height;

  00d3e	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  00d41	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00d44	8b 4d d4	 mov	 ecx, DWORD PTR _controlTable$[ebp]
  00d47	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00d4a	89 55 ec	 mov	 DWORD PTR _colorTable$[ebp], edx

; 413  : 
; 414  : 	// Draw the inset rectangle
; 415  : 	int lastyi = -1;

  00d4d	c7 45 e4 ff ff
	ff ff		 mov	 DWORD PTR _lastyi$[ebp], -1

; 416  : 	for (y = y1; y <= y2; y++)

  00d54	8b 45 cc	 mov	 eax, DWORD PTR _y1$[ebp]
  00d57	89 45 dc	 mov	 DWORD PTR _y$[ebp], eax
  00d5a	eb 09		 jmp	 SHORT $L58874
$L58875:
  00d5c	8b 4d dc	 mov	 ecx, DWORD PTR _y$[ebp]
  00d5f	83 c1 01	 add	 ecx, 1
  00d62	89 4d dc	 mov	 DWORD PTR _y$[ebp], ecx
$L58874:
  00d65	8b 55 dc	 mov	 edx, DWORD PTR _y$[ebp]
  00d68	3b 55 c8	 cmp	 edx, DWORD PTR _y2$[ebp]
  00d6b	0f 8f 20 02 00
	00		 jg	 $L58876

; 418  : 		uchar* target = dest.Addr(x1, y);

  00d71	8b 45 dc	 mov	 eax, DWORD PTR _y$[ebp]
  00d74	50		 push	 eax
  00d75	8b 4d e0	 mov	 ecx, DWORD PTR _x1$[ebp]
  00d78	51		 push	 ecx
  00d79	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  00d7c	8b 02		 mov	 eax, DWORD PTR [edx]
  00d7e	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00d81	ff 10		 call	 DWORD PTR [eax]
  00d83	89 45 b0	 mov	 DWORD PTR _target$58877[ebp], eax

; 419  : 		if (lastyi != scaleY1[y])

  00d86	8b 4d dc	 mov	 ecx, DWORD PTR _y$[ebp]
  00d89	8b 55 e4	 mov	 edx, DWORD PTR _lastyi$[ebp]
  00d8c	3b 14 8d 00 00
	00 00		 cmp	 edx, DWORD PTR ?scaleY1@CelObj@@2PAHA[ecx*4]
  00d93	0f 84 4a 01 00
	00		 je	 $L58884

; 421  : 			// Find the row data
; 422  : 			lastyi = scaleY1[y];

  00d99	8b 45 dc	 mov	 eax, DWORD PTR _y$[ebp]
  00d9c	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?scaleY1@CelObj@@2PAHA[eax*4]
  00da3	89 4d e4	 mov	 DWORD PTR _lastyi$[ebp], ecx

; 423  : 			uchar* controlPtr = controlData + controlTable[lastyi];

  00da6	8b 55 e4	 mov	 edx, DWORD PTR _lastyi$[ebp]
  00da9	8b 45 d4	 mov	 eax, DWORD PTR _controlTable$[ebp]
  00dac	8b 4d f8	 mov	 ecx, DWORD PTR _controlData$[ebp]
  00daf	03 0c 90	 add	 ecx, DWORD PTR [eax+edx*4]
  00db2	89 4d a8	 mov	 DWORD PTR _controlPtr$58879[ebp], ecx

; 424  : 			uchar* colorPtr = colorData + colorTable[lastyi];

  00db5	8b 55 e4	 mov	 edx, DWORD PTR _lastyi$[ebp]
  00db8	8b 45 ec	 mov	 eax, DWORD PTR _colorTable$[ebp]
  00dbb	8b 4d d0	 mov	 ecx, DWORD PTR _colorData$[ebp]
  00dbe	03 0c 90	 add	 ecx, DWORD PTR [eax+edx*4]
  00dc1	89 4d a4	 mov	 DWORD PTR _colorPtr$58880[ebp], ecx

; 425  : 
; 426  : 			// Build a line
; 427  : 			for (int j = 0; j < hBuild; )

  00dc4	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _j$58881[ebp], 0
$L58883:
  00dcb	8b 55 ac	 mov	 edx, DWORD PTR _j$58881[ebp]
  00dce	3b 55 f4	 cmp	 edx, DWORD PTR _hBuild$[ebp]
  00dd1	0f 8d 0c 01 00
	00		 jge	 $L58884

; 429  : 				// Get the control character
; 430  : 				uchar control = *controlPtr++;

  00dd7	8b 45 a8	 mov	 eax, DWORD PTR _controlPtr$58879[ebp]
  00dda	8a 08		 mov	 cl, BYTE PTR [eax]
  00ddc	88 4d a0	 mov	 BYTE PTR _control$58885[ebp], cl
  00ddf	8b 55 a8	 mov	 edx, DWORD PTR _controlPtr$58879[ebp]
  00de2	83 c2 01	 add	 edx, 1
  00de5	89 55 a8	 mov	 DWORD PTR _controlPtr$58879[ebp], edx

; 431  : 				if (!(control & REPEATC))

  00de8	8b 45 a0	 mov	 eax, DWORD PTR _control$58885[ebp]
  00deb	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00df0	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00df5	85 c0		 test	 eax, eax
  00df7	75 45		 jne	 SHORT $L58886

; 433  : 					// Do a run of unique bytes
; 434  : 					memcpy(&line[j], colorPtr, control);

  00df9	8b 4d a0	 mov	 ecx, DWORD PTR _control$58885[ebp]
  00dfc	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00e02	51		 push	 ecx
  00e03	8b 55 a4	 mov	 edx, DWORD PTR _colorPtr$58880[ebp]
  00e06	52		 push	 edx
  00e07	8b 45 ac	 mov	 eax, DWORD PTR _j$58881[ebp]
  00e0a	05 00 00 00 00	 add	 eax, OFFSET FLAT:?line@CelObj@@2PAEA ; CelObj::line
  00e0f	50		 push	 eax
  00e10	e8 00 00 00 00	 call	 _memcpy
  00e15	83 c4 0c	 add	 esp, 12			; 0000000cH

; 435  : 					colorPtr += control;

  00e18	8b 4d a0	 mov	 ecx, DWORD PTR _control$58885[ebp]
  00e1b	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00e21	8b 55 a4	 mov	 edx, DWORD PTR _colorPtr$58880[ebp]
  00e24	03 d1		 add	 edx, ecx
  00e26	89 55 a4	 mov	 DWORD PTR _colorPtr$58880[ebp], edx

; 436  : 					j += control;

  00e29	8b 45 a0	 mov	 eax, DWORD PTR _control$58885[ebp]
  00e2c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00e31	8b 4d ac	 mov	 ecx, DWORD PTR _j$58881[ebp]
  00e34	03 c8		 add	 ecx, eax
  00e36	89 4d ac	 mov	 DWORD PTR _j$58881[ebp], ecx

; 438  : 				else

  00e39	e9 a0 00 00 00	 jmp	 $L58889
$L58886:

; 440  : 					if (control & REPSKIP)

  00e3e	8b 55 a0	 mov	 edx, DWORD PTR _control$58885[ebp]
  00e41	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00e47	83 e2 40	 and	 edx, 64			; 00000040H
  00e4a	85 d2		 test	 edx, edx
  00e4c	74 40		 je	 SHORT $L58888

; 442  : 						// Do a run of repeated skip
; 443  : 						control &= 0x3f;

  00e4e	8a 45 a0	 mov	 al, BYTE PTR _control$58885[ebp]
  00e51	24 3f		 and	 al, 63			; 0000003fH
  00e53	88 45 a0	 mov	 BYTE PTR _control$58885[ebp], al

; 444  : 						memset(&line[j],skip,control);

  00e56	8b 4d a0	 mov	 ecx, DWORD PTR _control$58885[ebp]
  00e59	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00e5f	51		 push	 ecx
  00e60	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  00e63	33 c0		 xor	 eax, eax
  00e65	8a 42 38	 mov	 al, BYTE PTR [edx+56]
  00e68	50		 push	 eax
  00e69	8b 4d ac	 mov	 ecx, DWORD PTR _j$58881[ebp]
  00e6c	81 c1 00 00 00
	00		 add	 ecx, OFFSET FLAT:?line@CelObj@@2PAEA ; CelObj::line
  00e72	51		 push	 ecx
  00e73	e8 00 00 00 00	 call	 _memset
  00e78	83 c4 0c	 add	 esp, 12			; 0000000cH

; 445  : 						j += control;

  00e7b	8b 55 a0	 mov	 edx, DWORD PTR _control$58885[ebp]
  00e7e	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00e84	8b 45 ac	 mov	 eax, DWORD PTR _j$58881[ebp]
  00e87	03 c2		 add	 eax, edx
  00e89	89 45 ac	 mov	 DWORD PTR _j$58881[ebp], eax

; 447  : 					else

  00e8c	eb 50		 jmp	 SHORT $L58889
$L58888:

; 449  : 						// Do a run of repeated color
; 450  : 						control &= 0x3f;

  00e8e	8a 4d a0	 mov	 cl, BYTE PTR _control$58885[ebp]
  00e91	80 e1 3f	 and	 cl, 63			; 0000003fH
  00e94	88 4d a0	 mov	 BYTE PTR _control$58885[ebp], cl

; 451  : 						uchar color = *colorPtr++;

  00e97	8b 55 a4	 mov	 edx, DWORD PTR _colorPtr$58880[ebp]
  00e9a	8a 02		 mov	 al, BYTE PTR [edx]
  00e9c	88 45 9c	 mov	 BYTE PTR _color$58890[ebp], al
  00e9f	8b 4d a4	 mov	 ecx, DWORD PTR _colorPtr$58880[ebp]
  00ea2	83 c1 01	 add	 ecx, 1
  00ea5	89 4d a4	 mov	 DWORD PTR _colorPtr$58880[ebp], ecx

; 452  : 						memset(&line[j],color,control);

  00ea8	8b 55 a0	 mov	 edx, DWORD PTR _control$58885[ebp]
  00eab	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00eb1	52		 push	 edx
  00eb2	8b 45 9c	 mov	 eax, DWORD PTR _color$58890[ebp]
  00eb5	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00eba	50		 push	 eax
  00ebb	8b 4d ac	 mov	 ecx, DWORD PTR _j$58881[ebp]
  00ebe	81 c1 00 00 00
	00		 add	 ecx, OFFSET FLAT:?line@CelObj@@2PAEA ; CelObj::line
  00ec4	51		 push	 ecx
  00ec5	e8 00 00 00 00	 call	 _memset
  00eca	83 c4 0c	 add	 esp, 12			; 0000000cH

; 453  : 						j += control;

  00ecd	8b 55 a0	 mov	 edx, DWORD PTR _control$58885[ebp]
  00ed0	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00ed6	8b 45 ac	 mov	 eax, DWORD PTR _j$58881[ebp]
  00ed9	03 c2		 add	 eax, edx
  00edb	89 45 ac	 mov	 DWORD PTR _j$58881[ebp], eax
$L58889:

; 456  : 			}

  00ede	e9 e8 fe ff ff	 jmp	 $L58883
$L58884:

; 458  : 
; 459  : 		// Draw a line
; 460  : 		for (int x = x1; x <= x2; x++)

  00ee3	8b 4d e0	 mov	 ecx, DWORD PTR _x1$[ebp]
  00ee6	89 4d b4	 mov	 DWORD PTR _x$58891[ebp], ecx
  00ee9	eb 09		 jmp	 SHORT $L58892
$L58893:
  00eeb	8b 55 b4	 mov	 edx, DWORD PTR _x$58891[ebp]
  00eee	83 c2 01	 add	 edx, 1
  00ef1	89 55 b4	 mov	 DWORD PTR _x$58891[ebp], edx
$L58892:
  00ef4	8b 45 b4	 mov	 eax, DWORD PTR _x$58891[ebp]
  00ef7	3b 45 d8	 cmp	 eax, DWORD PTR _x2$[ebp]
  00efa	0f 8f 8c 00 00
	00		 jg	 $L58894

; 462  : 			uchar color = line[scaleX1[x]];

  00f00	8b 4d b4	 mov	 ecx, DWORD PTR _x$58891[ebp]
  00f03	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?scaleX1@CelObj@@2PAHA[ecx*4]
  00f0a	8a 82 00 00 00
	00		 mov	 al, BYTE PTR ?line@CelObj@@2PAEA[edx]
  00f10	88 45 98	 mov	 BYTE PTR _color$58895[ebp], al

; 463  : 			if (color != skip)

  00f13	8b 4d 98	 mov	 ecx, DWORD PTR _color$58895[ebp]
  00f16	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00f1c	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  00f1f	33 c0		 xor	 eax, eax
  00f21	8a 42 38	 mov	 al, BYTE PTR [edx+56]
  00f24	3b c8		 cmp	 ecx, eax
  00f26	74 56		 je	 SHORT $L58899

; 464  : 				if (color < REMAP_START_COLOR)

  00f28	8b 4d 98	 mov	 ecx, DWORD PTR _color$58895[ebp]
  00f2b	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00f31	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?REMAP_START_COLOR@@3HA ; REMAP_START_COLOR
  00f37	7d 0a		 jge	 SHORT $L58897

; 465  : 					*target = color;

  00f39	8b 55 b0	 mov	 edx, DWORD PTR _target$58877[ebp]
  00f3c	8a 45 98	 mov	 al, BYTE PTR _color$58895[ebp]
  00f3f	88 02		 mov	 BYTE PTR [edx], al

; 466  : 				else

  00f41	eb 3b		 jmp	 SHORT $L58899
$L58897:

; 467  : 					if (Remap::remapOn[color])

  00f43	8b 4d 98	 mov	 ecx, DWORD PTR _color$58895[ebp]
  00f46	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00f4c	33 d2		 xor	 edx, edx
  00f4e	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR ?remapOn@Remap@@2PAEA[ecx]
  00f54	85 d2		 test	 edx, edx
  00f56	74 26		 je	 SHORT $L58899

; 468  : 						*target = Remap::remapColor[REMAP_END_COLOR - color][*target];

  00f58	8b 45 98	 mov	 eax, DWORD PTR _color$58895[ebp]
  00f5b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00f60	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?REMAP_END_COLOR@@3HA ; REMAP_END_COLOR
  00f66	2b c8		 sub	 ecx, eax
  00f68	c1 e1 08	 shl	 ecx, 8
  00f6b	8b 55 b0	 mov	 edx, DWORD PTR _target$58877[ebp]
  00f6e	33 c0		 xor	 eax, eax
  00f70	8a 02		 mov	 al, BYTE PTR [edx]
  00f72	8b 55 b0	 mov	 edx, DWORD PTR _target$58877[ebp]
  00f75	8a 84 01 00 00
	00 00		 mov	 al, BYTE PTR ?remapColor@Remap@@2PAY0BAA@EA[ecx+eax]
  00f7c	88 02		 mov	 BYTE PTR [edx], al
$L58899:

; 469  : 			target++;

  00f7e	8b 4d b0	 mov	 ecx, DWORD PTR _target$58877[ebp]
  00f81	83 c1 01	 add	 ecx, 1
  00f84	89 4d b0	 mov	 DWORD PTR _target$58877[ebp], ecx

; 470  : 		}

  00f87	e9 5f ff ff ff	 jmp	 $L58893
$L58894:

; 471  : 	}

  00f8c	e9 cb fd ff ff	 jmp	 $L58875
$L58876:

; 472  : }

  00f91	8b e5		 mov	 esp, ebp
  00f93	5d		 pop	 ebp
  00f94	c2 14 00	 ret	 20			; 00000014H
?ScaleDrawMap@CelObj@@QAEXABVBuffer@@ABVRatio@@1ABVSOL_Rect@@ABVSOL_Point@@@Z ENDP ; CelObj::ScaleDrawMap
_TEXT	ENDS
PUBLIC	?ScaleDrawUncompMap@CelObj@@QAEXABVBuffer@@ABVRatio@@1ABVSOL_Rect@@ABVSOL_Point@@@Z ; CelObj::ScaleDrawUncompMap
_TEXT	SEGMENT
_dest$ = 8
_ratioX$ = 12
_ratioY$ = 16
_drawRect$ = 20
_pt$ = 24
_this$ = -72
_x1$ = -16
_y1$ = -32
_x2$ = -24
_y2$ = -36
_celX1$ = -4
_celY1$ = -8
_y$ = -20
_maxx$58924 = -48
_x$58925 = -44
_x$58932 = -52
_resBuffer$ = -40
_celPtr$ = -12
_colorData$ = -28
_target$58950 = -64
_colorPtr$58951 = -60
_x$58952 = -56
_color$58956 = -68
?ScaleDrawUncompMap@CelObj@@QAEXABVBuffer@@ABVRatio@@1ABVSOL_Rect@@ABVSOL_Point@@@Z PROC NEAR ; CelObj::ScaleDrawUncompMap

; 478  : {

  00f97	55		 push	 ebp
  00f98	8b ec		 mov	 ebp, esp
  00f9a	83 ec 48	 sub	 esp, 72			; 00000048H
  00f9d	89 4d b8	 mov	 DWORD PTR _this$[ebp], ecx

; 479  : 	assert(dest.Assert());
; 480  : 	assert(ratioX.Assert());
; 481  : 	assert(ratioX.Assert());
; 482  : 	assert(drawRect.IsWithin(dest.XDim(), dest.YDim()));
; 483  : 
; 484  : 	// Calculate the scaling tables
; 485  : 	ScaleTables(ratioX, ratioY);

  00fa0	8b 45 10	 mov	 eax, DWORD PTR _ratioY$[ebp]
  00fa3	50		 push	 eax
  00fa4	8b 4d 0c	 mov	 ecx, DWORD PTR _ratioX$[ebp]
  00fa7	51		 push	 ecx
  00fa8	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  00fab	e8 00 00 00 00	 call	 ?ScaleTables@CelObj@@QAEXABVRatio@@0@Z ; CelObj::ScaleTables

; 486  : 
; 487  : 	int x1 = drawRect.A.x;

  00fb0	8b 55 14	 mov	 edx, DWORD PTR _drawRect$[ebp]
  00fb3	8b 02		 mov	 eax, DWORD PTR [edx]
  00fb5	89 45 f0	 mov	 DWORD PTR _x1$[ebp], eax

; 488  : 	int y1 = drawRect.A.y;

  00fb8	8b 4d 14	 mov	 ecx, DWORD PTR _drawRect$[ebp]
  00fbb	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00fbe	89 55 e0	 mov	 DWORD PTR _y1$[ebp], edx

; 489  : 	int x2 = drawRect.B.x;

  00fc1	8b 45 14	 mov	 eax, DWORD PTR _drawRect$[ebp]
  00fc4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00fc7	89 4d e8	 mov	 DWORD PTR _x2$[ebp], ecx

; 490  : 	int y2 = drawRect.B.y;

  00fca	8b 55 14	 mov	 edx, DWORD PTR _drawRect$[ebp]
  00fcd	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00fd0	89 45 dc	 mov	 DWORD PTR _y2$[ebp], eax

; 491  : 	int celX1 = pt.x;

  00fd3	8b 4d 18	 mov	 ecx, DWORD PTR _pt$[ebp]
  00fd6	8b 11		 mov	 edx, DWORD PTR [ecx]
  00fd8	89 55 fc	 mov	 DWORD PTR _celX1$[ebp], edx

; 492  : 	int celY1 = pt.y;

  00fdb	8b 45 18	 mov	 eax, DWORD PTR _pt$[ebp]
  00fde	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00fe1	89 4d f8	 mov	 DWORD PTR _celY1$[ebp], ecx

; 493  : 	int y;
; 494  : 
; 495  : 	assert(x1 <= x2);
; 496  : 	assert(y1 <= y2);
; 497  : 	assert(celX1 <= x1);
; 498  : 	assert(celY1 <= y1);
; 499  : 
; 500  : 	if (horzFlip)

  00fe4	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  00fe7	83 7a 4c 00	 cmp	 DWORD PTR [edx+76], 0
  00feb	74 44		 je	 SHORT $L58923

; 502  : 		int maxx = width - 1;

  00fed	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  00ff0	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00ff3	83 e9 01	 sub	 ecx, 1
  00ff6	89 4d d0	 mov	 DWORD PTR _maxx$58924[ebp], ecx

; 503  : 		for (int x = x1; x <= x2; x++)

  00ff9	8b 55 f0	 mov	 edx, DWORD PTR _x1$[ebp]
  00ffc	89 55 d4	 mov	 DWORD PTR _x$58925[ebp], edx
  00fff	eb 09		 jmp	 SHORT $L58926
$L58927:
  01001	8b 45 d4	 mov	 eax, DWORD PTR _x$58925[ebp]
  01004	83 c0 01	 add	 eax, 1
  01007	89 45 d4	 mov	 DWORD PTR _x$58925[ebp], eax
$L58926:
  0100a	8b 4d d4	 mov	 ecx, DWORD PTR _x$58925[ebp]
  0100d	3b 4d e8	 cmp	 ecx, DWORD PTR _x2$[ebp]
  01010	7f 1d		 jg	 SHORT $L58928

; 505  : 			scaleX1[x] = maxx - (scaleX[x - celX1]);

  01012	8b 55 d4	 mov	 edx, DWORD PTR _x$58925[ebp]
  01015	2b 55 fc	 sub	 edx, DWORD PTR _celX1$[ebp]
  01018	a1 00 00 00 00	 mov	 eax, DWORD PTR ?scaleX@CelObj@@2PAHA ; CelObj::scaleX
  0101d	8b 4d d0	 mov	 ecx, DWORD PTR _maxx$58924[ebp]
  01020	2b 0c 90	 sub	 ecx, DWORD PTR [eax+edx*4]
  01023	8b 55 d4	 mov	 edx, DWORD PTR _x$58925[ebp]
  01026	89 0c 95 00 00
	00 00		 mov	 DWORD PTR ?scaleX1@CelObj@@2PAHA[edx*4], ecx

; 506  : 			assert(scaleX1[x] >= 0);
; 507  : 			assert(scaleX1[x] < width);
; 508  : 		}

  0102d	eb d2		 jmp	 SHORT $L58927
$L58928:

; 510  : 	else

  0102f	eb 34		 jmp	 SHORT $L58935
$L58923:

; 512  : 		for (int x = x1; x <= x2; x++)

  01031	8b 45 f0	 mov	 eax, DWORD PTR _x1$[ebp]
  01034	89 45 cc	 mov	 DWORD PTR _x$58932[ebp], eax
  01037	eb 09		 jmp	 SHORT $L58933
$L58934:
  01039	8b 4d cc	 mov	 ecx, DWORD PTR _x$58932[ebp]
  0103c	83 c1 01	 add	 ecx, 1
  0103f	89 4d cc	 mov	 DWORD PTR _x$58932[ebp], ecx
$L58933:
  01042	8b 55 cc	 mov	 edx, DWORD PTR _x$58932[ebp]
  01045	3b 55 e8	 cmp	 edx, DWORD PTR _x2$[ebp]
  01048	7f 1b		 jg	 SHORT $L58935

; 514  : 			scaleX1[x] = scaleX[x - celX1];

  0104a	8b 45 cc	 mov	 eax, DWORD PTR _x$58932[ebp]
  0104d	2b 45 fc	 sub	 eax, DWORD PTR _celX1$[ebp]
  01050	8b 4d cc	 mov	 ecx, DWORD PTR _x$58932[ebp]
  01053	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?scaleX@CelObj@@2PAHA ; CelObj::scaleX
  01059	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  0105c	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?scaleX1@CelObj@@2PAHA[ecx*4], eax

; 515  : 			assert(scaleX1[x] >= 0);
; 516  : 			assert(scaleX1[x] < width);
; 517  : 		}

  01063	eb d4		 jmp	 SHORT $L58934
$L58935:

; 519  : 
; 520  : 
; 521  : 	for (y = y1; y <= y2; y++)

  01065	8b 4d e0	 mov	 ecx, DWORD PTR _y1$[ebp]
  01068	89 4d ec	 mov	 DWORD PTR _y$[ebp], ecx
  0106b	eb 09		 jmp	 SHORT $L58938
$L58939:
  0106d	8b 55 ec	 mov	 edx, DWORD PTR _y$[ebp]
  01070	83 c2 01	 add	 edx, 1
  01073	89 55 ec	 mov	 DWORD PTR _y$[ebp], edx
$L58938:
  01076	8b 45 ec	 mov	 eax, DWORD PTR _y$[ebp]
  01079	3b 45 dc	 cmp	 eax, DWORD PTR _y2$[ebp]
  0107c	7f 1a		 jg	 SHORT $L58940

; 523  : 		scaleY1[y] = scaleY[y - celY1];

  0107e	8b 4d ec	 mov	 ecx, DWORD PTR _y$[ebp]
  01081	2b 4d f8	 sub	 ecx, DWORD PTR _celY1$[ebp]
  01084	8b 55 ec	 mov	 edx, DWORD PTR _y$[ebp]
  01087	a1 00 00 00 00	 mov	 eax, DWORD PTR ?scaleY@CelObj@@2PAHA ; CelObj::scaleY
  0108c	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  0108f	89 0c 95 00 00
	00 00		 mov	 DWORD PTR ?scaleY1@CelObj@@2PAHA[edx*4], ecx

; 524  : 		assert(scaleY1[y] >= 0);
; 525  : 		assert(scaleY1[y] < height);
; 526  : 	}

  01096	eb d5		 jmp	 SHORT $L58939
$L58940:

; 527  : 
; 528  : 	// Get a pointer to the cel.
; 529  : 	uchar* resBuffer = ResPointer();

  01098	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  0109b	8b 02		 mov	 eax, DWORD PTR [edx]
  0109d	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  010a0	ff 50 14	 call	 DWORD PTR [eax+20]
  010a3	89 45 d8	 mov	 DWORD PTR _resBuffer$[ebp], eax

; 530  : 	CelHeader* celPtr = (CelHeader*) (resBuffer + celOffset);

  010a6	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  010a9	8b 55 d8	 mov	 edx, DWORD PTR _resBuffer$[ebp]
  010ac	03 51 18	 add	 edx, DWORD PTR [ecx+24]
  010af	89 55 f4	 mov	 DWORD PTR _celPtr$[ebp], edx

; 531  : 	uchar* colorData = resBuffer + celPtr->controlOffset;

  010b2	8b 45 f4	 mov	 eax, DWORD PTR _celPtr$[ebp]
  010b5	8b 4d d8	 mov	 ecx, DWORD PTR _resBuffer$[ebp]
  010b8	03 48 18	 add	 ecx, DWORD PTR [eax+24]
  010bb	89 4d e4	 mov	 DWORD PTR _colorData$[ebp], ecx

; 532  : 
; 533  : 	// Draw the inset rectangle
; 534  : 	for (y = y1; y <= y2; y++)

  010be	8b 55 e0	 mov	 edx, DWORD PTR _y1$[ebp]
  010c1	89 55 ec	 mov	 DWORD PTR _y$[ebp], edx
  010c4	eb 09		 jmp	 SHORT $L58947
$L58948:
  010c6	8b 45 ec	 mov	 eax, DWORD PTR _y$[ebp]
  010c9	83 c0 01	 add	 eax, 1
  010cc	89 45 ec	 mov	 DWORD PTR _y$[ebp], eax
$L58947:
  010cf	8b 4d ec	 mov	 ecx, DWORD PTR _y$[ebp]
  010d2	3b 4d dc	 cmp	 ecx, DWORD PTR _y2$[ebp]
  010d5	0f 8f dd 00 00
	00		 jg	 $L58949

; 536  : 		uchar* target = dest.Addr(x1, y);

  010db	8b 55 ec	 mov	 edx, DWORD PTR _y$[ebp]
  010de	52		 push	 edx
  010df	8b 45 f0	 mov	 eax, DWORD PTR _x1$[ebp]
  010e2	50		 push	 eax
  010e3	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  010e6	8b 11		 mov	 edx, DWORD PTR [ecx]
  010e8	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  010eb	ff 12		 call	 DWORD PTR [edx]
  010ed	89 45 c0	 mov	 DWORD PTR _target$58950[ebp], eax

; 537  : 		uchar* colorPtr = colorData + (width * scaleY1[y]);

  010f0	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  010f3	8b 4d ec	 mov	 ecx, DWORD PTR _y$[ebp]
  010f6	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  010f9	0f af 14 8d 00
	00 00 00	 imul	 edx, DWORD PTR ?scaleY1@CelObj@@2PAHA[ecx*4]
  01101	8b 45 e4	 mov	 eax, DWORD PTR _colorData$[ebp]
  01104	03 c2		 add	 eax, edx
  01106	89 45 c4	 mov	 DWORD PTR _colorPtr$58951[ebp], eax

; 538  : 
; 539  : 		// Draw a line
; 540  : 		for (int x = x1; x <= x2; x++) {

  01109	8b 4d f0	 mov	 ecx, DWORD PTR _x1$[ebp]
  0110c	89 4d c8	 mov	 DWORD PTR _x$58952[ebp], ecx
  0110f	eb 09		 jmp	 SHORT $L58953
$L58954:
  01111	8b 55 c8	 mov	 edx, DWORD PTR _x$58952[ebp]
  01114	83 c2 01	 add	 edx, 1
  01117	89 55 c8	 mov	 DWORD PTR _x$58952[ebp], edx
$L58953:
  0111a	8b 45 c8	 mov	 eax, DWORD PTR _x$58952[ebp]
  0111d	3b 45 e8	 cmp	 eax, DWORD PTR _x2$[ebp]
  01120	0f 8f 8d 00 00
	00		 jg	 $L58955

; 541  : 			uchar color = colorPtr[scaleX1[x]];

  01126	8b 4d c8	 mov	 ecx, DWORD PTR _x$58952[ebp]
  01129	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?scaleX1@CelObj@@2PAHA[ecx*4]
  01130	8b 45 c4	 mov	 eax, DWORD PTR _colorPtr$58951[ebp]
  01133	8a 0c 10	 mov	 cl, BYTE PTR [eax+edx]
  01136	88 4d bc	 mov	 BYTE PTR _color$58956[ebp], cl

; 542  : 			if (color != skip  &&  color < REMAP_START_COLOR)

  01139	8b 55 bc	 mov	 edx, DWORD PTR _color$58956[ebp]
  0113c	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  01142	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  01145	33 c9		 xor	 ecx, ecx
  01147	8a 48 38	 mov	 cl, BYTE PTR [eax+56]
  0114a	3b d1		 cmp	 edx, ecx
  0114c	74 1b		 je	 SHORT $L58957
  0114e	8b 55 bc	 mov	 edx, DWORD PTR _color$58956[ebp]
  01151	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  01157	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?REMAP_START_COLOR@@3HA ; REMAP_START_COLOR
  0115d	7d 0a		 jge	 SHORT $L58957

; 543  : 				*target = color;

  0115f	8b 45 c0	 mov	 eax, DWORD PTR _target$58950[ebp]
  01162	8a 4d bc	 mov	 cl, BYTE PTR _color$58956[ebp]
  01165	88 08		 mov	 BYTE PTR [eax], cl

; 544  : 			else

  01167	eb 3c		 jmp	 SHORT $L58959
$L58957:

; 545  : 				if (Remap::remapOn[color])

  01169	8b 55 bc	 mov	 edx, DWORD PTR _color$58956[ebp]
  0116c	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  01172	33 c0		 xor	 eax, eax
  01174	8a 82 00 00 00
	00		 mov	 al, BYTE PTR ?remapOn@Remap@@2PAEA[edx]
  0117a	85 c0		 test	 eax, eax
  0117c	74 27		 je	 SHORT $L58959

; 546  : 					*target = Remap::remapColor[REMAP_END_COLOR - color][*target];

  0117e	8b 4d bc	 mov	 ecx, DWORD PTR _color$58956[ebp]
  01181	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  01187	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?REMAP_END_COLOR@@3HA ; REMAP_END_COLOR
  0118d	2b d1		 sub	 edx, ecx
  0118f	c1 e2 08	 shl	 edx, 8
  01192	8b 45 c0	 mov	 eax, DWORD PTR _target$58950[ebp]
  01195	33 c9		 xor	 ecx, ecx
  01197	8a 08		 mov	 cl, BYTE PTR [eax]
  01199	8b 45 c0	 mov	 eax, DWORD PTR _target$58950[ebp]
  0119c	8a 8c 0a 00 00
	00 00		 mov	 cl, BYTE PTR ?remapColor@Remap@@2PAY0BAA@EA[edx+ecx]
  011a3	88 08		 mov	 BYTE PTR [eax], cl
$L58959:

; 547  : 			target++;

  011a5	8b 55 c0	 mov	 edx, DWORD PTR _target$58950[ebp]
  011a8	83 c2 01	 add	 edx, 1
  011ab	89 55 c0	 mov	 DWORD PTR _target$58950[ebp], edx

; 548  : 		}

  011ae	e9 5e ff ff ff	 jmp	 $L58954
$L58955:

; 549  : 	}

  011b3	e9 0e ff ff ff	 jmp	 $L58948
$L58949:

; 550  : }

  011b8	8b e5		 mov	 esp, ebp
  011ba	5d		 pop	 ebp
  011bb	c2 14 00	 ret	 20			; 00000014H
?ScaleDrawUncompMap@CelObj@@QAEXABVBuffer@@ABVRatio@@1ABVSOL_Rect@@ABVSOL_Point@@@Z ENDP ; CelObj::ScaleDrawUncompMap
_TEXT	ENDS
;	COMDAT ?Xlen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Xlen@SOL_Rect@@QBEHXZ PROC NEAR			; SOL_Rect::Xlen, COMDAT

; 153  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 154  : 	return B.x - A.x + 1;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00010	2b 01		 sub	 eax, DWORD PTR [ecx]
  00012	83 c0 01	 add	 eax, 1

; 155  : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?Xlen@SOL_Rect@@QBEHXZ ENDP				; SOL_Rect::Xlen
_TEXT	ENDS
;	COMDAT ?Ylen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Ylen@SOL_Rect@@QBEHXZ PROC NEAR			; SOL_Rect::Ylen, COMDAT

; 161  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 	return B.y - A.y + 1;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00010	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00013	83 c0 01	 add	 eax, 1

; 163  : }

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?Ylen@SOL_Rect@@QBEHXZ ENDP				; SOL_Rect::Ylen
_TEXT	ENDS
;	COMDAT ?XDim@Buffer@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?XDim@Buffer@@QBEHXZ PROC NEAR				; Buffer::XDim, COMDAT

; 12   : 	int		XDim() const							{return xDim;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?XDim@Buffer@@QBEHXZ ENDP				; Buffer::XDim
_TEXT	ENDS
END
