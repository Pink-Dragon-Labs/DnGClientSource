	TITLE	\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\List.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MemoryMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckValid@MemoryMgr@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GMemoryMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@MemID@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@V1@III@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AMemID@@QBEAADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8MemID@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??7MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeArrayID@@QBEPAUArrayHeader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ArrayID@@QAE@HW4ArrayType@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@ArrayID@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAE?AVMemID@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lock@Array@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?unlock@Array@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAEXVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_List@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@SOL_List@@QAEAAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?createElements@SOL_List@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeSOL_ListID@@QBEPAVSOL_List@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_ListID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_ListID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@SOL_ListID@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeDispatchTblID@@QBEPAUDispatchTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeScriptEntryID@@QBEPAUScriptEntry@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntry@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeVariableID@@QBEPAUVariable@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Script@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Object@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGraphicsUpdate@Object@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?selectorDict@Object@@QAEPAVSelectorDict@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AObject@@QAEAAFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddr@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedPropAddr@Object@@QAEPBFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedProperty@Object@@QAEFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddrCheck@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@Object@@QAEFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropOffset@Object@@QAEIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetIndexedProperty@Object@@QAEXHF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetProperty@Object@@QAEXGF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssureValid@ObjectID@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsObject@ObjectID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@ObjectID@@QBEFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeClassTblID@@QBEPAUClassTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_ListID@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7MemoryMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?size@SOL_List@@QAEAAHXZ			; SOL_List::size
PUBLIC	?at@SOL_List@@QAEGH@Z				; SOL_List::at
PUBLIC	?createElements@SOL_List@@QAEXXZ		; SOL_List::createElements
EXTRN	?at@Array@@QAEHH@Z:NEAR				; Array::at
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
?at@SOL_List@@QAEGH@Z PROC NEAR				; SOL_List::at

; 13   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 14   : 	createElements();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?createElements@SOL_List@@QAEXXZ ; SOL_List::createElements

; 15   : 
; 16   : 	if ( size() )

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?size@SOL_List@@QAEAAHXZ ; SOL_List::size
  00017	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001a	74 0e		 je	 SHORT $L58268

; 17   : 		return (SCIUWord)elements.at ( index );

  0001c	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?at@Array@@QAEHH@Z	; Array::at
  00028	eb 03		 jmp	 SHORT $L58267
$L58268:

; 18   : 	
; 19   : 	return 0;

  0002a	66 33 c0	 xor	 ax, ax
$L58267:

; 20   : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?at@SOL_List@@QAEGH@Z ENDP				; SOL_List::at
_TEXT	ENDS
;	COMDAT ?size@SOL_List@@QAEAAHXZ
_TEXT	SEGMENT
_this$ = -4
?size@SOL_List@@QAEAAHXZ PROC NEAR			; SOL_List::size, COMDAT

; 24   : 	inline int &size ( void ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 25   : 		return _size;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4

; 26   : 	}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?size@SOL_List@@QAEAAHXZ ENDP				; SOL_List::size
_TEXT	ENDS
PUBLIC	??0MemID@@QAE@ABV0@@Z				; MemID::MemID
PUBLIC	??7MemID@@QBEHXZ				; MemID::operator!
PUBLIC	??0ArrayID@@QAE@HW4ArrayType@@@Z		; ArrayID::ArrayID
PUBLIC	?dataID@Array@@QAE?AVMemID@@XZ			; Array::dataID
PUBLIC	?dataID@Array@@QAEXVMemID@@@Z			; Array::dataID
;	COMDAT ?createElements@SOL_List@@QAEXXZ
_TEXT	SEGMENT
$T58736 = -4
$T58738 = -12
_this$ = -16
?createElements@SOL_List@@QAEXXZ PROC NEAR		; SOL_List::createElements, COMDAT

; 65   : 	void createElements ( void ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 66   : 		if ( !elements.dataID() )

  00009	8d 45 fc	 lea	 eax, DWORD PTR $T58736[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?dataID@Array@@QAE?AVMemID@@XZ ; Array::dataID
  00015	8b c8		 mov	 ecx, eax
  00017	e8 00 00 00 00	 call	 ??7MemID@@QBEHXZ	; MemID::operator!
  0001c	85 c0		 test	 eax, eax
  0001e	74 1d		 je	 SHORT $L55131

; 67   : 			elements.dataID ( ArrayID ( 10, INTARRAY ) );

  00020	6a 00		 push	 0
  00022	6a 0a		 push	 10			; 0000000aH
  00024	8d 4d f4	 lea	 ecx, DWORD PTR $T58738[ebp]
  00027	e8 00 00 00 00	 call	 ??0ArrayID@@QAE@HW4ArrayType@@@Z ; ArrayID::ArrayID
  0002c	51		 push	 ecx
  0002d	8b cc		 mov	 ecx, esp
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00035	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?dataID@Array@@QAEXVMemID@@@Z ; Array::dataID
$L55131:

; 68   : 	}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?createElements@SOL_List@@QAEXXZ ENDP			; SOL_List::createElements
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0MemID@@QAE@ABV0@@Z PROC NEAR				; MemID::MemID, COMDAT

; 19   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  0000d	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00010	66 89 10	 mov	 WORD PTR [eax], dx

; 20   : 	}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0MemID@@QAE@ABV0@@Z ENDP				; MemID::MemID
_TEXT	ENDS
;	COMDAT ??7MemID@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
??7MemID@@QBEHXZ PROC NEAR				; MemID::operator!, COMDAT

; 118  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 119  : 		return handle == 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000f	8b c1		 mov	 eax, ecx
  00011	f7 d8		 neg	 eax
  00013	1b c0		 sbb	 eax, eax
  00015	40		 inc	 eax

; 120  : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??7MemID@@QBEHXZ ENDP					; MemID::operator!
_TEXT	ENDS
PUBLIC	??0FakeArrayID@@QAE@XZ				; FakeArrayID::FakeArrayID
PUBLIC	??DFakeArrayID@@QBEPAUArrayHeader@@XZ		; FakeArrayID::operator*
PUBLIC	?Get@ArrayID@@QAEXI@Z				; ArrayID::Get
EXTRN	?ArrayElementSize@@3PAHA:BYTE			; ArrayElementSize
;	COMDAT ??0ArrayID@@QAE@HW4ArrayType@@@Z
_TEXT	SEGMENT
_size$ = 8
_type$ = 12
_this$ = -12
_elementSize$ = -8
_array$ = -4
??0ArrayID@@QAE@HW4ArrayType@@@Z PROC NEAR		; ArrayID::ArrayID, COMDAT

; 40   : 	ArrayID ( int size, ArrayType type )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0FakeArrayID@@QAE@XZ	; FakeArrayID::FakeArrayID

; 41   : 	{
; 42   : 		int elementSize = ArrayElementSize[type];

  00011	8b 45 0c	 mov	 eax, DWORD PTR _type$[ebp]
  00014	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ArrayElementSize@@3PAHA[eax*4]
  0001b	89 4d f8	 mov	 DWORD PTR _elementSize$[ebp], ecx

; 43   : 
; 44   : 		// allocate the base array
; 45   : 		Get ( elementSize * size + sizeof ( ArrayHeader ) );

  0001e	8b 55 f8	 mov	 edx, DWORD PTR _elementSize$[ebp]
  00021	0f af 55 08	 imul	 edx, DWORD PTR _size$[ebp]
  00025	83 c2 04	 add	 edx, 4
  00028	52		 push	 edx
  00029	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?Get@ArrayID@@QAEXI@Z	; ArrayID::Get

; 46   : 
; 47   : 		// set the default values for the Array struct that I represent
; 48   : 		ArrayHeader *array = **this;

  00031	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ??DFakeArrayID@@QBEPAUArrayHeader@@XZ ; FakeArrayID::operator*
  00039	89 45 fc	 mov	 DWORD PTR _array$[ebp], eax

; 49   : 		array->elementSize = elementSize;

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _array$[ebp]
  0003f	66 8b 4d f8	 mov	 cx, WORD PTR _elementSize$[ebp]
  00043	66 89 08	 mov	 WORD PTR [eax], cx

; 50   : 		array->size = size;

  00046	8b 55 fc	 mov	 edx, DWORD PTR _array$[ebp]
  00049	66 8b 45 08	 mov	 ax, WORD PTR _size$[ebp]
  0004d	66 89 42 02	 mov	 WORD PTR [edx+2], ax

; 51   : 	}

  00051	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 08 00	 ret	 8
??0ArrayID@@QAE@HW4ArrayType@@@Z ENDP			; ArrayID::ArrayID
_TEXT	ENDS
PUBLIC	??0MemID@@QAE@XZ				; MemID::MemID
;	COMDAT ??0FakeArrayID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0FakeArrayID@@QAE@XZ PROC NEAR			; FakeArrayID::FakeArrayID, COMDAT

; 34   : FakeTemplateID ( FakeArrayID, ArrayHeader, MemArray )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0FakeArrayID@@QAE@XZ ENDP				; FakeArrayID::FakeArrayID
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0MemID@@QAE@XZ PROC NEAR				; MemID::MemID, COMDAT

; 15   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 16   : 	}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0MemID@@QAE@XZ ENDP					; MemID::MemID
_TEXT	ENDS
PUBLIC	??DMemID@@QBEPAXXZ				; MemID::operator*
;	COMDAT ??DFakeArrayID@@QBEPAUArrayHeader@@XZ
_TEXT	SEGMENT
_this$ = -4
??DFakeArrayID@@QBEPAUArrayHeader@@XZ PROC NEAR		; FakeArrayID::operator*, COMDAT

; 34   : FakeTemplateID ( FakeArrayID, ArrayHeader, MemArray )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??DFakeArrayID@@QBEPAUArrayHeader@@XZ ENDP		; FakeArrayID::operator*
_TEXT	ENDS
PUBLIC	?GetAddr@MemoryMgr@@QAEPAXG@Z			; MemoryMgr::GetAddr
EXTRN	_memMgr:DWORD
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT
_this$ = -4
??DMemID@@QBEPAXXZ PROC NEAR				; MemID::operator*, COMDAT

; 98   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 99   : 		return memMgr->GetAddr(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr

; 100  : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??DMemID@@QBEPAXXZ ENDP					; MemID::operator*
_TEXT	ENDS
EXTRN	__descPtrTable:BYTE
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -4
?GetAddr@MemoryMgr@@QAEPAXG@Z PROC NEAR			; MemoryMgr::GetAddr, COMDAT

; 462  : 	inline void* MemoryMgr::GetAddr(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : //		CheckValid(theID);
; 464  : 		return _descPtrTable[(unsigned int)((unsigned short)theID)];

  00007	8b 45 08	 mov	 eax, DWORD PTR _theID$[ebp]
  0000a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0000f	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR __descPtrTable[eax*4]

; 465  : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?GetAddr@MemoryMgr@@QAEPAXG@Z ENDP			; MemoryMgr::GetAddr
_TEXT	ENDS
PUBLIC	?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get
;	COMDAT ?Get@ArrayID@@QAEXI@Z
_TEXT	SEGMENT
_size$ = 8
_this$ = -4
?Get@ArrayID@@QAEXI@Z PROC NEAR				; ArrayID::Get, COMDAT

; 55   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 56   : 		// initialize arrays to 0
; 57   : 
; 58   : 		//	include defaulted args because CodeWarrior 1.1.1.2 doesn't
; 59   : 		//	consider enums a separate type and so can't distinguish between
; 60   : 		//	overloaded Get()s.
; 61   : 		MemID::Get(MemArray, size, INITMEMORY | MOVEABLE, 0, 0, 0, IllegalHandle);

  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 00		 push	 0
  0000f	68 00 02 01 00	 push	 66048			; 00010200H
  00014	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  00017	50		 push	 eax
  00018	6a 35		 push	 53			; 00000035H
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get

; 62   : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?Get@ArrayID@@QAEXI@Z ENDP				; ArrayID::Get
_TEXT	ENDS
EXTRN	?Alloc@MemoryMgr@@QAEGIIIPAUMemClient@@DW4ReservedHandle@@@Z:NEAR ; MemoryMgr::Alloc
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT
_type$ = 8
_size$ = 12
_a$ = 16
_num$ = 20
_client$ = 24
_initChar$ = 28
_h$ = 32
_this$ = -4
?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z PROC NEAR ; MemID::Get, COMDAT

; 42   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 43   : 		handle = memMgr->Alloc(type | a, size, num, client, initChar, h);

  00007	8b 45 20	 mov	 eax, DWORD PTR _h$[ebp]
  0000a	50		 push	 eax
  0000b	8a 4d 1c	 mov	 cl, BYTE PTR _initChar$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 18	 mov	 edx, DWORD PTR _client$[ebp]
  00012	52		 push	 edx
  00013	8b 45 14	 mov	 eax, DWORD PTR _num$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 55 08	 mov	 edx, DWORD PTR _type$[ebp]
  0001e	0b 55 10	 or	 edx, DWORD PTR _a$[ebp]
  00021	52		 push	 edx
  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00028	e8 00 00 00 00	 call	 ?Alloc@MemoryMgr@@QAEGIIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemoryMgr::Alloc
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	66 89 01	 mov	 WORD PTR [ecx], ax

; 44   : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 1c 00	 ret	 28			; 0000001cH
?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ENDP ; MemID::Get
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAE?AVMemID@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
?dataID@Array@@QAE?AVMemID@@XZ PROC NEAR		; Array::dataID, COMDAT

; 96   : 	MemID dataID ( void ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 97   : 		return _dataID;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00013	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 98   : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?dataID@Array@@QAE?AVMemID@@XZ ENDP			; Array::dataID
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAEXVMemID@@@Z
_TEXT	SEGMENT
_memID$ = 8
_this$ = -4
?dataID@Array@@QAEXVMemID@@@Z PROC NEAR			; Array::dataID, COMDAT

; 111  : 	void dataID ( MemID memID ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		_dataID = memID;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 4d 08	 mov	 cx, WORD PTR _memID$[ebp]
  0000e	66 89 08	 mov	 WORD PTR [eax], cx

; 113  : 	}

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?dataID@Array@@QAEXVMemID@@@Z ENDP			; Array::dataID
_TEXT	ENDS
PUBLIC	?addAfter@SOL_List@@QAEHGG@Z			; SOL_List::addAfter
PUBLIC	?indexOf@SOL_List@@QAEHG@Z			; SOL_List::indexOf
EXTRN	?insert@Array@@QAEXHH@Z:NEAR			; Array::insert
_TEXT	SEGMENT
_existingKey$ = 8
_key$ = 12
_this$ = -8
_index$ = -4
?addAfter@SOL_List@@QAEHGG@Z PROC NEAR			; SOL_List::addAfter

; 24   : {

  00033	55		 push	 ebp
  00034	8b ec		 mov	 ebp, esp
  00036	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00039	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 25   : 	createElements();

  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?createElements@SOL_List@@QAEXXZ ; SOL_List::createElements

; 26   : 
; 27   : 	int index = indexOf ( existingKey );

  00044	66 8b 45 08	 mov	 ax, WORD PTR _existingKey$[ebp]
  00048	50		 push	 eax
  00049	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?indexOf@SOL_List@@QAEHG@Z ; SOL_List::indexOf
  00051	89 45 fc	 mov	 DWORD PTR _index$[ebp], eax

; 28   : 
; 29   : 	if ( index == -1 )

  00054	83 7d fc ff	 cmp	 DWORD PTR _index$[ebp], -1
  00058	75 04		 jne	 SHORT $L58276

; 30   : 		return 0;

  0005a	33 c0		 xor	 eax, eax
  0005c	eb 36		 jmp	 SHORT $L58274
$L58276:

; 31   : 
; 32   : 	size()++;

  0005e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	e8 00 00 00 00	 call	 ?size@SOL_List@@QAEAAHXZ ; SOL_List::size
  00066	89 45 f4	 mov	 DWORD PTR -12+[ebp], eax
  00069	8b 4d f4	 mov	 ecx, DWORD PTR -12+[ebp]
  0006c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006e	83 c2 01	 add	 edx, 1
  00071	8b 45 f4	 mov	 eax, DWORD PTR -12+[ebp]
  00074	89 10		 mov	 DWORD PTR [eax], edx

; 33   : 
; 34   : 	elements.insert ( key, index + 1 );

  00076	8b 4d fc	 mov	 ecx, DWORD PTR _index$[ebp]
  00079	83 c1 01	 add	 ecx, 1
  0007c	51		 push	 ecx
  0007d	8b 55 0c	 mov	 edx, DWORD PTR _key$[ebp]
  00080	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00086	52		 push	 edx
  00087	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	e8 00 00 00 00	 call	 ?insert@Array@@QAEXHH@Z	; Array::insert

; 35   : 
; 36   : 	return 1;

  0008f	b8 01 00 00 00	 mov	 eax, 1
$L58274:

; 37   : }

  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 08 00	 ret	 8
?addAfter@SOL_List@@QAEHGG@Z ENDP			; SOL_List::addAfter
_TEXT	ENDS
PUBLIC	?addBefore@SOL_List@@QAEHGG@Z			; SOL_List::addBefore
_TEXT	SEGMENT
_existingKey$ = 8
_key$ = 12
_this$ = -8
_index$ = -4
?addBefore@SOL_List@@QAEHGG@Z PROC NEAR			; SOL_List::addBefore

; 41   : {

  0009a	55		 push	 ebp
  0009b	8b ec		 mov	 ebp, esp
  0009d	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000a0	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 42   : 	createElements();

  000a3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	e8 00 00 00 00	 call	 ?createElements@SOL_List@@QAEXXZ ; SOL_List::createElements

; 43   : 
; 44   : 	int index = indexOf ( existingKey );

  000ab	66 8b 45 08	 mov	 ax, WORD PTR _existingKey$[ebp]
  000af	50		 push	 eax
  000b0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	e8 00 00 00 00	 call	 ?indexOf@SOL_List@@QAEHG@Z ; SOL_List::indexOf
  000b8	89 45 fc	 mov	 DWORD PTR _index$[ebp], eax

; 45   : 
; 46   : 	if ( index == -1 )

  000bb	83 7d fc ff	 cmp	 DWORD PTR _index$[ebp], -1
  000bf	75 04		 jne	 SHORT $L58283

; 47   : 		return 0;

  000c1	33 c0		 xor	 eax, eax
  000c3	eb 33		 jmp	 SHORT $L58281
$L58283:

; 48   : 
; 49   : 	size()++;

  000c5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	e8 00 00 00 00	 call	 ?size@SOL_List@@QAEAAHXZ ; SOL_List::size
  000cd	89 45 f4	 mov	 DWORD PTR -12+[ebp], eax
  000d0	8b 4d f4	 mov	 ecx, DWORD PTR -12+[ebp]
  000d3	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d5	83 c2 01	 add	 edx, 1
  000d8	8b 45 f4	 mov	 eax, DWORD PTR -12+[ebp]
  000db	89 10		 mov	 DWORD PTR [eax], edx

; 50   : 	elements.insert ( key, index );

  000dd	8b 4d fc	 mov	 ecx, DWORD PTR _index$[ebp]
  000e0	51		 push	 ecx
  000e1	8b 55 0c	 mov	 edx, DWORD PTR _key$[ebp]
  000e4	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  000ea	52		 push	 edx
  000eb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ee	e8 00 00 00 00	 call	 ?insert@Array@@QAEXHH@Z	; Array::insert

; 51   : 
; 52   : 	return 1;

  000f3	b8 01 00 00 00	 mov	 eax, 1
$L58281:

; 53   : }

  000f8	8b e5		 mov	 esp, ebp
  000fa	5d		 pop	 ebp
  000fb	c2 08 00	 ret	 8
?addBefore@SOL_List@@QAEHGG@Z ENDP			; SOL_List::addBefore
_TEXT	ENDS
PUBLIC	?addToFront@SOL_List@@QAEXG@Z			; SOL_List::addToFront
_TEXT	SEGMENT
_key$ = 8
_this$ = -4
?addToFront@SOL_List@@QAEXG@Z PROC NEAR			; SOL_List::addToFront

; 57   : {

  000fe	55		 push	 ebp
  000ff	8b ec		 mov	 ebp, esp
  00101	83 ec 08	 sub	 esp, 8
  00104	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 58   : 	createElements();

  00107	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0010a	e8 00 00 00 00	 call	 ?createElements@SOL_List@@QAEXXZ ; SOL_List::createElements

; 59   : 
; 60   : 	size()++;

  0010f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00112	e8 00 00 00 00	 call	 ?size@SOL_List@@QAEAAHXZ ; SOL_List::size
  00117	89 45 f8	 mov	 DWORD PTR -8+[ebp], eax
  0011a	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]
  0011d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0011f	83 c1 01	 add	 ecx, 1
  00122	8b 55 f8	 mov	 edx, DWORD PTR -8+[ebp]
  00125	89 0a		 mov	 DWORD PTR [edx], ecx

; 61   : 
; 62   : 	elements.insert ( key, 0 );

  00127	6a 00		 push	 0
  00129	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  0012c	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00131	50		 push	 eax
  00132	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00135	e8 00 00 00 00	 call	 ?insert@Array@@QAEXHH@Z	; Array::insert

; 63   : }

  0013a	8b e5		 mov	 esp, ebp
  0013c	5d		 pop	 ebp
  0013d	c2 04 00	 ret	 4
?addToFront@SOL_List@@QAEXG@Z ENDP			; SOL_List::addToFront
_TEXT	ENDS
PUBLIC	?addToEnd@SOL_List@@QAEXG@Z			; SOL_List::addToEnd
EXTRN	?at@Array@@QAEXHH@Z:NEAR			; Array::at
_TEXT	SEGMENT
_key$ = 8
_this$ = -4
?addToEnd@SOL_List@@QAEXG@Z PROC NEAR			; SOL_List::addToEnd

; 67   : {

  00140	55		 push	 ebp
  00141	8b ec		 mov	 ebp, esp
  00143	83 ec 08	 sub	 esp, 8
  00146	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 68   : 	createElements();

  00149	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0014c	e8 00 00 00 00	 call	 ?createElements@SOL_List@@QAEXXZ ; SOL_List::createElements

; 69   : 
; 70   : 	elements.at ( size(), key );

  00151	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  00154	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00159	50		 push	 eax
  0015a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015d	e8 00 00 00 00	 call	 ?size@SOL_List@@QAEAAHXZ ; SOL_List::size
  00162	8b 08		 mov	 ecx, DWORD PTR [eax]
  00164	51		 push	 ecx
  00165	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00168	e8 00 00 00 00	 call	 ?at@Array@@QAEXHH@Z	; Array::at

; 71   : 	size()++;

  0016d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00170	e8 00 00 00 00	 call	 ?size@SOL_List@@QAEAAHXZ ; SOL_List::size
  00175	89 45 f8	 mov	 DWORD PTR -8+[ebp], eax
  00178	8b 55 f8	 mov	 edx, DWORD PTR -8+[ebp]
  0017b	8b 02		 mov	 eax, DWORD PTR [edx]
  0017d	83 c0 01	 add	 eax, 1
  00180	8b 4d f8	 mov	 ecx, DWORD PTR -8+[ebp]
  00183	89 01		 mov	 DWORD PTR [ecx], eax

; 72   : }

  00185	8b e5		 mov	 esp, ebp
  00187	5d		 pop	 ebp
  00188	c2 04 00	 ret	 4
?addToEnd@SOL_List@@QAEXG@Z ENDP			; SOL_List::addToEnd
_TEXT	ENDS
PUBLIC	?moveToFront@SOL_List@@QAEHG@Z			; SOL_List::moveToFront
PUBLIC	?del@SOL_List@@QAEHG@Z				; SOL_List::del
_TEXT	SEGMENT
_key$ = 8
_this$ = -4
?moveToFront@SOL_List@@QAEHG@Z PROC NEAR		; SOL_List::moveToFront

; 76   : {

  0018b	55		 push	 ebp
  0018c	8b ec		 mov	 ebp, esp
  0018e	51		 push	 ecx
  0018f	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 77   : 	createElements();

  00192	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00195	e8 00 00 00 00	 call	 ?createElements@SOL_List@@QAEXXZ ; SOL_List::createElements

; 78   : 
; 79   : 	if ( del ( key ) ) {

  0019a	66 8b 45 08	 mov	 ax, WORD PTR _key$[ebp]
  0019e	50		 push	 eax
  0019f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001a2	e8 00 00 00 00	 call	 ?del@SOL_List@@QAEHG@Z	; SOL_List::del
  001a7	85 c0		 test	 eax, eax
  001a9	74 14		 je	 SHORT $L58296

; 80   : 		addToFront ( key );

  001ab	66 8b 4d 08	 mov	 cx, WORD PTR _key$[ebp]
  001af	51		 push	 ecx
  001b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001b3	e8 00 00 00 00	 call	 ?addToFront@SOL_List@@QAEXG@Z ; SOL_List::addToFront

; 81   : 		return 1;

  001b8	b8 01 00 00 00	 mov	 eax, 1
  001bd	eb 02		 jmp	 SHORT $L58295
$L58296:

; 83   : 
; 84   : 	return 0;

  001bf	33 c0		 xor	 eax, eax
$L58295:

; 85   : }

  001c1	8b e5		 mov	 esp, ebp
  001c3	5d		 pop	 ebp
  001c4	c2 04 00	 ret	 4
?moveToFront@SOL_List@@QAEHG@Z ENDP			; SOL_List::moveToFront
_TEXT	ENDS
PUBLIC	?moveToEnd@SOL_List@@QAEHG@Z			; SOL_List::moveToEnd
_TEXT	SEGMENT
_key$ = 8
_this$ = -4
?moveToEnd@SOL_List@@QAEHG@Z PROC NEAR			; SOL_List::moveToEnd

; 89   : {

  001c7	55		 push	 ebp
  001c8	8b ec		 mov	 ebp, esp
  001ca	51		 push	 ecx
  001cb	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 90   : 	createElements();

  001ce	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001d1	e8 00 00 00 00	 call	 ?createElements@SOL_List@@QAEXXZ ; SOL_List::createElements

; 91   : 
; 92   : 	if ( del ( key ) ) {

  001d6	66 8b 45 08	 mov	 ax, WORD PTR _key$[ebp]
  001da	50		 push	 eax
  001db	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001de	e8 00 00 00 00	 call	 ?del@SOL_List@@QAEHG@Z	; SOL_List::del
  001e3	85 c0		 test	 eax, eax
  001e5	74 14		 je	 SHORT $L58301

; 93   : 		addToEnd ( key );

  001e7	66 8b 4d 08	 mov	 cx, WORD PTR _key$[ebp]
  001eb	51		 push	 ecx
  001ec	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001ef	e8 00 00 00 00	 call	 ?addToEnd@SOL_List@@QAEXG@Z ; SOL_List::addToEnd

; 94   : 		return 1;

  001f4	b8 01 00 00 00	 mov	 eax, 1
  001f9	eb 02		 jmp	 SHORT $L58300
$L58301:

; 96   : 
; 97   : 	return 0;

  001fb	33 c0		 xor	 eax, eax
$L58300:

; 98   : }

  001fd	8b e5		 mov	 esp, ebp
  001ff	5d		 pop	 ebp
  00200	c2 04 00	 ret	 4
?moveToEnd@SOL_List@@QAEHG@Z ENDP			; SOL_List::moveToEnd
_TEXT	ENDS
EXTRN	?del@Array@@QAEXH@Z:NEAR			; Array::del
_TEXT	SEGMENT
_key$ = 8
_this$ = -8
_index$ = -4
?del@SOL_List@@QAEHG@Z PROC NEAR			; SOL_List::del

; 102  : {

  00203	55		 push	 ebp
  00204	8b ec		 mov	 ebp, esp
  00206	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00209	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 103  : 	createElements();

  0020c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0020f	e8 00 00 00 00	 call	 ?createElements@SOL_List@@QAEXXZ ; SOL_List::createElements

; 104  : 
; 105  : 	int index = indexOf ( key );

  00214	66 8b 45 08	 mov	 ax, WORD PTR _key$[ebp]
  00218	50		 push	 eax
  00219	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0021c	e8 00 00 00 00	 call	 ?indexOf@SOL_List@@QAEHG@Z ; SOL_List::indexOf
  00221	89 45 fc	 mov	 DWORD PTR _index$[ebp], eax

; 106  : 
; 107  : 	if ( index == -1 ) 

  00224	83 7d fc ff	 cmp	 DWORD PTR _index$[ebp], -1
  00228	75 04		 jne	 SHORT $L58307

; 108  : 		return 0;

  0022a	33 c0		 xor	 eax, eax
  0022c	eb 29		 jmp	 SHORT $L58305
$L58307:

; 109  : 
; 110  : 	size()--;

  0022e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00231	e8 00 00 00 00	 call	 ?size@SOL_List@@QAEAAHXZ ; SOL_List::size
  00236	89 45 f4	 mov	 DWORD PTR -12+[ebp], eax
  00239	8b 4d f4	 mov	 ecx, DWORD PTR -12+[ebp]
  0023c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0023e	83 ea 01	 sub	 edx, 1
  00241	8b 45 f4	 mov	 eax, DWORD PTR -12+[ebp]
  00244	89 10		 mov	 DWORD PTR [eax], edx

; 111  : 
; 112  : 	elements.del ( index );

  00246	8b 4d fc	 mov	 ecx, DWORD PTR _index$[ebp]
  00249	51		 push	 ecx
  0024a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0024d	e8 00 00 00 00	 call	 ?del@Array@@QAEXH@Z	; Array::del

; 113  : 
; 114  : 	return 1;

  00252	b8 01 00 00 00	 mov	 eax, 1
$L58305:

; 115  : }

  00257	8b e5		 mov	 esp, ebp
  00259	5d		 pop	 ebp
  0025a	c2 04 00	 ret	 4
?del@SOL_List@@QAEHG@Z ENDP				; SOL_List::del
_TEXT	ENDS
PUBLIC	?sortByValue@SOL_List@@QAEXH@Z			; SOL_List::sortByValue
EXTRN	?calcAddress@Array@@QAEPAXH@Z:NEAR		; Array::calcAddress
_TEXT	SEGMENT
_descending$ = 8
_this$ = -32
_elementData$ = -4
_i$ = -8
_leastIndex$58318 = -20
_key$58319 = -12
_comparisonElements$58320 = -24
_j$58321 = -16
_comparisonKey$58325 = -28
?sortByValue@SOL_List@@QAEXH@Z PROC NEAR		; SOL_List::sortByValue

; 119  : {

  0025d	55		 push	 ebp
  0025e	8b ec		 mov	 ebp, esp
  00260	83 ec 20	 sub	 esp, 32			; 00000020H
  00263	56		 push	 esi
  00264	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 120  : 	createElements();

  00267	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0026a	e8 00 00 00 00	 call	 ?createElements@SOL_List@@QAEXXZ ; SOL_List::createElements

; 121  : 
; 122  : 	SCIUWord *elementData = (SCIUWord *)elements.calcAddress ( 0 );

  0026f	6a 00		 push	 0
  00271	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00274	e8 00 00 00 00	 call	 ?calcAddress@Array@@QAEPAXH@Z ; Array::calcAddress
  00279	89 45 fc	 mov	 DWORD PTR _elementData$[ebp], eax

; 123  : 
; 124  : 	for ( int i=0; i<size(); i++ ) {

  0027c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00283	eb 09		 jmp	 SHORT $L58315
$L58316:
  00285	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00288	83 c0 01	 add	 eax, 1
  0028b	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L58315:
  0028e	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00291	e8 00 00 00 00	 call	 ?size@SOL_List@@QAEAAHXZ ; SOL_List::size
  00296	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00299	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0029b	0f 8d cb 00 00
	00		 jge	 $L58317

; 125  : 		int leastIndex = i;

  002a1	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  002a4	89 55 ec	 mov	 DWORD PTR _leastIndex$58318[ebp], edx

; 126  : 
; 127  : 		SCIUWord key = *elementData++;

  002a7	8b 45 fc	 mov	 eax, DWORD PTR _elementData$[ebp]
  002aa	66 8b 08	 mov	 cx, WORD PTR [eax]
  002ad	66 89 4d f4	 mov	 WORD PTR _key$58319[ebp], cx
  002b1	8b 55 fc	 mov	 edx, DWORD PTR _elementData$[ebp]
  002b4	83 c2 02	 add	 edx, 2
  002b7	89 55 fc	 mov	 DWORD PTR _elementData$[ebp], edx

; 128  : 		SCIUWord *comparisonElements = elementData;

  002ba	8b 45 fc	 mov	 eax, DWORD PTR _elementData$[ebp]
  002bd	89 45 e8	 mov	 DWORD PTR _comparisonElements$58320[ebp], eax

; 129  : 
; 130  : 		for ( int j=i+1; j<size(); j++ ) {

  002c0	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  002c3	83 c1 01	 add	 ecx, 1
  002c6	89 4d f0	 mov	 DWORD PTR _j$58321[ebp], ecx
  002c9	eb 09		 jmp	 SHORT $L58322
$L58323:
  002cb	8b 55 f0	 mov	 edx, DWORD PTR _j$58321[ebp]
  002ce	83 c2 01	 add	 edx, 1
  002d1	89 55 f0	 mov	 DWORD PTR _j$58321[ebp], edx
$L58322:
  002d4	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  002d7	e8 00 00 00 00	 call	 ?size@SOL_List@@QAEAAHXZ ; SOL_List::size
  002dc	8b 4d f0	 mov	 ecx, DWORD PTR _j$58321[ebp]
  002df	3b 08		 cmp	 ecx, DWORD PTR [eax]
  002e1	7d 5a		 jge	 SHORT $L58324

; 131  : 			SCIUWord comparisonKey = *comparisonElements++;

  002e3	8b 55 e8	 mov	 edx, DWORD PTR _comparisonElements$58320[ebp]
  002e6	66 8b 02	 mov	 ax, WORD PTR [edx]
  002e9	66 89 45 e4	 mov	 WORD PTR _comparisonKey$58325[ebp], ax
  002ed	8b 4d e8	 mov	 ecx, DWORD PTR _comparisonElements$58320[ebp]
  002f0	83 c1 02	 add	 ecx, 2
  002f3	89 4d e8	 mov	 DWORD PTR _comparisonElements$58320[ebp], ecx

; 132  : 
; 133  : 			if ( (!descending && comparisonKey < key) || (descending && key < comparisonKey) ) {

  002f6	83 7d 08 00	 cmp	 DWORD PTR _descending$[ebp], 0
  002fa	75 15		 jne	 SHORT $L58328
  002fc	8b 55 e4	 mov	 edx, DWORD PTR _comparisonKey$58325[ebp]
  002ff	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00305	8b 45 f4	 mov	 eax, DWORD PTR _key$58319[ebp]
  00308	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0030d	3b d0		 cmp	 edx, eax
  0030f	7c 1c		 jl	 SHORT $L58327
$L58328:
  00311	83 7d 08 00	 cmp	 DWORD PTR _descending$[ebp], 0
  00315	74 24		 je	 SHORT $L58326
  00317	8b 4d f4	 mov	 ecx, DWORD PTR _key$58319[ebp]
  0031a	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00320	8b 55 e4	 mov	 edx, DWORD PTR _comparisonKey$58325[ebp]
  00323	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00329	3b ca		 cmp	 ecx, edx
  0032b	7d 0e		 jge	 SHORT $L58326
$L58327:

; 134  : 				key = comparisonKey;

  0032d	66 8b 45 e4	 mov	 ax, WORD PTR _comparisonKey$58325[ebp]
  00331	66 89 45 f4	 mov	 WORD PTR _key$58319[ebp], ax

; 135  : 				leastIndex = j;

  00335	8b 4d f0	 mov	 ecx, DWORD PTR _j$58321[ebp]
  00338	89 4d ec	 mov	 DWORD PTR _leastIndex$58318[ebp], ecx
$L58326:

; 137  : 		}

  0033b	eb 8e		 jmp	 SHORT $L58323
$L58324:

; 138  : 
; 139  : 		// do the swap if we have an out-of-order key
; 140  : 		if ( leastIndex != i ) {

  0033d	8b 55 ec	 mov	 edx, DWORD PTR _leastIndex$58318[ebp]
  00340	3b 55 f8	 cmp	 edx, DWORD PTR _i$[ebp]
  00343	74 22		 je	 SHORT $L58329

; 141  : 			elementData[leastIndex] = elementData[i];

  00345	8b 45 ec	 mov	 eax, DWORD PTR _leastIndex$58318[ebp]
  00348	8b 4d fc	 mov	 ecx, DWORD PTR _elementData$[ebp]
  0034b	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0034e	8b 75 fc	 mov	 esi, DWORD PTR _elementData$[ebp]
  00351	66 8b 14 56	 mov	 dx, WORD PTR [esi+edx*2]
  00355	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 142  : 			elementData[i] = key;

  00359	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0035c	8b 4d fc	 mov	 ecx, DWORD PTR _elementData$[ebp]
  0035f	66 8b 55 f4	 mov	 dx, WORD PTR _key$58319[ebp]
  00363	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
$L58329:

; 144  : 	}

  00367	e9 19 ff ff ff	 jmp	 $L58316
$L58317:

; 145  : }

  0036c	5e		 pop	 esi
  0036d	8b e5		 mov	 esp, ebp
  0036f	5d		 pop	 ebp
  00370	c2 04 00	 ret	 4
?sortByValue@SOL_List@@QAEXH@Z ENDP			; SOL_List::sortByValue
_TEXT	ENDS
PUBLIC	??0ObjectID@@QAE@ABV0@@Z			; ObjectID::ObjectID
PUBLIC	?GetProperty@ObjectID@@QBEFG@Z			; ObjectID::GetProperty
PUBLIC	?sortByProperty@SOL_List@@QAEXHH@Z		; SOL_List::sortByProperty
_TEXT	SEGMENT
_property$ = 8
_descending$ = 12
_this$ = -40
_elementData$ = -4
_i$ = -8
_leastIndex$58341 = -24
_key$58342 = -16
_keyValue$58343 = -12
_comparisonElements$58344 = -28
_j$58345 = -20
_comparisonKey$58349 = -32
_comparisonKeyValue$58350 = -36
?sortByProperty@SOL_List@@QAEXHH@Z PROC NEAR		; SOL_List::sortByProperty

; 150  : {

  00373	55		 push	 ebp
  00374	8b ec		 mov	 ebp, esp
  00376	83 ec 30	 sub	 esp, 48			; 00000030H
  00379	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx

; 151  : 	createElements();

  0037c	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0037f	e8 00 00 00 00	 call	 ?createElements@SOL_List@@QAEXXZ ; SOL_List::createElements

; 152  : 
; 153  : 	ObjectID *elementData = (ObjectID *)elements.calcAddress ( 0 );

  00384	6a 00		 push	 0
  00386	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00389	e8 00 00 00 00	 call	 ?calcAddress@Array@@QAEPAXH@Z ; Array::calcAddress
  0038e	89 45 fc	 mov	 DWORD PTR _elementData$[ebp], eax

; 154  : 
; 155  : 	for ( int i=0; i<size(); i++ ) {

  00391	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00398	eb 09		 jmp	 SHORT $L58338
$L58339:
  0039a	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0039d	83 c0 01	 add	 eax, 1
  003a0	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L58338:
  003a3	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  003a6	e8 00 00 00 00	 call	 ?size@SOL_List@@QAEAAHXZ ; SOL_List::size
  003ab	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  003ae	3b 08		 cmp	 ecx, DWORD PTR [eax]
  003b0	0f 8d f2 00 00
	00		 jge	 $L58340

; 156  : 		int leastIndex = i;

  003b6	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  003b9	89 55 e8	 mov	 DWORD PTR _leastIndex$58341[ebp], edx

; 157  : 
; 158  : 		ObjectID key = *elementData++;

  003bc	8b 45 fc	 mov	 eax, DWORD PTR _elementData$[ebp]
  003bf	89 45 d4	 mov	 DWORD PTR -44+[ebp], eax
  003c2	8b 4d d4	 mov	 ecx, DWORD PTR -44+[ebp]
  003c5	51		 push	 ecx
  003c6	8b 55 fc	 mov	 edx, DWORD PTR _elementData$[ebp]
  003c9	83 c2 02	 add	 edx, 2
  003cc	89 55 fc	 mov	 DWORD PTR _elementData$[ebp], edx
  003cf	8d 4d f0	 lea	 ecx, DWORD PTR _key$58342[ebp]
  003d2	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID

; 159  : 		Property keyValue = key.GetProperty ( property );

  003d7	66 8b 45 08	 mov	 ax, WORD PTR _property$[ebp]
  003db	50		 push	 eax
  003dc	8d 4d f0	 lea	 ecx, DWORD PTR _key$58342[ebp]
  003df	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  003e4	66 89 45 f4	 mov	 WORD PTR _keyValue$58343[ebp], ax

; 160  : 
; 161  : 		ObjectID *comparisonElements = elementData;

  003e8	8b 4d fc	 mov	 ecx, DWORD PTR _elementData$[ebp]
  003eb	89 4d e4	 mov	 DWORD PTR _comparisonElements$58344[ebp], ecx

; 162  : 
; 163  : 		for ( int j=i+1; j<size(); j++ ) {

  003ee	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  003f1	83 c2 01	 add	 edx, 1
  003f4	89 55 ec	 mov	 DWORD PTR _j$58345[ebp], edx
  003f7	eb 09		 jmp	 SHORT $L58346
$L58347:
  003f9	8b 45 ec	 mov	 eax, DWORD PTR _j$58345[ebp]
  003fc	83 c0 01	 add	 eax, 1
  003ff	89 45 ec	 mov	 DWORD PTR _j$58345[ebp], eax
$L58346:
  00402	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00405	e8 00 00 00 00	 call	 ?size@SOL_List@@QAEAAHXZ ; SOL_List::size
  0040a	8b 4d ec	 mov	 ecx, DWORD PTR _j$58345[ebp]
  0040d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0040f	7d 68		 jge	 SHORT $L58348

; 164  : 			ObjectID comparisonKey = *comparisonElements++;

  00411	8b 55 e4	 mov	 edx, DWORD PTR _comparisonElements$58344[ebp]
  00414	89 55 d0	 mov	 DWORD PTR -48+[ebp], edx
  00417	8b 45 d0	 mov	 eax, DWORD PTR -48+[ebp]
  0041a	50		 push	 eax
  0041b	8b 4d e4	 mov	 ecx, DWORD PTR _comparisonElements$58344[ebp]
  0041e	83 c1 02	 add	 ecx, 2
  00421	89 4d e4	 mov	 DWORD PTR _comparisonElements$58344[ebp], ecx
  00424	8d 4d e0	 lea	 ecx, DWORD PTR _comparisonKey$58349[ebp]
  00427	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID

; 165  : 			Property comparisonKeyValue = comparisonKey.GetProperty ( property );

  0042c	66 8b 55 08	 mov	 dx, WORD PTR _property$[ebp]
  00430	52		 push	 edx
  00431	8d 4d e0	 lea	 ecx, DWORD PTR _comparisonKey$58349[ebp]
  00434	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  00439	66 89 45 dc	 mov	 WORD PTR _comparisonKeyValue$58350[ebp], ax

; 166  : 
; 167  : 			if ( (!descending && comparisonKeyValue < keyValue) || (descending && keyValue < comparisonKeyValue) ) {

  0043d	83 7d 0c 00	 cmp	 DWORD PTR _descending$[ebp], 0
  00441	75 0c		 jne	 SHORT $L58353
  00443	0f bf 45 dc	 movsx	 eax, WORD PTR _comparisonKeyValue$58350[ebp]
  00447	0f bf 4d f4	 movsx	 ecx, WORD PTR _keyValue$58343[ebp]
  0044b	3b c1		 cmp	 eax, ecx
  0044d	7c 12		 jl	 SHORT $L58352
$L58353:
  0044f	83 7d 0c 00	 cmp	 DWORD PTR _descending$[ebp], 0
  00453	74 22		 je	 SHORT $L58351
  00455	0f bf 55 f4	 movsx	 edx, WORD PTR _keyValue$58343[ebp]
  00459	0f bf 45 dc	 movsx	 eax, WORD PTR _comparisonKeyValue$58350[ebp]
  0045d	3b d0		 cmp	 edx, eax
  0045f	7d 16		 jge	 SHORT $L58351
$L58352:

; 168  : 				keyValue = comparisonKeyValue;

  00461	66 8b 4d dc	 mov	 cx, WORD PTR _comparisonKeyValue$58350[ebp]
  00465	66 89 4d f4	 mov	 WORD PTR _keyValue$58343[ebp], cx

; 169  : 				key = comparisonKey;

  00469	66 8b 55 e0	 mov	 dx, WORD PTR _comparisonKey$58349[ebp]
  0046d	66 89 55 f0	 mov	 WORD PTR _key$58342[ebp], dx

; 170  : 
; 171  : 				leastIndex = j;

  00471	8b 45 ec	 mov	 eax, DWORD PTR _j$58345[ebp]
  00474	89 45 e8	 mov	 DWORD PTR _leastIndex$58341[ebp], eax
$L58351:

; 173  : 		}

  00477	eb 80		 jmp	 SHORT $L58347
$L58348:

; 174  : 
; 175  : 		// do the swap if we have an out-of-order key
; 176  : 		if ( leastIndex != i ) {

  00479	8b 4d e8	 mov	 ecx, DWORD PTR _leastIndex$58341[ebp]
  0047c	3b 4d f8	 cmp	 ecx, DWORD PTR _i$[ebp]
  0047f	74 22		 je	 SHORT $L58354

; 177  : 			elementData[leastIndex] = elementData[i];

  00481	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00484	8b 45 fc	 mov	 eax, DWORD PTR _elementData$[ebp]
  00487	66 8b 0c 50	 mov	 cx, WORD PTR [eax+edx*2]
  0048b	8b 55 e8	 mov	 edx, DWORD PTR _leastIndex$58341[ebp]
  0048e	8b 45 fc	 mov	 eax, DWORD PTR _elementData$[ebp]
  00491	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 178  : 			elementData[i] = key;

  00495	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00498	8b 55 fc	 mov	 edx, DWORD PTR _elementData$[ebp]
  0049b	66 8b 45 f0	 mov	 ax, WORD PTR _key$58342[ebp]
  0049f	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
$L58354:

; 180  : 	}

  004a3	e9 f2 fe ff ff	 jmp	 $L58339
$L58340:

; 181  : }

  004a8	8b e5		 mov	 esp, ebp
  004aa	5d		 pop	 ebp
  004ab	c2 08 00	 ret	 8
?sortByProperty@SOL_List@@QAEXHH@Z ENDP			; SOL_List::sortByProperty
_TEXT	ENDS
PUBLIC	??0FakeObjectID@@QAE@ABVMemID@@@Z		; FakeObjectID::FakeObjectID
;	COMDAT ??0ObjectID@@QAE@ABV0@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0ObjectID@@QAE@ABV0@@Z PROC NEAR			; ObjectID::ObjectID, COMDAT

; 229  : 	ObjectID(const ObjectID& id) : FakeObjectID((MemID&) id) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0FakeObjectID@@QAE@ABVMemID@@@Z ; FakeObjectID::FakeObjectID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0ObjectID@@QAE@ABV0@@Z ENDP				; ObjectID::ObjectID
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0FakeObjectID@@QAE@ABVMemID@@@Z PROC NEAR		; FakeObjectID::FakeObjectID, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0FakeObjectID@@QAE@ABVMemID@@@Z ENDP			; FakeObjectID::FakeObjectID
_TEXT	ENDS
PUBLIC	?GetProperty@Object@@QAEFG@Z			; Object::GetProperty
PUBLIC	??CFakeObjectID@@QBEPAUObject@@XZ		; FakeObjectID::operator->
PUBLIC	?AssureValid@ObjectID@@QBEXXZ			; ObjectID::AssureValid
;	COMDAT ?GetProperty@ObjectID@@QBEFG@Z
_TEXT	SEGMENT
_selector$ = 8
_this$ = -4
?GetProperty@ObjectID@@QBEFG@Z PROC NEAR		; ObjectID::GetProperty, COMDAT

; 290  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 291  : 		//	get a property given a selector
; 292  : 		AssureValid();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?AssureValid@ObjectID@@QBEXXZ ; ObjectID::AssureValid

; 293  : 		return (*this)->GetProperty(selector);

  0000f	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  00013	50		 push	 eax
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  0001c	8b c8		 mov	 ecx, eax
  0001e	e8 00 00 00 00	 call	 ?GetProperty@Object@@QAEFG@Z ; Object::GetProperty

; 294  : 	}

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?GetProperty@ObjectID@@QBEFG@Z ENDP			; ObjectID::GetProperty
_TEXT	ENDS
PUBLIC	?GetPropAddrCheck@Object@@QAEPAFG@Z		; Object::GetPropAddrCheck
;	COMDAT ?GetProperty@Object@@QAEFG@Z
_TEXT	SEGMENT
_selector$ = 8
_this$ = -4
?GetProperty@Object@@QAEFG@Z PROC NEAR			; Object::GetProperty, COMDAT

; 170  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 171  : 		//	get a property given a selector
; 172  : 		return *GetPropAddrCheck(selector);

  00007	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?GetPropAddrCheck@Object@@QAEPAFG@Z ; Object::GetPropAddrCheck
  00014	66 8b 00	 mov	 ax, WORD PTR [eax]

; 173  : 	}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?GetProperty@Object@@QAEFG@Z ENDP			; Object::GetProperty
_TEXT	ENDS
PUBLIC	?GetPropAddr@Object@@QAEPAFG@Z			; Object::GetPropAddr
EXTRN	?Fatal@MsgMgr@@QAAXHZZ:NEAR			; MsgMgr::Fatal
EXTRN	?msgMgr@@3PAVMsgMgr@@A:DWORD			; msgMgr
;	COMDAT ?GetPropAddrCheck@Object@@QAEPAFG@Z
_TEXT	SEGMENT
_selector$ = 8
_this$ = -8
_property$ = -4
?GetPropAddrCheck@Object@@QAEPAFG@Z PROC NEAR		; Object::GetPropAddrCheck, COMDAT

; 153  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 154  : 		//	get a property's address, checking for valid property
; 155  : 		Property* property = GetPropAddr(selector);

  00009	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?GetPropAddr@Object@@QAEPAFG@Z ; Object::GetPropAddr
  00016	89 45 fc	 mov	 DWORD PTR _property$[ebp], eax

; 156  : 		if (!property)

  00019	83 7d fc 00	 cmp	 DWORD PTR _property$[ebp], 0
  0001d	75 1b		 jne	 SHORT $L57879

; 157  : 			msgMgr->Fatal(Msg_InvalidProperty, selector);

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _selector$[ebp]
  00022	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00028	51		 push	 ecx
  00029	6a 29		 push	 41			; 00000029H
  0002b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXHZZ	; MsgMgr::Fatal
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
$L57879:

; 158  : 		return property;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _property$[ebp]

; 159  : 	}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
?GetPropAddrCheck@Object@@QAEPAFG@Z ENDP		; Object::GetPropAddrCheck
_TEXT	ENDS
PUBLIC	?selectorDict@Object@@QAEPAVSelectorDict@@XZ	; Object::selectorDict
PUBLIC	??AObject@@QAEAAFH@Z				; Object::operator[]
EXTRN	?get@SelectorDict@@QAEHG@Z:NEAR			; SelectorDict::get
;	COMDAT ?GetPropAddr@Object@@QAEPAFG@Z
_TEXT	SEGMENT
_selector$ = 8
_this$ = -8
_index$ = -4
?GetPropAddr@Object@@QAEPAFG@Z PROC NEAR		; Object::GetPropAddr, COMDAT

; 127  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 128  : 		int index = selectorDict()->get ( selector );

  00009	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?selectorDict@Object@@QAEPAVSelectorDict@@XZ ; Object::selectorDict
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 ?get@SelectorDict@@QAEHG@Z ; SelectorDict::get
  0001d	89 45 fc	 mov	 DWORD PTR _index$[ebp], eax

; 129  : 
; 130  : 		if ( index != -1 && !selectorDict()->script )

  00020	83 7d fc ff	 cmp	 DWORD PTR _index$[ebp], -1
  00024	74 2b		 je	 SHORT $L57870
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?selectorDict@Object@@QAEPAVSelectorDict@@XZ ; Object::selectorDict
  0002e	33 c9		 xor	 ecx, ecx
  00030	66 8b 48 16	 mov	 cx, WORD PTR [eax+22]
  00034	85 c9		 test	 ecx, ecx
  00036	75 19		 jne	 SHORT $L57870

; 131  : 			return &(*this)[selectorDict()->offset]; 

  00038	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?selectorDict@Object@@QAEPAVSelectorDict@@XZ ; Object::selectorDict
  00040	33 d2		 xor	 edx, edx
  00042	66 8b 50 14	 mov	 dx, WORD PTR [eax+20]
  00046	52		 push	 edx
  00047	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ??AObject@@QAEAAFH@Z	; Object::operator[]
  0004f	eb 02		 jmp	 SHORT $L57868
$L57870:

; 132  : 
; 133  : 		return 0;

  00051	33 c0		 xor	 eax, eax
$L57868:

; 134  : 	}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
?GetPropAddr@Object@@QAEPAFG@Z ENDP			; Object::GetPropAddr
_TEXT	ENDS
;	COMDAT ?selectorDict@Object@@QAEPAVSelectorDict@@XZ
_TEXT	SEGMENT
_this$ = -4
?selectorDict@Object@@QAEPAVSelectorDict@@XZ PROC NEAR	; Object::selectorDict, COMDAT

; 102  : 	SelectorDict *selectorDict ( void ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 103  : 		return _selectorDict;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 104  : 	};

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?selectorDict@Object@@QAEPAVSelectorDict@@XZ ENDP	; Object::selectorDict
_TEXT	ENDS
;	COMDAT ??AObject@@QAEAAFH@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
??AObject@@QAEAAFH@Z PROC NEAR				; Object::operator[], COMDAT

; 117  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 118  : 		//	get a reference to a property given the number of the property
; 119  : 		return ((Property*) this)[index];

  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]

; 120  : 	}

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??AObject@@QAEAAFH@Z ENDP				; Object::operator[]
_TEXT	ENDS
;	COMDAT ??CFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT
_this$ = -4
??CFakeObjectID@@QBEPAUObject@@XZ PROC NEAR		; FakeObjectID::operator->, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??CFakeObjectID@@QBEPAUObject@@XZ ENDP			; FakeObjectID::operator->
_TEXT	ENDS
PUBLIC	??BMemID@@QBEGXZ				; MemID::operator unsigned short
PUBLIC	?IsObject@ObjectID@@QBEHXZ			; ObjectID::IsObject
;	COMDAT ?AssureValid@ObjectID@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4
?AssureValid@ObjectID@@QBEXXZ PROC NEAR			; ObjectID::AssureValid, COMDAT

; 238  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 239  : 		if (!IsObject())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?IsObject@ObjectID@@QBEHXZ ; ObjectID::IsObject
  0000f	85 c0		 test	 eax, eax
  00011	75 1e		 jne	 SHORT $L58038

; 240  : 			msgMgr->Fatal(Msg_NotObject, (int) *this);

  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  0001b	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00020	50		 push	 eax
  00021	6a 2f		 push	 47			; 0000002fH
  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXHZZ	; MsgMgr::Fatal
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L58038:

; 241  : 	}

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?AssureValid@ObjectID@@QBEXXZ ENDP			; ObjectID::AssureValid
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4
??BMemID@@QBEGXZ PROC NEAR				; MemID::operator unsigned short, COMDAT

; 93   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   : 		return handle;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 00	 mov	 ax, WORD PTR [eax]

; 95   : 	}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??BMemID@@QBEGXZ ENDP					; MemID::operator unsigned short
_TEXT	ENDS
PUBLIC	?IsValid@MemID@@QBEHXZ				; MemID::IsValid
EXTRN	?GetMemType@MemID@@QBE?AW4MemType@@XZ:NEAR	; MemID::GetMemType
;	COMDAT ?IsObject@ObjectID@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsObject@ObjectID@@QBEHXZ PROC NEAR			; ObjectID::IsObject, COMDAT

; 247  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 248  : 		return IsValid() && GetMemType() == MemObject;

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  00011	85 c0		 test	 eax, eax
  00013	74 16		 je	 SHORT $L58772
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  0001d	83 f8 34	 cmp	 eax, 52			; 00000034H
  00020	75 09		 jne	 SHORT $L58772
  00022	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR -8+[ebp], 1
  00029	eb 07		 jmp	 SHORT $L58773
$L58772:
  0002b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], 0
$L58773:
  00032	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]

; 249  : 	}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?IsObject@ObjectID@@QBEHXZ ENDP				; ObjectID::IsObject
_TEXT	ENDS
PUBLIC	?IsValid@MemoryMgr@@QAEHG@Z			; MemoryMgr::IsValid
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsValid@MemID@@QBEHXZ PROC NEAR			; MemID::IsValid, COMDAT

; 62   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 63   : 		return memMgr->IsValid(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?IsValid@MemoryMgr@@QAEHG@Z ; MemoryMgr::IsValid

; 64   : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?IsValid@MemID@@QBEHXZ ENDP				; MemID::IsValid
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -8
_tempID$ = -4
?IsValid@MemoryMgr@@QAEHG@Z PROC NEAR			; MemoryMgr::IsValid, COMDAT

; 475  : 	inline Bool MemoryMgr::IsValid(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 476  : 		unsigned short tempID = (unsigned short)theID;

  00009	66 8b 45 08	 mov	 ax, WORD PTR _theID$[ebp]
  0000d	66 89 45 fc	 mov	 WORD PTR _tempID$[ebp], ax

; 477  : 
; 478  : 		return(
; 479  : 				(tempID)															&&
; 480  : 				(tempID < maxDescriptors)									&&
; 481  : 				(desc[tempID].memInfo.bits.freeDescriptor == False)	&&
; 482  : 				(desc[tempID].memInfo.bits.freeMemory == False)
; 483  : 				);

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _tempID$[ebp]
  00014	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 58		 je	 SHORT $L58776
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _tempID$[ebp]
  00021	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  0002d	73 47		 jae	 SHORT $L58776
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _tempID$[ebp]
  00032	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00038	c1 e1 04	 shl	 ecx, 4
  0003b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00041	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00044	c1 e1 0e	 shl	 ecx, 14			; 0000000eH
  00047	c1 f9 1f	 sar	 ecx, 31			; 0000001fH
  0004a	85 c9		 test	 ecx, ecx
  0004c	75 28		 jne	 SHORT $L58776
  0004e	8b 55 fc	 mov	 edx, DWORD PTR _tempID$[ebp]
  00051	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00057	c1 e2 04	 shl	 edx, 4
  0005a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00060	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00063	c1 e2 14	 shl	 edx, 20			; 00000014H
  00066	c1 fa 1f	 sar	 edx, 31			; 0000001fH
  00069	85 d2		 test	 edx, edx
  0006b	75 09		 jne	 SHORT $L58776
  0006d	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR -12+[ebp], 1
  00074	eb 07		 jmp	 SHORT $L58777
$L58776:
  00076	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR -12+[ebp], 0
$L58777:
  0007d	8b 45 f4	 mov	 eax, DWORD PTR -12+[ebp]

; 484  : 	}

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 04 00	 ret	 4
?IsValid@MemoryMgr@@QAEHG@Z ENDP			; MemoryMgr::IsValid
_TEXT	ENDS
_TEXT	SEGMENT
_key$ = 8
_this$ = -12
_elementData$ = -4
_i$ = -8
?indexOf@SOL_List@@QAEHG@Z PROC NEAR			; SOL_List::indexOf

; 185  : {

  004ae	55		 push	 ebp
  004af	8b ec		 mov	 ebp, esp
  004b1	83 ec 0c	 sub	 esp, 12			; 0000000cH
  004b4	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 186  : 	createElements();

  004b7	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  004ba	e8 00 00 00 00	 call	 ?createElements@SOL_List@@QAEXXZ ; SOL_List::createElements

; 187  : 
; 188  : 	SCIUWord *elementData = (SCIUWord *)elements.calcAddress ( 0 );

  004bf	6a 00		 push	 0
  004c1	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  004c4	e8 00 00 00 00	 call	 ?calcAddress@Array@@QAEPAXH@Z ; Array::calcAddress
  004c9	89 45 fc	 mov	 DWORD PTR _elementData$[ebp], eax

; 189  : 
; 190  : 	for ( int i=0; i<size(); i++ ) 

  004cc	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  004d3	eb 09		 jmp	 SHORT $L58362
$L58363:
  004d5	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  004d8	83 c0 01	 add	 eax, 1
  004db	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L58362:
  004de	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  004e1	e8 00 00 00 00	 call	 ?size@SOL_List@@QAEAAHXZ ; SOL_List::size
  004e6	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  004e9	3b 08		 cmp	 ecx, DWORD PTR [eax]
  004eb	7d 25		 jge	 SHORT $L58364

; 191  : 		if ( *elementData++ == key )

  004ed	8b 55 fc	 mov	 edx, DWORD PTR _elementData$[ebp]
  004f0	33 c0		 xor	 eax, eax
  004f2	66 8b 02	 mov	 ax, WORD PTR [edx]
  004f5	8b 4d 08	 mov	 ecx, DWORD PTR _key$[ebp]
  004f8	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  004fe	8b 55 fc	 mov	 edx, DWORD PTR _elementData$[ebp]
  00501	83 c2 02	 add	 edx, 2
  00504	89 55 fc	 mov	 DWORD PTR _elementData$[ebp], edx
  00507	3b c1		 cmp	 eax, ecx
  00509	75 05		 jne	 SHORT $L58365

; 192  : 			return i;

  0050b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0050e	eb 05		 jmp	 SHORT $L58358
$L58365:

; 193  : 
; 194  : 	return -1;

  00510	eb c3		 jmp	 SHORT $L58363
$L58364:
  00512	83 c8 ff	 or	 eax, -1
$L58358:

; 195  : }

  00515	8b e5		 mov	 esp, ebp
  00517	5d		 pop	 ebp
  00518	c2 04 00	 ret	 4
?indexOf@SOL_List@@QAEHG@Z ENDP				; SOL_List::indexOf
_TEXT	ENDS
PUBLIC	?lock@Array@@QAEXXZ				; Array::lock
PUBLIC	?lock@SOL_List@@QAEXXZ				; SOL_List::lock
_TEXT	SEGMENT
_this$ = -8
$T58780 = -4
?lock@SOL_List@@QAEXXZ PROC NEAR			; SOL_List::lock

; 199  : {

  0051b	55		 push	 ebp
  0051c	8b ec		 mov	 ebp, esp
  0051e	83 ec 08	 sub	 esp, 8
  00521	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 200  : 	if ( elements.dataID() )

  00524	8d 45 fc	 lea	 eax, DWORD PTR $T58780[ebp]
  00527	50		 push	 eax
  00528	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0052b	e8 00 00 00 00	 call	 ?dataID@Array@@QAE?AVMemID@@XZ ; Array::dataID
  00530	8b c8		 mov	 ecx, eax
  00532	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00537	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0053c	85 c0		 test	 eax, eax
  0053e	74 08		 je	 SHORT $L58371

; 201  : 		elements.lock();

  00540	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00543	e8 00 00 00 00	 call	 ?lock@Array@@QAEXXZ	; Array::lock
$L58371:

; 202  : }

  00548	8b e5		 mov	 esp, ebp
  0054a	5d		 pop	 ebp
  0054b	c3		 ret	 0
?lock@SOL_List@@QAEXXZ ENDP				; SOL_List::lock
_TEXT	ENDS
EXTRN	?Lock@MemID@@QBEPAXXZ:NEAR			; MemID::Lock
;	COMDAT ?lock@Array@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?lock@Array@@QAEXXZ PROC NEAR				; Array::lock, COMDAT

; 101  : 	void lock ( void ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 102  : 		_dataID.Lock();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Lock@MemID@@QBEPAXXZ	; MemID::Lock

; 103  : 	}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?lock@Array@@QAEXXZ ENDP				; Array::lock
_TEXT	ENDS
PUBLIC	?unlock@Array@@QAEXXZ				; Array::unlock
PUBLIC	?unlock@SOL_List@@QAEXXZ			; SOL_List::unlock
_TEXT	SEGMENT
_this$ = -8
$T58783 = -4
?unlock@SOL_List@@QAEXXZ PROC NEAR			; SOL_List::unlock

; 206  : {

  0054c	55		 push	 ebp
  0054d	8b ec		 mov	 ebp, esp
  0054f	83 ec 08	 sub	 esp, 8
  00552	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 	if ( elements.dataID() )

  00555	8d 45 fc	 lea	 eax, DWORD PTR $T58783[ebp]
  00558	50		 push	 eax
  00559	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0055c	e8 00 00 00 00	 call	 ?dataID@Array@@QAE?AVMemID@@XZ ; Array::dataID
  00561	8b c8		 mov	 ecx, eax
  00563	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00568	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0056d	85 c0		 test	 eax, eax
  0056f	74 08		 je	 SHORT $L58377

; 208  : 		elements.unlock();

  00571	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00574	e8 00 00 00 00	 call	 ?unlock@Array@@QAEXXZ	; Array::unlock
$L58377:

; 209  : }

  00579	8b e5		 mov	 esp, ebp
  0057b	5d		 pop	 ebp
  0057c	c3		 ret	 0
?unlock@SOL_List@@QAEXXZ ENDP				; SOL_List::unlock
_TEXT	ENDS
EXTRN	?Unlock@MemID@@QBEPAXXZ:NEAR			; MemID::Unlock
;	COMDAT ?unlock@Array@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?unlock@Array@@QAEXXZ PROC NEAR				; Array::unlock, COMDAT

; 106  : 	void unlock ( void ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 107  : 		_dataID.Unlock();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Unlock@MemID@@QBEPAXXZ	; MemID::Unlock

; 108  : 	}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?unlock@Array@@QAEXXZ ENDP				; Array::unlock
_TEXT	ENDS
PUBLIC	?Free@MemID@@QAEXXZ				; MemID::Free
PUBLIC	?KList@@YAXPAF@Z				; KList
PUBLIC	??0ObjectID@@QAE@XZ				; ObjectID::ObjectID
PUBLIC	??0ObjectID@@QAE@G@Z				; ObjectID::ObjectID
PUBLIC	??DFakeSOL_ListID@@QBEPAVSOL_List@@XZ		; FakeSOL_ListID::operator*
PUBLIC	??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ		; FakeSOL_ListID::operator->
PUBLIC	??0SOL_ListID@@QAE@XZ				; SOL_ListID::SOL_ListID
PUBLIC	??0SOL_ListID@@QAE@G@Z				; SOL_ListID::SOL_ListID
PUBLIC	?Get@SOL_ListID@@QAEXXZ				; SOL_ListID::Get
PUBLIC	??0SOL_ListID@@QAE@ABU0@@Z			; SOL_ListID::SOL_ListID
EXTRN	?Fatal@MsgMgr@@QAAXPADZZ:NEAR			; MsgMgr::Fatal
EXTRN	?resize@Array@@QAEXH@Z:NEAR			; Array::resize
EXTRN	?pmQuickMessage@@YAXIIPAX@Z:NEAR		; pmQuickMessage
EXTRN	?pmPushMany@@YAXGIPAF@Z:NEAR			; pmPushMany
EXTRN	?pm@@3VPMachine@@A:BYTE				; pm
_DATA	SEGMENT
$SG58414 DB	'Unable to create SOL_ListID in (KList ListNew) kernel ca'
	DB	'll', 00H
	ORG $+1
$SG58417 DB	'list->elements.dataID() is not set after createElements('
	DB	')', 00H
	ORG $+2
$SG58428 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\List'
	DB	'.cpp', 00H
	ORG $+3
$SG58429 DB	'%s(%d): list handle 0x%x is invalid', 00H
$SG58432 DB	'KList: NewNode call is no longer supported.', 00H
$SG58434 DB	'KList: FirstNode call is no longer supported.', 00H
	ORG $+2
$SG58436 DB	'KList: LastNode call is no longer supported.', 00H
	ORG $+3
$SG58443 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\List'
	DB	'.cpp', 00H
	ORG $+3
$SG58444 DB	'%s(%d): list handle 0x%x is invalid', 00H
$SG58447 DB	'KList: NextNode call is no longer supported.', 00H
	ORG $+3
$SG58449 DB	'KList: PrevNode call is no longer supported.', 00H
	ORG $+3
$SG58451 DB	'KList: NodeValue call is no longer supported.', 00H
	ORG $+2
$SG58458 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\List'
	DB	'.cpp', 00H
	ORG $+3
$SG58459 DB	'%s(%d): list handle 0x%x is invalid', 00H
$SG58466 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\List'
	DB	'.cpp', 00H
	ORG $+3
$SG58467 DB	'%s(%d): list handle 0x%x is invalid', 00H
$SG58474 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\List'
	DB	'.cpp', 00H
	ORG $+3
$SG58475 DB	'%s(%d): list handle 0x%x is invalid', 00H
$SG58482 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\List'
	DB	'.cpp', 00H
	ORG $+3
$SG58483 DB	'%s(%d): list handle 0x%x is invalid', 00H
$SG58490 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\List'
	DB	'.cpp', 00H
	ORG $+3
$SG58491 DB	'%s(%d): list handle 0x%x is invalid', 00H
$SG58498 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\List'
	DB	'.cpp', 00H
	ORG $+3
$SG58499 DB	'%s(%d): list handle 0x%x is invalid', 00H
$SG58501 DB	'KList: FindKey call is no longer supported.', 00H
$SG58508 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\List'
	DB	'.cpp', 00H
	ORG $+3
$SG58509 DB	'%s(%d): list handle 0x%x is invalid', 00H
$SG58516 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\List'
	DB	'.cpp', 00H
	ORG $+3
$SG58517 DB	'%s(%d): list handle 0x%x is invalid', 00H
$SG58524 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\List'
	DB	'.cpp', 00H
	ORG $+3
$SG58525 DB	'%s(%d): list handle 0x%x is invalid', 00H
$SG58534 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\List'
	DB	'.cpp', 00H
	ORG $+3
$SG58535 DB	'%s(%d): list handle 0x%x is invalid', 00H
$SG58555 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\List'
	DB	'.cpp', 00H
	ORG $+3
$SG58556 DB	'%s(%d): list handle 0x%x is invalid', 00H
$SG58565 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\List'
	DB	'.cpp', 00H
	ORG $+3
$SG58566 DB	'%s(%d): list handle 0x%x is invalid', 00H
$SG58585 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\List'
	DB	'.cpp', 00H
	ORG $+3
$SG58586 DB	'%s(%d): list handle 0x%x is invalid', 00H
$SG58594 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\List'
	DB	'.cpp', 00H
	ORG $+3
$SG58595 DB	'%s(%d): list handle 0x%x is invalid', 00H
$SG58614 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\List'
	DB	'.cpp', 00H
	ORG $+3
$SG58615 DB	'%s(%d): list handle 0x%x is invalid', 00H
$SG58623 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\List'
	DB	'.cpp', 00H
	ORG $+3
$SG58624 DB	'%s(%d): list handle 0x%x is invalid', 00H
$SG58633 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\List'
	DB	'.cpp', 00H
	ORG $+3
$SG58634 DB	'%s(%d): list handle 0x%x is invalid', 00H
_DATA	ENDS
_TEXT	SEGMENT
_args$ = 8
_list$58411 = -4
_list$58423 = -8
_list$58438 = -12
_list$58453 = -16
_list$58461 = -20
_list$58469 = -24
_list$58477 = -28
_list$58485 = -32
_list$58493 = -36
_list$58503 = -40
_list$58511 = -44
_list$58519 = -48
_list$58527 = -60
_saveObject$58536 = -56
_obj$58537 = -68
_listPtr$58538 = -52
_i$58539 = -64
_nArgs$58547 = -72
_nArgChars$58548 = -76
_list$58560 = -84
_saveObject$58567 = -80
_obj$58568 = -92
_i$58569 = -88
_nArgs$58577 = -96
_nArgChars$58578 = -100
_list$58589 = -108
_saveObject$58596 = -104
_obj$58597 = -116
_i$58598 = -112
_nArgs$58606 = -120
_nArgChars$58607 = -124
_list$58618 = -128
_list$58628 = -132
$T58786 = -136
$T58787 = -140
$T58788 = -144
$T58789 = -148
$T58790 = -152
$T58791 = -156
?KList@@YAXPAF@Z PROC NEAR				; KList

; 215  : {

  0057d	55		 push	 ebp
  0057e	8b ec		 mov	 ebp, esp
  00580	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H

; 216  : 	enum {
; 217  : 		ListNew,
; 218  : 		ListDispose,
; 219  : 		ListNewNode,
; 220  : 		ListFirstNode,
; 221  : 		ListLastNode,
; 222  : 		ListEmpty,
; 223  : 		ListNextNode,
; 224  : 		ListPrevNode,
; 225  : 		ListNodeValue,
; 226  : 		ListAddAfter,
; 227  : 		ListAddToFront,
; 228  : 		ListAddToEnd,
; 229  : 		ListAddBefore,
; 230  : 		ListMoveToFront,
; 231  : 		ListMoveToEnd,
; 232  : 		ListFindKey,
; 233  : 		ListDeleteKey,
; 234  : 		ListAt,
; 235  : 		ListIndexOf,
; 236  : 		ListEachElementDo,
; 237  : 		ListFirstTrue,
; 238  : 		ListAllTrue,
; 239  : 		ListSort,
; 240  : 		ListSize
; 241  : 	};
; 242  : 
; 243  : 	switch (arg(1)) {

  00586	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00589	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  0058d	89 8d 60 ff ff
	ff		 mov	 DWORD PTR -160+[ebp], ecx
  00593	83 bd 60 ff ff
	ff 17		 cmp	 DWORD PTR -160+[ebp], 23 ; 00000017H
  0059a	0f 87 38 0f 00
	00		 ja	 $L58407
  005a0	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR -160+[ebp]
  005a6	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L58796[edx*4]
$L58410:

; 245  : 			SOL_ListID list;

  005ad	8d 4d fc	 lea	 ecx, DWORD PTR _list$58411[ebp]
  005b0	e8 00 00 00 00	 call	 ??0SOL_ListID@@QAE@XZ	; SOL_ListID::SOL_ListID

; 246  : 			list.Get();

  005b5	8d 4d fc	 lea	 ecx, DWORD PTR _list$58411[ebp]
  005b8	e8 00 00 00 00	 call	 ?Get@SOL_ListID@@QAEXXZ	; SOL_ListID::Get

; 247  : 
; 248  : 			if ( !(SOL_Handle)list )

  005bd	8d 4d fc	 lea	 ecx, DWORD PTR _list$58411[ebp]
  005c0	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  005c5	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  005ca	85 c0		 test	 eax, eax
  005cc	75 13		 jne	 SHORT $L58413

; 249  : 				msgMgr->Fatal ( "Unable to create SOL_ListID in (KList ListNew) kernel call" );

  005ce	68 00 00 00 00	 push	 OFFSET FLAT:$SG58414
  005d3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  005d8	50		 push	 eax
  005d9	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  005de	83 c4 08	 add	 esp, 8
$L58413:

; 250  : 
; 251  : 			list->createElements();

  005e1	8d 4d fc	 lea	 ecx, DWORD PTR _list$58411[ebp]
  005e4	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  005e9	8b c8		 mov	 ecx, eax
  005eb	e8 00 00 00 00	 call	 ?createElements@SOL_List@@QAEXXZ ; SOL_List::createElements

; 252  : 
; 253  : 			if ( !list->elements.dataID() )

  005f0	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T58786[ebp]
  005f6	51		 push	 ecx
  005f7	8d 4d fc	 lea	 ecx, DWORD PTR _list$58411[ebp]
  005fa	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  005ff	8b c8		 mov	 ecx, eax
  00601	e8 00 00 00 00	 call	 ?dataID@Array@@QAE?AVMemID@@XZ ; Array::dataID
  00606	8b c8		 mov	 ecx, eax
  00608	e8 00 00 00 00	 call	 ??7MemID@@QBEHXZ	; MemID::operator!
  0060d	85 c0		 test	 eax, eax
  0060f	74 14		 je	 SHORT $L58416

; 254  : 				msgMgr->Fatal ( "list->elements.dataID() is not set after createElements()" );

  00611	68 00 00 00 00	 push	 OFFSET FLAT:$SG58417
  00616	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  0061c	52		 push	 edx
  0061d	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00622	83 c4 08	 add	 esp, 8
$L58416:

; 255  : 
; 256  : 			if ( argCount > 1 ) {

  00625	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00628	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0062b	83 f9 01	 cmp	 ecx, 1
  0062e	7e 1c		 jle	 SHORT $L58418

; 257  : 				list->elements.resize ( arg(2) + 1 );

  00630	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00633	0f bf 42 04	 movsx	 eax, WORD PTR [edx+4]
  00637	83 c0 01	 add	 eax, 1
  0063a	50		 push	 eax
  0063b	8d 4d fc	 lea	 ecx, DWORD PTR _list$58411[ebp]
  0063e	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  00643	8b c8		 mov	 ecx, eax
  00645	e8 00 00 00 00	 call	 ?resize@Array@@QAEXH@Z	; Array::resize

; 258  : 			} else {

  0064a	eb 11		 jmp	 SHORT $L58419
$L58418:

; 259  : 				list->elements.resize ( 25 );

  0064c	6a 19		 push	 25			; 00000019H
  0064e	8d 4d fc	 lea	 ecx, DWORD PTR _list$58411[ebp]
  00651	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  00656	8b c8		 mov	 ecx, eax
  00658	e8 00 00 00 00	 call	 ?resize@Array@@QAEXH@Z	; Array::resize
$L58419:

; 261  : 
; 262  : 			pm.acc = (Acc) (SOL_Handle)list;

  0065d	8d 4d fc	 lea	 ecx, DWORD PTR _list$58411[ebp]
  00660	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00665	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0066a	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 264  : 
; 265  : 		break;

  0066f	e9 64 0e 00 00	 jmp	 $L58407
$L58422:

; 268  : 			SOL_ListID list = arg(2);

  00674	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00677	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  0067b	52		 push	 edx
  0067c	8d 4d f8	 lea	 ecx, DWORD PTR _list$58423[ebp]
  0067f	e8 00 00 00 00	 call	 ??0SOL_ListID@@QAE@G@Z	; SOL_ListID::SOL_ListID

; 269  : 
; 270  : 			if ( !list ) {

  00684	8d 4d f8	 lea	 ecx, DWORD PTR _list$58423[ebp]
  00687	e8 00 00 00 00	 call	 ??7MemID@@QBEHXZ	; MemID::operator!
  0068c	85 c0		 test	 eax, eax
  0068e	74 0f		 je	 SHORT $L58424

; 271  : 				pm.acc = -1;

  00690	c7 05 04 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, -1

; 272  : 				break;

  0069a	e9 39 0e 00 00	 jmp	 $L58407
$L58424:

; 274  : 
; 275  : 			if ( !list.IsValid() || list.GetMemType() != MemList )  

  0069f	8d 4d f8	 lea	 ecx, DWORD PTR _list$58423[ebp]
  006a2	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  006a7	85 c0		 test	 eax, eax
  006a9	74 0d		 je	 SHORT $L58426
  006ab	8d 4d f8	 lea	 ecx, DWORD PTR _list$58423[ebp]
  006ae	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  006b3	83 f8 38	 cmp	 eax, 56			; 00000038H
  006b6	74 2b		 je	 SHORT $L58425
$L58426:

; 276  : 				msgMgr->Fatal ( "%s(%d): list handle 0x%x is invalid", __FILE__, __LINE__, (SOL_Handle)list );

  006b8	8d 4d f8	 lea	 ecx, DWORD PTR _list$58423[ebp]
  006bb	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  006c0	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  006c5	50		 push	 eax
  006c6	68 14 01 00 00	 push	 276			; 00000114H
  006cb	68 00 00 00 00	 push	 OFFSET FLAT:$SG58428
  006d0	68 00 00 00 00	 push	 OFFSET FLAT:$SG58429
  006d5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  006da	50		 push	 eax
  006db	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  006e0	83 c4 14	 add	 esp, 20			; 00000014H
$L58425:

; 277  : 
; 278  : 			list->elements.dataID().Free();

  006e3	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T58787[ebp]
  006e9	51		 push	 ecx
  006ea	8d 4d f8	 lea	 ecx, DWORD PTR _list$58423[ebp]
  006ed	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  006f2	8b c8		 mov	 ecx, eax
  006f4	e8 00 00 00 00	 call	 ?dataID@Array@@QAE?AVMemID@@XZ ; Array::dataID
  006f9	8b c8		 mov	 ecx, eax
  006fb	e8 00 00 00 00	 call	 ?Free@MemID@@QAEXXZ	; MemID::Free

; 279  : 			list.Free();

  00700	8d 4d f8	 lea	 ecx, DWORD PTR _list$58423[ebp]
  00703	e8 00 00 00 00	 call	 ?Free@MemID@@QAEXXZ	; MemID::Free

; 281  : 
; 282  : 		break;

  00708	e9 cb 0d 00 00	 jmp	 $L58407
$L58431:

; 285  : 			msgMgr->Fatal ( "KList: NewNode call is no longer supported." );

  0070d	68 00 00 00 00	 push	 OFFSET FLAT:$SG58432
  00712	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00718	52		 push	 edx
  00719	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  0071e	83 c4 08	 add	 esp, 8

; 287  : 
; 288  : 		break;

  00721	e9 b2 0d 00 00	 jmp	 $L58407
$L58433:

; 291  : 			msgMgr->Fatal ( "KList: FirstNode call is no longer supported." );

  00726	68 00 00 00 00	 push	 OFFSET FLAT:$SG58434
  0072b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00730	50		 push	 eax
  00731	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00736	83 c4 08	 add	 esp, 8

; 293  : 
; 294  : 		break;

  00739	e9 9a 0d 00 00	 jmp	 $L58407
$L58435:

; 297  : 			msgMgr->Fatal ( "KList: LastNode call is no longer supported." );

  0073e	68 00 00 00 00	 push	 OFFSET FLAT:$SG58436
  00743	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00749	51		 push	 ecx
  0074a	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  0074f	83 c4 08	 add	 esp, 8

; 299  : 
; 300  : 		break;

  00752	e9 81 0d 00 00	 jmp	 $L58407
$L58437:

; 303  : 			SOL_ListID list = arg(2);

  00757	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  0075a	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  0075e	50		 push	 eax
  0075f	8d 4d f4	 lea	 ecx, DWORD PTR _list$58438[ebp]
  00762	e8 00 00 00 00	 call	 ??0SOL_ListID@@QAE@G@Z	; SOL_ListID::SOL_ListID

; 304  : 
; 305  : 			if ( !list ) {

  00767	8d 4d f4	 lea	 ecx, DWORD PTR _list$58438[ebp]
  0076a	e8 00 00 00 00	 call	 ??7MemID@@QBEHXZ	; MemID::operator!
  0076f	85 c0		 test	 eax, eax
  00771	74 0f		 je	 SHORT $L58439

; 306  : 				pm.acc = True;

  00773	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, 1

; 307  : 				break;

  0077d	e9 56 0d 00 00	 jmp	 $L58407
$L58439:

; 309  : 
; 310  : 			if ( !list.IsValid() || list.GetMemType() != MemList )  

  00782	8d 4d f4	 lea	 ecx, DWORD PTR _list$58438[ebp]
  00785	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  0078a	85 c0		 test	 eax, eax
  0078c	74 0d		 je	 SHORT $L58441
  0078e	8d 4d f4	 lea	 ecx, DWORD PTR _list$58438[ebp]
  00791	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  00796	83 f8 38	 cmp	 eax, 56			; 00000038H
  00799	74 2c		 je	 SHORT $L58440
$L58441:

; 311  : 				msgMgr->Fatal ( "%s(%d): list handle 0x%x is invalid", __FILE__, __LINE__, (SOL_Handle)list );

  0079b	8d 4d f4	 lea	 ecx, DWORD PTR _list$58438[ebp]
  0079e	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  007a3	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  007a8	50		 push	 eax
  007a9	68 37 01 00 00	 push	 311			; 00000137H
  007ae	68 00 00 00 00	 push	 OFFSET FLAT:$SG58443
  007b3	68 00 00 00 00	 push	 OFFSET FLAT:$SG58444
  007b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  007be	51		 push	 ecx
  007bf	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  007c4	83 c4 14	 add	 esp, 20			; 00000014H
$L58440:

; 312  : 
; 313  : 			pm.acc = (Acc)!list->size();

  007c7	8d 4d f4	 lea	 ecx, DWORD PTR _list$58438[ebp]
  007ca	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  007cf	8b c8		 mov	 ecx, eax
  007d1	e8 00 00 00 00	 call	 ?size@SOL_List@@QAEAAHXZ ; SOL_List::size
  007d6	33 d2		 xor	 edx, edx
  007d8	83 38 00	 cmp	 DWORD PTR [eax], 0
  007db	0f 94 c2	 sete	 dl
  007de	89 15 04 00 00
	00		 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, edx

; 315  : 
; 316  : 		break;

  007e4	e9 ef 0c 00 00	 jmp	 $L58407
$L58446:

; 319  : 			msgMgr->Fatal ( "KList: NextNode call is no longer supported." );

  007e9	68 00 00 00 00	 push	 OFFSET FLAT:$SG58447
  007ee	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  007f3	50		 push	 eax
  007f4	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  007f9	83 c4 08	 add	 esp, 8

; 321  : 
; 322  : 		break;

  007fc	e9 d7 0c 00 00	 jmp	 $L58407
$L58448:

; 325  : 			msgMgr->Fatal ( "KList: PrevNode call is no longer supported." );

  00801	68 00 00 00 00	 push	 OFFSET FLAT:$SG58449
  00806	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  0080c	51		 push	 ecx
  0080d	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00812	83 c4 08	 add	 esp, 8

; 327  : 
; 328  : 		break;

  00815	e9 be 0c 00 00	 jmp	 $L58407
$L58450:

; 331  : 			msgMgr->Fatal ( "KList: NodeValue call is no longer supported." );

  0081a	68 00 00 00 00	 push	 OFFSET FLAT:$SG58451
  0081f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00825	52		 push	 edx
  00826	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  0082b	83 c4 08	 add	 esp, 8

; 333  : 
; 334  : 		break;

  0082e	e9 a5 0c 00 00	 jmp	 $L58407
$L58452:

; 337  : 			SOL_ListID list = arg(2);

  00833	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00836	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  0083a	51		 push	 ecx
  0083b	8d 4d f0	 lea	 ecx, DWORD PTR _list$58453[ebp]
  0083e	e8 00 00 00 00	 call	 ??0SOL_ListID@@QAE@G@Z	; SOL_ListID::SOL_ListID

; 338  : 
; 339  : 			if ( !list ) {

  00843	8d 4d f0	 lea	 ecx, DWORD PTR _list$58453[ebp]
  00846	e8 00 00 00 00	 call	 ??7MemID@@QBEHXZ	; MemID::operator!
  0084b	85 c0		 test	 eax, eax
  0084d	74 0f		 je	 SHORT $L58454

; 340  : 				pm.acc = -1;

  0084f	c7 05 04 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, -1

; 341  : 				break;

  00859	e9 7a 0c 00 00	 jmp	 $L58407
$L58454:

; 343  : 
; 344  : 			if ( !list.IsValid() || list.GetMemType() != MemList )  

  0085e	8d 4d f0	 lea	 ecx, DWORD PTR _list$58453[ebp]
  00861	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  00866	85 c0		 test	 eax, eax
  00868	74 0d		 je	 SHORT $L58456
  0086a	8d 4d f0	 lea	 ecx, DWORD PTR _list$58453[ebp]
  0086d	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  00872	83 f8 38	 cmp	 eax, 56			; 00000038H
  00875	74 2c		 je	 SHORT $L58455
$L58456:

; 345  : 				msgMgr->Fatal ( "%s(%d): list handle 0x%x is invalid", __FILE__, __LINE__, (SOL_Handle)list );

  00877	8d 4d f0	 lea	 ecx, DWORD PTR _list$58453[ebp]
  0087a	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  0087f	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00884	50		 push	 eax
  00885	68 59 01 00 00	 push	 345			; 00000159H
  0088a	68 00 00 00 00	 push	 OFFSET FLAT:$SG58458
  0088f	68 00 00 00 00	 push	 OFFSET FLAT:$SG58459
  00894	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  0089a	52		 push	 edx
  0089b	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  008a0	83 c4 14	 add	 esp, 20			; 00000014H
$L58455:

; 346  : 
; 347  : 			pm.acc = list->addAfter ( arg(3), arg(4) );

  008a3	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  008a6	66 8b 48 08	 mov	 cx, WORD PTR [eax+8]
  008aa	51		 push	 ecx
  008ab	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  008ae	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  008b2	50		 push	 eax
  008b3	8d 4d f0	 lea	 ecx, DWORD PTR _list$58453[ebp]
  008b6	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  008bb	8b c8		 mov	 ecx, eax
  008bd	e8 00 00 00 00	 call	 ?addAfter@SOL_List@@QAEHGG@Z ; SOL_List::addAfter
  008c2	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 349  : 
; 350  : 		break;

  008c7	e9 0c 0c 00 00	 jmp	 $L58407
$L58460:

; 353  : 			SOL_ListID list = arg(2);

  008cc	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  008cf	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  008d3	52		 push	 edx
  008d4	8d 4d ec	 lea	 ecx, DWORD PTR _list$58461[ebp]
  008d7	e8 00 00 00 00	 call	 ??0SOL_ListID@@QAE@G@Z	; SOL_ListID::SOL_ListID

; 354  : 
; 355  : 			if ( !list ) {

  008dc	8d 4d ec	 lea	 ecx, DWORD PTR _list$58461[ebp]
  008df	e8 00 00 00 00	 call	 ??7MemID@@QBEHXZ	; MemID::operator!
  008e4	85 c0		 test	 eax, eax
  008e6	74 0f		 je	 SHORT $L58462

; 356  : 				pm.acc = -1;

  008e8	c7 05 04 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, -1

; 357  : 				break;

  008f2	e9 e1 0b 00 00	 jmp	 $L58407
$L58462:

; 359  : 
; 360  : 			if ( !list.IsValid() || list.GetMemType() != MemList )  

  008f7	8d 4d ec	 lea	 ecx, DWORD PTR _list$58461[ebp]
  008fa	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  008ff	85 c0		 test	 eax, eax
  00901	74 0d		 je	 SHORT $L58464
  00903	8d 4d ec	 lea	 ecx, DWORD PTR _list$58461[ebp]
  00906	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  0090b	83 f8 38	 cmp	 eax, 56			; 00000038H
  0090e	74 2b		 je	 SHORT $L58463
$L58464:

; 361  : 				msgMgr->Fatal ( "%s(%d): list handle 0x%x is invalid", __FILE__, __LINE__, (SOL_Handle)list );

  00910	8d 4d ec	 lea	 ecx, DWORD PTR _list$58461[ebp]
  00913	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00918	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0091d	50		 push	 eax
  0091e	68 69 01 00 00	 push	 361			; 00000169H
  00923	68 00 00 00 00	 push	 OFFSET FLAT:$SG58466
  00928	68 00 00 00 00	 push	 OFFSET FLAT:$SG58467
  0092d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00932	50		 push	 eax
  00933	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00938	83 c4 14	 add	 esp, 20			; 00000014H
$L58463:

; 362  : 
; 363  : 			list->addToFront ( arg(3) );

  0093b	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  0093e	66 8b 51 06	 mov	 dx, WORD PTR [ecx+6]
  00942	52		 push	 edx
  00943	8d 4d ec	 lea	 ecx, DWORD PTR _list$58461[ebp]
  00946	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  0094b	8b c8		 mov	 ecx, eax
  0094d	e8 00 00 00 00	 call	 ?addToFront@SOL_List@@QAEXG@Z ; SOL_List::addToFront

; 365  : 
; 366  : 		break;

  00952	e9 81 0b 00 00	 jmp	 $L58407
$L58468:

; 369  : 			SOL_ListID list = arg(2);

  00957	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  0095a	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  0095e	51		 push	 ecx
  0095f	8d 4d e8	 lea	 ecx, DWORD PTR _list$58469[ebp]
  00962	e8 00 00 00 00	 call	 ??0SOL_ListID@@QAE@G@Z	; SOL_ListID::SOL_ListID

; 370  : 
; 371  : 			if ( !list ) {

  00967	8d 4d e8	 lea	 ecx, DWORD PTR _list$58469[ebp]
  0096a	e8 00 00 00 00	 call	 ??7MemID@@QBEHXZ	; MemID::operator!
  0096f	85 c0		 test	 eax, eax
  00971	74 0f		 je	 SHORT $L58470

; 372  : 				pm.acc = -1;

  00973	c7 05 04 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, -1

; 373  : 				break;

  0097d	e9 56 0b 00 00	 jmp	 $L58407
$L58470:

; 375  : 
; 376  : 			if ( !list.IsValid() || list.GetMemType() != MemList )  

  00982	8d 4d e8	 lea	 ecx, DWORD PTR _list$58469[ebp]
  00985	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  0098a	85 c0		 test	 eax, eax
  0098c	74 0d		 je	 SHORT $L58472
  0098e	8d 4d e8	 lea	 ecx, DWORD PTR _list$58469[ebp]
  00991	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  00996	83 f8 38	 cmp	 eax, 56			; 00000038H
  00999	74 2c		 je	 SHORT $L58471
$L58472:

; 377  : 				msgMgr->Fatal ( "%s(%d): list handle 0x%x is invalid", __FILE__, __LINE__, (SOL_Handle)list );

  0099b	8d 4d e8	 lea	 ecx, DWORD PTR _list$58469[ebp]
  0099e	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  009a3	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  009a8	50		 push	 eax
  009a9	68 79 01 00 00	 push	 377			; 00000179H
  009ae	68 00 00 00 00	 push	 OFFSET FLAT:$SG58474
  009b3	68 00 00 00 00	 push	 OFFSET FLAT:$SG58475
  009b8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  009be	52		 push	 edx
  009bf	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  009c4	83 c4 14	 add	 esp, 20			; 00000014H
$L58471:

; 378  : 
; 379  : 			list->addToEnd ( arg(3) );

  009c7	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  009ca	66 8b 48 06	 mov	 cx, WORD PTR [eax+6]
  009ce	51		 push	 ecx
  009cf	8d 4d e8	 lea	 ecx, DWORD PTR _list$58469[ebp]
  009d2	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  009d7	8b c8		 mov	 ecx, eax
  009d9	e8 00 00 00 00	 call	 ?addToEnd@SOL_List@@QAEXG@Z ; SOL_List::addToEnd

; 381  : 
; 382  : 		break;

  009de	e9 f5 0a 00 00	 jmp	 $L58407
$L58476:

; 385  : 			SOL_ListID list = arg(2);

  009e3	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  009e6	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  009ea	50		 push	 eax
  009eb	8d 4d e4	 lea	 ecx, DWORD PTR _list$58477[ebp]
  009ee	e8 00 00 00 00	 call	 ??0SOL_ListID@@QAE@G@Z	; SOL_ListID::SOL_ListID

; 386  : 
; 387  : 			if ( !list ) {

  009f3	8d 4d e4	 lea	 ecx, DWORD PTR _list$58477[ebp]
  009f6	e8 00 00 00 00	 call	 ??7MemID@@QBEHXZ	; MemID::operator!
  009fb	85 c0		 test	 eax, eax
  009fd	74 0f		 je	 SHORT $L58478

; 388  : 				pm.acc = -1;

  009ff	c7 05 04 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, -1

; 389  : 				break;

  00a09	e9 ca 0a 00 00	 jmp	 $L58407
$L58478:

; 391  : 
; 392  : 			if ( !list.IsValid() || list.GetMemType() != MemList )  

  00a0e	8d 4d e4	 lea	 ecx, DWORD PTR _list$58477[ebp]
  00a11	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  00a16	85 c0		 test	 eax, eax
  00a18	74 0d		 je	 SHORT $L58480
  00a1a	8d 4d e4	 lea	 ecx, DWORD PTR _list$58477[ebp]
  00a1d	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  00a22	83 f8 38	 cmp	 eax, 56			; 00000038H
  00a25	74 2c		 je	 SHORT $L58479
$L58480:

; 393  : 				msgMgr->Fatal ( "%s(%d): list handle 0x%x is invalid", __FILE__, __LINE__, (SOL_Handle)list );

  00a27	8d 4d e4	 lea	 ecx, DWORD PTR _list$58477[ebp]
  00a2a	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00a2f	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00a34	50		 push	 eax
  00a35	68 89 01 00 00	 push	 393			; 00000189H
  00a3a	68 00 00 00 00	 push	 OFFSET FLAT:$SG58482
  00a3f	68 00 00 00 00	 push	 OFFSET FLAT:$SG58483
  00a44	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00a4a	51		 push	 ecx
  00a4b	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00a50	83 c4 14	 add	 esp, 20			; 00000014H
$L58479:

; 394  : 
; 395  : 			pm.acc = list->addBefore ( arg(3), arg(4) );

  00a53	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00a56	66 8b 42 08	 mov	 ax, WORD PTR [edx+8]
  00a5a	50		 push	 eax
  00a5b	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00a5e	66 8b 51 06	 mov	 dx, WORD PTR [ecx+6]
  00a62	52		 push	 edx
  00a63	8d 4d e4	 lea	 ecx, DWORD PTR _list$58477[ebp]
  00a66	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  00a6b	8b c8		 mov	 ecx, eax
  00a6d	e8 00 00 00 00	 call	 ?addBefore@SOL_List@@QAEHGG@Z ; SOL_List::addBefore
  00a72	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 397  : 
; 398  : 		break;

  00a77	e9 5c 0a 00 00	 jmp	 $L58407
$L58484:

; 401  : 			SOL_ListID list = arg(2);

  00a7c	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00a7f	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  00a83	51		 push	 ecx
  00a84	8d 4d e0	 lea	 ecx, DWORD PTR _list$58485[ebp]
  00a87	e8 00 00 00 00	 call	 ??0SOL_ListID@@QAE@G@Z	; SOL_ListID::SOL_ListID

; 402  : 
; 403  : 			if ( !list ) {

  00a8c	8d 4d e0	 lea	 ecx, DWORD PTR _list$58485[ebp]
  00a8f	e8 00 00 00 00	 call	 ??7MemID@@QBEHXZ	; MemID::operator!
  00a94	85 c0		 test	 eax, eax
  00a96	74 0f		 je	 SHORT $L58486

; 404  : 				pm.acc = -1;

  00a98	c7 05 04 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, -1

; 405  : 				break;

  00aa2	e9 31 0a 00 00	 jmp	 $L58407
$L58486:

; 407  : 
; 408  : 			if ( !list.IsValid() || list.GetMemType() != MemList )  

  00aa7	8d 4d e0	 lea	 ecx, DWORD PTR _list$58485[ebp]
  00aaa	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  00aaf	85 c0		 test	 eax, eax
  00ab1	74 0d		 je	 SHORT $L58488
  00ab3	8d 4d e0	 lea	 ecx, DWORD PTR _list$58485[ebp]
  00ab6	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  00abb	83 f8 38	 cmp	 eax, 56			; 00000038H
  00abe	74 2c		 je	 SHORT $L58487
$L58488:

; 409  : 				msgMgr->Fatal ( "%s(%d): list handle 0x%x is invalid", __FILE__, __LINE__, (SOL_Handle)list );

  00ac0	8d 4d e0	 lea	 ecx, DWORD PTR _list$58485[ebp]
  00ac3	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00ac8	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00acd	50		 push	 eax
  00ace	68 99 01 00 00	 push	 409			; 00000199H
  00ad3	68 00 00 00 00	 push	 OFFSET FLAT:$SG58490
  00ad8	68 00 00 00 00	 push	 OFFSET FLAT:$SG58491
  00add	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00ae3	52		 push	 edx
  00ae4	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00ae9	83 c4 14	 add	 esp, 20			; 00000014H
$L58487:

; 410  : 
; 411  : 			list->moveToFront ( arg(3) );

  00aec	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00aef	66 8b 48 06	 mov	 cx, WORD PTR [eax+6]
  00af3	51		 push	 ecx
  00af4	8d 4d e0	 lea	 ecx, DWORD PTR _list$58485[ebp]
  00af7	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  00afc	8b c8		 mov	 ecx, eax
  00afe	e8 00 00 00 00	 call	 ?moveToFront@SOL_List@@QAEHG@Z ; SOL_List::moveToFront

; 413  : 
; 414  : 		break;

  00b03	e9 d0 09 00 00	 jmp	 $L58407
$L58492:

; 417  : 			SOL_ListID list = arg(2);

  00b08	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00b0b	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  00b0f	50		 push	 eax
  00b10	8d 4d dc	 lea	 ecx, DWORD PTR _list$58493[ebp]
  00b13	e8 00 00 00 00	 call	 ??0SOL_ListID@@QAE@G@Z	; SOL_ListID::SOL_ListID

; 418  : 
; 419  : 			if ( !list ) {

  00b18	8d 4d dc	 lea	 ecx, DWORD PTR _list$58493[ebp]
  00b1b	e8 00 00 00 00	 call	 ??7MemID@@QBEHXZ	; MemID::operator!
  00b20	85 c0		 test	 eax, eax
  00b22	74 0f		 je	 SHORT $L58494

; 420  : 				pm.acc = -1;

  00b24	c7 05 04 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, -1

; 421  : 				break;

  00b2e	e9 a5 09 00 00	 jmp	 $L58407
$L58494:

; 423  : 
; 424  : 			if ( !list.IsValid() || list.GetMemType() != MemList )  

  00b33	8d 4d dc	 lea	 ecx, DWORD PTR _list$58493[ebp]
  00b36	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  00b3b	85 c0		 test	 eax, eax
  00b3d	74 0d		 je	 SHORT $L58496
  00b3f	8d 4d dc	 lea	 ecx, DWORD PTR _list$58493[ebp]
  00b42	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  00b47	83 f8 38	 cmp	 eax, 56			; 00000038H
  00b4a	74 2c		 je	 SHORT $L58495
$L58496:

; 425  : 				msgMgr->Fatal ( "%s(%d): list handle 0x%x is invalid", __FILE__, __LINE__, (SOL_Handle)list );

  00b4c	8d 4d dc	 lea	 ecx, DWORD PTR _list$58493[ebp]
  00b4f	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00b54	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00b59	50		 push	 eax
  00b5a	68 a9 01 00 00	 push	 425			; 000001a9H
  00b5f	68 00 00 00 00	 push	 OFFSET FLAT:$SG58498
  00b64	68 00 00 00 00	 push	 OFFSET FLAT:$SG58499
  00b69	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00b6f	51		 push	 ecx
  00b70	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00b75	83 c4 14	 add	 esp, 20			; 00000014H
$L58495:

; 426  : 
; 427  : 			list->moveToEnd ( arg(3) );

  00b78	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00b7b	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  00b7f	50		 push	 eax
  00b80	8d 4d dc	 lea	 ecx, DWORD PTR _list$58493[ebp]
  00b83	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  00b88	8b c8		 mov	 ecx, eax
  00b8a	e8 00 00 00 00	 call	 ?moveToEnd@SOL_List@@QAEHG@Z ; SOL_List::moveToEnd

; 429  : 
; 430  : 		break;

  00b8f	e9 44 09 00 00	 jmp	 $L58407
$L58500:

; 433  : 			msgMgr->Fatal ( "KList: FindKey call is no longer supported." );

  00b94	68 00 00 00 00	 push	 OFFSET FLAT:$SG58501
  00b99	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00b9f	51		 push	 ecx
  00ba0	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00ba5	83 c4 08	 add	 esp, 8

; 435  : 
; 436  : 		break;

  00ba8	e9 2b 09 00 00	 jmp	 $L58407
$L58502:

; 439  : 			SOL_ListID list = arg(2);

  00bad	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00bb0	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  00bb4	50		 push	 eax
  00bb5	8d 4d d8	 lea	 ecx, DWORD PTR _list$58503[ebp]
  00bb8	e8 00 00 00 00	 call	 ??0SOL_ListID@@QAE@G@Z	; SOL_ListID::SOL_ListID

; 440  : 
; 441  : 			if ( !list ) {

  00bbd	8d 4d d8	 lea	 ecx, DWORD PTR _list$58503[ebp]
  00bc0	e8 00 00 00 00	 call	 ??7MemID@@QBEHXZ	; MemID::operator!
  00bc5	85 c0		 test	 eax, eax
  00bc7	74 0f		 je	 SHORT $L58504

; 442  : 				pm.acc = 0;

  00bc9	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, 0

; 443  : 				break;

  00bd3	e9 00 09 00 00	 jmp	 $L58407
$L58504:

; 445  : 
; 446  : 			if ( !list.IsValid() || list.GetMemType() != MemList )  

  00bd8	8d 4d d8	 lea	 ecx, DWORD PTR _list$58503[ebp]
  00bdb	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  00be0	85 c0		 test	 eax, eax
  00be2	74 0d		 je	 SHORT $L58506
  00be4	8d 4d d8	 lea	 ecx, DWORD PTR _list$58503[ebp]
  00be7	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  00bec	83 f8 38	 cmp	 eax, 56			; 00000038H
  00bef	74 2c		 je	 SHORT $L58505
$L58506:

; 447  : 				msgMgr->Fatal ( "%s(%d): list handle 0x%x is invalid", __FILE__, __LINE__, (SOL_Handle)list );

  00bf1	8d 4d d8	 lea	 ecx, DWORD PTR _list$58503[ebp]
  00bf4	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00bf9	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00bfe	50		 push	 eax
  00bff	68 bf 01 00 00	 push	 447			; 000001bfH
  00c04	68 00 00 00 00	 push	 OFFSET FLAT:$SG58508
  00c09	68 00 00 00 00	 push	 OFFSET FLAT:$SG58509
  00c0e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00c14	51		 push	 ecx
  00c15	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00c1a	83 c4 14	 add	 esp, 20			; 00000014H
$L58505:

; 448  : 
; 449  : 			pm.acc = list->del ( arg(3) );

  00c1d	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00c20	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  00c24	50		 push	 eax
  00c25	8d 4d d8	 lea	 ecx, DWORD PTR _list$58503[ebp]
  00c28	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  00c2d	8b c8		 mov	 ecx, eax
  00c2f	e8 00 00 00 00	 call	 ?del@SOL_List@@QAEHG@Z	; SOL_List::del
  00c34	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 451  : 
; 452  : 		break;

  00c39	e9 9a 08 00 00	 jmp	 $L58407
$L58510:

; 455  : 			SOL_ListID list = arg(2);

  00c3e	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00c41	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  00c45	52		 push	 edx
  00c46	8d 4d d4	 lea	 ecx, DWORD PTR _list$58511[ebp]
  00c49	e8 00 00 00 00	 call	 ??0SOL_ListID@@QAE@G@Z	; SOL_ListID::SOL_ListID

; 456  : 
; 457  : 			if ( !list ) {

  00c4e	8d 4d d4	 lea	 ecx, DWORD PTR _list$58511[ebp]
  00c51	e8 00 00 00 00	 call	 ??7MemID@@QBEHXZ	; MemID::operator!
  00c56	85 c0		 test	 eax, eax
  00c58	74 0f		 je	 SHORT $L58512

; 458  : 				pm.acc = 0;

  00c5a	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, 0

; 459  : 				break;

  00c64	e9 6f 08 00 00	 jmp	 $L58407
$L58512:

; 461  : 
; 462  : 			if ( !list.IsValid() || list.GetMemType() != MemList )  

  00c69	8d 4d d4	 lea	 ecx, DWORD PTR _list$58511[ebp]
  00c6c	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  00c71	85 c0		 test	 eax, eax
  00c73	74 0d		 je	 SHORT $L58514
  00c75	8d 4d d4	 lea	 ecx, DWORD PTR _list$58511[ebp]
  00c78	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  00c7d	83 f8 38	 cmp	 eax, 56			; 00000038H
  00c80	74 2b		 je	 SHORT $L58513
$L58514:

; 463  : 				msgMgr->Fatal ( "%s(%d): list handle 0x%x is invalid", __FILE__, __LINE__, (SOL_Handle)list );

  00c82	8d 4d d4	 lea	 ecx, DWORD PTR _list$58511[ebp]
  00c85	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00c8a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00c8f	50		 push	 eax
  00c90	68 cf 01 00 00	 push	 463			; 000001cfH
  00c95	68 00 00 00 00	 push	 OFFSET FLAT:$SG58516
  00c9a	68 00 00 00 00	 push	 OFFSET FLAT:$SG58517
  00c9f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00ca4	50		 push	 eax
  00ca5	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00caa	83 c4 14	 add	 esp, 20			; 00000014H
$L58513:

; 464  : 
; 465  : 			pm.acc = list->at ( arg(3) );

  00cad	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00cb0	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00cb4	52		 push	 edx
  00cb5	8d 4d d4	 lea	 ecx, DWORD PTR _list$58511[ebp]
  00cb8	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  00cbd	8b c8		 mov	 ecx, eax
  00cbf	e8 00 00 00 00	 call	 ?at@SOL_List@@QAEGH@Z	; SOL_List::at
  00cc4	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00cc9	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 467  : 
; 468  : 		break;

  00cce	e9 05 08 00 00	 jmp	 $L58407
$L58518:

; 471  : 			SOL_ListID list = arg(2);

  00cd3	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00cd6	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  00cda	51		 push	 ecx
  00cdb	8d 4d d0	 lea	 ecx, DWORD PTR _list$58519[ebp]
  00cde	e8 00 00 00 00	 call	 ??0SOL_ListID@@QAE@G@Z	; SOL_ListID::SOL_ListID

; 472  : 
; 473  : 			if ( !list ) {

  00ce3	8d 4d d0	 lea	 ecx, DWORD PTR _list$58519[ebp]
  00ce6	e8 00 00 00 00	 call	 ??7MemID@@QBEHXZ	; MemID::operator!
  00ceb	85 c0		 test	 eax, eax
  00ced	74 0f		 je	 SHORT $L58520

; 474  : 				pm.acc = -1;

  00cef	c7 05 04 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, -1

; 475  : 				break;

  00cf9	e9 da 07 00 00	 jmp	 $L58407
$L58520:

; 477  : 
; 478  : 			if ( !list.IsValid() || list.GetMemType() != MemList )  

  00cfe	8d 4d d0	 lea	 ecx, DWORD PTR _list$58519[ebp]
  00d01	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  00d06	85 c0		 test	 eax, eax
  00d08	74 0d		 je	 SHORT $L58522
  00d0a	8d 4d d0	 lea	 ecx, DWORD PTR _list$58519[ebp]
  00d0d	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  00d12	83 f8 38	 cmp	 eax, 56			; 00000038H
  00d15	74 2c		 je	 SHORT $L58521
$L58522:

; 479  : 				msgMgr->Fatal ( "%s(%d): list handle 0x%x is invalid", __FILE__, __LINE__, (SOL_Handle)list );

  00d17	8d 4d d0	 lea	 ecx, DWORD PTR _list$58519[ebp]
  00d1a	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00d1f	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00d24	50		 push	 eax
  00d25	68 df 01 00 00	 push	 479			; 000001dfH
  00d2a	68 00 00 00 00	 push	 OFFSET FLAT:$SG58524
  00d2f	68 00 00 00 00	 push	 OFFSET FLAT:$SG58525
  00d34	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00d3a	52		 push	 edx
  00d3b	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00d40	83 c4 14	 add	 esp, 20			; 00000014H
$L58521:

; 480  : 
; 481  : 			pm.acc = list->indexOf ( arg(3) );

  00d43	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00d46	66 8b 48 06	 mov	 cx, WORD PTR [eax+6]
  00d4a	51		 push	 ecx
  00d4b	8d 4d d0	 lea	 ecx, DWORD PTR _list$58519[ebp]
  00d4e	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  00d53	8b c8		 mov	 ecx, eax
  00d55	e8 00 00 00 00	 call	 ?indexOf@SOL_List@@QAEHG@Z ; SOL_List::indexOf
  00d5a	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 483  : 
; 484  : 		break;

  00d5f	e9 74 07 00 00	 jmp	 $L58407
$L58526:

; 487  : 			SOL_ListID list = (SOL_ListID)arg(2);

  00d64	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00d67	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  00d6b	50		 push	 eax
  00d6c	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T58788[ebp]
  00d72	e8 00 00 00 00	 call	 ??0SOL_ListID@@QAE@G@Z	; SOL_ListID::SOL_ListID
  00d77	50		 push	 eax
  00d78	8d 4d c4	 lea	 ecx, DWORD PTR _list$58527[ebp]
  00d7b	e8 00 00 00 00	 call	 ??0SOL_ListID@@QAE@ABU0@@Z ; SOL_ListID::SOL_ListID

; 488  : 
; 489  : 			if ( !list )

  00d80	8d 4d c4	 lea	 ecx, DWORD PTR _list$58527[ebp]
  00d83	e8 00 00 00 00	 call	 ??7MemID@@QBEHXZ	; MemID::operator!
  00d88	85 c0		 test	 eax, eax
  00d8a	74 05		 je	 SHORT $L58530

; 490  : 				break;

  00d8c	e9 47 07 00 00	 jmp	 $L58407
$L58530:

; 491  : 
; 492  : 			if ( !list.IsValid() || list.GetMemType() != MemList )  

  00d91	8d 4d c4	 lea	 ecx, DWORD PTR _list$58527[ebp]
  00d94	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  00d99	85 c0		 test	 eax, eax
  00d9b	74 0d		 je	 SHORT $L58532
  00d9d	8d 4d c4	 lea	 ecx, DWORD PTR _list$58527[ebp]
  00da0	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  00da5	83 f8 38	 cmp	 eax, 56			; 00000038H
  00da8	74 2c		 je	 SHORT $L58531
$L58532:

; 493  : 				msgMgr->Fatal ( "%s(%d): list handle 0x%x is invalid", __FILE__, __LINE__, (SOL_Handle)list );

  00daa	8d 4d c4	 lea	 ecx, DWORD PTR _list$58527[ebp]
  00dad	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00db2	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00db7	50		 push	 eax
  00db8	68 ed 01 00 00	 push	 493			; 000001edH
  00dbd	68 00 00 00 00	 push	 OFFSET FLAT:$SG58534
  00dc2	68 00 00 00 00	 push	 OFFSET FLAT:$SG58535
  00dc7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00dcd	51		 push	 ecx
  00dce	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00dd3	83 c4 14	 add	 esp, 20			; 00000014H
$L58531:

; 494  : 
; 495  : 			ObjectID saveObject = pm.object;

  00dd6	66 8b 15 02 00
	00 00		 mov	 dx, WORD PTR ?pm@@3VPMachine@@A+2
  00ddd	52		 push	 edx
  00dde	8d 4d c8	 lea	 ecx, DWORD PTR _saveObject$58536[ebp]
  00de1	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID

; 496  : 			ObjectID obj;

  00de6	8d 4d bc	 lea	 ecx, DWORD PTR _obj$58537[ebp]
  00de9	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@XZ	; ObjectID::ObjectID

; 497  : 
; 498  : 			void *listPtr = *list;

  00dee	8d 4d c4	 lea	 ecx, DWORD PTR _list$58527[ebp]
  00df1	e8 00 00 00 00	 call	 ??DFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator*
  00df6	89 45 cc	 mov	 DWORD PTR _listPtr$58538[ebp], eax

; 499  : 
; 500  : 			for ( int i=0; (list.IsValid() && i<list->size()); i++ ) {

  00df9	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _i$58539[ebp], 0
  00e00	eb 09		 jmp	 SHORT $L58540
$L58541:
  00e02	8b 45 c0	 mov	 eax, DWORD PTR _i$58539[ebp]
  00e05	83 c0 01	 add	 eax, 1
  00e08	89 45 c0	 mov	 DWORD PTR _i$58539[ebp], eax
$L58540:
  00e0b	8d 4d c4	 lea	 ecx, DWORD PTR _list$58527[ebp]
  00e0e	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  00e13	85 c0		 test	 eax, eax
  00e15	0f 84 47 01 00
	00		 je	 $L58542
  00e1b	8d 4d c4	 lea	 ecx, DWORD PTR _list$58527[ebp]
  00e1e	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  00e23	8b c8		 mov	 ecx, eax
  00e25	e8 00 00 00 00	 call	 ?size@SOL_List@@QAEAAHXZ ; SOL_List::size
  00e2a	8b 4d c0	 mov	 ecx, DWORD PTR _i$58539[ebp]
  00e2d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00e2f	0f 8d 2d 01 00
	00		 jge	 $L58542

; 501  : 				obj = (ObjectID)list->at ( i );

  00e35	8b 55 c0	 mov	 edx, DWORD PTR _i$58539[ebp]
  00e38	52		 push	 edx
  00e39	8d 4d c4	 lea	 ecx, DWORD PTR _list$58527[ebp]
  00e3c	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  00e41	8b c8		 mov	 ecx, eax
  00e43	e8 00 00 00 00	 call	 ?at@SOL_List@@QAEGH@Z	; SOL_List::at
  00e48	50		 push	 eax
  00e49	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR $T58789[ebp]
  00e4f	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  00e54	66 8b 00	 mov	 ax, WORD PTR [eax]
  00e57	66 89 45 bc	 mov	 WORD PTR _obj$58537[ebp], ax

; 502  : 
; 503  : 				if ( !obj.IsObject() ) {

  00e5b	8d 4d bc	 lea	 ecx, DWORD PTR _obj$58537[ebp]
  00e5e	e8 00 00 00 00	 call	 ?IsObject@ObjectID@@QBEHXZ ; ObjectID::IsObject
  00e63	85 c0		 test	 eax, eax
  00e65	75 26		 jne	 SHORT $L58545

; 504  : 					list->del ( (SCIUWord)obj );

  00e67	8d 4d bc	 lea	 ecx, DWORD PTR _obj$58537[ebp]
  00e6a	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00e6f	50		 push	 eax
  00e70	8d 4d c4	 lea	 ecx, DWORD PTR _list$58527[ebp]
  00e73	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  00e78	8b c8		 mov	 ecx, eax
  00e7a	e8 00 00 00 00	 call	 ?del@SOL_List@@QAEHG@Z	; SOL_List::del

; 505  : 					i--;

  00e7f	8b 4d c0	 mov	 ecx, DWORD PTR _i$58539[ebp]
  00e82	83 e9 01	 sub	 ecx, 1
  00e85	89 4d c0	 mov	 DWORD PTR _i$58539[ebp], ecx

; 506  : 					continue;

  00e88	e9 75 ff ff ff	 jmp	 $L58541
$L58545:

; 508  : 
; 509  : 				int nArgs = argCount - 3;

  00e8d	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00e90	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00e93	83 e8 03	 sub	 eax, 3
  00e96	89 45 b8	 mov	 DWORD PTR _nArgs$58547[ebp], eax

; 510  : 	
; 511  : 				// add 1 for selector and 1 for # args
; 512  : 				int nArgChars = (nArgs + 2) * sizeof(Property);

  00e99	8b 4d b8	 mov	 ecx, DWORD PTR _nArgs$58547[ebp]
  00e9c	8d 54 09 04	 lea	 edx, DWORD PTR [ecx+ecx+4]
  00ea0	89 55 b4	 mov	 DWORD PTR _nArgChars$58548[ebp], edx

; 513  : 	
; 514  : 				//	set new current object
; 515  : 				pm.object = obj;

  00ea3	8d 4d bc	 lea	 ecx, DWORD PTR _obj$58537[ebp]
  00ea6	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00eab	66 a3 02 00 00
	00		 mov	 WORD PTR ?pm@@3VPMachine@@A+2, ax

; 516  : 	
; 517  : 				//	push the selector, # of Args, ptr to arg list
; 518  : 				pmPushMany( arg(3), nArgs, &arg(4));

  00eb1	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00eb4	83 c0 08	 add	 eax, 8
  00eb7	50		 push	 eax
  00eb8	8b 4d b8	 mov	 ecx, DWORD PTR _nArgs$58547[ebp]
  00ebb	51		 push	 ecx
  00ebc	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00ebf	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  00ec3	50		 push	 eax
  00ec4	e8 00 00 00 00	 call	 ?pmPushMany@@YAXGIPAF@Z	; pmPushMany
  00ec9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 519  : 	
; 520  : 				//	call the method
; 521  : 				// MUST be cast as short or else CPP converts them signed (Bryan Waters)
; 522  : 				pmQuickMessage( (unsigned short) obj, (unsigned short) nArgChars, pm.StackPtr);

  00ecc	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR ?pm@@3VPMachine@@A+12
  00ed2	51		 push	 ecx
  00ed3	8b 55 b4	 mov	 edx, DWORD PTR _nArgChars$58548[ebp]
  00ed6	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00edc	52		 push	 edx
  00edd	8d 4d bc	 lea	 ecx, DWORD PTR _obj$58537[ebp]
  00ee0	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00ee5	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00eea	50		 push	 eax
  00eeb	e8 00 00 00 00	 call	 ?pmQuickMessage@@YAXIIPAX@Z ; pmQuickMessage
  00ef0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 523  : 
; 524  : 				if ( !list.IsValid() || list.GetMemType() != MemList )  

  00ef3	8d 4d c4	 lea	 ecx, DWORD PTR _list$58527[ebp]
  00ef6	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  00efb	85 c0		 test	 eax, eax
  00efd	74 0d		 je	 SHORT $L58553
  00eff	8d 4d c4	 lea	 ecx, DWORD PTR _list$58527[ebp]
  00f02	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  00f07	83 f8 38	 cmp	 eax, 56			; 00000038H
  00f0a	74 2b		 je	 SHORT $L58552
$L58553:

; 525  : 					msgMgr->Fatal ( "%s(%d): list handle 0x%x is invalid", __FILE__, __LINE__, (SOL_Handle)list );

  00f0c	8d 4d c4	 lea	 ecx, DWORD PTR _list$58527[ebp]
  00f0f	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00f14	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00f19	50		 push	 eax
  00f1a	68 0d 02 00 00	 push	 525			; 0000020dH
  00f1f	68 00 00 00 00	 push	 OFFSET FLAT:$SG58555
  00f24	68 00 00 00 00	 push	 OFFSET FLAT:$SG58556
  00f29	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00f2e	50		 push	 eax
  00f2f	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00f34	83 c4 14	 add	 esp, 20			; 00000014H
$L58552:

; 526  : 
; 527  : 				// check to see if the method we called forced the object to
; 528  : 				// delete itself from the list. if so, fix it!
; 529  : 				if ( list->indexOf ( (SCIUWord)obj ) == -1 ) {

  00f37	8d 4d bc	 lea	 ecx, DWORD PTR _obj$58537[ebp]
  00f3a	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00f3f	50		 push	 eax
  00f40	8d 4d c4	 lea	 ecx, DWORD PTR _list$58527[ebp]
  00f43	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  00f48	8b c8		 mov	 ecx, eax
  00f4a	e8 00 00 00 00	 call	 ?indexOf@SOL_List@@QAEHG@Z ; SOL_List::indexOf
  00f4f	83 f8 ff	 cmp	 eax, -1
  00f52	75 09		 jne	 SHORT $L58558

; 530  : 					i--;

  00f54	8b 4d c0	 mov	 ecx, DWORD PTR _i$58539[ebp]
  00f57	83 e9 01	 sub	 ecx, 1
  00f5a	89 4d c0	 mov	 DWORD PTR _i$58539[ebp], ecx
$L58558:

; 532  : 			}

  00f5d	e9 a0 fe ff ff	 jmp	 $L58541
$L58542:

; 533  : 
; 534  : 			//	restore current object
; 535  : 			pm.object = saveObject;

  00f62	8d 4d c8	 lea	 ecx, DWORD PTR _saveObject$58536[ebp]
  00f65	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00f6a	66 a3 02 00 00
	00		 mov	 WORD PTR ?pm@@3VPMachine@@A+2, ax

; 537  : 
; 538  : 		break;

  00f70	e9 63 05 00 00	 jmp	 $L58407
$L58559:

; 541  : 			pm.acc = 0;

  00f75	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, 0

; 542  : 
; 543  : 			SOL_ListID list = arg(2);

  00f7f	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00f82	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  00f86	50		 push	 eax
  00f87	8d 4d ac	 lea	 ecx, DWORD PTR _list$58560[ebp]
  00f8a	e8 00 00 00 00	 call	 ??0SOL_ListID@@QAE@G@Z	; SOL_ListID::SOL_ListID

; 544  : 
; 545  : 			if ( !list )

  00f8f	8d 4d ac	 lea	 ecx, DWORD PTR _list$58560[ebp]
  00f92	e8 00 00 00 00	 call	 ??7MemID@@QBEHXZ	; MemID::operator!
  00f97	85 c0		 test	 eax, eax
  00f99	74 05		 je	 SHORT $L58561

; 546  : 				break;

  00f9b	e9 38 05 00 00	 jmp	 $L58407
$L58561:

; 547  : 
; 548  : 			if ( !list.IsValid() || list.GetMemType() != MemList )  

  00fa0	8d 4d ac	 lea	 ecx, DWORD PTR _list$58560[ebp]
  00fa3	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  00fa8	85 c0		 test	 eax, eax
  00faa	74 0d		 je	 SHORT $L58563
  00fac	8d 4d ac	 lea	 ecx, DWORD PTR _list$58560[ebp]
  00faf	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  00fb4	83 f8 38	 cmp	 eax, 56			; 00000038H
  00fb7	74 2c		 je	 SHORT $L58562
$L58563:

; 549  : 				msgMgr->Fatal ( "%s(%d): list handle 0x%x is invalid", __FILE__, __LINE__, (SOL_Handle)list );

  00fb9	8d 4d ac	 lea	 ecx, DWORD PTR _list$58560[ebp]
  00fbc	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00fc1	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00fc6	50		 push	 eax
  00fc7	68 25 02 00 00	 push	 549			; 00000225H
  00fcc	68 00 00 00 00	 push	 OFFSET FLAT:$SG58565
  00fd1	68 00 00 00 00	 push	 OFFSET FLAT:$SG58566
  00fd6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00fdc	51		 push	 ecx
  00fdd	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00fe2	83 c4 14	 add	 esp, 20			; 00000014H
$L58562:

; 550  : 
; 551  : 			ObjectID saveObject = pm.object;

  00fe5	66 8b 15 02 00
	00 00		 mov	 dx, WORD PTR ?pm@@3VPMachine@@A+2
  00fec	52		 push	 edx
  00fed	8d 4d b0	 lea	 ecx, DWORD PTR _saveObject$58567[ebp]
  00ff0	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID

; 552  : 			ObjectID obj;

  00ff5	8d 4d a4	 lea	 ecx, DWORD PTR _obj$58568[ebp]
  00ff8	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@XZ	; ObjectID::ObjectID

; 553  : 
; 554  : 			for ( int i=0; i<list->size(); i++ ) {

  00ffd	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _i$58569[ebp], 0
  01004	eb 09		 jmp	 SHORT $L58570
$L58571:
  01006	8b 45 a8	 mov	 eax, DWORD PTR _i$58569[ebp]
  01009	83 c0 01	 add	 eax, 1
  0100c	89 45 a8	 mov	 DWORD PTR _i$58569[ebp], eax
$L58570:
  0100f	8d 4d ac	 lea	 ecx, DWORD PTR _list$58560[ebp]
  01012	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  01017	8b c8		 mov	 ecx, eax
  01019	e8 00 00 00 00	 call	 ?size@SOL_List@@QAEAAHXZ ; SOL_List::size
  0101e	8b 4d a8	 mov	 ecx, DWORD PTR _i$58569[ebp]
  01021	3b 08		 cmp	 ecx, DWORD PTR [eax]
  01023	0f 8d 21 01 00
	00		 jge	 $L58572

; 555  : 				obj = (ObjectID)list->at ( i );

  01029	8b 55 a8	 mov	 edx, DWORD PTR _i$58569[ebp]
  0102c	52		 push	 edx
  0102d	8d 4d ac	 lea	 ecx, DWORD PTR _list$58560[ebp]
  01030	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  01035	8b c8		 mov	 ecx, eax
  01037	e8 00 00 00 00	 call	 ?at@SOL_List@@QAEGH@Z	; SOL_List::at
  0103c	50		 push	 eax
  0103d	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR $T58790[ebp]
  01043	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  01048	66 8b 00	 mov	 ax, WORD PTR [eax]
  0104b	66 89 45 a4	 mov	 WORD PTR _obj$58568[ebp], ax

; 556  : 
; 557  : 				if ( !obj.IsObject() ) {

  0104f	8d 4d a4	 lea	 ecx, DWORD PTR _obj$58568[ebp]
  01052	e8 00 00 00 00	 call	 ?IsObject@ObjectID@@QBEHXZ ; ObjectID::IsObject
  01057	85 c0		 test	 eax, eax
  01059	75 23		 jne	 SHORT $L58575

; 558  : 					list->del ( (SCIUWord)obj );

  0105b	8d 4d a4	 lea	 ecx, DWORD PTR _obj$58568[ebp]
  0105e	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  01063	50		 push	 eax
  01064	8d 4d ac	 lea	 ecx, DWORD PTR _list$58560[ebp]
  01067	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  0106c	8b c8		 mov	 ecx, eax
  0106e	e8 00 00 00 00	 call	 ?del@SOL_List@@QAEHG@Z	; SOL_List::del

; 559  : 					i--;

  01073	8b 4d a8	 mov	 ecx, DWORD PTR _i$58569[ebp]
  01076	83 e9 01	 sub	 ecx, 1
  01079	89 4d a8	 mov	 DWORD PTR _i$58569[ebp], ecx

; 560  : 					continue;

  0107c	eb 88		 jmp	 SHORT $L58571
$L58575:

; 562  : 
; 563  : 				int nArgs = argCount - 3;

  0107e	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  01081	0f bf 02	 movsx	 eax, WORD PTR [edx]
  01084	83 e8 03	 sub	 eax, 3
  01087	89 45 a0	 mov	 DWORD PTR _nArgs$58577[ebp], eax

; 564  : 	
; 565  : 				// add 1 for selector and 1 for # args
; 566  : 				int nArgChars = (nArgs + 2) * sizeof(Property);

  0108a	8b 4d a0	 mov	 ecx, DWORD PTR _nArgs$58577[ebp]
  0108d	8d 54 09 04	 lea	 edx, DWORD PTR [ecx+ecx+4]
  01091	89 55 9c	 mov	 DWORD PTR _nArgChars$58578[ebp], edx

; 567  : 	
; 568  : 				//	set new current object
; 569  : 				pm.object = obj;

  01094	8d 4d a4	 lea	 ecx, DWORD PTR _obj$58568[ebp]
  01097	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  0109c	66 a3 02 00 00
	00		 mov	 WORD PTR ?pm@@3VPMachine@@A+2, ax

; 570  : 	
; 571  : 				//	push the selector, # of Args, ptr to arg list
; 572  : 				pmPushMany( arg(3), nArgs, &arg(4));

  010a2	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  010a5	83 c0 08	 add	 eax, 8
  010a8	50		 push	 eax
  010a9	8b 4d a0	 mov	 ecx, DWORD PTR _nArgs$58577[ebp]
  010ac	51		 push	 ecx
  010ad	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  010b0	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  010b4	50		 push	 eax
  010b5	e8 00 00 00 00	 call	 ?pmPushMany@@YAXGIPAF@Z	; pmPushMany
  010ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 573  : 	
; 574  : 				//	call the method
; 575  : 				// MUST be cast as short or else CPP converts them signed (Bryan Waters)
; 576  : 				pmQuickMessage( (unsigned short) obj, (unsigned short) nArgChars, pm.StackPtr);

  010bd	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR ?pm@@3VPMachine@@A+12
  010c3	51		 push	 ecx
  010c4	8b 55 9c	 mov	 edx, DWORD PTR _nArgChars$58578[ebp]
  010c7	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  010cd	52		 push	 edx
  010ce	8d 4d a4	 lea	 ecx, DWORD PTR _obj$58568[ebp]
  010d1	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  010d6	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  010db	50		 push	 eax
  010dc	e8 00 00 00 00	 call	 ?pmQuickMessage@@YAXIIPAX@Z ; pmQuickMessage
  010e1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 577  : 		
; 578  : 				if ( !list.IsValid() || list.GetMemType() != MemList )  

  010e4	8d 4d ac	 lea	 ecx, DWORD PTR _list$58560[ebp]
  010e7	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  010ec	85 c0		 test	 eax, eax
  010ee	74 0d		 je	 SHORT $L58583
  010f0	8d 4d ac	 lea	 ecx, DWORD PTR _list$58560[ebp]
  010f3	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  010f8	83 f8 38	 cmp	 eax, 56			; 00000038H
  010fb	74 2b		 je	 SHORT $L58582
$L58583:

; 579  : 					msgMgr->Fatal ( "%s(%d): list handle 0x%x is invalid", __FILE__, __LINE__, (SOL_Handle)list );

  010fd	8d 4d ac	 lea	 ecx, DWORD PTR _list$58560[ebp]
  01100	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  01105	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0110a	50		 push	 eax
  0110b	68 43 02 00 00	 push	 579			; 00000243H
  01110	68 00 00 00 00	 push	 OFFSET FLAT:$SG58585
  01115	68 00 00 00 00	 push	 OFFSET FLAT:$SG58586
  0111a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  0111f	50		 push	 eax
  01120	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  01125	83 c4 14	 add	 esp, 20			; 00000014H
$L58582:

; 580  : 
; 581  : 				if (pm.acc) {

  01128	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?pm@@3VPMachine@@A+4, 0
  0112f	74 14		 je	 SHORT $L58587

; 582  : 					pm.acc = obj;

  01131	8d 4d a4	 lea	 ecx, DWORD PTR _obj$58568[ebp]
  01134	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  01139	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0113e	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 583  : 					break;

  01143	eb 05		 jmp	 SHORT $L58572
$L58587:

; 585  : 			}

  01145	e9 bc fe ff ff	 jmp	 $L58571
$L58572:

; 586  : 
; 587  : 			//	restore current object
; 588  : 			pm.object = saveObject;

  0114a	8d 4d b0	 lea	 ecx, DWORD PTR _saveObject$58567[ebp]
  0114d	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  01152	66 a3 02 00 00
	00		 mov	 WORD PTR ?pm@@3VPMachine@@A+2, ax

; 590  : 
; 591  : 		break;

  01158	e9 7b 03 00 00	 jmp	 $L58407
$L58588:

; 594  : 			SOL_ListID list = arg(2);

  0115d	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  01160	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  01164	52		 push	 edx
  01165	8d 4d 94	 lea	 ecx, DWORD PTR _list$58589[ebp]
  01168	e8 00 00 00 00	 call	 ??0SOL_ListID@@QAE@G@Z	; SOL_ListID::SOL_ListID

; 595  : 
; 596  : 			//	an empty list is "all true," apparently
; 597  : 			pm.acc = True;

  0116d	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, 1

; 598  : 	
; 599  : 			if ( !list )

  01177	8d 4d 94	 lea	 ecx, DWORD PTR _list$58589[ebp]
  0117a	e8 00 00 00 00	 call	 ??7MemID@@QBEHXZ	; MemID::operator!
  0117f	85 c0		 test	 eax, eax
  01181	74 05		 je	 SHORT $L58590

; 600  : 				break;

  01183	e9 50 03 00 00	 jmp	 $L58407
$L58590:

; 601  : 
; 602  : 			if ( !list.IsValid() || list.GetMemType() != MemList )  

  01188	8d 4d 94	 lea	 ecx, DWORD PTR _list$58589[ebp]
  0118b	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  01190	85 c0		 test	 eax, eax
  01192	74 0d		 je	 SHORT $L58592
  01194	8d 4d 94	 lea	 ecx, DWORD PTR _list$58589[ebp]
  01197	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  0119c	83 f8 38	 cmp	 eax, 56			; 00000038H
  0119f	74 2b		 je	 SHORT $L58591
$L58592:

; 603  : 				msgMgr->Fatal ( "%s(%d): list handle 0x%x is invalid", __FILE__, __LINE__, (SOL_Handle)list );

  011a1	8d 4d 94	 lea	 ecx, DWORD PTR _list$58589[ebp]
  011a4	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  011a9	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  011ae	50		 push	 eax
  011af	68 5b 02 00 00	 push	 603			; 0000025bH
  011b4	68 00 00 00 00	 push	 OFFSET FLAT:$SG58594
  011b9	68 00 00 00 00	 push	 OFFSET FLAT:$SG58595
  011be	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  011c3	50		 push	 eax
  011c4	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  011c9	83 c4 14	 add	 esp, 20			; 00000014H
$L58591:

; 604  : 
; 605  : 			ObjectID saveObject = pm.object;

  011cc	66 8b 0d 02 00
	00 00		 mov	 cx, WORD PTR ?pm@@3VPMachine@@A+2
  011d3	51		 push	 ecx
  011d4	8d 4d 98	 lea	 ecx, DWORD PTR _saveObject$58596[ebp]
  011d7	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID

; 606  : 			ObjectID obj;

  011dc	8d 4d 8c	 lea	 ecx, DWORD PTR _obj$58597[ebp]
  011df	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@XZ	; ObjectID::ObjectID

; 607  : 
; 608  : 			for ( int i=0; i<list->size(); i++ ) {

  011e4	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _i$58598[ebp], 0
  011eb	eb 09		 jmp	 SHORT $L58599
$L58600:
  011ed	8b 55 90	 mov	 edx, DWORD PTR _i$58598[ebp]
  011f0	83 c2 01	 add	 edx, 1
  011f3	89 55 90	 mov	 DWORD PTR _i$58598[ebp], edx
$L58599:
  011f6	8d 4d 94	 lea	 ecx, DWORD PTR _list$58589[ebp]
  011f9	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  011fe	8b c8		 mov	 ecx, eax
  01200	e8 00 00 00 00	 call	 ?size@SOL_List@@QAEAAHXZ ; SOL_List::size
  01205	8b 4d 90	 mov	 ecx, DWORD PTR _i$58598[ebp]
  01208	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0120a	0f 8d 19 01 00
	00		 jge	 $L58601

; 609  : 				obj = (ObjectID)list->at ( i );

  01210	8b 55 90	 mov	 edx, DWORD PTR _i$58598[ebp]
  01213	52		 push	 edx
  01214	8d 4d 94	 lea	 ecx, DWORD PTR _list$58589[ebp]
  01217	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  0121c	8b c8		 mov	 ecx, eax
  0121e	e8 00 00 00 00	 call	 ?at@SOL_List@@QAEGH@Z	; SOL_List::at
  01223	50		 push	 eax
  01224	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR $T58791[ebp]
  0122a	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  0122f	66 8b 00	 mov	 ax, WORD PTR [eax]
  01232	66 89 45 8c	 mov	 WORD PTR _obj$58597[ebp], ax

; 610  : 
; 611  : 				if ( !obj.IsObject() ) {

  01236	8d 4d 8c	 lea	 ecx, DWORD PTR _obj$58597[ebp]
  01239	e8 00 00 00 00	 call	 ?IsObject@ObjectID@@QBEHXZ ; ObjectID::IsObject
  0123e	85 c0		 test	 eax, eax
  01240	75 23		 jne	 SHORT $L58604

; 612  : 					list->del ( (SCIUWord)obj );

  01242	8d 4d 8c	 lea	 ecx, DWORD PTR _obj$58597[ebp]
  01245	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  0124a	50		 push	 eax
  0124b	8d 4d 94	 lea	 ecx, DWORD PTR _list$58589[ebp]
  0124e	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  01253	8b c8		 mov	 ecx, eax
  01255	e8 00 00 00 00	 call	 ?del@SOL_List@@QAEHG@Z	; SOL_List::del

; 613  : 					i--;

  0125a	8b 4d 90	 mov	 ecx, DWORD PTR _i$58598[ebp]
  0125d	83 e9 01	 sub	 ecx, 1
  01260	89 4d 90	 mov	 DWORD PTR _i$58598[ebp], ecx

; 614  : 					continue;

  01263	eb 88		 jmp	 SHORT $L58600
$L58604:

; 616  : 
; 617  : 				int nArgs = argCount - 3;

  01265	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  01268	0f bf 02	 movsx	 eax, WORD PTR [edx]
  0126b	83 e8 03	 sub	 eax, 3
  0126e	89 45 88	 mov	 DWORD PTR _nArgs$58606[ebp], eax

; 618  : 	
; 619  : 				// add 1 for selector and 1 for # args
; 620  : 				int nArgChars = (nArgs + 2) * sizeof(Property);

  01271	8b 4d 88	 mov	 ecx, DWORD PTR _nArgs$58606[ebp]
  01274	8d 54 09 04	 lea	 edx, DWORD PTR [ecx+ecx+4]
  01278	89 55 84	 mov	 DWORD PTR _nArgChars$58607[ebp], edx

; 621  : 	
; 622  : 				//	set new current object
; 623  : 				pm.object = obj;

  0127b	8d 4d 8c	 lea	 ecx, DWORD PTR _obj$58597[ebp]
  0127e	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  01283	66 a3 02 00 00
	00		 mov	 WORD PTR ?pm@@3VPMachine@@A+2, ax

; 624  : 	
; 625  : 				//	push the selector, # of Args, ptr to arg list
; 626  : 				pmPushMany( arg(3), nArgs, &arg(4));

  01289	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  0128c	83 c0 08	 add	 eax, 8
  0128f	50		 push	 eax
  01290	8b 4d 88	 mov	 ecx, DWORD PTR _nArgs$58606[ebp]
  01293	51		 push	 ecx
  01294	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  01297	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  0129b	50		 push	 eax
  0129c	e8 00 00 00 00	 call	 ?pmPushMany@@YAXGIPAF@Z	; pmPushMany
  012a1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 627  : 	
; 628  : 				//	call the method
; 629  : 				// MUST be cast as short or else CPP converts them signed (Bryan Waters)
; 630  : 				pmQuickMessage( (unsigned short) obj, (unsigned short) nArgChars, pm.StackPtr);

  012a4	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR ?pm@@3VPMachine@@A+12
  012aa	51		 push	 ecx
  012ab	8b 55 84	 mov	 edx, DWORD PTR _nArgChars$58607[ebp]
  012ae	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  012b4	52		 push	 edx
  012b5	8d 4d 8c	 lea	 ecx, DWORD PTR _obj$58597[ebp]
  012b8	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  012bd	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  012c2	50		 push	 eax
  012c3	e8 00 00 00 00	 call	 ?pmQuickMessage@@YAXIIPAX@Z ; pmQuickMessage
  012c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 631  : 		
; 632  : 				if ( !list.IsValid() || list.GetMemType() != MemList )  

  012cb	8d 4d 94	 lea	 ecx, DWORD PTR _list$58589[ebp]
  012ce	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  012d3	85 c0		 test	 eax, eax
  012d5	74 0d		 je	 SHORT $L58612
  012d7	8d 4d 94	 lea	 ecx, DWORD PTR _list$58589[ebp]
  012da	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  012df	83 f8 38	 cmp	 eax, 56			; 00000038H
  012e2	74 2b		 je	 SHORT $L58611
$L58612:

; 633  : 					msgMgr->Fatal ( "%s(%d): list handle 0x%x is invalid", __FILE__, __LINE__, (SOL_Handle)list );

  012e4	8d 4d 94	 lea	 ecx, DWORD PTR _list$58589[ebp]
  012e7	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  012ec	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  012f1	50		 push	 eax
  012f2	68 79 02 00 00	 push	 633			; 00000279H
  012f7	68 00 00 00 00	 push	 OFFSET FLAT:$SG58614
  012fc	68 00 00 00 00	 push	 OFFSET FLAT:$SG58615
  01301	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  01306	50		 push	 eax
  01307	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  0130c	83 c4 14	 add	 esp, 20			; 00000014H
$L58611:

; 634  : 
; 635  : 				if (!pm.acc) {

  0130f	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?pm@@3VPMachine@@A+4, 0
  01316	75 0c		 jne	 SHORT $L58616

; 636  : 					pm.acc = False;

  01318	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, 0

; 637  : 					break;

  01322	eb 05		 jmp	 SHORT $L58601
$L58616:

; 639  : 			}

  01324	e9 c4 fe ff ff	 jmp	 $L58600
$L58601:

; 640  : 
; 641  : 			//	restore current object
; 642  : 			pm.object = saveObject;

  01329	8d 4d 98	 lea	 ecx, DWORD PTR _saveObject$58596[ebp]
  0132c	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  01331	66 a3 02 00 00
	00		 mov	 WORD PTR ?pm@@3VPMachine@@A+2, ax

; 644  : 
; 645  : 		break;

  01337	e9 9c 01 00 00	 jmp	 $L58407
$L58617:

; 648  : 			SOL_ListID list = arg(2);

  0133c	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  0133f	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  01343	52		 push	 edx
  01344	8d 4d 80	 lea	 ecx, DWORD PTR _list$58618[ebp]
  01347	e8 00 00 00 00	 call	 ??0SOL_ListID@@QAE@G@Z	; SOL_ListID::SOL_ListID

; 649  : 
; 650  : 			if ( !list )

  0134c	8d 4d 80	 lea	 ecx, DWORD PTR _list$58618[ebp]
  0134f	e8 00 00 00 00	 call	 ??7MemID@@QBEHXZ	; MemID::operator!
  01354	85 c0		 test	 eax, eax
  01356	74 05		 je	 SHORT $L58619

; 651  : 				break;

  01358	e9 7b 01 00 00	 jmp	 $L58407
$L58619:

; 652  : 
; 653  : 			if ( !list.IsValid() || list.GetMemType() != MemList )  

  0135d	8d 4d 80	 lea	 ecx, DWORD PTR _list$58618[ebp]
  01360	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  01365	85 c0		 test	 eax, eax
  01367	74 0d		 je	 SHORT $L58621
  01369	8d 4d 80	 lea	 ecx, DWORD PTR _list$58618[ebp]
  0136c	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  01371	83 f8 38	 cmp	 eax, 56			; 00000038H
  01374	74 2b		 je	 SHORT $L58620
$L58621:

; 654  : 				msgMgr->Fatal ( "%s(%d): list handle 0x%x is invalid", __FILE__, __LINE__, (SOL_Handle)list );

  01376	8d 4d 80	 lea	 ecx, DWORD PTR _list$58618[ebp]
  01379	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  0137e	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  01383	50		 push	 eax
  01384	68 8e 02 00 00	 push	 654			; 0000028eH
  01389	68 00 00 00 00	 push	 OFFSET FLAT:$SG58623
  0138e	68 00 00 00 00	 push	 OFFSET FLAT:$SG58624
  01393	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  01398	50		 push	 eax
  01399	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  0139e	83 c4 14	 add	 esp, 20			; 00000014H
$L58620:

; 655  : 
; 656  : 			if ( arg(3) == -1 ) 

  013a1	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  013a4	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  013a8	83 fa ff	 cmp	 edx, -1
  013ab	75 3c		 jne	 SHORT $L58625

; 657  : 				list->sortByValue ( argCount > 3 ? arg(4) : False );

  013ad	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  013b0	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  013b3	83 f9 03	 cmp	 ecx, 3
  013b6	7e 0f		 jle	 SHORT $L58792
  013b8	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  013bb	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  013bf	89 85 5c ff ff
	ff		 mov	 DWORD PTR -164+[ebp], eax
  013c5	eb 0a		 jmp	 SHORT $L58793
$L58792:
  013c7	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR -164+[ebp], 0
$L58793:
  013d1	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR -164+[ebp]
  013d7	51		 push	 ecx
  013d8	8d 4d 80	 lea	 ecx, DWORD PTR _list$58618[ebp]
  013db	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  013e0	8b c8		 mov	 ecx, eax
  013e2	e8 00 00 00 00	 call	 ?sortByValue@SOL_List@@QAEXH@Z ; SOL_List::sortByValue

; 658  : 			else

  013e7	eb 42		 jmp	 SHORT $L58626
$L58625:

; 659  : 				list->sortByProperty ( arg(3), argCount > 3 ? arg(4) : False );

  013e9	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  013ec	0f bf 02	 movsx	 eax, WORD PTR [edx]
  013ef	83 f8 03	 cmp	 eax, 3
  013f2	7e 0f		 jle	 SHORT $L58794
  013f4	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  013f7	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  013fb	89 95 58 ff ff
	ff		 mov	 DWORD PTR -168+[ebp], edx
  01401	eb 0a		 jmp	 SHORT $L58795
$L58794:
  01403	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR -168+[ebp], 0
$L58795:
  0140d	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR -168+[ebp]
  01413	50		 push	 eax
  01414	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  01417	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  0141b	52		 push	 edx
  0141c	8d 4d 80	 lea	 ecx, DWORD PTR _list$58618[ebp]
  0141f	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  01424	8b c8		 mov	 ecx, eax
  01426	e8 00 00 00 00	 call	 ?sortByProperty@SOL_List@@QAEXHH@Z ; SOL_List::sortByProperty
$L58626:

; 661  : 
; 662  : 		break;

  0142b	e9 a8 00 00 00	 jmp	 $L58407
$L58627:

; 665  : 			SOL_ListID list = arg(2);

  01430	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  01433	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  01437	51		 push	 ecx
  01438	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _list$58628[ebp]
  0143e	e8 00 00 00 00	 call	 ??0SOL_ListID@@QAE@G@Z	; SOL_ListID::SOL_ListID

; 666  : 
; 667  : 			if ( !list ) {

  01443	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _list$58628[ebp]
  01449	e8 00 00 00 00	 call	 ??7MemID@@QBEHXZ	; MemID::operator!
  0144e	85 c0		 test	 eax, eax
  01450	74 0c		 je	 SHORT $L58629

; 668  : 				pm.acc = 0;

  01452	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, 0

; 669  : 				break;

  0145c	eb 7a		 jmp	 SHORT $L58407
$L58629:

; 671  : 
; 672  : 			if ( !list.IsValid() || list.GetMemType() != MemList )  

  0145e	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _list$58628[ebp]
  01464	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  01469	85 c0		 test	 eax, eax
  0146b	74 10		 je	 SHORT $L58631
  0146d	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _list$58628[ebp]
  01473	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  01478	83 f8 38	 cmp	 eax, 56			; 00000038H
  0147b	74 2f		 je	 SHORT $L58630
$L58631:

; 673  : 				msgMgr->Fatal ( "%s(%d): list handle 0x%x is invalid", __FILE__, __LINE__, (SOL_Handle)list );

  0147d	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _list$58628[ebp]
  01483	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  01488	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0148d	50		 push	 eax
  0148e	68 a1 02 00 00	 push	 673			; 000002a1H
  01493	68 00 00 00 00	 push	 OFFSET FLAT:$SG58633
  01498	68 00 00 00 00	 push	 OFFSET FLAT:$SG58634
  0149d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  014a3	52		 push	 edx
  014a4	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  014a9	83 c4 14	 add	 esp, 20			; 00000014H
$L58630:

; 674  : 
; 675  : 			pm.acc = (Acc)list->size();

  014ac	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _list$58628[ebp]
  014b2	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  014b7	8b c8		 mov	 ecx, eax
  014b9	e8 00 00 00 00	 call	 ?size@SOL_List@@QAEAAHXZ ; SOL_List::size
  014be	8b 00		 mov	 eax, DWORD PTR [eax]
  014c0	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 676  : 
; 677  : 			if ( pm.acc < 0 )

  014c5	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?pm@@3VPMachine@@A+4, 0
  014cc	7d 0a		 jge	 SHORT $L58636

; 678  : 				pm.acc = 0;

  014ce	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, 0
$L58636:
$L58407:

; 683  : }

  014d8	8b e5		 mov	 esp, ebp
  014da	5d		 pop	 ebp
  014db	c3		 ret	 0
$L58796:
  014dc	00 00 00 00	 DD	 $L58410
  014e0	00 00 00 00	 DD	 $L58422
  014e4	00 00 00 00	 DD	 $L58431
  014e8	00 00 00 00	 DD	 $L58433
  014ec	00 00 00 00	 DD	 $L58435
  014f0	00 00 00 00	 DD	 $L58437
  014f4	00 00 00 00	 DD	 $L58446
  014f8	00 00 00 00	 DD	 $L58448
  014fc	00 00 00 00	 DD	 $L58450
  01500	00 00 00 00	 DD	 $L58452
  01504	00 00 00 00	 DD	 $L58460
  01508	00 00 00 00	 DD	 $L58468
  0150c	00 00 00 00	 DD	 $L58476
  01510	00 00 00 00	 DD	 $L58484
  01514	00 00 00 00	 DD	 $L58492
  01518	00 00 00 00	 DD	 $L58500
  0151c	00 00 00 00	 DD	 $L58502
  01520	00 00 00 00	 DD	 $L58510
  01524	00 00 00 00	 DD	 $L58518
  01528	00 00 00 00	 DD	 $L58526
  0152c	00 00 00 00	 DD	 $L58559
  01530	00 00 00 00	 DD	 $L58588
  01534	00 00 00 00	 DD	 $L58617
  01538	00 00 00 00	 DD	 $L58627
?KList@@YAXPAF@Z ENDP					; KList
_TEXT	ENDS
EXTRN	?Free@MemoryMgr@@QAEXG@Z:NEAR			; MemoryMgr::Free
;	COMDAT ?Free@MemID@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Free@MemID@@QAEXXZ PROC NEAR				; MemID::Free, COMDAT

; 32   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 33   : 		if (handle) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000f	85 c9		 test	 ecx, ecx
  00011	74 1a		 je	 SHORT $L54807

; 34   : 			memMgr->Free(handle);

  00013	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00016	66 8b 02	 mov	 ax, WORD PTR [edx]
  00019	50		 push	 eax
  0001a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00020	e8 00 00 00 00	 call	 ?Free@MemoryMgr@@QAEXG@Z ; MemoryMgr::Free

; 35   : 			handle = 0;

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	66 c7 01 00 00	 mov	 WORD PTR [ecx], 0
$L54807:

; 37   : 	}

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?Free@MemID@@QAEXXZ ENDP				; MemID::Free
_TEXT	ENDS
;	COMDAT ??DFakeSOL_ListID@@QBEPAVSOL_List@@XZ
_TEXT	SEGMENT
_this$ = -4
??DFakeSOL_ListID@@QBEPAVSOL_List@@XZ PROC NEAR		; FakeSOL_ListID::operator*, COMDAT

; 84   : FakeTemplateID(FakeSOL_ListID, SOL_List, MemList)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??DFakeSOL_ListID@@QBEPAVSOL_List@@XZ ENDP		; FakeSOL_ListID::operator*
_TEXT	ENDS
;	COMDAT ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ
_TEXT	SEGMENT
_this$ = -4
??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ PROC NEAR		; FakeSOL_ListID::operator->, COMDAT

; 84   : FakeTemplateID(FakeSOL_ListID, SOL_List, MemList)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ENDP		; FakeSOL_ListID::operator->
_TEXT	ENDS
PUBLIC	??0FakeSOL_ListID@@QAE@XZ			; FakeSOL_ListID::FakeSOL_ListID
;	COMDAT ??0SOL_ListID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0SOL_ListID@@QAE@XZ PROC NEAR				; SOL_ListID::SOL_ListID, COMDAT

; 86   : 	SOL_ListID() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0FakeSOL_ListID@@QAE@XZ ; FakeSOL_ListID::FakeSOL_ListID
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0SOL_ListID@@QAE@XZ ENDP				; SOL_ListID::SOL_ListID
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0FakeSOL_ListID@@QAE@XZ PROC NEAR			; FakeSOL_ListID::FakeSOL_ListID, COMDAT

; 84   : FakeTemplateID(FakeSOL_ListID, SOL_List, MemList)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0FakeSOL_ListID@@QAE@XZ ENDP				; FakeSOL_ListID::FakeSOL_ListID
_TEXT	ENDS
PUBLIC	??0FakeSOL_ListID@@QAE@G@Z			; FakeSOL_ListID::FakeSOL_ListID
;	COMDAT ??0SOL_ListID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0SOL_ListID@@QAE@G@Z PROC NEAR			; SOL_ListID::SOL_ListID, COMDAT

; 88   : 	SOL_ListID(SOL_Handle h) : FakeSOL_ListID(h) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	66 8b 45 08	 mov	 ax, WORD PTR _h$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0FakeSOL_ListID@@QAE@G@Z ; FakeSOL_ListID::FakeSOL_ListID
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0SOL_ListID@@QAE@G@Z ENDP				; SOL_ListID::SOL_ListID
_TEXT	ENDS
PUBLIC	??0MemID@@QAE@G@Z				; MemID::MemID
;	COMDAT ??0FakeSOL_ListID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0FakeSOL_ListID@@QAE@G@Z PROC NEAR			; FakeSOL_ListID::FakeSOL_ListID, COMDAT

; 84   : FakeTemplateID(FakeSOL_ListID, SOL_List, MemList)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	66 8b 45 08	 mov	 ax, WORD PTR _h$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0FakeSOL_ListID@@QAE@G@Z ENDP				; FakeSOL_ListID::FakeSOL_ListID
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0MemID@@QAE@G@Z PROC NEAR				; MemID::MemID, COMDAT

; 23   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 4d 08	 mov	 cx, WORD PTR _h$[ebp]
  0000e	66 89 08	 mov	 WORD PTR [eax], cx

; 24   : 	}

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??0MemID@@QAE@G@Z ENDP					; MemID::MemID
_TEXT	ENDS
PUBLIC	??2@YAPAXIG@Z					; operator new
PUBLIC	??0SOL_List@@QAE@XZ				; SOL_List::SOL_List
;	COMDAT ?Get@SOL_ListID@@QAEXXZ
_TEXT	SEGMENT
$T58806 = -4
_this$ = -8
?Get@SOL_ListID@@QAEXXZ PROC NEAR			; SOL_ListID::Get, COMDAT

; 92   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 93   : 		MemID::Get ( MemList, sizeof ( SOL_List ), LOCKED, 0, 0, 0, IllegalHandle );

  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 00		 push	 0
  0000f	6a 00		 push	 0
  00011	6a 00		 push	 0
  00013	6a 08		 push	 8
  00015	6a 38		 push	 56			; 00000038H
  00017	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get

; 94   : 		new(handle) SOL_List;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	66 8b 08	 mov	 cx, WORD PTR [eax]
  00025	51		 push	 ecx
  00026	6a 08		 push	 8
  00028	e8 00 00 00 00	 call	 ??2@YAPAXIG@Z		; operator new
  0002d	83 c4 08	 add	 esp, 8
  00030	89 45 fc	 mov	 DWORD PTR $T58806[ebp], eax
  00033	83 7d fc 00	 cmp	 DWORD PTR $T58806[ebp], 0
  00037	74 0d		 je	 SHORT $L58807
  00039	8b 4d fc	 mov	 ecx, DWORD PTR $T58806[ebp]
  0003c	e8 00 00 00 00	 call	 ??0SOL_List@@QAE@XZ	; SOL_List::SOL_List
  00041	89 45 f4	 mov	 DWORD PTR -12+[ebp], eax
  00044	eb 07		 jmp	 SHORT $L58808
$L58807:
  00046	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR -12+[ebp], 0
$L58808:

; 95   : 	}

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
?Get@SOL_ListID@@QAEXXZ ENDP				; SOL_ListID::Get
_TEXT	ENDS
;	COMDAT ??2@YAPAXIG@Z
_TEXT	SEGMENT
_handle$ = 12
??2@YAPAXIG@Z PROC NEAR					; operator new, COMDAT

; 186  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 	return memMgr->GetAddr(handle);

  00003	66 8b 45 0c	 mov	 ax, WORD PTR _handle$[ebp]
  00007	50		 push	 eax
  00008	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  0000e	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr

; 188  : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??2@YAPAXIG@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??0Array@@QAE@XZ				; Array::Array
PUBLIC	??1Array@@QAE@XZ				; Array::~Array
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File \\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\list.hpp
xdata$x	SEGMENT
$T58815	DD	019930520H
	DD	01H
	DD	FLAT:$T58818
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T58818	DD	0ffffffffH
	DD	FLAT:$L58811
xdata$x	ENDS
;	COMDAT ??0SOL_List@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??0SOL_List@@QAE@XZ PROC NEAR				; SOL_List::SOL_List, COMDAT

; 19   : 	SOL_List() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 $L58816
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??0Array@@QAE@XZ	; Array::Array
  00024	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 20   : 		size() = 0;

  0002b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?size@SOL_List@@QAEAAHXZ ; SOL_List::size
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 21   : 	} 

  00039	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00040	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00046	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L58811:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e8 00 00 00 00	 call	 ??1Array@@QAE@XZ	; Array::~Array
  00008	c3		 ret	 0
$L58816:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T58815
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0SOL_List@@QAE@XZ ENDP				; SOL_List::SOL_List
;	COMDAT ??0Array@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8
??0Array@@QAE@XZ PROC NEAR				; Array::Array, COMDAT

; 74   : 	Array() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID

; 75   : 		dataID ( 0 );

  00011	51		 push	 ecx
  00012	8b cc		 mov	 ecx, esp
  00014	6a 00		 push	 0
  00016	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?dataID@Array@@QAEXVMemID@@@Z ; Array::dataID

; 76   : 	}

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??0Array@@QAE@XZ ENDP					; Array::Array
_TEXT	ENDS
;	COMDAT ??1Array@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1Array@@QAE@XZ PROC NEAR				; Array::~Array, COMDAT

; 88   : 	~Array() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1Array@@QAE@XZ ENDP					; Array::~Array
_TEXT	ENDS
PUBLIC	??0FakeObjectID@@QAE@XZ				; FakeObjectID::FakeObjectID
;	COMDAT ??0ObjectID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0ObjectID@@QAE@XZ PROC NEAR				; ObjectID::ObjectID, COMDAT

; 227  : 	ObjectID() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0FakeObjectID@@QAE@XZ	; FakeObjectID::FakeObjectID
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0ObjectID@@QAE@XZ ENDP				; ObjectID::ObjectID
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0FakeObjectID@@QAE@XZ PROC NEAR			; FakeObjectID::FakeObjectID, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0FakeObjectID@@QAE@XZ ENDP				; FakeObjectID::FakeObjectID
_TEXT	ENDS
PUBLIC	??0FakeObjectID@@QAE@G@Z			; FakeObjectID::FakeObjectID
;	COMDAT ??0ObjectID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0ObjectID@@QAE@G@Z PROC NEAR				; ObjectID::ObjectID, COMDAT

; 230  : 	ObjectID(SOL_Handle h) : FakeObjectID(h) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	66 8b 45 08	 mov	 ax, WORD PTR _h$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0FakeObjectID@@QAE@G@Z ; FakeObjectID::FakeObjectID
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0ObjectID@@QAE@G@Z ENDP				; ObjectID::ObjectID
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0FakeObjectID@@QAE@G@Z PROC NEAR			; FakeObjectID::FakeObjectID, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	66 8b 45 08	 mov	 ax, WORD PTR _h$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0FakeObjectID@@QAE@G@Z ENDP				; FakeObjectID::FakeObjectID
_TEXT	ENDS
PUBLIC	??0FakeSOL_ListID@@QAE@ABU0@@Z			; FakeSOL_ListID::FakeSOL_ListID
;	COMDAT ??0SOL_ListID@@QAE@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0SOL_ListID@@QAE@ABU0@@Z PROC NEAR			; SOL_ListID::SOL_ListID, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0FakeSOL_ListID@@QAE@ABU0@@Z ; FakeSOL_ListID::FakeSOL_ListID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0SOL_ListID@@QAE@ABU0@@Z ENDP				; SOL_ListID::SOL_ListID
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0FakeSOL_ListID@@QAE@ABU0@@Z PROC NEAR		; FakeSOL_ListID::FakeSOL_ListID, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0FakeSOL_ListID@@QAE@ABU0@@Z ENDP			; FakeSOL_ListID::FakeSOL_ListID
_TEXT	ENDS
END
