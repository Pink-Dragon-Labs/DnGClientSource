	TITLE	\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Message.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_07CCG@ResView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KCEF@?4v56?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06IAEF@ResPic?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04EODC@?4p56?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08OCKJ@ResChunk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PIPI@?4chk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07ICMB@ResHunk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GG@?4scr?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08BLBP@ResSound?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KPDA@?4snd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NNMB@ResVocab?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PGDD@?4voc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FLKK@ResPatch?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CEHK@?4pat?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07MKGC@ResFont?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04IDCK@?4fon?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06DEEM@ResPal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NJLC@?4pal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07HFNL@ResHeap?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GFFD@?4hep?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06HDCC@ResMsg?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JONM@?4msg?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NFDN@ResAudio?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MOHF@?4aud?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BKMJ@ResWave?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MPDF@?4wav?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@IMEI@ResAudio36?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BONB@ResSync?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KFFK@?4syn?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09CBJE@ResSync36?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06MIEL@ResMap?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CFLF@?4map?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@LIAH@ResMsgTranslation?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JFJA@?4trn?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08JLOL@ResRobot?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04LLKI@?4rbt?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06OEMP@ResVMD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04IOID@?4vmd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MemoryMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckValid@MemoryMgr@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GMemoryMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@MemID@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@V1@III@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AMemID@@QBEAADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8MemID@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??7MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeArrayID@@QBEPAUArrayHeader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ArrayID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ArrayID@@QAE@HW4ArrayType@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@ArrayID@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Data@ArrayID@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAE?AVMemID@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAEXVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetExtension@SOL_ResType@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSupported@SOL_ResType@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAttrs@SOL_ResType@@UBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResView@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPic@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResChunk@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResScript@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSound@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResVocab@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPatch@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResFont@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPal@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResHeap@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMsg@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResAudio@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResWave@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResAudio36@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSync@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSync36@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMap@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMsgTranslation@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileType@ResMsgTranslation@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResRobot@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResVMD@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_List@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@SOL_List@@QAEAAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeDispatchTblID@@QBEPAUDispatchTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeScriptEntryID@@QBEPAUScriptEntry@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntry@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeVariableID@@QBEPAUVariable@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Script@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Object@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGraphicsUpdate@Object@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?selectorDict@Object@@QAEPAVSelectorDict@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AObject@@QAEAAFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddr@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedPropAddr@Object@@QAEPBFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedProperty@Object@@QAEFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddrCheck@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@Object@@QAEFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropOffset@Object@@QAEIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetIndexedProperty@Object@@QAEXHF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetProperty@Object@@QAEXGF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssureValid@ObjectID@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsObject@ObjectID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@ObjectID@@QBEFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeClassTblID@@QBEPAUClassTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DTextID@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@TextID@@QAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TextID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MsgStackID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MsgStackID@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DMsgStackID@@QBEPAUMsgStack@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MsgStackID@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7ResPic@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResView@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResPal@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResHeap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResWave@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResRobot@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResPatch@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMsgTranslation@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResScript@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSync36@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMsg@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResAudio36@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResAudio@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResFont@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7MemoryMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResVMD@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResChunk@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSync@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResVocab@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?messageMgr@@3UMessageMgr@@A			; messageMgr
_BSS	SEGMENT
?messageMgr@@3UMessageMgr@@A DB 01H DUP (?)		; messageMgr
_BSS	ENDS
CRT$XCU	SEGMENT
_$S7	DD	FLAT:_$E6
CRT$XCU	ENDS
_DATA	SEGMENT
_?hexDigits@?1??MassageText@@YAXPAD0@Z@4PADA DB '01234567890abcdef', 00H
_DATA	ENDS
_TEXT	SEGMENT
_$E6	PROC NEAR
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	e8 00 00 00 00	 call	 _$E5
  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
_$E6	ENDP
_TEXT	ENDS
PUBLIC	??0MsgStackStack@@QAE@XZ			; MsgStackStack::MsgStackStack
_BSS	SEGMENT
	ALIGN	4

_stackStack DB	0eH DUP (?)
_BSS	ENDS
_TEXT	SEGMENT
_$E5	PROC NEAR

; 81   : static MsgStackStack stackStack;

  0000a	55		 push	 ebp
  0000b	8b ec		 mov	 ebp, esp
  0000d	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_stackStack
  00012	e8 00 00 00 00	 call	 ??0MsgStackStack@@QAE@XZ ; MsgStackStack::MsgStackStack
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
_$E5	ENDP
_TEXT	ENDS
PUBLIC	?Push@MsgStackStack@@QAEXAAUMsgStack@@@Z	; MsgStackStack::Push
PUBLIC	?Pop@MsgStackStack@@QAE?AUMsgStack@@XZ		; MsgStackStack::Pop
PUBLIC	?KMessage@@YAXPAF@Z				; KMessage
PUBLIC	??0ArrayID@@QAE@G@Z				; ArrayID::ArrayID
PUBLIC	?Data@ArrayID@@QAEPAXXZ				; ArrayID::Data
PUBLIC	??0TextID@@QAE@ABV0@@Z				; TextID::TextID
EXTRN	?Fatal@MsgMgr@@QAAXDPADHHZZ:NEAR		; MsgMgr::Fatal
EXTRN	?msgMgr@@3PAVMsgMgr@@A:DWORD			; msgMgr
EXTRN	?pm@@3VPMachine@@A:BYTE				; pm
EXTRN	??0TextID@@QAE@G@Z:NEAR				; TextID::TextID
_BSS	SEGMENT
	ALIGN	4

_curModule DW	01H DUP (?)
	ALIGN	4

_curNoun DD	01H DUP (?)
_curVerb DD	01H DUP (?)
_curCond DD	01H DUP (?)
_curSeq	DD	01H DUP (?)
_stack	DB	02eH DUP (?)
_BSS	ENDS
_DATA	SEGMENT
	ORG $+2
$SG59698 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Mess'
	DB	'age.cpp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_args$ = 8
_rc$ = -4
_refNoun$59683 = -8
_refVerb$59684 = -12
_refCond$59685 = -16
_data$59693 = -20
$T60066 = -28
$T60070 = -36
$T60077 = -84
$T60078 = -88
?KMessage@@YAXPAF@Z PROC NEAR				; KMessage

; 118  : {

  00019	55		 push	 ebp
  0001a	8b ec		 mov	 ebp, esp
  0001c	83 ec 6c	 sub	 esp, 108		; 0000006cH
  0001f	56		 push	 esi
  00020	57		 push	 edi

; 119  : 	Bool	rc;
; 120  : 
; 121  : 	switch (arg(1)) {

  00021	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00024	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00028	89 4d a4	 mov	 DWORD PTR -92+[ebp], ecx
  0002b	83 7d a4 09	 cmp	 DWORD PTR -92+[ebp], 9
  0002f	0f 87 0b 02 00
	00		 ja	 $L59697
  00035	8b 55 a4	 mov	 edx, DWORD PTR -92+[ebp]
  00038	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L60079[edx*4]
$L59673:

; 122  : 		case MSG_GET:
; 123  : 			Get(	(ResNum) arg(2),							// module
; 124  : 					arg(3),										// noun
; 125  : 					arg(4),										// verb
; 126  : 					arg(5),										// case
; 127  : 					arg(6),										// sequence
; 128  : 					TextID(argCount < 7 ? 0 : arg(7))	// buffer
; 129  : 				);

  0003f	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00042	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00045	83 f9 07	 cmp	 ecx, 7
  00048	7d 09		 jge	 SHORT $L60067
  0004a	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR -96+[ebp], 0
  00051	eb 0a		 jmp	 SHORT $L60068
$L60067:
  00053	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00056	0f bf 42 0e	 movsx	 eax, WORD PTR [edx+14]
  0005a	89 45 a0	 mov	 DWORD PTR -96+[ebp], eax
$L60068:
  0005d	66 8b 4d a0	 mov	 cx, WORD PTR -96+[ebp]
  00061	51		 push	 ecx
  00062	8d 4d e4	 lea	 ecx, DWORD PTR $T60066[ebp]
  00065	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  0006a	51		 push	 ecx
  0006b	8b cc		 mov	 ecx, esp
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 ??0TextID@@QAE@ABV0@@Z	; TextID::TextID
  00073	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00076	8a 42 0c	 mov	 al, BYTE PTR [edx+12]
  00079	50		 push	 eax
  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  0007d	8a 51 0a	 mov	 dl, BYTE PTR [ecx+10]
  00080	52		 push	 edx
  00081	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00084	8a 48 08	 mov	 cl, BYTE PTR [eax+8]
  00087	51		 push	 ecx
  00088	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  0008b	8a 42 06	 mov	 al, BYTE PTR [edx+6]
  0008e	50		 push	 eax
  0008f	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00092	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  00096	52		 push	 edx
  00097	e8 00 00 00 00	 call	 ?Get@@YAXGEEEEVTextID@@@Z ; Get
  0009c	83 c4 18	 add	 esp, 24			; 00000018H

; 130  : 			break;

  0009f	e9 c1 01 00 00	 jmp	 $L59670
$L59677:

; 131  : 
; 132  : 		case MSG_NEXT:
; 133  : 			GetNext(TextID(argCount < 2 ? 0 : arg(2))); //	buffer

  000a4	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  000a7	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  000aa	83 f9 02	 cmp	 ecx, 2
  000ad	7d 09		 jge	 SHORT $L60071
  000af	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR -100+[ebp], 0
  000b6	eb 0a		 jmp	 SHORT $L60072
$L60071:
  000b8	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  000bb	0f bf 42 04	 movsx	 eax, WORD PTR [edx+4]
  000bf	89 45 9c	 mov	 DWORD PTR -100+[ebp], eax
$L60072:
  000c2	66 8b 4d 9c	 mov	 cx, WORD PTR -100+[ebp]
  000c6	51		 push	 ecx
  000c7	8d 4d dc	 lea	 ecx, DWORD PTR $T60070[ebp]
  000ca	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  000cf	51		 push	 ecx
  000d0	8b cc		 mov	 ecx, esp
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ??0TextID@@QAE@ABV0@@Z	; TextID::TextID
  000d8	e8 00 00 00 00	 call	 ?GetNext@@YAXVTextID@@@Z ; GetNext
  000dd	83 c4 04	 add	 esp, 4

; 134  : 			break;

  000e0	e9 80 01 00 00	 jmp	 $L59670
$L59680:

; 135  : 
; 136  : 		case MSG_SIZE:
; 137  : 			GetSize(	(ResNum) arg(2),	// module
; 138  : 						arg(3),				// noun
; 139  : 						arg(4),				// verb
; 140  : 						arg(5),				// case
; 141  : 						arg(6)				// sequence
; 142  : 					 );

  000e5	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  000e8	8a 42 0c	 mov	 al, BYTE PTR [edx+12]
  000eb	50		 push	 eax
  000ec	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  000ef	8a 51 0a	 mov	 dl, BYTE PTR [ecx+10]
  000f2	52		 push	 edx
  000f3	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  000f6	8a 48 08	 mov	 cl, BYTE PTR [eax+8]
  000f9	51		 push	 ecx
  000fa	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  000fd	8a 42 06	 mov	 al, BYTE PTR [edx+6]
  00100	50		 push	 eax
  00101	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00104	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  00108	52		 push	 edx
  00109	e8 00 00 00 00	 call	 ?GetSize@@YAXGEEEE@Z	; GetSize
  0010e	83 c4 14	 add	 esp, 20			; 00000014H

; 143  : 			break;

  00111	e9 4f 01 00 00	 jmp	 $L59670
$L59682:

; 144  : 		
; 145  : 		case MSG_GETREFNOUN:
; 146  : 		case MSG_GETREFVERB:
; 147  : 		case MSG_GETREFCASE:
; 148  : 			uchar	refNoun;
; 149  : 			uchar	refVerb;
; 150  : 			uchar	refCond;
; 151  : 			rc = GetRefValues((ResNum) arg(2),		// module
; 152  : 										 		arg(3),		// noun
; 153  : 										 		arg(4),		// verb
; 154  : 										 		arg(5),		// case
; 155  : 										 		arg(6),		// sequence
; 156  : 										 		&refNoun,
; 157  : 										 		&refVerb,
; 158  : 										 		&refCond
; 159  : 							 );

  00116	8d 45 f0	 lea	 eax, DWORD PTR _refCond$59685[ebp]
  00119	50		 push	 eax
  0011a	8d 4d f4	 lea	 ecx, DWORD PTR _refVerb$59684[ebp]
  0011d	51		 push	 ecx
  0011e	8d 55 f8	 lea	 edx, DWORD PTR _refNoun$59683[ebp]
  00121	52		 push	 edx
  00122	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00125	8a 48 0c	 mov	 cl, BYTE PTR [eax+12]
  00128	51		 push	 ecx
  00129	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  0012c	8a 42 0a	 mov	 al, BYTE PTR [edx+10]
  0012f	50		 push	 eax
  00130	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00133	8a 51 08	 mov	 dl, BYTE PTR [ecx+8]
  00136	52		 push	 edx
  00137	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  0013a	8a 48 06	 mov	 cl, BYTE PTR [eax+6]
  0013d	51		 push	 ecx
  0013e	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00141	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  00145	50		 push	 eax
  00146	e8 00 00 00 00	 call	 ?GetRefValues@@YAHGEEEEPAE00@Z ; GetRefValues
  0014b	83 c4 20	 add	 esp, 32			; 00000020H
  0014e	89 45 fc	 mov	 DWORD PTR _rc$[ebp], eax

; 160  : 			if (!rc)

  00151	83 7d fc 00	 cmp	 DWORD PTR _rc$[ebp], 0
  00155	75 0c		 jne	 SHORT $L59687

; 161  : 				pm.acc = -1;

  00157	c7 05 04 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, -1

; 162  : 			else 

  00161	eb 41		 jmp	 SHORT $L59688
$L59687:

; 163  : 				pm.acc = arg(1) == MSG_GETREFNOUN ? refNoun :
; 164  : 						   arg(1) == MSG_GETREFVERB ? refVerb :
; 165  : 						                              refCond;

  00163	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00166	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  0016a	83 fa 04	 cmp	 edx, 4
  0016d	75 08		 jne	 SHORT $L60075
  0016f	8a 45 f8	 mov	 al, BYTE PTR _refNoun$59683[ebp]
  00172	88 45 98	 mov	 BYTE PTR -104+[ebp], al
  00175	eb 20		 jmp	 SHORT $L60076
$L60075:
  00177	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  0017a	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  0017e	83 fa 05	 cmp	 edx, 5
  00181	75 08		 jne	 SHORT $L60073
  00183	8a 45 f4	 mov	 al, BYTE PTR _refVerb$59684[ebp]
  00186	88 45 97	 mov	 BYTE PTR -105+[ebp], al
  00189	eb 06		 jmp	 SHORT $L60074
$L60073:
  0018b	8a 4d f0	 mov	 cl, BYTE PTR _refCond$59685[ebp]
  0018e	88 4d 97	 mov	 BYTE PTR -105+[ebp], cl
$L60074:
  00191	8a 55 97	 mov	 dl, BYTE PTR -105+[ebp]
  00194	88 55 98	 mov	 BYTE PTR -104+[ebp], dl
$L60076:
  00197	8b 45 98	 mov	 eax, DWORD PTR -104+[ebp]
  0019a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0019f	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax
$L59688:

; 166  : 			break;

  001a4	e9 bc 00 00 00	 jmp	 $L59670
$L59689:

; 167  : 
; 168  : 		case MSG_PUSH:
; 169  : 			stackStack.Push(stack);

  001a9	68 00 00 00 00	 push	 OFFSET FLAT:_stack
  001ae	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_stackStack
  001b3	e8 00 00 00 00	 call	 ?Push@MsgStackStack@@QAEXAAUMsgStack@@@Z ; MsgStackStack::Push

; 170  : 			break;

  001b8	e9 a8 00 00 00	 jmp	 $L59670
$L59690:

; 171  : 			
; 172  : 		case MSG_POP:
; 173  : 			stack = stackStack.Pop();

  001bd	8d 4d ac	 lea	 ecx, DWORD PTR $T60077[ebp]
  001c0	51		 push	 ecx
  001c1	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_stackStack
  001c6	e8 00 00 00 00	 call	 ?Pop@MsgStackStack@@QAE?AUMsgStack@@XZ ; MsgStackStack::Pop
  001cb	8b f0		 mov	 esi, eax
  001cd	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  001d2	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_stack
  001d7	f3 a5		 rep movsd
  001d9	66 a5		 movsw

; 174  : 			break;

  001db	e9 85 00 00 00	 jmp	 $L59670
$L59692:

; 178  : 			Property* data = (Property*) ((ArrayID) arg(2)).Data();

  001e0	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  001e3	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  001e7	50		 push	 eax
  001e8	8d 4d a8	 lea	 ecx, DWORD PTR $T60078[ebp]
  001eb	e8 00 00 00 00	 call	 ??0ArrayID@@QAE@G@Z	; ArrayID::ArrayID
  001f0	8b c8		 mov	 ecx, eax
  001f2	e8 00 00 00 00	 call	 ?Data@ArrayID@@QAEPAXXZ	; ArrayID::Data
  001f7	89 45 ec	 mov	 DWORD PTR _data$59693[ebp], eax

; 179  : 			data[0] = curModule;

  001fa	8b 4d ec	 mov	 ecx, DWORD PTR _data$59693[ebp]
  001fd	66 8b 15 00 00
	00 00		 mov	 dx, WORD PTR _curModule
  00204	66 89 11	 mov	 WORD PTR [ecx], dx

; 180  : 			data[1] = curNoun;

  00207	8b 45 ec	 mov	 eax, DWORD PTR _data$59693[ebp]
  0020a	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR _curNoun
  00211	66 89 48 02	 mov	 WORD PTR [eax+2], cx

; 181  : 			data[2] = curVerb;

  00215	8b 55 ec	 mov	 edx, DWORD PTR _data$59693[ebp]
  00218	66 a1 00 00 00
	00		 mov	 ax, WORD PTR _curVerb
  0021e	66 89 42 04	 mov	 WORD PTR [edx+4], ax

; 182  : 			data[3] = curCond;

  00222	8b 4d ec	 mov	 ecx, DWORD PTR _data$59693[ebp]
  00225	66 8b 15 00 00
	00 00		 mov	 dx, WORD PTR _curCond
  0022c	66 89 51 06	 mov	 WORD PTR [ecx+6], dx

; 183  : 			data[4] = curSeq;

  00230	8b 45 ec	 mov	 eax, DWORD PTR _data$59693[ebp]
  00233	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR _curSeq
  0023a	66 89 48 08	 mov	 WORD PTR [eax+8], cx

; 184  : 			break;

  0023e	eb 25		 jmp	 SHORT $L59670
$L59697:

; 186  : 		
; 187  : 		default:
; 188  : 			msgMgr->Fatal(SrcLoc, Msg_Message, arg(1));

  00240	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00243	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  00247	50		 push	 eax
  00248	6a 22		 push	 34			; 00000022H
  0024a	68 bc 00 00 00	 push	 188			; 000000bcH
  0024f	68 00 00 00 00	 push	 OFFSET FLAT:$SG59698
  00254	6a 61		 push	 97			; 00000061H
  00256	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  0025c	51		 push	 ecx
  0025d	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXDPADHHZZ ; MsgMgr::Fatal
  00262	83 c4 18	 add	 esp, 24			; 00000018H
$L59670:

; 190  : }

  00265	5f		 pop	 edi
  00266	5e		 pop	 esi
  00267	8b e5		 mov	 esp, ebp
  00269	5d		 pop	 ebp
  0026a	c3		 ret	 0
$L60079:
  0026b	00 00 00 00	 DD	 $L59673
  0026f	00 00 00 00	 DD	 $L59677
  00273	00 00 00 00	 DD	 $L59680
  00277	00 00 00 00	 DD	 $L59697
  0027b	00 00 00 00	 DD	 $L59682
  0027f	00 00 00 00	 DD	 $L59682
  00283	00 00 00 00	 DD	 $L59682
  00287	00 00 00 00	 DD	 $L59689
  0028b	00 00 00 00	 DD	 $L59690
  0028f	00 00 00 00	 DD	 $L59692
?KMessage@@YAXPAF@Z ENDP				; KMessage
_TEXT	ENDS
PUBLIC	??0FakeArrayID@@QAE@G@Z				; FakeArrayID::FakeArrayID
;	COMDAT ??0ArrayID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0ArrayID@@QAE@G@Z PROC NEAR				; ArrayID::ArrayID, COMDAT

; 38   : 	ArrayID(SOL_Handle h) : FakeArrayID(h) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	66 8b 45 08	 mov	 ax, WORD PTR _h$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0FakeArrayID@@QAE@G@Z	; FakeArrayID::FakeArrayID
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0ArrayID@@QAE@G@Z ENDP				; ArrayID::ArrayID
_TEXT	ENDS
PUBLIC	??0MemID@@QAE@G@Z				; MemID::MemID
;	COMDAT ??0FakeArrayID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0FakeArrayID@@QAE@G@Z PROC NEAR			; FakeArrayID::FakeArrayID, COMDAT

; 34   : FakeTemplateID ( FakeArrayID, ArrayHeader, MemArray )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	66 8b 45 08	 mov	 ax, WORD PTR _h$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0FakeArrayID@@QAE@G@Z ENDP				; FakeArrayID::FakeArrayID
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0MemID@@QAE@G@Z PROC NEAR				; MemID::MemID, COMDAT

; 23   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 4d 08	 mov	 cx, WORD PTR _h$[ebp]
  0000e	66 89 08	 mov	 WORD PTR [eax], cx

; 24   : 	}

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??0MemID@@QAE@G@Z ENDP					; MemID::MemID
_TEXT	ENDS
PUBLIC	??DFakeArrayID@@QBEPAUArrayHeader@@XZ		; FakeArrayID::operator*
;	COMDAT ?Data@ArrayID@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4
?Data@ArrayID@@QAEPAXXZ PROC NEAR			; ArrayID::Data, COMDAT

; 64   : 	void *Data ( void ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 65   : 		return ((char *)**this) + sizeof ( ArrayHeader );

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??DFakeArrayID@@QBEPAUArrayHeader@@XZ ; FakeArrayID::operator*
  0000f	83 c0 04	 add	 eax, 4

; 66   : 	}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?Data@ArrayID@@QAEPAXXZ ENDP				; ArrayID::Data
_TEXT	ENDS
PUBLIC	??DMemID@@QBEPAXXZ				; MemID::operator*
;	COMDAT ??DFakeArrayID@@QBEPAUArrayHeader@@XZ
_TEXT	SEGMENT
_this$ = -4
??DFakeArrayID@@QBEPAUArrayHeader@@XZ PROC NEAR		; FakeArrayID::operator*, COMDAT

; 34   : FakeTemplateID ( FakeArrayID, ArrayHeader, MemArray )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??DFakeArrayID@@QBEPAUArrayHeader@@XZ ENDP		; FakeArrayID::operator*
_TEXT	ENDS
PUBLIC	?GetAddr@MemoryMgr@@QAEPAXG@Z			; MemoryMgr::GetAddr
EXTRN	_memMgr:DWORD
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT
_this$ = -4
??DMemID@@QBEPAXXZ PROC NEAR				; MemID::operator*, COMDAT

; 98   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 99   : 		return memMgr->GetAddr(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr

; 100  : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??DMemID@@QBEPAXXZ ENDP					; MemID::operator*
_TEXT	ENDS
EXTRN	__descPtrTable:BYTE
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -4
?GetAddr@MemoryMgr@@QAEPAXG@Z PROC NEAR			; MemoryMgr::GetAddr, COMDAT

; 462  : 	inline void* MemoryMgr::GetAddr(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : //		CheckValid(theID);
; 464  : 		return _descPtrTable[(unsigned int)((unsigned short)theID)];

  00007	8b 45 08	 mov	 eax, DWORD PTR _theID$[ebp]
  0000a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0000f	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR __descPtrTable[eax*4]

; 465  : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?GetAddr@MemoryMgr@@QAEPAXG@Z ENDP			; MemoryMgr::GetAddr
_TEXT	ENDS
PUBLIC	??0MemID@@QAE@ABV0@@Z				; MemID::MemID
;	COMDAT ??0TextID@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0TextID@@QAE@ABV0@@Z PROC NEAR			; TextID::TextID, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0TextID@@QAE@ABV0@@Z ENDP				; TextID::TextID
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0MemID@@QAE@ABV0@@Z PROC NEAR				; MemID::MemID, COMDAT

; 19   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  0000d	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00010	66 89 10	 mov	 WORD PTR [eax], dx

; 20   : 	}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0MemID@@QAE@ABV0@@Z ENDP				; MemID::MemID
_TEXT	ENDS
PUBLIC	?Init@MsgStack@@QAEXGEEEE@Z			; MsgStack::Init
_TEXT	SEGMENT
_module$ = 8
_noun$ = 12
_verb$ = 16
_cond$ = 20
_seq$ = 24
_buffer$ = 28
?Get@@YAXGEEEEVTextID@@@Z PROC NEAR			; Get

; 194  : {

  00293	55		 push	 ebp
  00294	8b ec		 mov	 ebp, esp
  00296	51		 push	 ecx

; 195  : 	//	sets current message stack parameters and gets message associated with
; 196  : 	//	them
; 197  : 	//	if found,pm.acc = talker number and if buffer supplied, copies the message
; 198  : 	//		to the buffer minus stage directions
; 199  : 	//	else pm.acc = 0 and if buffer supplied, copies an error message to it
; 200  : 
; 201  : 	stack.Init(module, noun, verb, cond, seq);

  00297	8a 45 18	 mov	 al, BYTE PTR _seq$[ebp]
  0029a	50		 push	 eax
  0029b	8a 4d 14	 mov	 cl, BYTE PTR _cond$[ebp]
  0029e	51		 push	 ecx
  0029f	8a 55 10	 mov	 dl, BYTE PTR _verb$[ebp]
  002a2	52		 push	 edx
  002a3	8a 45 0c	 mov	 al, BYTE PTR _noun$[ebp]
  002a6	50		 push	 eax
  002a7	66 8b 4d 08	 mov	 cx, WORD PTR _module$[ebp]
  002ab	51		 push	 ecx
  002ac	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_stack
  002b1	e8 00 00 00 00	 call	 ?Init@MsgStack@@QAEXGEEEE@Z ; MsgStack::Init

; 202  : 	
; 203  : 	GetNext(buffer);

  002b6	51		 push	 ecx
  002b7	8b cc		 mov	 ecx, esp
  002b9	8d 55 1c	 lea	 edx, DWORD PTR _buffer$[ebp]
  002bc	52		 push	 edx
  002bd	e8 00 00 00 00	 call	 ??0TextID@@QAE@ABV0@@Z	; TextID::TextID
  002c2	e8 00 00 00 00	 call	 ?GetNext@@YAXVTextID@@@Z ; GetNext
  002c7	83 c4 04	 add	 esp, 4

; 204  : }

  002ca	8b e5		 mov	 esp, ebp
  002cc	5d		 pop	 ebp
  002cd	c3		 ret	 0
?Get@@YAXGEEEEVTextID@@@Z ENDP				; Get
_TEXT	ENDS
PUBLIC	?Top@MsgStack@@QAE?AUMsgEntry@@XZ		; MsgStack::Top
PUBLIC	?IncSeq@MsgStack@@QAEXXZ			; MsgStack::IncSeq
PUBLIC	??BMemID@@QBEGXZ				; MemID::operator unsigned short
PUBLIC	??AMemID@@QBEAADI@Z				; MemID::operator[]
PUBLIC	??7MemID@@QBEHXZ				; MemID::operator!
PUBLIC	??DTextID@@QAEPADXZ				; TextID::operator*
EXTRN	__imp__sprintf:NEAR
EXTRN	?Realloc@MemID@@QBEPAXI@Z:NEAR			; MemID::Realloc
EXTRN	_strlen:NEAR
EXTRN	?Snug@TextID@@QAEXXZ:NEAR			; TextID::Snug
_DATA	SEGMENT
$SG59721 DB	'Msg %d: %d %d %d %d not found', 00H
_DATA	ENDS
_TEXT	SEGMENT
_buffer$ = 8
_saveStack$ = -48
_textOffset$ = -52
_indexOffset$ = -60
_id$ = -56
_entry$59719 = -64
_entry$59725 = -68
$T60092 = -72
$T60093 = -76
$T60094 = -80
?GetNext@@YAXVTextID@@@Z PROC NEAR			; GetNext

; 208  : {

  002ce	55		 push	 ebp
  002cf	8b ec		 mov	 ebp, esp
  002d1	83 ec 50	 sub	 esp, 80			; 00000050H
  002d4	56		 push	 esi
  002d5	57		 push	 edi

; 209  : 	//	finds the next message in the sequence on the stack
; 210  : 	//	if found,pm.acc = talker number and if buffer supplied, copies the message
; 211  : 	//		to the buffer minus stage directions and increments current seq num
; 212  : 	//	else pm.acc = 0 and if buffer supplied, copies an error message to it
; 213  : 
; 214  : 	//	save the stack in case of error or if this is just a query
; 215  : 	MsgStack saveStack = stack;

  002d6	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  002db	be 00 00 00 00	 mov	 esi, OFFSET FLAT:_stack
  002e0	8d 7d d0	 lea	 edi, DWORD PTR _saveStack$[ebp]
  002e3	f3 a5		 rep movsd
  002e5	66 a5		 movsw

; 216  : 
; 217  : 	size_t	textOffset;
; 218  : 	size_t	indexOffset;
; 219  : 	MemID id = Find(stack, &textOffset, &indexOffset);

  002e7	6a 01		 push	 1
  002e9	8d 45 c4	 lea	 eax, DWORD PTR _indexOffset$[ebp]
  002ec	50		 push	 eax
  002ed	8d 4d cc	 lea	 ecx, DWORD PTR _textOffset$[ebp]
  002f0	51		 push	 ecx
  002f1	68 00 00 00 00	 push	 OFFSET FLAT:_stack
  002f6	8d 55 b8	 lea	 edx, DWORD PTR $T60092[ebp]
  002f9	52		 push	 edx
  002fa	e8 00 00 00 00	 call	 ?Find@@YA?AVMemID@@AAUMsgStack@@PAI1H@Z ; Find
  002ff	83 c4 14	 add	 esp, 20			; 00000014H
  00302	50		 push	 eax
  00303	8d 4d c8	 lea	 ecx, DWORD PTR _id$[ebp]
  00306	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID

; 220  : 
; 221  : 	if (!id) {

  0030b	8d 4d c8	 lea	 ecx, DWORD PTR _id$[ebp]
  0030e	e8 00 00 00 00	 call	 ??7MemID@@QBEHXZ	; MemID::operator!
  00313	85 c0		 test	 eax, eax
  00315	0f 84 8a 00 00
	00		 je	 $L59716

; 222  : 		if ((int) buffer) {

  0031b	8d 4d 08	 lea	 ecx, DWORD PTR _buffer$[ebp]
  0031e	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00323	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00328	85 c0		 test	 eax, eax
  0032a	74 6a		 je	 SHORT $L59718

; 223  : 			MsgEntry entry = saveStack.Top();

  0032c	8d 45 b4	 lea	 eax, DWORD PTR $T60093[ebp]
  0032f	50		 push	 eax
  00330	8d 4d d0	 lea	 ecx, DWORD PTR _saveStack$[ebp]
  00333	e8 00 00 00 00	 call	 ?Top@MsgStack@@QAE?AUMsgEntry@@XZ ; MsgStack::Top
  00338	8b 08		 mov	 ecx, DWORD PTR [eax]
  0033a	89 4d c0	 mov	 DWORD PTR _entry$59719[ebp], ecx

; 224  : 			buffer.Realloc(100);

  0033d	6a 64		 push	 100			; 00000064H
  0033f	8d 4d 08	 lea	 ecx, DWORD PTR _buffer$[ebp]
  00342	e8 00 00 00 00	 call	 ?Realloc@MemID@@QBEPAXI@Z ; MemID::Realloc

; 225  : 			sprintf(*buffer, "Msg %d: %d %d %d %d not found",
; 226  : 									saveStack.module, entry.noun, entry.verb, entry.cond,
; 227  : 									entry.seq);

  00347	8b 55 c3	 mov	 edx, DWORD PTR _entry$59719[ebp+3]
  0034a	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00350	52		 push	 edx
  00351	8b 45 c2	 mov	 eax, DWORD PTR _entry$59719[ebp+2]
  00354	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00359	50		 push	 eax
  0035a	8b 4d c1	 mov	 ecx, DWORD PTR _entry$59719[ebp+1]
  0035d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00363	51		 push	 ecx
  00364	8b 55 c0	 mov	 edx, DWORD PTR _entry$59719[ebp]
  00367	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0036d	52		 push	 edx
  0036e	8b 45 d0	 mov	 eax, DWORD PTR _saveStack$[ebp]
  00371	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00376	50		 push	 eax
  00377	68 00 00 00 00	 push	 OFFSET FLAT:$SG59721
  0037c	8d 4d 08	 lea	 ecx, DWORD PTR _buffer$[ebp]
  0037f	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  00384	50		 push	 eax
  00385	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  0038b	83 c4 1c	 add	 esp, 28			; 0000001cH

; 228  : 			buffer.Snug();

  0038e	8d 4d 08	 lea	 ecx, DWORD PTR _buffer$[ebp]
  00391	e8 00 00 00 00	 call	 ?Snug@TextID@@QAEXXZ	; TextID::Snug
$L59718:

; 230  : 		pm.acc = 0;

  00396	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, 0

; 231  : 
; 232  : 	} else {

  003a0	e9 ce 00 00 00	 jmp	 $L59722
$L59716:

; 233  : 		if ((int) buffer) {

  003a5	8d 4d 08	 lea	 ecx, DWORD PTR _buffer$[ebp]
  003a8	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  003ad	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  003b2	85 c0		 test	 eax, eax
  003b4	0f 84 a2 00 00
	00		 je	 $L59724

; 234  : 			buffer.Realloc(strlen(&id[textOffset]) + 1);

  003ba	8b 4d cc	 mov	 ecx, DWORD PTR _textOffset$[ebp]
  003bd	51		 push	 ecx
  003be	8d 4d c8	 lea	 ecx, DWORD PTR _id$[ebp]
  003c1	e8 00 00 00 00	 call	 ??AMemID@@QBEAADI@Z	; MemID::operator[]
  003c6	50		 push	 eax
  003c7	e8 00 00 00 00	 call	 _strlen
  003cc	83 c4 04	 add	 esp, 4
  003cf	83 c0 01	 add	 eax, 1
  003d2	50		 push	 eax
  003d3	8d 4d 08	 lea	 ecx, DWORD PTR _buffer$[ebp]
  003d6	e8 00 00 00 00	 call	 ?Realloc@MemID@@QBEPAXI@Z ; MemID::Realloc

; 235  : 			MassageText(*buffer, &id[textOffset]);

  003db	8b 55 cc	 mov	 edx, DWORD PTR _textOffset$[ebp]
  003de	52		 push	 edx
  003df	8d 4d c8	 lea	 ecx, DWORD PTR _id$[ebp]
  003e2	e8 00 00 00 00	 call	 ??AMemID@@QBEAADI@Z	; MemID::operator[]
  003e7	50		 push	 eax
  003e8	8d 4d 08	 lea	 ecx, DWORD PTR _buffer$[ebp]
  003eb	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  003f0	50		 push	 eax
  003f1	e8 00 00 00 00	 call	 ?MassageText@@YAXPAD0@Z	; MassageText
  003f6	83 c4 08	 add	 esp, 8

; 236  : 			MsgEntry entry = stack.Top();

  003f9	8d 45 b0	 lea	 eax, DWORD PTR $T60094[ebp]
  003fc	50		 push	 eax
  003fd	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_stack
  00402	e8 00 00 00 00	 call	 ?Top@MsgStack@@QAE?AUMsgEntry@@XZ ; MsgStack::Top
  00407	8b 08		 mov	 ecx, DWORD PTR [eax]
  00409	89 4d bc	 mov	 DWORD PTR _entry$59725[ebp], ecx

; 237  : 			curModule = stack.module;

  0040c	66 8b 15 00 00
	00 00		 mov	 dx, WORD PTR _stack
  00413	66 89 15 00 00
	00 00		 mov	 WORD PTR _curModule, dx

; 238  : 			curNoun = entry.noun;

  0041a	8b 45 bc	 mov	 eax, DWORD PTR _entry$59725[ebp]
  0041d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00422	a3 00 00 00 00	 mov	 DWORD PTR _curNoun, eax

; 239  : 			curVerb = entry.verb;

  00427	8b 4d bd	 mov	 ecx, DWORD PTR _entry$59725[ebp+1]
  0042a	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00430	89 0d 00 00 00
	00		 mov	 DWORD PTR _curVerb, ecx

; 240  : 			curCond = entry.cond;

  00436	8b 55 be	 mov	 edx, DWORD PTR _entry$59725[ebp+2]
  00439	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0043f	89 15 00 00 00
	00		 mov	 DWORD PTR _curCond, edx

; 241  : 			curSeq = entry.seq;

  00445	8b 45 bf	 mov	 eax, DWORD PTR _entry$59725[ebp+3]
  00448	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0044d	a3 00 00 00 00	 mov	 DWORD PTR _curSeq, eax

; 242  : 			stack.IncSeq();

  00452	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_stack
  00457	e8 00 00 00 00	 call	 ?IncSeq@MsgStack@@QAEXXZ ; MsgStack::IncSeq
$L59724:

; 250  : 		pm.acc = ((IndexEntry*) &id[indexOffset])->talker;

  0045c	8b 4d c4	 mov	 ecx, DWORD PTR _indexOffset$[ebp]
  0045f	51		 push	 ecx
  00460	8d 4d c8	 lea	 ecx, DWORD PTR _id$[ebp]
  00463	e8 00 00 00 00	 call	 ??AMemID@@QBEAADI@Z	; MemID::operator[]
  00468	33 d2		 xor	 edx, edx
  0046a	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  0046d	89 15 04 00 00
	00		 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, edx
$L59722:

; 252  : 	
; 253  : 	//	if this is just a query, restore stack
; 254  : 	if (!buffer)

  00473	8d 4d 08	 lea	 ecx, DWORD PTR _buffer$[ebp]
  00476	e8 00 00 00 00	 call	 ??7MemID@@QBEHXZ	; MemID::operator!
  0047b	85 c0		 test	 eax, eax
  0047d	74 13		 je	 SHORT $L59728

; 255  : 		stack = saveStack;

  0047f	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00484	8d 75 d0	 lea	 esi, DWORD PTR _saveStack$[ebp]
  00487	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_stack
  0048c	f3 a5		 rep movsd
  0048e	66 a5		 movsw

; 256  : 	else

  00490	eb 08		 jmp	 SHORT $L59729
$L59728:

; 257  : 		buffer.Snug();

  00492	8d 4d 08	 lea	 ecx, DWORD PTR _buffer$[ebp]
  00495	e8 00 00 00 00	 call	 ?Snug@TextID@@QAEXXZ	; TextID::Snug
$L59729:

; 258  : }

  0049a	5f		 pop	 edi
  0049b	5e		 pop	 esi
  0049c	8b e5		 mov	 esp, ebp
  0049e	5d		 pop	 ebp
  0049f	c3		 ret	 0
?GetNext@@YAXVTextID@@@Z ENDP				; GetNext
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4
??BMemID@@QBEGXZ PROC NEAR				; MemID::operator unsigned short, COMDAT

; 93   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   : 		return handle;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 00	 mov	 ax, WORD PTR [eax]

; 95   : 	}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??BMemID@@QBEGXZ ENDP					; MemID::operator unsigned short
_TEXT	ENDS
;	COMDAT ??AMemID@@QBEAADI@Z
_TEXT	SEGMENT
_s$ = 8
_this$ = -4
??AMemID@@QBEAADI@Z PROC NEAR				; MemID::operator[], COMDAT

; 103  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 104  : 		return *((char*) memMgr->GetAddr(handle) + s);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr
  00019	03 45 08	 add	 eax, DWORD PTR _s$[ebp]

; 105  : 	}

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??AMemID@@QBEAADI@Z ENDP				; MemID::operator[]
_TEXT	ENDS
;	COMDAT ??7MemID@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
??7MemID@@QBEHXZ PROC NEAR				; MemID::operator!, COMDAT

; 118  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 119  : 		return handle == 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000f	8b c1		 mov	 eax, ecx
  00011	f7 d8		 neg	 eax
  00013	1b c0		 sbb	 eax, eax
  00015	40		 inc	 eax

; 120  : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??7MemID@@QBEHXZ ENDP					; MemID::operator!
_TEXT	ENDS
PUBLIC	??_C@_00A@?$AA@					; `string'
;	COMDAT ??_C@_00A@?$AA@
; File \\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\textid.hpp
_BSS	SEGMENT
??_C@_00A@?$AA@ DB 01H DUP (?)				; `string'
_BSS	ENDS
;	COMDAT ??DTextID@@QAEPADXZ
_TEXT	SEGMENT
_this$ = -4
??DTextID@@QAEPADXZ PROC NEAR				; TextID::operator*, COMDAT

; 24   : 	char	*operator *() { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 25   : 		return handle ? (char *)MemID::operator*() : ""; 

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	33 c9		 xor	 ecx, ecx
  0000e	66 8b 08	 mov	 cx, WORD PTR [eax]
  00011	85 c9		 test	 ecx, ecx
  00013	74 0d		 je	 SHORT $L60099
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0001d	89 45 f8	 mov	 DWORD PTR -8+[ebp], eax
  00020	eb 07		 jmp	 SHORT $L60100
$L60099:
  00022	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
$L60100:
  00029	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]

; 26   : 	}

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??DTextID@@QAEPADXZ ENDP				; TextID::operator*
_TEXT	ENDS
PUBLIC	?Free@MemID@@QAEXXZ				; MemID::Free
PUBLIC	?Get@TextID@@QAEXII@Z				; TextID::Get
EXTRN	??0TextID@@QAE@XZ:NEAR				; TextID::TextID
_TEXT	SEGMENT
_module$ = 8
_noun$ = 12
_verb$ = 16
_cond$ = 20
_seq$ = 24
_stack$ = -48
_textOffset$ = -52
_id$ = -56
_buf$59743 = -60
$T60103 = -64
?GetSize@@YAXGEEEE@Z PROC NEAR				; GetSize

; 262  : {

  004a0	55		 push	 ebp
  004a1	8b ec		 mov	 ebp, esp
  004a3	83 ec 40	 sub	 esp, 64			; 00000040H

; 263  : 	//	return size of buffer needed to hold the message, including trailing
; 264  : 	//	0, or 0 if message not found
; 265  : 
; 266  : 	//	use a local stack, since no need to save info across calls
; 267  : 	MsgStack	stack;
; 268  : 	stack.Init(module, noun, verb, cond, seq);

  004a6	8a 45 18	 mov	 al, BYTE PTR _seq$[ebp]
  004a9	50		 push	 eax
  004aa	8a 4d 14	 mov	 cl, BYTE PTR _cond$[ebp]
  004ad	51		 push	 ecx
  004ae	8a 55 10	 mov	 dl, BYTE PTR _verb$[ebp]
  004b1	52		 push	 edx
  004b2	8a 45 0c	 mov	 al, BYTE PTR _noun$[ebp]
  004b5	50		 push	 eax
  004b6	66 8b 4d 08	 mov	 cx, WORD PTR _module$[ebp]
  004ba	51		 push	 ecx
  004bb	8d 4d d0	 lea	 ecx, DWORD PTR _stack$[ebp]
  004be	e8 00 00 00 00	 call	 ?Init@MsgStack@@QAEXGEEEE@Z ; MsgStack::Init

; 269  : 
; 270  : 	//	find the message
; 271  : 	size_t textOffset;
; 272  : 	MemID id = Find(stack, &textOffset);

  004c3	6a 01		 push	 1
  004c5	6a 00		 push	 0
  004c7	8d 55 cc	 lea	 edx, DWORD PTR _textOffset$[ebp]
  004ca	52		 push	 edx
  004cb	8d 45 d0	 lea	 eax, DWORD PTR _stack$[ebp]
  004ce	50		 push	 eax
  004cf	8d 4d c0	 lea	 ecx, DWORD PTR $T60103[ebp]
  004d2	51		 push	 ecx
  004d3	e8 00 00 00 00	 call	 ?Find@@YA?AVMemID@@AAUMsgStack@@PAI1H@Z ; Find
  004d8	83 c4 14	 add	 esp, 20			; 00000014H
  004db	50		 push	 eax
  004dc	8d 4d c8	 lea	 ecx, DWORD PTR _id$[ebp]
  004df	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID

; 273  : 	if (!id)

  004e4	8d 4d c8	 lea	 ecx, DWORD PTR _id$[ebp]
  004e7	e8 00 00 00 00	 call	 ??7MemID@@QBEHXZ	; MemID::operator!
  004ec	85 c0		 test	 eax, eax
  004ee	74 0c		 je	 SHORT $L59741

; 274  : 		pm.acc = 0;

  004f0	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, 0

; 275  : 	else {

  004fa	eb 6d		 jmp	 SHORT $L59742
$L59741:

; 276  : 		//	make a buffer to massage it into
; 277  : 		TextID buf;

  004fc	8d 4d c4	 lea	 ecx, DWORD PTR _buf$59743[ebp]
  004ff	e8 00 00 00 00	 call	 ??0TextID@@QAE@XZ	; TextID::TextID

; 278  : 		buf.Get(strlen(&id[textOffset]) + 1);

  00504	68 00 02 01 00	 push	 66048			; 00010200H
  00509	8b 55 cc	 mov	 edx, DWORD PTR _textOffset$[ebp]
  0050c	52		 push	 edx
  0050d	8d 4d c8	 lea	 ecx, DWORD PTR _id$[ebp]
  00510	e8 00 00 00 00	 call	 ??AMemID@@QBEAADI@Z	; MemID::operator[]
  00515	50		 push	 eax
  00516	e8 00 00 00 00	 call	 _strlen
  0051b	83 c4 04	 add	 esp, 4
  0051e	83 c0 01	 add	 eax, 1
  00521	50		 push	 eax
  00522	8d 4d c4	 lea	 ecx, DWORD PTR _buf$59743[ebp]
  00525	e8 00 00 00 00	 call	 ?Get@TextID@@QAEXII@Z	; TextID::Get

; 279  : 		MassageText(*buf, &id[textOffset]);

  0052a	8b 45 cc	 mov	 eax, DWORD PTR _textOffset$[ebp]
  0052d	50		 push	 eax
  0052e	8d 4d c8	 lea	 ecx, DWORD PTR _id$[ebp]
  00531	e8 00 00 00 00	 call	 ??AMemID@@QBEAADI@Z	; MemID::operator[]
  00536	50		 push	 eax
  00537	8d 4d c4	 lea	 ecx, DWORD PTR _buf$59743[ebp]
  0053a	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  0053f	50		 push	 eax
  00540	e8 00 00 00 00	 call	 ?MassageText@@YAXPAD0@Z	; MassageText
  00545	83 c4 08	 add	 esp, 8

; 280  : 	
; 281  : 		//	return the massaged length plus one for the trailing null
; 282  : 		pm.acc = strlen(*buf) + 1;

  00548	8d 4d c4	 lea	 ecx, DWORD PTR _buf$59743[ebp]
  0054b	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  00550	50		 push	 eax
  00551	e8 00 00 00 00	 call	 _strlen
  00556	83 c4 04	 add	 esp, 4
  00559	83 c0 01	 add	 eax, 1
  0055c	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 283  : 	
; 284  : 		buf.Free();

  00561	8d 4d c4	 lea	 ecx, DWORD PTR _buf$59743[ebp]
  00564	e8 00 00 00 00	 call	 ?Free@MemID@@QAEXXZ	; MemID::Free
$L59742:

; 286  : }

  00569	8b e5		 mov	 esp, ebp
  0056b	5d		 pop	 ebp
  0056c	c3		 ret	 0
?GetSize@@YAXGEEEE@Z ENDP				; GetSize
_TEXT	ENDS
EXTRN	?Free@MemoryMgr@@QAEXG@Z:NEAR			; MemoryMgr::Free
;	COMDAT ?Free@MemID@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Free@MemID@@QAEXXZ PROC NEAR				; MemID::Free, COMDAT

; 32   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 33   : 		if (handle) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000f	85 c9		 test	 ecx, ecx
  00011	74 1a		 je	 SHORT $L54849

; 34   : 			memMgr->Free(handle);

  00013	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00016	66 8b 02	 mov	 ax, WORD PTR [edx]
  00019	50		 push	 eax
  0001a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00020	e8 00 00 00 00	 call	 ?Free@MemoryMgr@@QAEXG@Z ; MemoryMgr::Free

; 35   : 			handle = 0;

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	66 c7 01 00 00	 mov	 WORD PTR [ecx], 0
$L54849:

; 37   : 	}

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?Free@MemID@@QAEXXZ ENDP				; MemID::Free
_TEXT	ENDS
PUBLIC	?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get
;	COMDAT ?Get@TextID@@QAEXII@Z
_TEXT	SEGMENT
_this$ = -4
_size$ = 8
_attrs$ = 12
?Get@TextID@@QAEXII@Z PROC NEAR				; TextID::Get, COMDAT

; 34   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 35   : 		MemID::Get(MemText, size, attrs);

  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 00		 push	 0
  0000f	8b 45 0c	 mov	 eax, DWORD PTR _attrs$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  00016	51		 push	 ecx
  00017	6a 33		 push	 51			; 00000033H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get

; 36   : 	}

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?Get@TextID@@QAEXII@Z ENDP				; TextID::Get
_TEXT	ENDS
EXTRN	?Alloc@MemoryMgr@@QAEGIIIPAUMemClient@@DW4ReservedHandle@@@Z:NEAR ; MemoryMgr::Alloc
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT
_type$ = 8
_size$ = 12
_a$ = 16
_num$ = 20
_client$ = 24
_initChar$ = 28
_h$ = 32
_this$ = -4
?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z PROC NEAR ; MemID::Get, COMDAT

; 42   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 43   : 		handle = memMgr->Alloc(type | a, size, num, client, initChar, h);

  00007	8b 45 20	 mov	 eax, DWORD PTR _h$[ebp]
  0000a	50		 push	 eax
  0000b	8a 4d 1c	 mov	 cl, BYTE PTR _initChar$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 18	 mov	 edx, DWORD PTR _client$[ebp]
  00012	52		 push	 edx
  00013	8b 45 14	 mov	 eax, DWORD PTR _num$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 55 08	 mov	 edx, DWORD PTR _type$[ebp]
  0001e	0b 55 10	 or	 edx, DWORD PTR _a$[ebp]
  00021	52		 push	 edx
  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00028	e8 00 00 00 00	 call	 ?Alloc@MemoryMgr@@QAEGIIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemoryMgr::Alloc
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	66 89 01	 mov	 WORD PTR [ecx], ax

; 44   : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 1c 00	 ret	 28			; 0000001cH
?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ENDP ; MemID::Get
_TEXT	ENDS
PUBLIC	??0MemID@@QAE@XZ				; MemID::MemID
_TEXT	SEGMENT
_module$ = 8
_noun$ = 12
_verb$ = 16
_cond$ = 20
_seq$ = 24
_refNoun$ = 28
_refVerb$ = 32
_refCond$ = 36
_stack$ = -52
_indexOffset$ = -60
_id$ = -56
_indexEntry$ = -4
$T60108 = -64
?GetRefValues@@YAHGEEEEPAE00@Z PROC NEAR		; GetRefValues

; 291  : {

  0056d	55		 push	 ebp
  0056e	8b ec		 mov	 ebp, esp
  00570	83 ec 40	 sub	 esp, 64			; 00000040H

; 292  : 	//	set reference values for this message, returning False if message not
; 293  : 	//	found.
; 294  : 
; 295  : 	//	use a local stack, since no need to save info across calls
; 296  : 	MsgStack stack;
; 297  : 	stack.Init(module, noun, verb, cond, seq);

  00573	8a 45 18	 mov	 al, BYTE PTR _seq$[ebp]
  00576	50		 push	 eax
  00577	8a 4d 14	 mov	 cl, BYTE PTR _cond$[ebp]
  0057a	51		 push	 ecx
  0057b	8a 55 10	 mov	 dl, BYTE PTR _verb$[ebp]
  0057e	52		 push	 edx
  0057f	8a 45 0c	 mov	 al, BYTE PTR _noun$[ebp]
  00582	50		 push	 eax
  00583	66 8b 4d 08	 mov	 cx, WORD PTR _module$[ebp]
  00587	51		 push	 ecx
  00588	8d 4d cc	 lea	 ecx, DWORD PTR _stack$[ebp]
  0058b	e8 00 00 00 00	 call	 ?Init@MsgStack@@QAEXGEEEE@Z ; MsgStack::Init

; 298  : 
; 299  : 	size_t indexOffset;
; 300  : 	MemID id;

  00590	8d 4d c8	 lea	 ecx, DWORD PTR _id$[ebp]
  00593	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID

; 301  : 	if (!(id = Find(stack, 0, &indexOffset, False)))

  00598	6a 00		 push	 0
  0059a	8d 55 c4	 lea	 edx, DWORD PTR _indexOffset$[ebp]
  0059d	52		 push	 edx
  0059e	6a 00		 push	 0
  005a0	8d 45 cc	 lea	 eax, DWORD PTR _stack$[ebp]
  005a3	50		 push	 eax
  005a4	8d 4d c0	 lea	 ecx, DWORD PTR $T60108[ebp]
  005a7	51		 push	 ecx
  005a8	e8 00 00 00 00	 call	 ?Find@@YA?AVMemID@@AAUMsgStack@@PAI1H@Z ; Find
  005ad	83 c4 14	 add	 esp, 20			; 00000014H
  005b0	66 8b 10	 mov	 dx, WORD PTR [eax]
  005b3	66 89 55 c8	 mov	 WORD PTR _id$[ebp], dx
  005b7	8d 4d c8	 lea	 ecx, DWORD PTR _id$[ebp]
  005ba	e8 00 00 00 00	 call	 ??7MemID@@QBEHXZ	; MemID::operator!
  005bf	85 c0		 test	 eax, eax
  005c1	74 04		 je	 SHORT $L59758

; 302  : 		return False;

  005c3	33 c0		 xor	 eax, eax
  005c5	eb 35		 jmp	 SHORT $L59753
$L59758:

; 303  : 
; 304  : 	IndexEntry* indexEntry = (IndexEntry*) &id[indexOffset];

  005c7	8b 45 c4	 mov	 eax, DWORD PTR _indexOffset$[ebp]
  005ca	50		 push	 eax
  005cb	8d 4d c8	 lea	 ecx, DWORD PTR _id$[ebp]
  005ce	e8 00 00 00 00	 call	 ??AMemID@@QBEAADI@Z	; MemID::operator[]
  005d3	89 45 fc	 mov	 DWORD PTR _indexEntry$[ebp], eax

; 305  : 	*refNoun = indexEntry->refNoun;

  005d6	8b 4d 1c	 mov	 ecx, DWORD PTR _refNoun$[ebp]
  005d9	8b 55 fc	 mov	 edx, DWORD PTR _indexEntry$[ebp]
  005dc	8a 42 07	 mov	 al, BYTE PTR [edx+7]
  005df	88 01		 mov	 BYTE PTR [ecx], al

; 306  : 	*refVerb = indexEntry->refVerb;

  005e1	8b 4d 20	 mov	 ecx, DWORD PTR _refVerb$[ebp]
  005e4	8b 55 fc	 mov	 edx, DWORD PTR _indexEntry$[ebp]
  005e7	8a 42 08	 mov	 al, BYTE PTR [edx+8]
  005ea	88 01		 mov	 BYTE PTR [ecx], al

; 307  : 	*refCond = indexEntry->refCond;

  005ec	8b 4d 24	 mov	 ecx, DWORD PTR _refCond$[ebp]
  005ef	8b 55 fc	 mov	 edx, DWORD PTR _indexEntry$[ebp]
  005f2	8a 42 09	 mov	 al, BYTE PTR [edx+9]
  005f5	88 01		 mov	 BYTE PTR [ecx], al

; 308  : 
; 309  : 	return True;

  005f7	b8 01 00 00 00	 mov	 eax, 1
$L59753:

; 310  : }

  005fc	8b e5		 mov	 esp, ebp
  005fe	5d		 pop	 ebp
  005ff	c3		 ret	 0
?GetRefValues@@YAHGEEEEPAE00@Z ENDP			; GetRefValues
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0MemID@@QAE@XZ PROC NEAR				; MemID::MemID, COMDAT

; 15   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 16   : 	}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0MemID@@QAE@XZ ENDP					; MemID::MemID
_TEXT	ENDS
PUBLIC	?Push@MsgStack@@QAEXEEEE@Z			; MsgStack::Push
PUBLIC	?Pop@MsgStack@@QAEHXZ				; MsgStack::Pop
EXTRN	?resMgr@@3PAVResourceMgr@@A:DWORD		; resMgr
_DATA	SEGMENT
	ORG $+2
$SG59774 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Mess'
	DB	'age.cpp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_stack$ = 12
_textOffset$ = 16
_indexOffset$ = 20
_deep$ = 24
___$ReturnUdt$ = 8
_id$ = -12
_data$ = -4
_ip$ = -8
_entry$59778 = -20
_i$59780 = -16
$T60111 = -24
$T60112 = -28
?Find@@YA?AVMemID@@AAUMsgStack@@PAI1H@Z PROC NEAR	; Find

; 314  : {

  00600	55		 push	 ebp
  00601	8b ec		 mov	 ebp, esp
  00603	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 315  : 	//	finds a message and returns its MemID and the offsets of its text and
; 316  : 	//	index entry if found, else 0
; 317  : 	//	'deep' means whether reference chain is followed
; 318  : 
; 319  : 	MemID			id = resMgr->Get(MemResMsg, stack.module);

  00606	6a 00		 push	 0
  00608	8b 45 0c	 mov	 eax, DWORD PTR _stack$[ebp]
  0060b	66 8b 08	 mov	 cx, WORD PTR [eax]
  0060e	51		 push	 ecx
  0060f	6a 0f		 push	 15			; 0000000fH
  00611	8d 55 e8	 lea	 edx, DWORD PTR $T60111[ebp]
  00614	52		 push	 edx
  00615	a1 00 00 00 00	 mov	 eax, DWORD PTR ?resMgr@@3PAVResourceMgr@@A ; resMgr
  0061a	8b 10		 mov	 edx, DWORD PTR [eax]
  0061c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMgr@@3PAVResourceMgr@@A ; resMgr
  00622	ff 52 20	 call	 DWORD PTR [edx+32]
  00625	50		 push	 eax
  00626	8d 4d f4	 lea	 ecx, DWORD PTR _id$[ebp]
  00629	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID

; 320  : 	MsgData*		data = (MsgData*) *id;

  0062e	8d 4d f4	 lea	 ecx, DWORD PTR _id$[ebp]
  00631	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  00636	89 45 fc	 mov	 DWORD PTR _data$[ebp], eax

; 321  : 	IndexEntry*	ip;
; 322  : 	
; 323  : 	if (data->version < MessageMajorVersion)

  00639	8b 45 fc	 mov	 eax, DWORD PTR _data$[ebp]
  0063c	81 38 a0 0f 00
	00		 cmp	 DWORD PTR [eax], 4000	; 00000fa0H
  00642	73 1d		 jae	 SHORT $L59773

; 324  : 		msgMgr->Fatal(SrcLoc, Msg_BadMsgVersion);

  00644	6a 25		 push	 37			; 00000025H
  00646	68 44 01 00 00	 push	 324			; 00000144H
  0064b	68 00 00 00 00	 push	 OFFSET FLAT:$SG59774
  00650	6a 61		 push	 97			; 00000061H
  00652	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00658	51		 push	 ecx
  00659	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXDPADHHZZ ; MsgMgr::Fatal
  0065e	83 c4 14	 add	 esp, 20			; 00000014H
$L59773:

; 325  : 	
; 326  : 	while (1) {

  00661	ba 01 00 00 00	 mov	 edx, 1
  00666	85 d2		 test	 edx, edx
  00668	0f 84 5e 01 00
	00		 je	 $L59777

; 327  : 		//	search for message on top of stack
; 328  : 		MsgEntry entry;
; 329  : 		entry = stack.Top();

  0066e	8d 45 e4	 lea	 eax, DWORD PTR $T60112[ebp]
  00671	50		 push	 eax
  00672	8b 4d 0c	 mov	 ecx, DWORD PTR _stack$[ebp]
  00675	e8 00 00 00 00	 call	 ?Top@MsgStack@@QAE?AUMsgEntry@@XZ ; MsgStack::Top
  0067a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0067c	89 4d ec	 mov	 DWORD PTR _entry$59778[ebp], ecx

; 330  : 		int i;
; 331  : 		for (i = 0, ip = data->entries; i < data->nEntries; i++, ip++)

  0067f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$59780[ebp], 0
  00686	8b 55 fc	 mov	 edx, DWORD PTR _data$[ebp]
  00689	83 c2 0a	 add	 edx, 10			; 0000000aH
  0068c	89 55 f8	 mov	 DWORD PTR _ip$[ebp], edx
  0068f	eb 12		 jmp	 SHORT $L59781
$L59782:
  00691	8b 45 f0	 mov	 eax, DWORD PTR _i$59780[ebp]
  00694	83 c0 01	 add	 eax, 1
  00697	89 45 f0	 mov	 DWORD PTR _i$59780[ebp], eax
  0069a	8b 4d f8	 mov	 ecx, DWORD PTR _ip$[ebp]
  0069d	83 c1 0b	 add	 ecx, 11			; 0000000bH
  006a0	89 4d f8	 mov	 DWORD PTR _ip$[ebp], ecx
$L59781:
  006a3	8b 55 fc	 mov	 edx, DWORD PTR _data$[ebp]
  006a6	33 c0		 xor	 eax, eax
  006a8	66 8b 42 08	 mov	 ax, WORD PTR [edx+8]
  006ac	39 45 f0	 cmp	 DWORD PTR _i$59780[ebp], eax
  006af	7d 53		 jge	 SHORT $L59783

; 333  : 				 ip->verb == entry.verb &&
; 334  : 				 ip->cond == entry.cond &&
; 335  : 				 ip->seq == entry.seq)

  006b1	8b 4d f8	 mov	 ecx, DWORD PTR _ip$[ebp]
  006b4	33 d2		 xor	 edx, edx
  006b6	8a 11		 mov	 dl, BYTE PTR [ecx]
  006b8	8b 45 ec	 mov	 eax, DWORD PTR _entry$59778[ebp]
  006bb	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006c0	3b d0		 cmp	 edx, eax
  006c2	75 3e		 jne	 SHORT $L59784
  006c4	8b 4d f8	 mov	 ecx, DWORD PTR _ip$[ebp]
  006c7	33 d2		 xor	 edx, edx
  006c9	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  006cc	8b 45 ed	 mov	 eax, DWORD PTR _entry$59778[ebp+1]
  006cf	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006d4	3b d0		 cmp	 edx, eax
  006d6	75 2a		 jne	 SHORT $L59784
  006d8	8b 4d f8	 mov	 ecx, DWORD PTR _ip$[ebp]
  006db	33 d2		 xor	 edx, edx
  006dd	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  006e0	8b 45 ee	 mov	 eax, DWORD PTR _entry$59778[ebp+2]
  006e3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006e8	3b d0		 cmp	 edx, eax
  006ea	75 16		 jne	 SHORT $L59784
  006ec	8b 4d f8	 mov	 ecx, DWORD PTR _ip$[ebp]
  006ef	33 d2		 xor	 edx, edx
  006f1	8a 51 03	 mov	 dl, BYTE PTR [ecx+3]
  006f4	8b 45 ef	 mov	 eax, DWORD PTR _entry$59778[ebp+3]
  006f7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006fc	3b d0		 cmp	 edx, eax
  006fe	75 02		 jne	 SHORT $L59784

; 336  : 				break;

  00700	eb 02		 jmp	 SHORT $L59783
$L59784:

; 337  : 		
; 338  : 		//	if wasn't found, try to pop; otherwise return failure
; 339  : 		if (i == data->nEntries)

  00702	eb 8d		 jmp	 SHORT $L59782
$L59783:
  00704	8b 4d fc	 mov	 ecx, DWORD PTR _data$[ebp]
  00707	33 d2		 xor	 edx, edx
  00709	66 8b 51 08	 mov	 dx, WORD PTR [ecx+8]
  0070d	39 55 f0	 cmp	 DWORD PTR _i$59780[ebp], edx
  00710	75 29		 jne	 SHORT $L59787

; 340  : 			if (deep && stack.Pop())

  00712	83 7d 18 00	 cmp	 DWORD PTR _deep$[ebp], 0
  00716	74 11		 je	 SHORT $L59786
  00718	8b 4d 0c	 mov	 ecx, DWORD PTR _stack$[ebp]
  0071b	e8 00 00 00 00	 call	 ?Pop@MsgStack@@QAEHXZ	; MsgStack::Pop
  00720	85 c0		 test	 eax, eax
  00722	74 05		 je	 SHORT $L59786

; 341  : 				continue;

  00724	e9 38 ff ff ff	 jmp	 $L59773
$L59786:

; 343  : 				return 0;

  00729	6a 00		 push	 0
  0072b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0072e	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  00733	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00736	e9 91 00 00 00	 jmp	 $L59777
$L59787:

; 344  : 		
; 345  : 		//	if it's a reference, push it onto the stack and go back around
; 346  : 		if (deep && (ip->refNoun || ip->refVerb || ip->refCond)) {

  0073b	83 7d 18 00	 cmp	 DWORD PTR _deep$[ebp], 0
  0073f	74 50		 je	 SHORT $L59788
  00741	8b 45 f8	 mov	 eax, DWORD PTR _ip$[ebp]
  00744	33 c9		 xor	 ecx, ecx
  00746	8a 48 07	 mov	 cl, BYTE PTR [eax+7]
  00749	85 c9		 test	 ecx, ecx
  0074b	75 18		 jne	 SHORT $L59789
  0074d	8b 55 f8	 mov	 edx, DWORD PTR _ip$[ebp]
  00750	33 c0		 xor	 eax, eax
  00752	8a 42 08	 mov	 al, BYTE PTR [edx+8]
  00755	85 c0		 test	 eax, eax
  00757	75 0c		 jne	 SHORT $L59789
  00759	8b 4d f8	 mov	 ecx, DWORD PTR _ip$[ebp]
  0075c	33 d2		 xor	 edx, edx
  0075e	8a 51 09	 mov	 dl, BYTE PTR [ecx+9]
  00761	85 d2		 test	 edx, edx
  00763	74 2c		 je	 SHORT $L59788
$L59789:

; 347  : 			stack.IncSeq();

  00765	8b 4d 0c	 mov	 ecx, DWORD PTR _stack$[ebp]
  00768	e8 00 00 00 00	 call	 ?IncSeq@MsgStack@@QAEXXZ ; MsgStack::IncSeq

; 348  : 			stack.Push(ip->refNoun, ip->refVerb, ip->refCond, 1);

  0076d	6a 01		 push	 1
  0076f	8b 45 f8	 mov	 eax, DWORD PTR _ip$[ebp]
  00772	8a 48 09	 mov	 cl, BYTE PTR [eax+9]
  00775	51		 push	 ecx
  00776	8b 55 f8	 mov	 edx, DWORD PTR _ip$[ebp]
  00779	8a 42 08	 mov	 al, BYTE PTR [edx+8]
  0077c	50		 push	 eax
  0077d	8b 4d f8	 mov	 ecx, DWORD PTR _ip$[ebp]
  00780	8a 51 07	 mov	 dl, BYTE PTR [ecx+7]
  00783	52		 push	 edx
  00784	8b 4d 0c	 mov	 ecx, DWORD PTR _stack$[ebp]
  00787	e8 00 00 00 00	 call	 ?Push@MsgStack@@QAEXEEEE@Z ; MsgStack::Push

; 349  : 			continue;

  0078c	e9 d0 fe ff ff	 jmp	 $L59773
$L59788:

; 351  : 
; 352  : 		//	otherwise, return the message
; 353  : 		if (textOffset)

  00791	83 7d 10 00	 cmp	 DWORD PTR _textOffset$[ebp], 0
  00795	74 0e		 je	 SHORT $L59790

; 354  : 			*textOffset = ip->offset;

  00797	8b 45 f8	 mov	 eax, DWORD PTR _ip$[ebp]
  0079a	33 c9		 xor	 ecx, ecx
  0079c	66 8b 48 05	 mov	 cx, WORD PTR [eax+5]
  007a0	8b 55 10	 mov	 edx, DWORD PTR _textOffset$[ebp]
  007a3	89 0a		 mov	 DWORD PTR [edx], ecx
$L59790:

; 355  : 		if (indexOffset)

  007a5	83 7d 14 00	 cmp	 DWORD PTR _indexOffset$[ebp], 0
  007a9	74 12		 je	 SHORT $L59791

; 356  : 			*indexOffset = (char*) ip - (char*) *id;

  007ab	8d 4d f4	 lea	 ecx, DWORD PTR _id$[ebp]
  007ae	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  007b3	8b 4d f8	 mov	 ecx, DWORD PTR _ip$[ebp]
  007b6	2b c8		 sub	 ecx, eax
  007b8	8b 55 14	 mov	 edx, DWORD PTR _indexOffset$[ebp]
  007bb	89 0a		 mov	 DWORD PTR [edx], ecx
$L59791:

; 357  : 		return id;

  007bd	8d 45 f4	 lea	 eax, DWORD PTR _id$[ebp]
  007c0	50		 push	 eax
  007c1	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  007c4	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  007c9	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$L59777:

; 359  : }

  007cc	8b e5		 mov	 esp, ebp
  007ce	5d		 pop	 ebp
  007cf	c3		 ret	 0
?Find@@YA?AVMemID@@AAUMsgStack@@PAI1H@Z ENDP		; Find
_TEXT	ENDS
EXTRN	?ToLower@@YAEE@Z:NEAR				; ToLower
EXTRN	__imp__strchr:NEAR
_TEXT	SEGMENT
_dst$ = 8
_src$ = 12
_dp$ = -4
_cp$59805 = -12
_val$59806 = -8
_c$59807 = -16
_end$59815 = -20
?MassageText@@YAXPAD0@Z PROC NEAR			; MassageText

; 395  : {

  007d0	55		 push	 ebp
  007d1	8b ec		 mov	 ebp, esp
  007d3	83 ec 14	 sub	 esp, 20			; 00000014H

; 396  : 	//	copies src into dst, deleting stage directions, which are phrases
; 397  : 	//	in caps enclosed by parens; and interpreting escape sequences of
; 398  : 	//	the form \xx, where x is a hex digit
; 399  : 
; 400  : 	static char	hexDigits[] = "01234567890abcdef";
; 401  : 
; 402  : 	char*	dp = dst;

  007d6	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  007d9	89 45 fc	 mov	 DWORD PTR _dp$[ebp], eax

; 403  : 
; 404  : 	for (; *src; src++) {

  007dc	eb 09		 jmp	 SHORT $L59801
$L59802:
  007de	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  007e1	83 c1 01	 add	 ecx, 1
  007e4	89 4d 0c	 mov	 DWORD PTR _src$[ebp], ecx
$L59801:
  007e7	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  007ea	0f be 02	 movsx	 eax, BYTE PTR [edx]
  007ed	85 c0		 test	 eax, eax
  007ef	0f 84 b5 01 00
	00		 je	 $L59803

; 405  : 		if (*src == '\\') {

  007f5	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  007f8	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  007fb	83 fa 5c	 cmp	 edx, 92			; 0000005cH
  007fe	0f 85 d3 00 00
	00		 jne	 $L59804

; 406  : 			char* cp;
; 407  : 			int	val = 0;

  00804	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _val$59806[ebp], 0

; 408  : 			char	c;
; 409  : 
; 410  : 			src++;

  0080b	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0080e	83 c0 01	 add	 eax, 1
  00811	89 45 0c	 mov	 DWORD PTR _src$[ebp], eax

; 411  : 
; 412  : 			//	check first digit
; 413  : 			c = ToLower(*src);

  00814	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00817	8a 11		 mov	 dl, BYTE PTR [ecx]
  00819	52		 push	 edx
  0081a	e8 00 00 00 00	 call	 ?ToLower@@YAEE@Z	; ToLower
  0081f	83 c4 04	 add	 esp, 4
  00822	88 45 f0	 mov	 BYTE PTR _c$59807[ebp], al

; 414  : 			if (!(cp = strchr(hexDigits, c))) {

  00825	0f be 45 f0	 movsx	 eax, BYTE PTR _c$59807[ebp]
  00829	50		 push	 eax
  0082a	68 00 00 00 00	 push	 OFFSET FLAT:_?hexDigits@?1??MassageText@@YAXPAD0@Z@4PADA
  0082f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strchr
  00835	83 c4 08	 add	 esp, 8
  00838	89 45 f4	 mov	 DWORD PTR _cp$59805[ebp], eax
  0083b	83 7d f4 00	 cmp	 DWORD PTR _cp$59805[ebp], 0
  0083f	75 15		 jne	 SHORT $L59808

; 415  : 				*dp++ = *src;

  00841	8b 4d fc	 mov	 ecx, DWORD PTR _dp$[ebp]
  00844	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00847	8a 02		 mov	 al, BYTE PTR [edx]
  00849	88 01		 mov	 BYTE PTR [ecx], al
  0084b	8b 4d fc	 mov	 ecx, DWORD PTR _dp$[ebp]
  0084e	83 c1 01	 add	 ecx, 1
  00851	89 4d fc	 mov	 DWORD PTR _dp$[ebp], ecx

; 416  : 				continue;

  00854	eb 88		 jmp	 SHORT $L59802
$L59808:

; 418  : 				val = val * 16 + cp - hexDigits;

  00856	8b 55 f8	 mov	 edx, DWORD PTR _val$59806[ebp]
  00859	c1 e2 04	 shl	 edx, 4
  0085c	8b 45 f4	 mov	 eax, DWORD PTR _cp$59805[ebp]
  0085f	03 c2		 add	 eax, edx
  00861	2d 00 00 00 00	 sub	 eax, OFFSET FLAT:_?hexDigits@?1??MassageText@@YAXPAD0@Z@4PADA
  00866	89 45 f8	 mov	 DWORD PTR _val$59806[ebp], eax

; 419  : 				src++;

  00869	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  0086c	83 c1 01	 add	 ecx, 1
  0086f	89 4d 0c	 mov	 DWORD PTR _src$[ebp], ecx

; 421  : 
; 422  : 			//	check second digit
; 423  : 			c = ToLower(*src);

  00872	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00875	8a 02		 mov	 al, BYTE PTR [edx]
  00877	50		 push	 eax
  00878	e8 00 00 00 00	 call	 ?ToLower@@YAEE@Z	; ToLower
  0087d	83 c4 04	 add	 esp, 4
  00880	88 45 f0	 mov	 BYTE PTR _c$59807[ebp], al

; 424  : 			if (!(cp = strchr(hexDigits, c))) {

  00883	0f be 4d f0	 movsx	 ecx, BYTE PTR _c$59807[ebp]
  00887	51		 push	 ecx
  00888	68 00 00 00 00	 push	 OFFSET FLAT:_?hexDigits@?1??MassageText@@YAXPAD0@Z@4PADA
  0088d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strchr
  00893	83 c4 08	 add	 esp, 8
  00896	89 45 f4	 mov	 DWORD PTR _cp$59805[ebp], eax
  00899	83 7d f4 00	 cmp	 DWORD PTR _cp$59805[ebp], 0
  0089d	75 0e		 jne	 SHORT $L59810

; 425  : 				src--;

  0089f	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  008a2	83 ea 01	 sub	 edx, 1
  008a5	89 55 0c	 mov	 DWORD PTR _src$[ebp], edx

; 426  : 				continue;

  008a8	e9 31 ff ff ff	 jmp	 $L59802
$L59810:

; 428  : 				val = val * 16 + cp - hexDigits;

  008ad	8b 45 f8	 mov	 eax, DWORD PTR _val$59806[ebp]
  008b0	c1 e0 04	 shl	 eax, 4
  008b3	8b 4d f4	 mov	 ecx, DWORD PTR _cp$59805[ebp]
  008b6	03 c8		 add	 ecx, eax
  008b8	81 e9 00 00 00
	00		 sub	 ecx, OFFSET FLAT:_?hexDigits@?1??MassageText@@YAXPAD0@Z@4PADA
  008be	89 4d f8	 mov	 DWORD PTR _val$59806[ebp], ecx

; 429  : 
; 430  : 			*dp++ = (uchar) val;

  008c1	8b 55 fc	 mov	 edx, DWORD PTR _dp$[ebp]
  008c4	8a 45 f8	 mov	 al, BYTE PTR _val$59806[ebp]
  008c7	88 02		 mov	 BYTE PTR [edx], al
  008c9	8b 4d fc	 mov	 ecx, DWORD PTR _dp$[ebp]
  008cc	83 c1 01	 add	 ecx, 1
  008cf	89 4d fc	 mov	 DWORD PTR _dp$[ebp], ecx

; 431  : 
; 432  : 		} else if (*src == '(') {

  008d2	e9 ce 00 00 00	 jmp	 $L59826
$L59804:
  008d7	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  008da	0f be 02	 movsx	 eax, BYTE PTR [edx]
  008dd	83 f8 28	 cmp	 eax, 40			; 00000028H
  008e0	0f 85 ac 00 00
	00		 jne	 $L59814

; 433  : 			//	find end of this stage direction (if it is) and set src to it
; 434  : 			for (char* end = src; *end; end++)

  008e6	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  008e9	89 4d ec	 mov	 DWORD PTR _end$59815[ebp], ecx
  008ec	eb 09		 jmp	 SHORT $L59816
$L59817:
  008ee	8b 55 ec	 mov	 edx, DWORD PTR _end$59815[ebp]
  008f1	83 c2 01	 add	 edx, 1
  008f4	89 55 ec	 mov	 DWORD PTR _end$59815[ebp], edx
$L59816:
  008f7	8b 45 ec	 mov	 eax, DWORD PTR _end$59815[ebp]
  008fa	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  008fd	85 c9		 test	 ecx, ecx
  008ff	0f 84 8b 00 00
	00		 je	 $L59818

; 435  : 				if (*end == ')') {

  00905	8b 55 ec	 mov	 edx, DWORD PTR _end$59815[ebp]
  00908	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0090b	83 f8 29	 cmp	 eax, 41			; 00000029H
  0090e	75 50		 jne	 SHORT $L59819

; 436  : 					/*	found end of stage direction:
; 437  : 						strip trailing whitespace, then exit	*/
; 438  : 					end++;

  00910	8b 4d ec	 mov	 ecx, DWORD PTR _end$59815[ebp]
  00913	83 c1 01	 add	 ecx, 1
  00916	89 4d ec	 mov	 DWORD PTR _end$59815[ebp], ecx
$L59821:

; 439  : 					while (*end && (*end == ' ' || *end == '\n' || *end == '\r'))

  00919	8b 55 ec	 mov	 edx, DWORD PTR _end$59815[ebp]
  0091c	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0091f	85 c0		 test	 eax, eax
  00921	74 2c		 je	 SHORT $L59822
  00923	8b 4d ec	 mov	 ecx, DWORD PTR _end$59815[ebp]
  00926	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00929	83 fa 20	 cmp	 edx, 32			; 00000020H
  0092c	74 16		 je	 SHORT $L59823
  0092e	8b 45 ec	 mov	 eax, DWORD PTR _end$59815[ebp]
  00931	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00934	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00937	74 0b		 je	 SHORT $L59823
  00939	8b 55 ec	 mov	 edx, DWORD PTR _end$59815[ebp]
  0093c	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0093f	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  00942	75 0b		 jne	 SHORT $L59822
$L59823:

; 440  : 						end++;

  00944	8b 4d ec	 mov	 ecx, DWORD PTR _end$59815[ebp]
  00947	83 c1 01	 add	 ecx, 1
  0094a	89 4d ec	 mov	 DWORD PTR _end$59815[ebp], ecx
  0094d	eb ca		 jmp	 SHORT $L59821
$L59822:

; 441  : 					src = --end;

  0094f	8b 55 ec	 mov	 edx, DWORD PTR _end$59815[ebp]
  00952	83 ea 01	 sub	 edx, 1
  00955	89 55 ec	 mov	 DWORD PTR _end$59815[ebp], edx
  00958	8b 45 ec	 mov	 eax, DWORD PTR _end$59815[ebp]
  0095b	89 45 0c	 mov	 DWORD PTR _src$[ebp], eax

; 442  : 					break;

  0095e	eb 30		 jmp	 SHORT $L59818
$L59819:

; 443  : 
; 444  : 				} else if (*end >= 'a' && *end <= 'z') {

  00960	8b 4d ec	 mov	 ecx, DWORD PTR _end$59815[ebp]
  00963	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00966	83 fa 61	 cmp	 edx, 97			; 00000061H
  00969	7c 20		 jl	 SHORT $L59825
  0096b	8b 45 ec	 mov	 eax, DWORD PTR _end$59815[ebp]
  0096e	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00971	83 f9 7a	 cmp	 ecx, 122		; 0000007aH
  00974	7f 15		 jg	 SHORT $L59825

; 445  : 					//	it's not a stage direction
; 446  : 					*dp++ = *src;

  00976	8b 55 fc	 mov	 edx, DWORD PTR _dp$[ebp]
  00979	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0097c	8a 08		 mov	 cl, BYTE PTR [eax]
  0097e	88 0a		 mov	 BYTE PTR [edx], cl
  00980	8b 55 fc	 mov	 edx, DWORD PTR _dp$[ebp]
  00983	83 c2 01	 add	 edx, 1
  00986	89 55 fc	 mov	 DWORD PTR _dp$[ebp], edx

; 447  : 					break;

  00989	eb 05		 jmp	 SHORT $L59818
$L59825:

; 449  : 
; 450  : 		} else

  0098b	e9 5e ff ff ff	 jmp	 $L59817
$L59818:
  00990	eb 13		 jmp	 SHORT $L59826
$L59814:

; 451  : 			*dp++ = *src;

  00992	8b 45 fc	 mov	 eax, DWORD PTR _dp$[ebp]
  00995	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00998	8a 11		 mov	 dl, BYTE PTR [ecx]
  0099a	88 10		 mov	 BYTE PTR [eax], dl
  0099c	8b 45 fc	 mov	 eax, DWORD PTR _dp$[ebp]
  0099f	83 c0 01	 add	 eax, 1
  009a2	89 45 fc	 mov	 DWORD PTR _dp$[ebp], eax
$L59826:

; 452  : 	}

  009a5	e9 34 fe ff ff	 jmp	 $L59802
$L59803:

; 453  : 	*dp = '\0';

  009aa	8b 4d fc	 mov	 ecx, DWORD PTR _dp$[ebp]
  009ad	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 454  : }

  009b0	8b e5		 mov	 esp, ebp
  009b2	5d		 pop	 ebp
  009b3	c3		 ret	 0
?MassageText@@YAXPAD0@Z ENDP				; MassageText
_module$ = 8
_noun$ = 12
_verb$ = 16
_cond$ = 20
_seq$ = 24
_this$ = -4
?Init@MsgStack@@QAEXGEEEE@Z PROC NEAR			; MsgStack::Init

; 480  : {

  009b4	55		 push	 ebp
  009b5	8b ec		 mov	 ebp, esp
  009b7	51		 push	 ecx
  009b8	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 481  : 	//	start a new stack
; 482  : 
; 483  : 	this->module = module;

  009bb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  009be	66 8b 4d 08	 mov	 cx, WORD PTR _module$[ebp]
  009c2	66 89 08	 mov	 WORD PTR [eax], cx

; 484  : 	sp = -1;

  009c5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  009c8	c7 42 2a ff ff
	ff ff		 mov	 DWORD PTR [edx+42], -1

; 485  : 	
; 486  : 	Push(noun, verb, cond, seq);

  009cf	8a 45 18	 mov	 al, BYTE PTR _seq$[ebp]
  009d2	50		 push	 eax
  009d3	8a 4d 14	 mov	 cl, BYTE PTR _cond$[ebp]
  009d6	51		 push	 ecx
  009d7	8a 55 10	 mov	 dl, BYTE PTR _verb$[ebp]
  009da	52		 push	 edx
  009db	8a 45 0c	 mov	 al, BYTE PTR _noun$[ebp]
  009de	50		 push	 eax
  009df	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  009e2	e8 00 00 00 00	 call	 ?Push@MsgStack@@QAEXEEEE@Z ; MsgStack::Push

; 487  : }

  009e7	8b e5		 mov	 esp, ebp
  009e9	5d		 pop	 ebp
  009ea	c2 14 00	 ret	 20			; 00000014H
?Init@MsgStack@@QAEXGEEEE@Z ENDP			; MsgStack::Init
_TEXT	ENDS
_DATA	SEGMENT
$SG59843 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Mess'
	DB	'age.cpp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_noun$ = 8
_verb$ = 12
_cond$ = 16
_seq$ = 20
_this$ = -4
?Push@MsgStack@@QAEXEEEE@Z PROC NEAR			; MsgStack::Push

; 491  : {

  009ed	55		 push	 ebp
  009ee	8b ec		 mov	 ebp, esp
  009f0	51		 push	 ecx
  009f1	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 492  : 	//	push a message onto stack
; 493  : 
; 494  : 	if (++sp >= Max)

  009f4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  009f7	8b 48 2a	 mov	 ecx, DWORD PTR [eax+42]
  009fa	83 c1 01	 add	 ecx, 1
  009fd	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00a00	89 4a 2a	 mov	 DWORD PTR [edx+42], ecx
  00a03	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a06	83 78 2a 0a	 cmp	 DWORD PTR [eax+42], 10	; 0000000aH
  00a0a	7c 1f		 jl	 SHORT $L59842

; 495  : 		msgMgr->Fatal(SrcLoc, Msg_MsgStackOverflow, Max);

  00a0c	6a 0a		 push	 10			; 0000000aH
  00a0e	6a 26		 push	 38			; 00000026H
  00a10	68 ef 01 00 00	 push	 495			; 000001efH
  00a15	68 00 00 00 00	 push	 OFFSET FLAT:$SG59843
  00a1a	6a 61		 push	 97			; 00000061H
  00a1c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00a22	51		 push	 ecx
  00a23	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXDPADHHZZ ; MsgMgr::Fatal
  00a28	83 c4 18	 add	 esp, 24			; 00000018H
$L59842:

; 496  : 	entries[sp].noun	= noun;

  00a2b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00a2e	8b 42 2a	 mov	 eax, DWORD PTR [edx+42]
  00a31	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a34	8a 55 08	 mov	 dl, BYTE PTR _noun$[ebp]
  00a37	88 54 81 02	 mov	 BYTE PTR [ecx+eax*4+2], dl

; 497  : 	entries[sp].verb	= verb;

  00a3b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a3e	8b 48 2a	 mov	 ecx, DWORD PTR [eax+42]
  00a41	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00a44	8a 45 0c	 mov	 al, BYTE PTR _verb$[ebp]
  00a47	88 44 8a 03	 mov	 BYTE PTR [edx+ecx*4+3], al

; 498  : 	entries[sp].cond	= cond;

  00a4b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a4e	8b 51 2a	 mov	 edx, DWORD PTR [ecx+42]
  00a51	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a54	8a 4d 10	 mov	 cl, BYTE PTR _cond$[ebp]
  00a57	88 4c 90 04	 mov	 BYTE PTR [eax+edx*4+4], cl

; 499  : 	entries[sp].seq	= seq;

  00a5b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00a5e	8b 42 2a	 mov	 eax, DWORD PTR [edx+42]
  00a61	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a64	8a 55 14	 mov	 dl, BYTE PTR _seq$[ebp]
  00a67	88 54 81 05	 mov	 BYTE PTR [ecx+eax*4+5], dl

; 500  : }

  00a6b	8b e5		 mov	 esp, ebp
  00a6d	5d		 pop	 ebp
  00a6e	c2 10 00	 ret	 16			; 00000010H
?Push@MsgStack@@QAEXEEEE@Z ENDP				; MsgStack::Push
___$ReturnUdt$ = 8
_this$ = -8
_entry$ = -4
?Top@MsgStack@@QAE?AUMsgEntry@@XZ PROC NEAR		; MsgStack::Top

; 504  : {

  00a71	55		 push	 ebp
  00a72	8b ec		 mov	 ebp, esp
  00a74	83 ec 08	 sub	 esp, 8
  00a77	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 505  : 	//	return the message on the top of stack, but don't pop it off
; 506  : 
; 507  : 	MsgEntry entry;
; 508  : 	entry.noun	= entries[sp].noun;

  00a7a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00a7d	8b 48 2a	 mov	 ecx, DWORD PTR [eax+42]
  00a80	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00a83	8a 44 8a 02	 mov	 al, BYTE PTR [edx+ecx*4+2]
  00a87	88 45 fc	 mov	 BYTE PTR _entry$[ebp], al

; 509  : 	entry.verb	= entries[sp].verb;

  00a8a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a8d	8b 51 2a	 mov	 edx, DWORD PTR [ecx+42]
  00a90	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00a93	8a 4c 90 03	 mov	 cl, BYTE PTR [eax+edx*4+3]
  00a97	88 4d fd	 mov	 BYTE PTR _entry$[ebp+1], cl

; 510  : 	entry.cond	= entries[sp].cond;

  00a9a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00a9d	8b 42 2a	 mov	 eax, DWORD PTR [edx+42]
  00aa0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00aa3	8a 54 81 04	 mov	 dl, BYTE PTR [ecx+eax*4+4]
  00aa7	88 55 fe	 mov	 BYTE PTR _entry$[ebp+2], dl

; 511  : 	entry.seq	= entries[sp].seq;

  00aaa	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00aad	8b 48 2a	 mov	 ecx, DWORD PTR [eax+42]
  00ab0	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00ab3	8a 44 8a 05	 mov	 al, BYTE PTR [edx+ecx*4+5]
  00ab7	88 45 ff	 mov	 BYTE PTR _entry$[ebp+3], al

; 512  : 	return entry;

  00aba	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00abd	8b 55 fc	 mov	 edx, DWORD PTR _entry$[ebp]
  00ac0	89 11		 mov	 DWORD PTR [ecx], edx
  00ac2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 513  : }

  00ac5	8b e5		 mov	 esp, ebp
  00ac7	5d		 pop	 ebp
  00ac8	c2 04 00	 ret	 4
?Top@MsgStack@@QAE?AUMsgEntry@@XZ ENDP			; MsgStack::Top
_this$ = -4
?Pop@MsgStack@@QAEHXZ PROC NEAR				; MsgStack::Pop

; 517  : {

  00acb	55		 push	 ebp
  00acc	8b ec		 mov	 ebp, esp
  00ace	51		 push	 ecx
  00acf	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 518  : 	//	throw away top of stack
; 519  : 
; 520  : 	return --sp >= 0;

  00ad2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00ad5	8b 48 2a	 mov	 ecx, DWORD PTR [eax+42]
  00ad8	83 e9 01	 sub	 ecx, 1
  00adb	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00ade	89 4a 2a	 mov	 DWORD PTR [edx+42], ecx
  00ae1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00ae4	33 c9		 xor	 ecx, ecx
  00ae6	83 78 2a 00	 cmp	 DWORD PTR [eax+42], 0
  00aea	0f 9d c1	 setge	 cl
  00aed	8b c1		 mov	 eax, ecx

; 521  : }

  00aef	8b e5		 mov	 esp, ebp
  00af1	5d		 pop	 ebp
  00af2	c3		 ret	 0
?Pop@MsgStack@@QAEHXZ ENDP				; MsgStack::Pop
_this$ = -4
?IncSeq@MsgStack@@QAEXXZ PROC NEAR			; MsgStack::IncSeq

; 525  : {

  00af3	55		 push	 ebp
  00af4	8b ec		 mov	 ebp, esp
  00af6	51		 push	 ecx
  00af7	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 526  : 	//	increment the sequence number of the entry on the top of stack
; 527  : 
; 528  : 	entries[sp].seq++;

  00afa	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00afd	8b 48 2a	 mov	 ecx, DWORD PTR [eax+42]
  00b00	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00b03	8a 44 8a 05	 mov	 al, BYTE PTR [edx+ecx*4+5]
  00b07	04 01		 add	 al, 1
  00b09	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b0c	8b 51 2a	 mov	 edx, DWORD PTR [ecx+42]
  00b0f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b12	88 44 91 05	 mov	 BYTE PTR [ecx+edx*4+5], al

; 529  : }

  00b16	8b e5		 mov	 esp, ebp
  00b18	5d		 pop	 ebp
  00b19	c3		 ret	 0
?IncSeq@MsgStack@@QAEXXZ ENDP				; MsgStack::IncSeq
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
PUBLIC	??0MsgStackID@@QAE@XZ				; MsgStackID::MsgStackID
_TEXT	SEGMENT
_this$ = -4
??0MsgStackStack@@QAE@XZ PROC NEAR			; MsgStackStack::MsgStackStack

; 534  : {

  00b1a	55		 push	 ebp
  00b1b	8b ec		 mov	 ebp, esp
  00b1d	51		 push	 ecx
  00b1e	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00b21	68 00 00 00 00	 push	 OFFSET FLAT:??0MsgStackID@@QAE@XZ ; MsgStackID::MsgStackID
  00b26	6a 05		 push	 5
  00b28	6a 02		 push	 2
  00b2a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b2d	50		 push	 eax
  00b2e	e8 00 00 00 00	 call	 ??_H@YGXPAXIHP6EX0@Z@Z	; `vector constructor iterator'
  00b33	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b36	c7 41 0a ff ff
	ff ff		 mov	 DWORD PTR [ecx+10], -1

; 535  : }

  00b3d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b40	8b e5		 mov	 esp, ebp
  00b42	5d		 pop	 ebp
  00b43	c3		 ret	 0
??0MsgStackStack@@QAE@XZ ENDP				; MsgStackStack::MsgStackStack
_TEXT	ENDS
;	COMDAT ??0MsgStackID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0MsgStackID@@QAE@XZ PROC NEAR				; MsgStackID::MsgStackID, COMDAT

; 57   : FakeTemplateID(MsgStackID, MsgStack, MemMsgStack)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0MsgStackID@@QAE@XZ ENDP				; MsgStackID::MsgStackID
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$L59867:
  00003	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00006	83 e8 01	 sub	 eax, 1
  00009	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  0000c	83 7d 10 00	 cmp	 DWORD PTR ___n$[ebp], 0
  00010	7c 11		 jl	 SHORT $L59868
  00012	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00015	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001b	03 4d 0c	 add	 ecx, DWORD PTR ___s$[ebp]
  0001e	89 4d 08	 mov	 DWORD PTR ___t$[ebp], ecx
  00021	eb e0		 jmp	 SHORT $L59867
$L59868:
  00023	5d		 pop	 ebp
  00024	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?Get@MsgStackID@@QAEXXZ				; MsgStackID::Get
PUBLIC	??DMsgStackID@@QBEPAUMsgStack@@XZ		; MsgStackID::operator*
_DATA	SEGMENT
$SG59875 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Mess'
	DB	'age.cpp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_ms$ = 8
_this$ = -4
?Push@MsgStackStack@@QAEXAAUMsgStack@@@Z PROC NEAR	; MsgStackStack::Push

; 539  : {

  00b44	55		 push	 ebp
  00b45	8b ec		 mov	 ebp, esp
  00b47	51		 push	 ecx
  00b48	56		 push	 esi
  00b49	57		 push	 edi
  00b4a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 540  : 	//	save current stack on stack stack
; 541  : 
; 542  : 	if (++sp >= Max)

  00b4d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b50	8b 48 0a	 mov	 ecx, DWORD PTR [eax+10]
  00b53	83 c1 01	 add	 ecx, 1
  00b56	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00b59	89 4a 0a	 mov	 DWORD PTR [edx+10], ecx
  00b5c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b5f	83 78 0a 05	 cmp	 DWORD PTR [eax+10], 5
  00b63	7c 1f		 jl	 SHORT $L59874

; 543  : 		msgMgr->Fatal(SrcLoc, Msg_MsgStackStackOverflow, Max);

  00b65	6a 05		 push	 5
  00b67	6a 27		 push	 39			; 00000027H
  00b69	68 1f 02 00 00	 push	 543			; 0000021fH
  00b6e	68 00 00 00 00	 push	 OFFSET FLAT:$SG59875
  00b73	6a 61		 push	 97			; 00000061H
  00b75	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00b7b	51		 push	 ecx
  00b7c	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXDPADHHZZ ; MsgMgr::Fatal
  00b81	83 c4 18	 add	 esp, 24			; 00000018H
$L59874:

; 544  : 
; 545  : 	stack[sp].Get();

  00b84	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00b87	8b 42 0a	 mov	 eax, DWORD PTR [edx+10]
  00b8a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b8d	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  00b90	e8 00 00 00 00	 call	 ?Get@MsgStackID@@QAEXXZ	; MsgStackID::Get

; 546  : 	**stack[sp] = ms;

  00b95	8b 75 08	 mov	 esi, DWORD PTR _ms$[ebp]
  00b98	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00b9b	8b 42 0a	 mov	 eax, DWORD PTR [edx+10]
  00b9e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ba1	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  00ba4	e8 00 00 00 00	 call	 ??DMsgStackID@@QBEPAUMsgStack@@XZ ; MsgStackID::operator*
  00ba9	8b f8		 mov	 edi, eax
  00bab	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00bb0	f3 a5		 rep movsd
  00bb2	66 a5		 movsw

; 547  : }

  00bb4	5f		 pop	 edi
  00bb5	5e		 pop	 esi
  00bb6	8b e5		 mov	 esp, ebp
  00bb8	5d		 pop	 ebp
  00bb9	c2 04 00	 ret	 4
?Push@MsgStackStack@@QAEXAAUMsgStack@@@Z ENDP		; MsgStackStack::Push
_TEXT	ENDS
PUBLIC	??2@YAPAXIG@Z					; operator new
;	COMDAT ?Get@MsgStackID@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8
$T60124 = -4
?Get@MsgStackID@@QAEXXZ PROC NEAR			; MsgStackID::Get, COMDAT

; 57   : FakeTemplateID(MsgStackID, MsgStack, MemMsgStack)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 00		 push	 0
  0000f	6a 00		 push	 0
  00011	68 00 02 00 00	 push	 512			; 00000200H
  00016	6a 2e		 push	 46			; 0000002eH
  00018	6a 42		 push	 66			; 00000042H
  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get
  00022	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00025	66 8b 08	 mov	 cx, WORD PTR [eax]
  00028	51		 push	 ecx
  00029	6a 2e		 push	 46			; 0000002eH
  0002b	e8 00 00 00 00	 call	 ??2@YAPAXIG@Z		; operator new
  00030	83 c4 08	 add	 esp, 8
  00033	89 45 fc	 mov	 DWORD PTR $T60124[ebp], eax
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?Get@MsgStackID@@QAEXXZ ENDP				; MsgStackID::Get
_TEXT	ENDS
;	COMDAT ??2@YAPAXIG@Z
_TEXT	SEGMENT
_handle$ = 12
??2@YAPAXIG@Z PROC NEAR					; operator new, COMDAT

; 186  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 	return memMgr->GetAddr(handle);

  00003	66 8b 45 0c	 mov	 ax, WORD PTR _handle$[ebp]
  00007	50		 push	 eax
  00008	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  0000e	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr

; 188  : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??2@YAPAXIG@Z ENDP					; operator new
_TEXT	ENDS
;	COMDAT ??DMsgStackID@@QBEPAUMsgStack@@XZ
_TEXT	SEGMENT
_this$ = -4
??DMsgStackID@@QBEPAUMsgStack@@XZ PROC NEAR		; MsgStackID::operator*, COMDAT

; 57   : FakeTemplateID(MsgStackID, MsgStack, MemMsgStack)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??DMsgStackID@@QBEPAUMsgStack@@XZ ENDP			; MsgStackID::operator*
_TEXT	ENDS
PUBLIC	??0MsgStackID@@QAE@ABU0@@Z			; MsgStackID::MsgStackID
_DATA	SEGMENT
$SG59881 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Mess'
	DB	'age.cpp', 00H
_DATA	ENDS
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -56
_id$ = -52
_stack$ = -48
?Pop@MsgStackStack@@QAE?AUMsgStack@@XZ PROC NEAR	; MsgStackStack::Pop

; 551  : {

  00bbc	55		 push	 ebp
  00bbd	8b ec		 mov	 ebp, esp
  00bbf	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00bc2	56		 push	 esi
  00bc3	57		 push	 edi
  00bc4	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx

; 552  : 	//	restore previous saved stack
; 553  : 	
; 554  : 	if (sp < 0)

  00bc7	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  00bca	83 78 0a 00	 cmp	 DWORD PTR [eax+10], 0
  00bce	7d 1d		 jge	 SHORT $L59880

; 555  : 		msgMgr->Fatal(SrcLoc, Msg_MsgStackStackUnderflow);

  00bd0	6a 28		 push	 40			; 00000028H
  00bd2	68 2b 02 00 00	 push	 555			; 0000022bH
  00bd7	68 00 00 00 00	 push	 OFFSET FLAT:$SG59881
  00bdc	6a 61		 push	 97			; 00000061H
  00bde	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00be4	51		 push	 ecx
  00be5	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXDPADHHZZ ; MsgMgr::Fatal
  00bea	83 c4 14	 add	 esp, 20			; 00000014H
$L59880:

; 556  : 		
; 557  : 	MsgStackID id = stack[sp--];

  00bed	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  00bf0	8b 42 0a	 mov	 eax, DWORD PTR [edx+10]
  00bf3	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00bf6	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00bf9	89 55 c4	 mov	 DWORD PTR -60+[ebp], edx
  00bfc	8b 45 c4	 mov	 eax, DWORD PTR -60+[ebp]
  00bff	50		 push	 eax
  00c00	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00c03	8b 51 0a	 mov	 edx, DWORD PTR [ecx+10]
  00c06	83 ea 01	 sub	 edx, 1
  00c09	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  00c0c	89 50 0a	 mov	 DWORD PTR [eax+10], edx
  00c0f	8d 4d cc	 lea	 ecx, DWORD PTR _id$[ebp]
  00c12	e8 00 00 00 00	 call	 ??0MsgStackID@@QAE@ABU0@@Z ; MsgStackID::MsgStackID

; 558  : 	MsgStack stack = **id;

  00c17	8d 4d cc	 lea	 ecx, DWORD PTR _id$[ebp]
  00c1a	e8 00 00 00 00	 call	 ??DMsgStackID@@QBEPAUMsgStack@@XZ ; MsgStackID::operator*
  00c1f	8b f0		 mov	 esi, eax
  00c21	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00c26	8d 7d d0	 lea	 edi, DWORD PTR _stack$[ebp]
  00c29	f3 a5		 rep movsd
  00c2b	66 a5		 movsw

; 559  : 	id.Free();

  00c2d	8d 4d cc	 lea	 ecx, DWORD PTR _id$[ebp]
  00c30	e8 00 00 00 00	 call	 ?Free@MemID@@QAEXXZ	; MemID::Free

; 560  : 	return stack;

  00c35	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00c3a	8d 75 d0	 lea	 esi, DWORD PTR _stack$[ebp]
  00c3d	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00c40	f3 a5		 rep movsd
  00c42	66 a5		 movsw
  00c44	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 561  : }

  00c47	5f		 pop	 edi
  00c48	5e		 pop	 esi
  00c49	8b e5		 mov	 esp, ebp
  00c4b	5d		 pop	 ebp
  00c4c	c2 04 00	 ret	 4
?Pop@MsgStackStack@@QAE?AUMsgStack@@XZ ENDP		; MsgStackStack::Pop
_TEXT	ENDS
;	COMDAT ??0MsgStackID@@QAE@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0MsgStackID@@QAE@ABU0@@Z PROC NEAR			; MsgStackID::MsgStackID, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0MsgStackID@@QAE@ABU0@@Z ENDP				; MsgStackID::MsgStackID
_TEXT	ENDS
END
