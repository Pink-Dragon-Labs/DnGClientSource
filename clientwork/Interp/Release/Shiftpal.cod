	TITLE	\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Shiftpal.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MemoryMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckValid@MemoryMgr@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GMemoryMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@V1@III@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AMemID@@QBEAADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8MemID@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@NN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Rgb24@@QAE@EEE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Rgb24@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Rgb24F@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Ratio@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@HHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@VMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Type@Bitmap@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObj@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObj@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjView@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjView@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjView@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjView@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjMem@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjMem@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjMem@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjMem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjColor@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjColor@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjColor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjColor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CelObj@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjColor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjView@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7MemoryMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjMem@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?AddPalShift@@YAHH@Z				; AddPalShift
EXTRN	?WING@@3HA:DWORD				; WING
_TEXT	SEGMENT
_val$ = 8
?AddPalShift@@YAHH@Z PROC NEAR				; AddPalShift

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17   : 	if (WING && (val < 246))

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?WING@@3HA, 0	; WING
  0000a	74 11		 je	 SHORT $L56362
  0000c	81 7d 08 f6 00
	00 00		 cmp	 DWORD PTR _val$[ebp], 246 ; 000000f6H
  00013	7d 08		 jge	 SHORT $L56362

; 18   : 		return (val + PALSHIFT);

  00015	8b 45 08	 mov	 eax, DWORD PTR _val$[ebp]
  00018	83 c0 0a	 add	 eax, 10			; 0000000aH
  0001b	eb 03		 jmp	 SHORT $L56363
$L56362:

; 20   : 		return val;

  0001d	8b 45 08	 mov	 eax, DWORD PTR _val$[ebp]
$L56363:

; 21   : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?AddPalShift@@YAHH@Z ENDP				; AddPalShift
_TEXT	ENDS
PUBLIC	?ShiftPaletteView@@YAXPAE@Z			; ShiftPaletteView
PUBLIC	?ShiftPaletteCel@@YAXPAEJ@Z			; ShiftPaletteCel
_TEXT	SEGMENT
_resBuffer$ = 8
_celOffset$ = -4
_loop$ = -8
_cel$ = -12
_viewPtr$ = -16
_loopPtr$56375 = -20
?ShiftPaletteView@@YAXPAE@Z PROC NEAR			; ShiftPaletteView

; 25   : {

  00022	55		 push	 ebp
  00023	8b ec		 mov	 ebp, esp
  00025	83 ec 14	 sub	 esp, 20			; 00000014H

; 26   : 	long celOffset;
; 27   : 	int  loop, cel;
; 28   : 
; 29   : 	ViewHeader* viewPtr = (ViewHeader*) resBuffer;

  00028	8b 45 08	 mov	 eax, DWORD PTR _resBuffer$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR _viewPtr$[ebp], eax

; 30   : 
; 31   : 	for (loop = 0; loop < viewPtr->loopCount; loop++) {

  0002e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _loop$[ebp], 0
  00035	eb 09		 jmp	 SHORT $L56372
$L56373:
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _loop$[ebp]
  0003a	83 c1 01	 add	 ecx, 1
  0003d	89 4d f8	 mov	 DWORD PTR _loop$[ebp], ecx
$L56372:
  00040	8b 55 f0	 mov	 edx, DWORD PTR _viewPtr$[ebp]
  00043	33 c0		 xor	 eax, eax
  00045	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  00048	39 45 f8	 cmp	 DWORD PTR _loop$[ebp], eax
  0004b	7d 7a		 jge	 SHORT $L56374

; 32   : 		LoopHeader* loopPtr =
; 33   : 			(LoopHeader*) ((char*) viewPtr + viewPtr->loopHeaderSize * loop
; 34   : 	                                   + viewPtr->viewHeaderSize + 2);

  0004d	8b 4d f0	 mov	 ecx, DWORD PTR _viewPtr$[ebp]
  00050	33 d2		 xor	 edx, edx
  00052	8a 51 0c	 mov	 dl, BYTE PTR [ecx+12]
  00055	0f af 55 f8	 imul	 edx, DWORD PTR _loop$[ebp]
  00059	8b 45 f0	 mov	 eax, DWORD PTR _viewPtr$[ebp]
  0005c	03 c2		 add	 eax, edx
  0005e	8b 4d f0	 mov	 ecx, DWORD PTR _viewPtr$[ebp]
  00061	33 d2		 xor	 edx, edx
  00063	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00066	8d 44 10 02	 lea	 eax, DWORD PTR [eax+edx+2]
  0006a	89 45 ec	 mov	 DWORD PTR _loopPtr$56375[ebp], eax

; 35   : 		if (loopPtr->altLoop == -1) {

  0006d	8b 4d ec	 mov	 ecx, DWORD PTR _loopPtr$56375[ebp]
  00070	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00073	83 fa ff	 cmp	 edx, -1
  00076	75 4a		 jne	 SHORT $L56381

; 36   : 			for (cel = 0; cel < loopPtr->numCels; cel++) {

  00078	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _cel$[ebp], 0
  0007f	eb 09		 jmp	 SHORT $L56379
$L56380:
  00081	8b 45 f4	 mov	 eax, DWORD PTR _cel$[ebp]
  00084	83 c0 01	 add	 eax, 1
  00087	89 45 f4	 mov	 DWORD PTR _cel$[ebp], eax
$L56379:
  0008a	8b 4d ec	 mov	 ecx, DWORD PTR _loopPtr$56375[ebp]
  0008d	33 d2		 xor	 edx, edx
  0008f	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  00092	39 55 f4	 cmp	 DWORD PTR _cel$[ebp], edx
  00095	7d 2b		 jge	 SHORT $L56381

; 37   : 				celOffset = loopPtr->celOffset + cel * viewPtr->celHeaderSize;

  00097	8b 45 f0	 mov	 eax, DWORD PTR _viewPtr$[ebp]
  0009a	33 c9		 xor	 ecx, ecx
  0009c	8a 48 0d	 mov	 cl, BYTE PTR [eax+13]
  0009f	8b 55 f4	 mov	 edx, DWORD PTR _cel$[ebp]
  000a2	0f af d1	 imul	 edx, ecx
  000a5	8b 45 ec	 mov	 eax, DWORD PTR _loopPtr$56375[ebp]
  000a8	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000ab	03 ca		 add	 ecx, edx
  000ad	89 4d fc	 mov	 DWORD PTR _celOffset$[ebp], ecx

; 38   : 				ShiftPaletteCel(resBuffer, celOffset);

  000b0	8b 55 fc	 mov	 edx, DWORD PTR _celOffset$[ebp]
  000b3	52		 push	 edx
  000b4	8b 45 08	 mov	 eax, DWORD PTR _resBuffer$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 ?ShiftPaletteCel@@YAXPAEJ@Z ; ShiftPaletteCel
  000bd	83 c4 08	 add	 esp, 8

; 39   : 			}

  000c0	eb bf		 jmp	 SHORT $L56380
$L56381:

; 41   : 	}

  000c2	e9 70 ff ff ff	 jmp	 $L56373
$L56374:

; 42   : }

  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c3		 ret	 0
?ShiftPaletteView@@YAXPAE@Z ENDP			; ShiftPaletteView
_TEXT	ENDS
PUBLIC	?ShiftPalettePic@@YAXPAE@Z			; ShiftPalettePic
_TEXT	SEGMENT
_resBuffer$ = 8
_celOffset$ = -4
_cel$ = -8
_picPtr$ = -12
?ShiftPalettePic@@YAXPAE@Z PROC NEAR			; ShiftPalettePic

; 46   : {

  000cb	55		 push	 ebp
  000cc	8b ec		 mov	 ebp, esp
  000ce	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 47   : 	long celOffset;
; 48   : 	int  cel;
; 49   : 
; 50   : 	PicHeader* picPtr = (PicHeader *) resBuffer;

  000d1	8b 45 08	 mov	 eax, DWORD PTR _resBuffer$[ebp]
  000d4	89 45 f4	 mov	 DWORD PTR _picPtr$[ebp], eax

; 51   : 	cel	= picPtr->celCount;

  000d7	8b 4d f4	 mov	 ecx, DWORD PTR _picPtr$[ebp]
  000da	33 d2		 xor	 edx, edx
  000dc	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  000df	89 55 f8	 mov	 DWORD PTR _cel$[ebp], edx

; 52   : 	for(cel = 0; cel < picPtr->celCount; cel++) {

  000e2	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cel$[ebp], 0
  000e9	eb 09		 jmp	 SHORT $L56389
$L56390:
  000eb	8b 45 f8	 mov	 eax, DWORD PTR _cel$[ebp]
  000ee	83 c0 01	 add	 eax, 1
  000f1	89 45 f8	 mov	 DWORD PTR _cel$[ebp], eax
$L56389:
  000f4	8b 4d f4	 mov	 ecx, DWORD PTR _picPtr$[ebp]
  000f7	33 d2		 xor	 edx, edx
  000f9	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  000fc	39 55 f8	 cmp	 DWORD PTR _cel$[ebp], edx
  000ff	7d 2e		 jge	 SHORT $L56391

; 53   : 		celOffset = picPtr->picHeaderSize + cel * picPtr->celHeaderSize;

  00101	8b 45 f4	 mov	 eax, DWORD PTR _picPtr$[ebp]
  00104	33 c9		 xor	 ecx, ecx
  00106	66 8b 08	 mov	 cx, WORD PTR [eax]
  00109	8b 55 f4	 mov	 edx, DWORD PTR _picPtr$[ebp]
  0010c	33 c0		 xor	 eax, eax
  0010e	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  00112	8b 55 f8	 mov	 edx, DWORD PTR _cel$[ebp]
  00115	0f af d0	 imul	 edx, eax
  00118	03 ca		 add	 ecx, edx
  0011a	89 4d fc	 mov	 DWORD PTR _celOffset$[ebp], ecx

; 54   : 	  	ShiftPaletteCel(resBuffer, celOffset);

  0011d	8b 45 fc	 mov	 eax, DWORD PTR _celOffset$[ebp]
  00120	50		 push	 eax
  00121	8b 4d 08	 mov	 ecx, DWORD PTR _resBuffer$[ebp]
  00124	51		 push	 ecx
  00125	e8 00 00 00 00	 call	 ?ShiftPaletteCel@@YAXPAEJ@Z ; ShiftPaletteCel
  0012a	83 c4 08	 add	 esp, 8

; 55   : 	}

  0012d	eb bc		 jmp	 SHORT $L56390
$L56391:

; 56   : }

  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c3		 ret	 0
?ShiftPalettePic@@YAXPAE@Z ENDP				; ShiftPalettePic
_resBuffer$ = 8
_celOffset$ = 12
_celPtr$ = -20
_hRun$ = -12
_vRun$ = -4
_controlData$ = -8
_colorData$ = -28
_controlTable$ = -24
_colorTable$ = -16
_i$56407 = -32
_controlPtr$56411 = -40
_colorPtr$56412 = -44
_j$56413 = -36
_control$56417 = -48
_k$56419 = -52
_i$56429 = -56
_src$56433 = -64
_j$56434 = -60
?ShiftPaletteCel@@YAXPAEJ@Z PROC NEAR			; ShiftPaletteCel

; 60   : {

  00133	55		 push	 ebp
  00134	8b ec		 mov	 ebp, esp
  00136	83 ec 40	 sub	 esp, 64			; 00000040H

; 61   : 	CelHeader* celPtr = (CelHeader*) (resBuffer + celOffset);

  00139	8b 45 08	 mov	 eax, DWORD PTR _resBuffer$[ebp]
  0013c	03 45 0c	 add	 eax, DWORD PTR _celOffset$[ebp]
  0013f	89 45 ec	 mov	 DWORD PTR _celPtr$[ebp], eax

; 62   : 	int hRun = celPtr->xDim;

  00142	8b 4d ec	 mov	 ecx, DWORD PTR _celPtr$[ebp]
  00145	33 d2		 xor	 edx, edx
  00147	66 8b 11	 mov	 dx, WORD PTR [ecx]
  0014a	89 55 f4	 mov	 DWORD PTR _hRun$[ebp], edx

; 63   : 	int vRun = celPtr->yDim;

  0014d	8b 45 ec	 mov	 eax, DWORD PTR _celPtr$[ebp]
  00150	33 c9		 xor	 ecx, ecx
  00152	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  00156	89 4d fc	 mov	 DWORD PTR _vRun$[ebp], ecx

; 64   : 
; 65   : 	uchar* controlData = resBuffer + celPtr->controlOffset;

  00159	8b 55 ec	 mov	 edx, DWORD PTR _celPtr$[ebp]
  0015c	8b 45 08	 mov	 eax, DWORD PTR _resBuffer$[ebp]
  0015f	03 42 18	 add	 eax, DWORD PTR [edx+24]
  00162	89 45 f8	 mov	 DWORD PTR _controlData$[ebp], eax

; 66   : 	uchar* colorData = resBuffer + celPtr->colorOffset;

  00165	8b 4d ec	 mov	 ecx, DWORD PTR _celPtr$[ebp]
  00168	8b 55 08	 mov	 edx, DWORD PTR _resBuffer$[ebp]
  0016b	03 51 1c	 add	 edx, DWORD PTR [ecx+28]
  0016e	89 55 e4	 mov	 DWORD PTR _colorData$[ebp], edx

; 67   : 	long* controlTable = (long *) (resBuffer + celPtr->rowTableOffset);

  00171	8b 45 ec	 mov	 eax, DWORD PTR _celPtr$[ebp]
  00174	8b 4d 08	 mov	 ecx, DWORD PTR _resBuffer$[ebp]
  00177	03 48 20	 add	 ecx, DWORD PTR [eax+32]
  0017a	89 4d e8	 mov	 DWORD PTR _controlTable$[ebp], ecx

; 68   : 	long* colorTable = controlTable + vRun;

  0017d	8b 55 fc	 mov	 edx, DWORD PTR _vRun$[ebp]
  00180	8b 45 e8	 mov	 eax, DWORD PTR _controlTable$[ebp]
  00183	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00186	89 4d f0	 mov	 DWORD PTR _colorTable$[ebp], ecx

; 69   : 
; 70   : 	if (celPtr->skip < 246)

  00189	8b 55 ec	 mov	 edx, DWORD PTR _celPtr$[ebp]
  0018c	33 c0		 xor	 eax, eax
  0018e	8a 42 08	 mov	 al, BYTE PTR [edx+8]
  00191	3d f6 00 00 00	 cmp	 eax, 246		; 000000f6H
  00196	7d 0f		 jge	 SHORT $L56405

; 71   : 		celPtr->skip += PALSHIFT;

  00198	8b 4d ec	 mov	 ecx, DWORD PTR _celPtr$[ebp]
  0019b	8a 51 08	 mov	 dl, BYTE PTR [ecx+8]
  0019e	80 c2 0a	 add	 dl, 10			; 0000000aH
  001a1	8b 45 ec	 mov	 eax, DWORD PTR _celPtr$[ebp]
  001a4	88 50 08	 mov	 BYTE PTR [eax+8], dl
$L56405:

; 72   : 	if (celPtr->compressType) {

  001a7	8b 4d ec	 mov	 ecx, DWORD PTR _celPtr$[ebp]
  001aa	33 d2		 xor	 edx, edx
  001ac	8a 51 09	 mov	 dl, BYTE PTR [ecx+9]
  001af	85 d2		 test	 edx, edx
  001b1	0f 84 3e 01 00
	00		 je	 $L56406

; 73   : 		for (int i = 0;i < vRun; i++) {

  001b7	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$56407[ebp], 0
  001be	eb 09		 jmp	 SHORT $L56408
$L56409:
  001c0	8b 45 e0	 mov	 eax, DWORD PTR _i$56407[ebp]
  001c3	83 c0 01	 add	 eax, 1
  001c6	89 45 e0	 mov	 DWORD PTR _i$56407[ebp], eax
$L56408:
  001c9	8b 4d e0	 mov	 ecx, DWORD PTR _i$56407[ebp]
  001cc	3b 4d fc	 cmp	 ecx, DWORD PTR _vRun$[ebp]
  001cf	0f 8d 1e 01 00
	00		 jge	 $L56410

; 74   : 			// Find the row data
; 75   : 			uchar* controlPtr = controlData + controlTable[i];

  001d5	8b 55 e0	 mov	 edx, DWORD PTR _i$56407[ebp]
  001d8	8b 45 e8	 mov	 eax, DWORD PTR _controlTable$[ebp]
  001db	8b 4d f8	 mov	 ecx, DWORD PTR _controlData$[ebp]
  001de	03 0c 90	 add	 ecx, DWORD PTR [eax+edx*4]
  001e1	89 4d d8	 mov	 DWORD PTR _controlPtr$56411[ebp], ecx

; 76   : 			uchar* colorPtr = colorData + colorTable[i];

  001e4	8b 55 e0	 mov	 edx, DWORD PTR _i$56407[ebp]
  001e7	8b 45 f0	 mov	 eax, DWORD PTR _colorTable$[ebp]
  001ea	8b 4d e4	 mov	 ecx, DWORD PTR _colorData$[ebp]
  001ed	03 0c 90	 add	 ecx, DWORD PTR [eax+edx*4]
  001f0	89 4d d4	 mov	 DWORD PTR _colorPtr$56412[ebp], ecx

; 77   : 			for (int j = 0;j < hRun;) {

  001f3	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _j$56413[ebp], 0
$L56415:
  001fa	8b 55 dc	 mov	 edx, DWORD PTR _j$56413[ebp]
  001fd	3b 55 f4	 cmp	 edx, DWORD PTR _hRun$[ebp]
  00200	0f 8d e8 00 00
	00		 jge	 $L56416

; 78   : 
; 79   : 				// Get the control character
; 80   : 				uchar control = *controlPtr++;

  00206	8b 45 d8	 mov	 eax, DWORD PTR _controlPtr$56411[ebp]
  00209	8a 08		 mov	 cl, BYTE PTR [eax]
  0020b	88 4d d0	 mov	 BYTE PTR _control$56417[ebp], cl
  0020e	8b 55 d8	 mov	 edx, DWORD PTR _controlPtr$56411[ebp]
  00211	83 c2 01	 add	 edx, 1
  00214	89 55 d8	 mov	 DWORD PTR _controlPtr$56411[ebp], edx

; 81   : 				if (!(control & REPEATC)) {

  00217	8b 45 d0	 mov	 eax, DWORD PTR _control$56417[ebp]
  0021a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0021f	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00224	85 c0		 test	 eax, eax
  00226	75 58		 jne	 SHORT $L56418

; 82   : 
; 83   : 				// Do a run of unique bytes
; 84   : 				  	for(int k=0;k<control;k++) {

  00228	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _k$56419[ebp], 0
  0022f	eb 09		 jmp	 SHORT $L56420
$L56421:
  00231	8b 4d cc	 mov	 ecx, DWORD PTR _k$56419[ebp]
  00234	83 c1 01	 add	 ecx, 1
  00237	89 4d cc	 mov	 DWORD PTR _k$56419[ebp], ecx
$L56420:
  0023a	8b 55 d0	 mov	 edx, DWORD PTR _control$56417[ebp]
  0023d	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00243	39 55 cc	 cmp	 DWORD PTR _k$56419[ebp], edx
  00246	7d 26		 jge	 SHORT $L56422

; 85   : 						if (*colorPtr < 246)

  00248	8b 45 d4	 mov	 eax, DWORD PTR _colorPtr$56412[ebp]
  0024b	33 c9		 xor	 ecx, ecx
  0024d	8a 08		 mov	 cl, BYTE PTR [eax]
  0024f	81 f9 f6 00 00
	00		 cmp	 ecx, 246		; 000000f6H
  00255	7d 0c		 jge	 SHORT $L56423

; 86   : 							*colorPtr += PALSHIFT;

  00257	8b 55 d4	 mov	 edx, DWORD PTR _colorPtr$56412[ebp]
  0025a	8a 02		 mov	 al, BYTE PTR [edx]
  0025c	04 0a		 add	 al, 10			; 0000000aH
  0025e	8b 4d d4	 mov	 ecx, DWORD PTR _colorPtr$56412[ebp]
  00261	88 01		 mov	 BYTE PTR [ecx], al
$L56423:

; 87   : 						colorPtr++;

  00263	8b 55 d4	 mov	 edx, DWORD PTR _colorPtr$56412[ebp]
  00266	83 c2 01	 add	 edx, 1
  00269	89 55 d4	 mov	 DWORD PTR _colorPtr$56412[ebp], edx

; 88   :                }

  0026c	eb c3		 jmp	 SHORT $L56421
$L56422:

; 89   : 					j += control;

  0026e	8b 45 d0	 mov	 eax, DWORD PTR _control$56417[ebp]
  00271	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00276	8b 4d dc	 mov	 ecx, DWORD PTR _j$56413[ebp]
  00279	03 c8		 add	 ecx, eax
  0027b	89 4d dc	 mov	 DWORD PTR _j$56413[ebp], ecx

; 90   : 
; 91   : 				} else {

  0027e	eb 69		 jmp	 SHORT $L56426
$L56418:

; 92   : 					if (control & REPSKIP) {

  00280	8b 55 d0	 mov	 edx, DWORD PTR _control$56417[ebp]
  00283	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00289	83 e2 40	 and	 edx, 64			; 00000040H
  0028c	85 d2		 test	 edx, edx
  0028e	74 1b		 je	 SHORT $L56425

; 93   : 						// Do a run of repeated skip
; 94   : 						control &= 0x3f;

  00290	8a 45 d0	 mov	 al, BYTE PTR _control$56417[ebp]
  00293	24 3f		 and	 al, 63			; 0000003fH
  00295	88 45 d0	 mov	 BYTE PTR _control$56417[ebp], al

; 95   : 						j += control;

  00298	8b 4d d0	 mov	 ecx, DWORD PTR _control$56417[ebp]
  0029b	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  002a1	8b 55 dc	 mov	 edx, DWORD PTR _j$56413[ebp]
  002a4	03 d1		 add	 edx, ecx
  002a6	89 55 dc	 mov	 DWORD PTR _j$56413[ebp], edx

; 96   : 
; 97   : 					} else {

  002a9	eb 3e		 jmp	 SHORT $L56426
$L56425:

; 98   : 						// Do a run of repeated color
; 99   : 						control &= 0x3f;

  002ab	8a 45 d0	 mov	 al, BYTE PTR _control$56417[ebp]
  002ae	24 3f		 and	 al, 63			; 0000003fH
  002b0	88 45 d0	 mov	 BYTE PTR _control$56417[ebp], al

; 100  : 						if (*colorPtr < 246)

  002b3	8b 4d d4	 mov	 ecx, DWORD PTR _colorPtr$56412[ebp]
  002b6	33 d2		 xor	 edx, edx
  002b8	8a 11		 mov	 dl, BYTE PTR [ecx]
  002ba	81 fa f6 00 00
	00		 cmp	 edx, 246		; 000000f6H
  002c0	7d 0d		 jge	 SHORT $L56427

; 101  : 						  	*colorPtr += PALSHIFT;

  002c2	8b 45 d4	 mov	 eax, DWORD PTR _colorPtr$56412[ebp]
  002c5	8a 08		 mov	 cl, BYTE PTR [eax]
  002c7	80 c1 0a	 add	 cl, 10			; 0000000aH
  002ca	8b 55 d4	 mov	 edx, DWORD PTR _colorPtr$56412[ebp]
  002cd	88 0a		 mov	 BYTE PTR [edx], cl
$L56427:

; 102  : 						colorPtr++;

  002cf	8b 45 d4	 mov	 eax, DWORD PTR _colorPtr$56412[ebp]
  002d2	83 c0 01	 add	 eax, 1
  002d5	89 45 d4	 mov	 DWORD PTR _colorPtr$56412[ebp], eax

; 103  : 						j += control;

  002d8	8b 4d d0	 mov	 ecx, DWORD PTR _control$56417[ebp]
  002db	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  002e1	8b 55 dc	 mov	 edx, DWORD PTR _j$56413[ebp]
  002e4	03 d1		 add	 edx, ecx
  002e6	89 55 dc	 mov	 DWORD PTR _j$56413[ebp], edx
$L56426:

; 106  : 			}				

  002e9	e9 0c ff ff ff	 jmp	 $L56415
$L56416:

; 107  : 		}

  002ee	e9 cd fe ff ff	 jmp	 $L56409
$L56410:

; 108  : 	} else {

  002f3	eb 78		 jmp	 SHORT $L56432
$L56406:

; 109  : 		colorData = resBuffer + celPtr->controlOffset;

  002f5	8b 45 ec	 mov	 eax, DWORD PTR _celPtr$[ebp]
  002f8	8b 4d 08	 mov	 ecx, DWORD PTR _resBuffer$[ebp]
  002fb	03 48 18	 add	 ecx, DWORD PTR [eax+24]
  002fe	89 4d e4	 mov	 DWORD PTR _colorData$[ebp], ecx

; 110  : 		for (int i = 0;i < vRun; i++) {

  00301	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _i$56429[ebp], 0
  00308	eb 09		 jmp	 SHORT $L56430
$L56431:
  0030a	8b 55 c8	 mov	 edx, DWORD PTR _i$56429[ebp]
  0030d	83 c2 01	 add	 edx, 1
  00310	89 55 c8	 mov	 DWORD PTR _i$56429[ebp], edx
$L56430:
  00313	8b 45 c8	 mov	 eax, DWORD PTR _i$56429[ebp]
  00316	3b 45 fc	 cmp	 eax, DWORD PTR _vRun$[ebp]
  00319	7d 52		 jge	 SHORT $L56432

; 111  : 			uchar* src = colorData;

  0031b	8b 4d e4	 mov	 ecx, DWORD PTR _colorData$[ebp]
  0031e	89 4d c0	 mov	 DWORD PTR _src$56433[ebp], ecx

; 112  : 			for (int j = 0;j < hRun;j++) {

  00321	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _j$56434[ebp], 0
  00328	eb 09		 jmp	 SHORT $L56435
$L56436:
  0032a	8b 55 c4	 mov	 edx, DWORD PTR _j$56434[ebp]
  0032d	83 c2 01	 add	 edx, 1
  00330	89 55 c4	 mov	 DWORD PTR _j$56434[ebp], edx
$L56435:
  00333	8b 45 c4	 mov	 eax, DWORD PTR _j$56434[ebp]
  00336	3b 45 f4	 cmp	 eax, DWORD PTR _hRun$[ebp]
  00339	7d 27		 jge	 SHORT $L56437

; 113  : 				if (*src < 246)

  0033b	8b 4d c0	 mov	 ecx, DWORD PTR _src$56433[ebp]
  0033e	33 d2		 xor	 edx, edx
  00340	8a 11		 mov	 dl, BYTE PTR [ecx]
  00342	81 fa f6 00 00
	00		 cmp	 edx, 246		; 000000f6H
  00348	7d 0d		 jge	 SHORT $L56438

; 114  : 					*src += PALSHIFT;

  0034a	8b 45 c0	 mov	 eax, DWORD PTR _src$56433[ebp]
  0034d	8a 08		 mov	 cl, BYTE PTR [eax]
  0034f	80 c1 0a	 add	 cl, 10			; 0000000aH
  00352	8b 55 c0	 mov	 edx, DWORD PTR _src$56433[ebp]
  00355	88 0a		 mov	 BYTE PTR [edx], cl
$L56438:

; 115  : 				src++;

  00357	8b 45 c0	 mov	 eax, DWORD PTR _src$56433[ebp]
  0035a	83 c0 01	 add	 eax, 1
  0035d	89 45 c0	 mov	 DWORD PTR _src$56433[ebp], eax

; 116  : 			}

  00360	eb c8		 jmp	 SHORT $L56436
$L56437:

; 117  : 			colorData += hRun;

  00362	8b 4d e4	 mov	 ecx, DWORD PTR _colorData$[ebp]
  00365	03 4d f4	 add	 ecx, DWORD PTR _hRun$[ebp]
  00368	89 4d e4	 mov	 DWORD PTR _colorData$[ebp], ecx

; 118  : 		}

  0036b	eb 9d		 jmp	 SHORT $L56431
$L56432:

; 120  : 
; 121  : #ifdef DEBUG
; 122  : 	#ifndef MACINTOSH
; 123  : 		memMgr->SetChecksum(resBuffer);
; 124  : 	#endif
; 125  : #endif
; 126  : 
; 127  : }

  0036d	8b e5		 mov	 esp, ebp
  0036f	5d		 pop	 ebp
  00370	c3		 ret	 0
?ShiftPaletteCel@@YAXPAEJ@Z ENDP			; ShiftPaletteCel
_TEXT	ENDS
END
