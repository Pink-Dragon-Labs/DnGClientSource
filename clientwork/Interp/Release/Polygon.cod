	TITLE	\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Polygon.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@LHED@Instructed?5to?5scale?5to?5zero?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MemoryMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMemType@MemoryMgr@@QAE?AW4MemType@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckValid@MemoryMgr@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GMemoryMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@MemID@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@V1@III@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AMemID@@QBEAADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8MemID@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??7MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeArrayID@@QBEPAUArrayHeader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ArrayID@@QAE@HW4ArrayType@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@ArrayID@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Array@@QAE@VMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Array@@QAE@HW4ArrayType@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAE?AVMemID@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAEXVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_List@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@SOL_List@@QAEAAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeSOL_ListID@@QBEPAVSOL_List@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_ListID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_ListID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeDispatchTblID@@QBEPAUDispatchTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeScriptEntryID@@QBEPAUScriptEntry@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntry@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeVariableID@@QBEPAUVariable@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Script@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Object@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGraphicsUpdate@Object@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?selectorDict@Object@@QAEPAVSelectorDict@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AObject@@QAEAAFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddr@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedPropAddr@Object@@QAEPBFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedProperty@Object@@QAEFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddrCheck@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@Object@@QAEFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropOffset@Object@@QAEIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetIndexedProperty@Object@@QAEXHF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetProperty@Object@@QAEXGF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssureValid@ObjectID@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsObject@ObjectID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@ObjectID@@QBEFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetProperty@ObjectID@@QBEXGF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeClassTblID@@QBEPAUClassTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SCI_Point@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@NN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SOL_Point@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HSCI_Point@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GSCI_Point@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GSCI_Point@@QBE?AU0@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DSCI_Point@@QBEHABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??TSCI_Point@@QBEHABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??ZSCI_Point@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8SCI_Point@@QBEHABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9SCI_Point@@QBEHABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4FPoint@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4FPoint@@QAEAAV0@ABUSCI_Point@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HFPoint@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GFPoint@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GFPoint@@QBE?AV0@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFPoint@@QBENABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??TFPoint@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8FPoint@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@AAVSOL_Point@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeEmpty@SOL_Rect@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Xlen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ylen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8SOL_Rect@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Ratio@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Rgb24@@QAE@EEE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Rgb24@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Rgb24F@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@HHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@VMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Type@Bitmap@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObj@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Skip@CelObj@@QBEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemapState@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Mirrored@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObj@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjView@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjView@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjView@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjView@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjMem@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjMem@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjMem@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjMem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjColor@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjColor@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjColor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjColor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Draw@ScreenItem@@QAEXABVBuffer@@ABVSOL_Rect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SOL_Rect@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0PolyNode@@QAE@USCI_Point@@0HHHPAU1@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_ListID@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CelObj@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjColor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjView@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7MemoryMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjMem@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?planePoly@@3PAUSCI_Point@@A			; planePoly
PUBLIC	?gCheckPlaneEdge@@3HA				; gCheckPlaneEdge
_BSS	SEGMENT
?planePoly@@3PAUSCI_Point@@A DD 04H DUP (?)		; planePoly
_BSS	ENDS
CRT$XCU	SEGMENT
_$S12	DD	FLAT:_$E11
CRT$XCU	ENDS
_DATA	SEGMENT
?gCheckPlaneEdge@@3HA DD 03H				; gCheckPlaneEdge
_DATA	ENDS
_TEXT	SEGMENT
_$E11	PROC NEAR
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	e8 00 00 00 00	 call	 _$E10
  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
_$E11	ENDP
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
PUBLIC	??0SCI_Point@@QAE@XZ				; SCI_Point::SCI_Point
_TEXT	SEGMENT
_$E10	PROC NEAR

; 40   : SCI_Point planePoly[4];

  0000a	55		 push	 ebp
  0000b	8b ec		 mov	 ebp, esp
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:??0SCI_Point@@QAE@XZ ; SCI_Point::SCI_Point
  00012	6a 04		 push	 4
  00014	6a 04		 push	 4
  00016	68 00 00 00 00	 push	 OFFSET FLAT:?planePoly@@3PAUSCI_Point@@A ; planePoly
  0001b	e8 00 00 00 00	 call	 ??_H@YGXPAXIHP6EX0@Z@Z	; `vector constructor iterator'
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
_$E10	ENDP
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0SCI_Point@@QAE@XZ PROC NEAR				; SCI_Point::SCI_Point, COMDAT

; 52   : 	SCI_Point() : x((SCIWord) DefaultCoord), y((SCIWord) DefaultCoord) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 c7 00 cd ab	 mov	 WORD PTR [eax], -21555	; ffffabcdH
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	66 c7 41 02 cd
	ab		 mov	 WORD PTR [ecx+2], -21555 ; ffffabcdH
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0SCI_Point@@QAE@XZ ENDP				; SCI_Point::SCI_Point
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$L60998:
  00003	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00006	83 e8 01	 sub	 eax, 1
  00009	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  0000c	83 7d 10 00	 cmp	 DWORD PTR ___n$[ebp], 0
  00010	7c 11		 jl	 SHORT $L60999
  00012	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00015	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001b	03 4d 0c	 add	 ecx, DWORD PTR ___s$[ebp]
  0001e	89 4d 08	 mov	 DWORD PTR ___t$[ebp], ecx
  00021	eb e0		 jmp	 SHORT $L60998
$L60999:
  00023	5d		 pop	 ebp
  00024	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??4SCI_Point@@QAEAAU0@ABU0@@Z			; SCI_Point::operator=
PUBLIC	??8SCI_Point@@QBEHABU0@@Z			; SCI_Point::operator==
PUBLIC	??GSCI_Point@@QBE?AU0@ABU0@@Z			; SCI_Point::operator-
PUBLIC	??GSCI_Point@@QBE?AU0@XZ			; SCI_Point::operator-
PUBLIC	??TSCI_Point@@QBEHABU0@@Z			; SCI_Point::operator^
PUBLIC	?PointInterior@@YAHAAUSCI_Point@@PAU1@H@Z	; PointInterior
_TEXT	SEGMENT
_M$ = 8
_polygon$ = 12
_n$ = 16
_N3$ = -36
_P1$ = -8
_P2$ = -12
_P3$ = -16
_P4$ = -20
_tmp1$ = -24
_tmp2$ = -28
_nextnode$ = -32
_interior$ = -4
$T62334 = -40
$T62335 = -44
$T62336 = -48
$T62337 = -52
$T62338 = -56
?PointInterior@@YAHAAUSCI_Point@@PAU1@H@Z PROC NEAR	; PointInterior

; 45   : {

  00022	55		 push	 ebp
  00023	8b ec		 mov	 ebp, esp
  00025	83 ec 38	 sub	 esp, 56			; 00000038H

; 46   :    SCI_Point   N3,P1,P2,P3,P4;

  00028	8d 4d dc	 lea	 ecx, DWORD PTR _N3$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  00030	8d 4d f8	 lea	 ecx, DWORD PTR _P1$[ebp]
  00033	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  00038	8d 4d f4	 lea	 ecx, DWORD PTR _P2$[ebp]
  0003b	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  00040	8d 4d f0	 lea	 ecx, DWORD PTR _P3$[ebp]
  00043	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  00048	8d 4d ec	 lea	 ecx, DWORD PTR _P4$[ebp]
  0004b	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point

; 47   :    SCI_Point   tmp1,tmp2;

  00050	8d 4d e8	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  00053	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  00058	8d 4d e4	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  0005b	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point

; 48   :    int         nextnode,interior = 0;

  00060	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _interior$[ebp], 0

; 49   : 
; 50   :    P1 = polygon[0];

  00067	8b 45 0c	 mov	 eax, DWORD PTR _polygon$[ebp]
  0006a	50		 push	 eax
  0006b	8d 4d f8	 lea	 ecx, DWORD PTR _P1$[ebp]
  0006e	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 51   :    P2 = polygon[1];

  00073	8b 4d 0c	 mov	 ecx, DWORD PTR _polygon$[ebp]
  00076	83 c1 04	 add	 ecx, 4
  00079	51		 push	 ecx
  0007a	8d 4d f4	 lea	 ecx, DWORD PTR _P2$[ebp]
  0007d	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 52   :    nextnode = 3;

  00082	c7 45 e0 03 00
	00 00		 mov	 DWORD PTR _nextnode$[ebp], 3

; 53   :    P3 = N3 = polygon[2];

  00089	8b 55 0c	 mov	 edx, DWORD PTR _polygon$[ebp]
  0008c	83 c2 08	 add	 edx, 8
  0008f	52		 push	 edx
  00090	8d 4d dc	 lea	 ecx, DWORD PTR _N3$[ebp]
  00093	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=
  00098	50		 push	 eax
  00099	8d 4d f0	 lea	 ecx, DWORD PTR _P3$[ebp]
  0009c	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 54   :    if (n>3)

  000a1	83 7d 10 03	 cmp	 DWORD PTR _n$[ebp], 3
  000a5	7e 11		 jle	 SHORT $L61016

; 55   :       P4 = polygon[3];

  000a7	8b 45 0c	 mov	 eax, DWORD PTR _polygon$[ebp]
  000aa	83 c0 0c	 add	 eax, 12			; 0000000cH
  000ad	50		 push	 eax
  000ae	8d 4d ec	 lea	 ecx, DWORD PTR _P4$[ebp]
  000b1	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 56   :    else

  000b6	eb 0c		 jmp	 SHORT $L61017
$L61016:

; 57   :       P4 = polygon[0];

  000b8	8b 4d 0c	 mov	 ecx, DWORD PTR _polygon$[ebp]
  000bb	51		 push	 ecx
  000bc	8d 4d ec	 lea	 ecx, DWORD PTR _P4$[ebp]
  000bf	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=
$L61017:

; 58   :    while (True)

  000c4	ba 01 00 00 00	 mov	 edx, 1
  000c9	85 d2		 test	 edx, edx
  000cb	0f 84 3b 02 00
	00		 je	 $L61020

; 63   :             (
; 64   :                (
; 65   :                (P1.y<=M.y)        &&
; 66   :                (M.y<=P2.y) 
; 67   :                )
; 68   :             ||
; 69   :                (
; 70   :                (P2.y<=M.y)        &&
; 71   :                (M.y<=P1.y)
; 72   :                )
; 73   :             )
; 74   :          &&
; 75   :             (
; 76   :                (
; 77   :                (P1.x<=M.x)        &&
; 78   :                (M.x<=P2.x) 
; 79   :                )
; 80   :             ||
; 81   :                (
; 82   :                (P2.x<=M.x)        &&
; 83   :                (M.x<=P1.x)
; 84   :                )
; 85   :             )
; 86   :          )

  000d1	0f bf 45 fa	 movsx	 eax, WORD PTR _P1$[ebp+2]
  000d5	8b 4d 08	 mov	 ecx, DWORD PTR _M$[ebp]
  000d8	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  000dc	3b c2		 cmp	 eax, edx
  000de	7f 0f		 jg	 SHORT $L61023
  000e0	8b 45 08	 mov	 eax, DWORD PTR _M$[ebp]
  000e3	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  000e7	0f bf 55 f6	 movsx	 edx, WORD PTR _P2$[ebp+2]
  000eb	3b ca		 cmp	 ecx, edx
  000ed	7e 26		 jle	 SHORT $L61022
$L61023:
  000ef	0f bf 45 f6	 movsx	 eax, WORD PTR _P2$[ebp+2]
  000f3	8b 4d 08	 mov	 ecx, DWORD PTR _M$[ebp]
  000f6	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  000fa	3b c2		 cmp	 eax, edx
  000fc	0f 8f 97 00 00
	00		 jg	 $L61028
  00102	8b 45 08	 mov	 eax, DWORD PTR _M$[ebp]
  00105	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00109	0f bf 55 fa	 movsx	 edx, WORD PTR _P1$[ebp+2]
  0010d	3b ca		 cmp	 ecx, edx
  0010f	0f 8f 84 00 00
	00		 jg	 $L61028
$L61022:
  00115	0f bf 45 f8	 movsx	 eax, WORD PTR _P1$[ebp]
  00119	8b 4d 08	 mov	 ecx, DWORD PTR _M$[ebp]
  0011c	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  0011f	3b c2		 cmp	 eax, edx
  00121	7f 0e		 jg	 SHORT $L61025
  00123	8b 45 08	 mov	 eax, DWORD PTR _M$[ebp]
  00126	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00129	0f bf 55 f4	 movsx	 edx, WORD PTR _P2$[ebp]
  0012d	3b ca		 cmp	 ecx, edx
  0012f	7e 1c		 jle	 SHORT $L61024
$L61025:
  00131	0f bf 45 f4	 movsx	 eax, WORD PTR _P2$[ebp]
  00135	8b 4d 08	 mov	 ecx, DWORD PTR _M$[ebp]
  00138	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  0013b	3b c2		 cmp	 eax, edx
  0013d	7f 5a		 jg	 SHORT $L61028
  0013f	8b 45 08	 mov	 eax, DWORD PTR _M$[ebp]
  00142	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00145	0f bf 55 f8	 movsx	 edx, WORD PTR _P1$[ebp]
  00149	3b ca		 cmp	 ecx, edx
  0014b	7f 4c		 jg	 SHORT $L61028
$L61024:

; 89   :          tmp1 = M - P1;

  0014d	8d 45 f8	 lea	 eax, DWORD PTR _P1$[ebp]
  00150	50		 push	 eax
  00151	8d 4d d8	 lea	 ecx, DWORD PTR $T62334[ebp]
  00154	51		 push	 ecx
  00155	8b 4d 08	 mov	 ecx, DWORD PTR _M$[ebp]
  00158	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  0015d	50		 push	 eax
  0015e	8d 4d e8	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  00161	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 90   :          tmp2 = M - P2;

  00166	8d 55 f4	 lea	 edx, DWORD PTR _P2$[ebp]
  00169	52		 push	 edx
  0016a	8d 45 d4	 lea	 eax, DWORD PTR $T62335[ebp]
  0016d	50		 push	 eax
  0016e	8b 4d 08	 mov	 ecx, DWORD PTR _M$[ebp]
  00171	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  00176	50		 push	 eax
  00177	8d 4d e4	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  0017a	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 91   :          if ((tmp1^tmp2) == 0) return(True);

  0017f	8d 4d e4	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  00182	51		 push	 ecx
  00183	8d 4d e8	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  00186	e8 00 00 00 00	 call	 ??TSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator^
  0018b	85 c0		 test	 eax, eax
  0018d	75 0a		 jne	 SHORT $L61028
  0018f	b8 01 00 00 00	 mov	 eax, 1
  00194	e9 86 01 00 00	 jmp	 $L61049
$L61028:

; 102  :             (
; 103  :             (P1.y<M.y)        &&
; 104  :             (M.y<P2.y) 
; 105  :             )
; 106  :          ||
; 107  :             (
; 108  :             (P2.y<M.y)        &&
; 109  :             (M.y<P1.y)
; 110  :             )
; 111  :          )

  00199	0f bf 55 fa	 movsx	 edx, WORD PTR _P1$[ebp+2]
  0019d	8b 45 08	 mov	 eax, DWORD PTR _M$[ebp]
  001a0	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  001a4	3b d1		 cmp	 edx, ecx
  001a6	7d 0f		 jge	 SHORT $L61031
  001a8	8b 55 08	 mov	 edx, DWORD PTR _M$[ebp]
  001ab	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  001af	0f bf 4d f6	 movsx	 ecx, WORD PTR _P2$[ebp+2]
  001b3	3b c1		 cmp	 eax, ecx
  001b5	7c 1e		 jl	 SHORT $L61030
$L61031:
  001b7	0f bf 55 f6	 movsx	 edx, WORD PTR _P2$[ebp+2]
  001bb	8b 45 08	 mov	 eax, DWORD PTR _M$[ebp]
  001be	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  001c2	3b d1		 cmp	 edx, ecx
  001c4	7d 79		 jge	 SHORT $L61029
  001c6	8b 55 08	 mov	 edx, DWORD PTR _M$[ebp]
  001c9	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  001cd	0f bf 4d fa	 movsx	 ecx, WORD PTR _P1$[ebp+2]
  001d1	3b c1		 cmp	 eax, ecx
  001d3	7d 6a		 jge	 SHORT $L61029
$L61030:

; 114  :          // If P1-P2 or P2-P1 is chosen so that the y delta is 
; 115  :          // positive and this vector is crossed with the vector
; 116  :          // P1-M then the z component is positive if M lies on
; 117  :          // the negative side of P1-P2 and negative if M lies
; 118  :          // on the positive side of P1-P2.
; 119  :          tmp1 = P2 - P1;

  001d5	8d 55 f8	 lea	 edx, DWORD PTR _P1$[ebp]
  001d8	52		 push	 edx
  001d9	8d 45 d0	 lea	 eax, DWORD PTR $T62336[ebp]
  001dc	50		 push	 eax
  001dd	8d 4d f4	 lea	 ecx, DWORD PTR _P2$[ebp]
  001e0	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  001e5	50		 push	 eax
  001e6	8d 4d e8	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  001e9	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 120  :          if (tmp1.y < 0 ) tmp1 = -tmp1;

  001ee	0f bf 4d ea	 movsx	 ecx, WORD PTR _tmp1$[ebp+2]
  001f2	85 c9		 test	 ecx, ecx
  001f4	7d 15		 jge	 SHORT $L61033
  001f6	8d 55 cc	 lea	 edx, DWORD PTR $T62337[ebp]
  001f9	52		 push	 edx
  001fa	8d 4d e8	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  001fd	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@XZ ; SCI_Point::operator-
  00202	50		 push	 eax
  00203	8d 4d e8	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  00206	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=
$L61033:

; 121  :          tmp2 = M - P1;

  0020b	8d 45 f8	 lea	 eax, DWORD PTR _P1$[ebp]
  0020e	50		 push	 eax
  0020f	8d 4d c8	 lea	 ecx, DWORD PTR $T62338[ebp]
  00212	51		 push	 ecx
  00213	8b 4d 08	 mov	 ecx, DWORD PTR _M$[ebp]
  00216	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  0021b	50		 push	 eax
  0021c	8d 4d e4	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  0021f	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 122  :          if ((tmp1^tmp2) > 0) ++interior;

  00224	8d 55 e4	 lea	 edx, DWORD PTR _tmp2$[ebp]
  00227	52		 push	 edx
  00228	8d 4d e8	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  0022b	e8 00 00 00 00	 call	 ??TSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator^
  00230	85 c0		 test	 eax, eax
  00232	7e 09		 jle	 SHORT $L61036
  00234	8b 45 fc	 mov	 eax, DWORD PTR _interior$[ebp]
  00237	83 c0 01	 add	 eax, 1
  0023a	89 45 fc	 mov	 DWORD PTR _interior$[ebp], eax
$L61036:

; 124  :       else

  0023d	eb 73		 jmp	 SHORT $L61046
$L61029:

; 134  :             (P2.y == M.y) &&
; 135  :             (M.x < P2.x)
; 136  :             )

  0023f	0f bf 4d f6	 movsx	 ecx, WORD PTR _P2$[ebp+2]
  00243	8b 55 08	 mov	 edx, DWORD PTR _M$[ebp]
  00246	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  0024a	3b c8		 cmp	 ecx, eax
  0024c	75 64		 jne	 SHORT $L61046
  0024e	8b 4d 08	 mov	 ecx, DWORD PTR _M$[ebp]
  00251	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00254	0f bf 45 f4	 movsx	 eax, WORD PTR _P2$[ebp]
  00258	3b d0		 cmp	 edx, eax
  0025a	7d 56		 jge	 SHORT $L61046

; 138  :             /* types of intersections checked here:
; 139  : 
; 140  :                *           *       *    *             *            *
; 141  :                 *           *     *      *             *          *
; 142  :                  *           *   *        *             *        *
; 143  :                   *           * *          *             *      *
; 144  :             <------*-----------*------------*****---------******----------M
; 145  :                    *                             *
; 146  :                    *                              *
; 147  :                    *                               *           
; 148  :                    *                                *
; 149  :                    *                                 *
; 150  : 
; 151  :                   intersection?
; 152  :                   yes          no             yes           no          
; 153  :             */
; 154  : 
; 155  : 
; 156  : 
; 157  :             if (P3.y != P2.y)

  0025c	0f bf 4d f2	 movsx	 ecx, WORD PTR _P3$[ebp+2]
  00260	0f bf 55 f6	 movsx	 edx, WORD PTR _P2$[ebp+2]
  00264	3b ca		 cmp	 ecx, edx
  00266	74 26		 je	 SHORT $L61039

; 159  :                if ((int)(P2.y-P1.y)*(int)(P3.y-P2.y) > 0) ++interior;

  00268	0f bf 45 f6	 movsx	 eax, WORD PTR _P2$[ebp+2]
  0026c	0f bf 4d fa	 movsx	 ecx, WORD PTR _P1$[ebp+2]
  00270	2b c1		 sub	 eax, ecx
  00272	0f bf 55 f2	 movsx	 edx, WORD PTR _P3$[ebp+2]
  00276	0f bf 4d f6	 movsx	 ecx, WORD PTR _P2$[ebp+2]
  0027a	2b d1		 sub	 edx, ecx
  0027c	0f af c2	 imul	 eax, edx
  0027f	85 c0		 test	 eax, eax
  00281	7e 09		 jle	 SHORT $L61042
  00283	8b 55 fc	 mov	 edx, DWORD PTR _interior$[ebp]
  00286	83 c2 01	 add	 edx, 1
  00289	89 55 fc	 mov	 DWORD PTR _interior$[ebp], edx
$L61042:

; 161  :             else

  0028c	eb 24		 jmp	 SHORT $L61046
$L61039:

; 163  :                if ((int)(P2.y-P1.y)*(int)(P4.y-P3.y) > 0) ++interior;

  0028e	0f bf 45 f6	 movsx	 eax, WORD PTR _P2$[ebp+2]
  00292	0f bf 4d fa	 movsx	 ecx, WORD PTR _P1$[ebp+2]
  00296	2b c1		 sub	 eax, ecx
  00298	0f bf 55 ee	 movsx	 edx, WORD PTR _P4$[ebp+2]
  0029c	0f bf 4d f2	 movsx	 ecx, WORD PTR _P3$[ebp+2]
  002a0	2b d1		 sub	 edx, ecx
  002a2	0f af c2	 imul	 eax, edx
  002a5	85 c0		 test	 eax, eax
  002a7	7e 09		 jle	 SHORT $L61046
  002a9	8b 55 fc	 mov	 edx, DWORD PTR _interior$[ebp]
  002ac	83 c2 01	 add	 edx, 1
  002af	89 55 fc	 mov	 DWORD PTR _interior$[ebp], edx
$L61046:

; 167  :       P1 = P2;

  002b2	8d 45 f4	 lea	 eax, DWORD PTR _P2$[ebp]
  002b5	50		 push	 eax
  002b6	8d 4d f8	 lea	 ecx, DWORD PTR _P1$[ebp]
  002b9	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 168  :       P2 = P3;

  002be	8d 4d f0	 lea	 ecx, DWORD PTR _P3$[ebp]
  002c1	51		 push	 ecx
  002c2	8d 4d f4	 lea	 ecx, DWORD PTR _P2$[ebp]
  002c5	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 169  :       P3 = P4;

  002ca	8d 55 ec	 lea	 edx, DWORD PTR _P4$[ebp]
  002cd	52		 push	 edx
  002ce	8d 4d f0	 lea	 ecx, DWORD PTR _P3$[ebp]
  002d1	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 170  : 
; 171  :       // See if there are any more line segments
; 172  :       // in the polygon to be tested.
; 173  :       if (P3 == N3) break;

  002d6	8d 45 dc	 lea	 eax, DWORD PTR _N3$[ebp]
  002d9	50		 push	 eax
  002da	8d 4d f0	 lea	 ecx, DWORD PTR _P3$[ebp]
  002dd	e8 00 00 00 00	 call	 ??8SCI_Point@@QBEHABU0@@Z ; SCI_Point::operator==
  002e2	85 c0		 test	 eax, eax
  002e4	74 02		 je	 SHORT $L61047
  002e6	eb 24		 jmp	 SHORT $L61020
$L61047:

; 174  : 
; 175  :       P4 = polygon[(++ nextnode) % n];

  002e8	8b 4d e0	 mov	 ecx, DWORD PTR _nextnode$[ebp]
  002eb	83 c1 01	 add	 ecx, 1
  002ee	89 4d e0	 mov	 DWORD PTR _nextnode$[ebp], ecx
  002f1	8b 45 e0	 mov	 eax, DWORD PTR _nextnode$[ebp]
  002f4	99		 cdq
  002f5	f7 7d 10	 idiv	 DWORD PTR _n$[ebp]
  002f8	8b 45 0c	 mov	 eax, DWORD PTR _polygon$[ebp]
  002fb	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  002fe	51		 push	 ecx
  002ff	8d 4d ec	 lea	 ecx, DWORD PTR _P4$[ebp]
  00302	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 176  :       }

  00307	e9 b8 fd ff ff	 jmp	 $L61017
$L61020:

; 177  : 
; 178  :    if (interior & 1)

  0030c	8b 55 fc	 mov	 edx, DWORD PTR _interior$[ebp]
  0030f	83 e2 01	 and	 edx, 1
  00312	85 d2		 test	 edx, edx
  00314	74 07		 je	 SHORT $L61048

; 179  :       return(True);

  00316	b8 01 00 00 00	 mov	 eax, 1
  0031b	eb 02		 jmp	 SHORT $L61049
$L61048:

; 181  :       return(False);

  0031d	33 c0		 xor	 eax, eax
$L61049:

; 182  : }

  0031f	8b e5		 mov	 esp, ebp
  00321	5d		 pop	 ebp
  00322	c3		 ret	 0
?PointInterior@@YAHAAUSCI_Point@@PAU1@H@Z ENDP		; PointInterior
_TEXT	ENDS
;	COMDAT ??4SCI_Point@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
??4SCI_Point@@QAEAAU0@ABU0@@Z PROC NEAR			; SCI_Point::operator=, COMDAT

; 58   : 	SCI_Point&	operator=(const SCI_Point& p) {x = p.x; y = p.y; return *this;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0000d	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00010	66 89 10	 mov	 WORD PTR [eax], dx
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00019	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  0001d	66 89 50 02	 mov	 WORD PTR [eax+2], dx
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??4SCI_Point@@QAEAAU0@ABU0@@Z ENDP			; SCI_Point::operator=
_TEXT	ENDS
PUBLIC	??0SCI_Point@@QAE@HH@Z				; SCI_Point::SCI_Point
PUBLIC	??0SCI_Point@@QAE@ABU0@@Z			; SCI_Point::SCI_Point
;	COMDAT ??GSCI_Point@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
_p$ = 12
___$ReturnUdt$ = 8
_this$ = -8
$T62341 = -4
??GSCI_Point@@QBE?AU0@ABU0@@Z PROC NEAR			; SCI_Point::operator-, COMDAT

; 214  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 215  :    return SCI_Point(x-p.x,y-p.y);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00010	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp]
  00013	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  00017	2b c8		 sub	 ecx, eax
  00019	51		 push	 ecx
  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00020	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  00023	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00026	2b d1		 sub	 edx, ecx
  00028	52		 push	 edx
  00029	8d 4d fc	 lea	 ecx, DWORD PTR $T62341[ebp]
  0002c	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@HH@Z	; SCI_Point::SCI_Point
  00031	50		 push	 eax
  00032	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00035	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@ABU0@@Z ; SCI_Point::SCI_Point
  0003a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 216  : }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
??GSCI_Point@@QBE?AU0@ABU0@@Z ENDP			; SCI_Point::operator-
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@HH@Z
_TEXT	SEGMENT
_x$ = 8
_y$ = 12
_this$ = -4
??0SCI_Point@@QAE@HH@Z PROC NEAR			; SCI_Point::SCI_Point, COMDAT

; 53   : 	SCI_Point(Coord x, Coord y) : x(x), y(y) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 4d 08	 mov	 cx, WORD PTR _x$[ebp]
  0000e	66 89 08	 mov	 WORD PTR [eax], cx
  00011	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00014	66 8b 45 0c	 mov	 ax, WORD PTR _y$[ebp]
  00018	66 89 42 02	 mov	 WORD PTR [edx+2], ax
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
??0SCI_Point@@QAE@HH@Z ENDP				; SCI_Point::SCI_Point
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@ABU0@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
??0SCI_Point@@QAE@ABU0@@Z PROC NEAR			; SCI_Point::SCI_Point, COMDAT

; 54   : 	SCI_Point(const SCI_Point& p) : x(p.x), y(p.y) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0000d	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00010	66 89 10	 mov	 WORD PTR [eax], dx
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00019	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  0001d	66 89 50 02	 mov	 WORD PTR [eax+2], dx
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??0SCI_Point@@QAE@ABU0@@Z ENDP				; SCI_Point::SCI_Point
_TEXT	ENDS
;	COMDAT ??GSCI_Point@@QBE?AU0@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -8
$T62345 = -4
??GSCI_Point@@QBE?AU0@XZ PROC NEAR			; SCI_Point::operator-, COMDAT

; 220  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 221  :    return SCI_Point(-x,-y);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00010	f7 d9		 neg	 ecx
  00012	51		 push	 ecx
  00013	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00016	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00019	f7 d8		 neg	 eax
  0001b	50		 push	 eax
  0001c	8d 4d fc	 lea	 ecx, DWORD PTR $T62345[ebp]
  0001f	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@HH@Z	; SCI_Point::SCI_Point
  00024	50		 push	 eax
  00025	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00028	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@ABU0@@Z ; SCI_Point::SCI_Point
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 222  : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??GSCI_Point@@QBE?AU0@XZ ENDP				; SCI_Point::operator-
_TEXT	ENDS
;	COMDAT ??TSCI_Point@@QBEHABU0@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -8
_direction$ = -4
??TSCI_Point@@QBEHABU0@@Z PROC NEAR			; SCI_Point::operator^, COMDAT

; 242  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 243  :    int direction;
; 244  :    direction = (
; 245  :                (((int) x) * ((int) p.y)) 
; 246  :                - 
; 247  :                (((int) y) * ((int) p.x))
; 248  :                );

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0000f	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00012	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  00016	0f af c8	 imul	 ecx, eax
  00019	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  00020	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00023	0f bf 12	 movsx	 edx, WORD PTR [edx]
  00026	0f af c2	 imul	 eax, edx
  00029	2b c8		 sub	 ecx, eax
  0002b	89 4d fc	 mov	 DWORD PTR _direction$[ebp], ecx

; 249  :    if (direction < 0)

  0002e	83 7d fc 00	 cmp	 DWORD PTR _direction$[ebp], 0
  00032	7d 05		 jge	 SHORT $L58615

; 250  :       return(-1);

  00034	83 c8 ff	 or	 eax, -1
  00037	eb 0f		 jmp	 SHORT $L58609
$L58615:

; 251  :    if (direction > 0)

  00039	83 7d fc 00	 cmp	 DWORD PTR _direction$[ebp], 0
  0003d	7e 07		 jle	 SHORT $L58616

; 252  :       return(1);

  0003f	b8 01 00 00 00	 mov	 eax, 1
  00044	eb 02		 jmp	 SHORT $L58609
$L58616:

; 253  :    return(0);

  00046	33 c0		 xor	 eax, eax
$L58609:

; 254  : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
??TSCI_Point@@QBEHABU0@@Z ENDP				; SCI_Point::operator^
_TEXT	ENDS
;	COMDAT ??8SCI_Point@@QBEHABU0@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
??8SCI_Point@@QBEHABU0@@Z PROC NEAR			; SCI_Point::operator==, COMDAT

; 274  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 275  : 	return x == p.x  &&  y == p.y;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0000f	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00012	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00015	3b c8		 cmp	 ecx, eax
  00017	75 1b		 jne	 SHORT $L62348
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  00020	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00023	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00027	3b d1		 cmp	 edx, ecx
  00029	75 09		 jne	 SHORT $L62348
  0002b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR -8+[ebp], 1
  00032	eb 07		 jmp	 SHORT $L62349
$L62348:
  00034	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], 0
$L62349:
  0003b	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]

; 276  : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??8SCI_Point@@QBEHABU0@@Z ENDP				; SCI_Point::operator==
_TEXT	ENDS
PUBLIC	??0MemID@@QAE@ABV0@@Z				; MemID::MemID
PUBLIC	?GetPath@@YA?AVMemID@@AAUSCI_Point@@0PAVSOL_Polygon@@H0@Z ; GetPath
PUBLIC	?AvoidPath@@YAXAAUSCI_Point@@0PAVSOL_Polygon@@HPAU1@@Z ; AvoidPath
PUBLIC	?CopyPath@@YA?AVMemID@@PAUSCI_Point@@@Z		; CopyPath
PUBLIC	?DeletePolygon@@YAXPAVSOL_Polygon@@H@Z		; DeletePolygon
PUBLIC	?EndPath@@YAXAAUSCI_Point@@PAU1@@Z		; EndPath
PUBLIC	?IntersectPolygon@@YAHAAUSCI_Point@@0PAU1@H11PAH2@Z ; IntersectPolygon
PUBLIC	?InvertPolygon@@YAXPAUSCI_Point@@H@Z		; InvertPolygon
PUBLIC	?NearPoint@@YAHAAUSCI_Point@@PAU1@H1H@Z		; NearPoint
PUBLIC	?StartPath@@YAXAAUSCI_Point@@PAU1@@Z		; StartPath
_TEXT	SEGMENT
_A$ = 12
_B$ = 16
_polylist$ = 20
_opt$ = 24
_planeDim$ = 28
___$ReturnUdt$ = 8
_pathType$ = -1032
_i$ = -1028
_exitPoint$ = -1016
_entryPoint$ = -1008
_I1$ = -1024
_I2$ = -1036
_nodeI1$ = -1040
_nodeI2$ = -4
_pathStart$ = -1012
_pathEnd$ = -1020
_path$ = -1004
$T62351 = -1044
?GetPath@@YA?AVMemID@@AAUSCI_Point@@0PAVSOL_Polygon@@H0@Z PROC NEAR ; GetPath

; 189  : {

  00323	55		 push	 ebp
  00324	8b ec		 mov	 ebp, esp
  00326	81 ec 20 04 00
	00		 sub	 esp, 1056		; 00000420H

; 190  : 
; 191  :    // Types of polygon exits and polygon entries
; 192  :    enum PathStartType
; 193  :       {
; 194  :       fromA,
; 195  :       fromAtoEXIT,
; 196  :       fromBAPtoEXIT
; 197  :       };
; 198  : 
; 199  :    enum PathEndType 
; 200  :       {
; 201  :       toB,
; 202  :       toENTRYtoB,
; 203  :       toENTRY
; 204  :       };
; 205  : 
; 206  :    #define	INVERTED	1
; 207  : 
; 208  :    int         pathType;
; 209  :    int         i;
; 210  : 	SCI_Point   exitPoint,entryPoint;

  0032c	8d 8d 08 fc ff
	ff		 lea	 ecx, DWORD PTR _exitPoint$[ebp]
  00332	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  00337	8d 8d 10 fc ff
	ff		 lea	 ecx, DWORD PTR _entryPoint$[ebp]
  0033d	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point

; 211  :    SCI_Point   I1,I2;

  00342	8d 8d 00 fc ff
	ff		 lea	 ecx, DWORD PTR _I1$[ebp]
  00348	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  0034d	8d 8d f4 fb ff
	ff		 lea	 ecx, DWORD PTR _I2$[ebp]
  00353	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point

; 212  :    int         nodeI1,nodeI2;
; 213  :    int         pathStart = fromA;

  00358	c7 85 0c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _pathStart$[ebp], 0

; 214  :    int         pathEnd = toB;

  00362	c7 85 04 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _pathEnd$[ebp], 0

; 215  :    SCI_Point   path[MAXPOLYPATH];

  0036c	68 00 00 00 00	 push	 OFFSET FLAT:??0SCI_Point@@QAE@XZ ; SCI_Point::SCI_Point
  00371	68 fa 00 00 00	 push	 250			; 000000faH
  00376	6a 04		 push	 4
  00378	8d 85 14 fc ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  0037e	50		 push	 eax
  0037f	e8 00 00 00 00	 call	 ??_H@YGXPAXIHP6EX0@Z@Z	; `vector constructor iterator'

; 216  : 
; 217  : #ifdef POLYTEST
; 218  :    // Make polygons clockwise.
; 219  : 	// The following code, TestClockwise and InvertPolygon are
; 220  :    // only needed if some polygons may be defined in a counter
; 221  :    // clockwise direction. Clockwise refers to users view point
; 222  :    // which is counter clockwise mathematically.
; 223  : 
; 224  :    for (i=0;polylist[i].n != 0;++i)
; 225  :       {
; 226  :       if (testClockwise(polylist[i].polyPoints,polylist[i].n) < 0)
; 227  :          {
; 228  :          if(polylist[i].type!=CAP)
; 229  :             {
; 230  :             InvertPolygon(polylist[i].polyPoints,polylist[i].n);
; 231  : 		      Message("Direction of !CAP polygon counter clockwise. Fixed!");
; 232  :             }
; 233  :          }
; 234  :       else
; 235  :          {
; 236  :          if(polylist[i].type==CAP)
; 237  :             {
; 238  :             InvertPolygon(polylist[i].polyPoints,polylist[i].n);
; 239  : 		      Message("Direction of CAP polygon clockwise. Fixed!");
; 240  :             }
; 241  : 
; 242  :          }
; 243  :       // also test for adjacent colinear line segments
; 244  :       int count = polylist[i].n;
; 245  : 		RemoveColinearLines(polylist[i].polyPoints,&polylist[i].n);
; 246  : 		if (count != polylist[i].n)
; 247  :          {
; 248  : 		   Message("%d adjacent colinear line segments found. Fixed!",count);
; 249  :          }
; 250  :       }
; 251  : #endif      // POLYTEST
; 252  : 
; 253  :    // set screen polygon
; 254  :    planePoly[0].x = 0;

  00384	66 c7 05 00 00
	00 00 00 00	 mov	 WORD PTR ?planePoly@@3PAUSCI_Point@@A, 0

; 255  :    planePoly[0].y = 0;

  0038d	66 c7 05 02 00
	00 00 00 00	 mov	 WORD PTR ?planePoly@@3PAUSCI_Point@@A+2, 0

; 256  :    planePoly[1].x = planeDim.x - 1;

  00396	8b 4d 1c	 mov	 ecx, DWORD PTR _planeDim$[ebp]
  00399	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  0039c	83 ea 01	 sub	 edx, 1
  0039f	66 89 15 04 00
	00 00		 mov	 WORD PTR ?planePoly@@3PAUSCI_Point@@A+4, dx

; 257  :    planePoly[1].y = 0;

  003a6	66 c7 05 06 00
	00 00 00 00	 mov	 WORD PTR ?planePoly@@3PAUSCI_Point@@A+6, 0

; 258  :    planePoly[2].x = planeDim.x - 1;

  003af	8b 45 1c	 mov	 eax, DWORD PTR _planeDim$[ebp]
  003b2	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  003b5	83 e9 01	 sub	 ecx, 1
  003b8	66 89 0d 08 00
	00 00		 mov	 WORD PTR ?planePoly@@3PAUSCI_Point@@A+8, cx

; 259  :    planePoly[2].y = planeDim.y - 1;

  003bf	8b 55 1c	 mov	 edx, DWORD PTR _planeDim$[ebp]
  003c2	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  003c6	83 e8 01	 sub	 eax, 1
  003c9	66 a3 0a 00 00
	00		 mov	 WORD PTR ?planePoly@@3PAUSCI_Point@@A+10, ax

; 260  :    planePoly[3].x = 0;

  003cf	66 c7 05 0c 00
	00 00 00 00	 mov	 WORD PTR ?planePoly@@3PAUSCI_Point@@A+12, 0

; 261  :    planePoly[3].y = planeDim.y - 1;

  003d8	8b 4d 1c	 mov	 ecx, DWORD PTR _planeDim$[ebp]
  003db	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  003df	83 ea 01	 sub	 edx, 1
  003e2	66 89 15 0e 00
	00 00		 mov	 WORD PTR ?planePoly@@3PAUSCI_Point@@A+14, dx

; 262  : 
; 263  :    // TAP polygons are invisable when optimization is off
; 264  :    for (i=0;polylist[i].n != 0;++i)

  003e9	c7 85 fc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  003f3	eb 0f		 jmp	 SHORT $L61079
$L61080:
  003f5	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  003fb	83 c0 01	 add	 eax, 1
  003fe	89 85 fc fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$L61079:
  00404	8b 8d fc fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  0040a	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  0040d	8b 55 14	 mov	 edx, DWORD PTR _polylist$[ebp]
  00410	83 7c 0a 08 00	 cmp	 DWORD PTR [edx+ecx+8], 0
  00415	74 57		 je	 SHORT $L61081

; 267  :             (polylist[i].type >= MERGED) ||
; 268  :             ((polylist[i].type == TAP) && (opt == False))
; 269  :          )

  00417	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0041d	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00420	8b 4d 14	 mov	 ecx, DWORD PTR _polylist$[ebp]
  00423	33 d2		 xor	 edx, edx
  00425	8a 54 01 04	 mov	 dl, BYTE PTR [ecx+eax+4]
  00429	83 fa 04	 cmp	 edx, 4
  0042c	7d 1c		 jge	 SHORT $L61083
  0042e	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00434	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00437	8b 4d 14	 mov	 ecx, DWORD PTR _polylist$[ebp]
  0043a	33 d2		 xor	 edx, edx
  0043c	8a 54 01 04	 mov	 dl, BYTE PTR [ecx+eax+4]
  00440	85 d2		 test	 edx, edx
  00442	75 28		 jne	 SHORT $L61082
  00444	83 7d 18 00	 cmp	 DWORD PTR _opt$[ebp], 0
  00448	75 22		 jne	 SHORT $L61082
$L61083:

; 271  :          DeletePolygon(polylist,i);

  0044a	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00450	50		 push	 eax
  00451	8b 4d 14	 mov	 ecx, DWORD PTR _polylist$[ebp]
  00454	51		 push	 ecx
  00455	e8 00 00 00 00	 call	 ?DeletePolygon@@YAXPAVSOL_Polygon@@H@Z ; DeletePolygon
  0045a	83 c4 08	 add	 esp, 8

; 272  :          --i;

  0045d	8b 95 fc fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00463	83 ea 01	 sub	 edx, 1
  00466	89 95 fc fb ff
	ff		 mov	 DWORD PTR _i$[ebp], edx
$L61082:

; 274  :       }

  0046c	eb 87		 jmp	 SHORT $L61080
$L61081:

; 275  : 
; 276  :    // are we starting in a polygon?
; 277  :    for (i=0;polylist[i].n != 0;++i)

  0046e	c7 85 fc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00478	eb 0f		 jmp	 SHORT $L61084
$L61085:
  0047a	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00480	83 c0 01	 add	 eax, 1
  00483	89 85 fc fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$L61084:
  00489	8b 8d fc fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  0048f	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  00492	8b 55 14	 mov	 edx, DWORD PTR _polylist$[ebp]
  00495	83 7c 0a 08 00	 cmp	 DWORD PTR [edx+ecx+8], 0
  0049a	0f 84 de 02 00
	00		 je	 $L61086

; 280  :             PointInterior(A,polylist[i].polyPoints,polylist[i].n) ||
; 281  :             (
; 282  :                (polylist[i].type==CAP) &&
; 283  :                (NearPoint(A,polylist[i].polyPoints,polylist[i].n,&I2,True)<2)
; 284  :             )
; 285  :          )

  004a0	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  004a6	6b c0 0c	 imul	 eax, 12			; 0000000cH
  004a9	8b 4d 14	 mov	 ecx, DWORD PTR _polylist$[ebp]
  004ac	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  004b0	52		 push	 edx
  004b1	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  004b7	6b c0 0c	 imul	 eax, 12			; 0000000cH
  004ba	8b 4d 14	 mov	 ecx, DWORD PTR _polylist$[ebp]
  004bd	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  004c0	52		 push	 edx
  004c1	8b 45 0c	 mov	 eax, DWORD PTR _A$[ebp]
  004c4	50		 push	 eax
  004c5	e8 00 00 00 00	 call	 ?PointInterior@@YAHAAUSCI_Point@@PAU1@H@Z ; PointInterior
  004ca	83 c4 0c	 add	 esp, 12			; 0000000cH
  004cd	85 c0		 test	 eax, eax
  004cf	75 5a		 jne	 SHORT $L61088
  004d1	8b 8d fc fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  004d7	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  004da	8b 55 14	 mov	 edx, DWORD PTR _polylist$[ebp]
  004dd	33 c0		 xor	 eax, eax
  004df	8a 44 0a 04	 mov	 al, BYTE PTR [edx+ecx+4]
  004e3	83 f8 03	 cmp	 eax, 3
  004e6	0f 85 18 02 00
	00		 jne	 $L61087
  004ec	6a 01		 push	 1
  004ee	8d 8d f4 fb ff
	ff		 lea	 ecx, DWORD PTR _I2$[ebp]
  004f4	51		 push	 ecx
  004f5	8b 95 fc fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  004fb	6b d2 0c	 imul	 edx, 12			; 0000000cH
  004fe	8b 45 14	 mov	 eax, DWORD PTR _polylist$[ebp]
  00501	8b 4c 10 08	 mov	 ecx, DWORD PTR [eax+edx+8]
  00505	51		 push	 ecx
  00506	8b 95 fc fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  0050c	6b d2 0c	 imul	 edx, 12			; 0000000cH
  0050f	8b 45 14	 mov	 eax, DWORD PTR _polylist$[ebp]
  00512	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00515	51		 push	 ecx
  00516	8b 55 0c	 mov	 edx, DWORD PTR _A$[ebp]
  00519	52		 push	 edx
  0051a	e8 00 00 00 00	 call	 ?NearPoint@@YAHAAUSCI_Point@@PAU1@H1H@Z ; NearPoint
  0051f	83 c4 14	 add	 esp, 20			; 00000014H
  00522	83 f8 02	 cmp	 eax, 2
  00525	0f 8d d9 01 00
	00		 jge	 $L61087
$L61088:

; 288  :          {

  0052b	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00531	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00534	8b 4d 14	 mov	 ecx, DWORD PTR _polylist$[ebp]
  00537	33 d2		 xor	 edx, edx
  00539	8a 54 01 04	 mov	 dl, BYTE PTR [ecx+eax+4]
  0053d	89 95 e8 fb ff
	ff		 mov	 DWORD PTR -1048+[ebp], edx
  00543	83 bd e8 fb ff
	ff 03		 cmp	 DWORD PTR -1048+[ebp], 3
  0054a	0f 87 b2 01 00
	00		 ja	 $L61090
  00550	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR -1048+[ebp]
  00556	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L62352[eax*4]
$L61093:

; 289  :             case TAP:
; 290  :                DeletePolygon(polylist,i);

  0055d	8b 8d fc fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00563	51		 push	 ecx
  00564	8b 55 14	 mov	 edx, DWORD PTR _polylist$[ebp]
  00567	52		 push	 edx
  00568	e8 00 00 00 00	 call	 ?DeletePolygon@@YAXPAVSOL_Polygon@@H@Z ; DeletePolygon
  0056d	83 c4 08	 add	 esp, 8

; 291  :                --i;

  00570	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00576	83 e8 01	 sub	 eax, 1
  00579	89 85 fc fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax

; 292  :                break;

  0057f	e9 7e 01 00 00	 jmp	 $L61090
$L61094:

; 293  :             case NAP:
; 294  :                pathStart = fromAtoEXIT;

  00584	c7 85 0c fc ff
	ff 01 00 00 00	 mov	 DWORD PTR _pathStart$[ebp], 1

; 295  :                if (opt)

  0058e	83 7d 18 00	 cmp	 DWORD PTR _opt$[ebp], 0
  00592	74 38		 je	 SHORT $L61095

; 296  :                   NearPoint(A,polylist[i].polyPoints,polylist[i].n,&exitPoint,True);

  00594	6a 01		 push	 1
  00596	8d 8d 08 fc ff
	ff		 lea	 ecx, DWORD PTR _exitPoint$[ebp]
  0059c	51		 push	 ecx
  0059d	8b 95 fc fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  005a3	6b d2 0c	 imul	 edx, 12			; 0000000cH
  005a6	8b 45 14	 mov	 eax, DWORD PTR _polylist$[ebp]
  005a9	8b 4c 10 08	 mov	 ecx, DWORD PTR [eax+edx+8]
  005ad	51		 push	 ecx
  005ae	8b 95 fc fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  005b4	6b d2 0c	 imul	 edx, 12			; 0000000cH
  005b7	8b 45 14	 mov	 eax, DWORD PTR _polylist$[ebp]
  005ba	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  005bd	51		 push	 ecx
  005be	8b 55 0c	 mov	 edx, DWORD PTR _A$[ebp]
  005c1	52		 push	 edx
  005c2	e8 00 00 00 00	 call	 ?NearPoint@@YAHAAUSCI_Point@@PAU1@H1H@Z ; NearPoint
  005c7	83 c4 14	 add	 esp, 20			; 00000014H

; 297  :                else

  005ca	eb 13		 jmp	 SHORT $L61096
$L61095:

; 298  :                   DeletePolygon(polylist,i);

  005cc	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  005d2	50		 push	 eax
  005d3	8b 4d 14	 mov	 ecx, DWORD PTR _polylist$[ebp]
  005d6	51		 push	 ecx
  005d7	e8 00 00 00 00	 call	 ?DeletePolygon@@YAXPAVSOL_Polygon@@H@Z ; DeletePolygon
  005dc	83 c4 08	 add	 esp, 8
$L61096:

; 299  :                break;

  005df	e9 1e 01 00 00	 jmp	 $L61090
$L61097:

; 300  :             case BAP:
; 301  :                pathStart = fromBAPtoEXIT;

  005e4	c7 85 0c fc ff
	ff 02 00 00 00	 mov	 DWORD PTR _pathStart$[ebp], 2

; 302  :                NearPoint(A,polylist[i].polyPoints,polylist[i].n,&exitPoint,True);

  005ee	6a 01		 push	 1
  005f0	8d 95 08 fc ff
	ff		 lea	 edx, DWORD PTR _exitPoint$[ebp]
  005f6	52		 push	 edx
  005f7	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  005fd	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00600	8b 4d 14	 mov	 ecx, DWORD PTR _polylist$[ebp]
  00603	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  00607	52		 push	 edx
  00608	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0060e	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00611	8b 4d 14	 mov	 ecx, DWORD PTR _polylist$[ebp]
  00614	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00617	52		 push	 edx
  00618	8b 45 0c	 mov	 eax, DWORD PTR _A$[ebp]
  0061b	50		 push	 eax
  0061c	e8 00 00 00 00	 call	 ?NearPoint@@YAHAAUSCI_Point@@PAU1@H1H@Z ; NearPoint
  00621	83 c4 14	 add	 esp, 20			; 00000014H

; 303  :                break;

  00624	e9 d9 00 00 00	 jmp	 $L61090
$L61098:

; 304  :             case CAP:
; 305  :                if (!PointInterior(B,polylist[i].polyPoints,polylist[i].n))

  00629	8b 8d fc fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  0062f	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  00632	8b 55 14	 mov	 edx, DWORD PTR _polylist$[ebp]
  00635	8b 44 0a 08	 mov	 eax, DWORD PTR [edx+ecx+8]
  00639	50		 push	 eax
  0063a	8b 8d fc fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00640	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  00643	8b 55 14	 mov	 edx, DWORD PTR _polylist$[ebp]
  00646	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00649	50		 push	 eax
  0064a	8b 4d 10	 mov	 ecx, DWORD PTR _B$[ebp]
  0064d	51		 push	 ecx
  0064e	e8 00 00 00 00	 call	 ?PointInterior@@YAHAAUSCI_Point@@PAU1@H@Z ; PointInterior
  00653	83 c4 0c	 add	 esp, 12			; 0000000cH
  00656	85 c0		 test	 eax, eax
  00658	0f 85 a4 00 00
	00		 jne	 $L61101

; 307  :                   /* Point A is interior and point B is exterior */
; 308  :                   pathEnd = toENTRY;

  0065e	c7 85 04 fc ff
	ff 02 00 00 00	 mov	 DWORD PTR _pathEnd$[ebp], 2

; 309  :                   /* Find the last exit point */
; 310  :                   if (opt)

  00668	83 7d 18 00	 cmp	 DWORD PTR _opt$[ebp], 0
  0066c	74 38		 je	 SHORT $L61100

; 312  :                      NearPoint(B,polylist[i].polyPoints,polylist[i].n,&entryPoint,False);

  0066e	6a 00		 push	 0
  00670	8d 95 10 fc ff
	ff		 lea	 edx, DWORD PTR _entryPoint$[ebp]
  00676	52		 push	 edx
  00677	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0067d	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00680	8b 4d 14	 mov	 ecx, DWORD PTR _polylist$[ebp]
  00683	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  00687	52		 push	 edx
  00688	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0068e	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00691	8b 4d 14	 mov	 ecx, DWORD PTR _polylist$[ebp]
  00694	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00697	52		 push	 edx
  00698	8b 45 10	 mov	 eax, DWORD PTR _B$[ebp]
  0069b	50		 push	 eax
  0069c	e8 00 00 00 00	 call	 ?NearPoint@@YAHAAUSCI_Point@@PAU1@H1H@Z ; NearPoint
  006a1	83 c4 14	 add	 esp, 20			; 00000014H

; 314  :                   else

  006a4	eb 5c		 jmp	 SHORT $L61101
$L61100:

; 316  :                      IntersectPolygon(A,B,polylist[i].polyPoints,polylist[i].n,&I1,&I2,&nodeI1,&nodeI2);

  006a6	8d 4d fc	 lea	 ecx, DWORD PTR _nodeI2$[ebp]
  006a9	51		 push	 ecx
  006aa	8d 95 f0 fb ff
	ff		 lea	 edx, DWORD PTR _nodeI1$[ebp]
  006b0	52		 push	 edx
  006b1	8d 85 f4 fb ff
	ff		 lea	 eax, DWORD PTR _I2$[ebp]
  006b7	50		 push	 eax
  006b8	8d 8d 00 fc ff
	ff		 lea	 ecx, DWORD PTR _I1$[ebp]
  006be	51		 push	 ecx
  006bf	8b 95 fc fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  006c5	6b d2 0c	 imul	 edx, 12			; 0000000cH
  006c8	8b 45 14	 mov	 eax, DWORD PTR _polylist$[ebp]
  006cb	8b 4c 10 08	 mov	 ecx, DWORD PTR [eax+edx+8]
  006cf	51		 push	 ecx
  006d0	8b 95 fc fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  006d6	6b d2 0c	 imul	 edx, 12			; 0000000cH
  006d9	8b 45 14	 mov	 eax, DWORD PTR _polylist$[ebp]
  006dc	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  006df	51		 push	 ecx
  006e0	8b 55 10	 mov	 edx, DWORD PTR _B$[ebp]
  006e3	52		 push	 edx
  006e4	8b 45 0c	 mov	 eax, DWORD PTR _A$[ebp]
  006e7	50		 push	 eax
  006e8	e8 00 00 00 00	 call	 ?IntersectPolygon@@YAHAAUSCI_Point@@0PAU1@H11PAH2@Z ; IntersectPolygon
  006ed	83 c4 20	 add	 esp, 32			; 00000020H

; 317  :                      entryPoint = I1;

  006f0	8d 8d 00 fc ff
	ff		 lea	 ecx, DWORD PTR _I1$[ebp]
  006f6	51		 push	 ecx
  006f7	8d 8d 10 fc ff
	ff		 lea	 ecx, DWORD PTR _entryPoint$[ebp]
  006fd	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=
$L61101:
$L61090:

; 323  :       else

  00702	eb 75		 jmp	 SHORT $L61103
$L61087:

; 325  :          // Turn CAP in BAP
; 326  :          if(polylist[i].type==CAP)

  00704	8b 95 fc fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  0070a	6b d2 0c	 imul	 edx, 12			; 0000000cH
  0070d	8b 45 14	 mov	 eax, DWORD PTR _polylist$[ebp]
  00710	33 c9		 xor	 ecx, ecx
  00712	8a 4c 10 04	 mov	 cl, BYTE PTR [eax+edx+4]
  00716	83 f9 03	 cmp	 ecx, 3
  00719	75 5e		 jne	 SHORT $L61103

; 328  :             InvertPolygon(polylist[i].polyPoints,polylist[i].n);

  0071b	8b 95 fc fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00721	6b d2 0c	 imul	 edx, 12			; 0000000cH
  00724	8b 45 14	 mov	 eax, DWORD PTR _polylist$[ebp]
  00727	8b 4c 10 08	 mov	 ecx, DWORD PTR [eax+edx+8]
  0072b	51		 push	 ecx
  0072c	8b 95 fc fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00732	6b d2 0c	 imul	 edx, 12			; 0000000cH
  00735	8b 45 14	 mov	 eax, DWORD PTR _polylist$[ebp]
  00738	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  0073b	51		 push	 ecx
  0073c	e8 00 00 00 00	 call	 ?InvertPolygon@@YAXPAUSCI_Point@@H@Z ; InvertPolygon
  00741	83 c4 08	 add	 esp, 8

; 329  :             polylist[i].type=BAP;

  00744	8b 95 fc fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  0074a	6b d2 0c	 imul	 edx, 12			; 0000000cH
  0074d	8b 45 14	 mov	 eax, DWORD PTR _polylist$[ebp]
  00750	c6 44 10 04 02	 mov	 BYTE PTR [eax+edx+4], 2

; 330  :             polylist[i].info = polylist[i].info | INVERTED;

  00755	8b 8d fc fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  0075b	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  0075e	8b 55 14	 mov	 edx, DWORD PTR _polylist$[ebp]
  00761	33 c0		 xor	 eax, eax
  00763	8a 44 0a 05	 mov	 al, BYTE PTR [edx+ecx+5]
  00767	0c 01		 or	 al, 1
  00769	8b 8d fc fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  0076f	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  00772	8b 55 14	 mov	 edx, DWORD PTR _polylist$[ebp]
  00775	88 44 0a 05	 mov	 BYTE PTR [edx+ecx+5], al
$L61103:

; 334  :    }

  00779	e9 fc fc ff ff	 jmp	 $L61085
$L61086:

; 335  : 
; 336  :    // are we ending in a polygon?
; 337  :    for (i=0;polylist[i].n != 0;++i)

  0077e	c7 85 fc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00788	eb 0f		 jmp	 SHORT $L61104
$L61105:
  0078a	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00790	83 c0 01	 add	 eax, 1
  00793	89 85 fc fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$L61104:
  00799	8b 8d fc fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  0079f	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  007a2	8b 55 14	 mov	 edx, DWORD PTR _polylist$[ebp]
  007a5	83 7c 0a 08 00	 cmp	 DWORD PTR [edx+ecx+8], 0
  007aa	0f 84 66 01 00
	00		 je	 $L61106

; 339  :       if (polylist[i].type!=CAP && PointInterior(B,polylist[i].polyPoints,polylist[i].n))

  007b0	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  007b6	6b c0 0c	 imul	 eax, 12			; 0000000cH
  007b9	8b 4d 14	 mov	 ecx, DWORD PTR _polylist$[ebp]
  007bc	33 d2		 xor	 edx, edx
  007be	8a 54 01 04	 mov	 dl, BYTE PTR [ecx+eax+4]
  007c2	83 fa 03	 cmp	 edx, 3
  007c5	0f 84 46 01 00
	00		 je	 $L61109
  007cb	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  007d1	6b c0 0c	 imul	 eax, 12			; 0000000cH
  007d4	8b 4d 14	 mov	 ecx, DWORD PTR _polylist$[ebp]
  007d7	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  007db	52		 push	 edx
  007dc	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  007e2	6b c0 0c	 imul	 eax, 12			; 0000000cH
  007e5	8b 4d 14	 mov	 ecx, DWORD PTR _polylist$[ebp]
  007e8	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  007eb	52		 push	 edx
  007ec	8b 45 10	 mov	 eax, DWORD PTR _B$[ebp]
  007ef	50		 push	 eax
  007f0	e8 00 00 00 00	 call	 ?PointInterior@@YAHAAUSCI_Point@@PAU1@H@Z ; PointInterior
  007f5	83 c4 0c	 add	 esp, 12			; 0000000cH
  007f8	85 c0		 test	 eax, eax
  007fa	0f 84 11 01 00
	00		 je	 $L61109

; 342  :          {

  00800	8b 8d fc fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00806	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  00809	8b 55 14	 mov	 edx, DWORD PTR _polylist$[ebp]
  0080c	8a 44 0a 04	 mov	 al, BYTE PTR [edx+ecx+4]
  00810	88 85 e4 fb ff
	ff		 mov	 BYTE PTR -1052+[ebp], al
  00816	80 bd e4 fb ff
	ff 00		 cmp	 BYTE PTR -1052+[ebp], 0
  0081d	74 1b		 je	 SHORT $L61112
  0081f	80 bd e4 fb ff
	ff 01		 cmp	 BYTE PTR -1052+[ebp], 1
  00826	74 43		 je	 SHORT $L61113
  00828	80 bd e4 fb ff
	ff 02		 cmp	 BYTE PTR -1052+[ebp], 2
  0082f	0f 84 93 00 00
	00		 je	 $L61116
  00835	e9 d7 00 00 00	 jmp	 $L61109
$L61112:

; 343  :             case TAP:
; 344  :                pathEnd = toB;

  0083a	c7 85 04 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _pathEnd$[ebp], 0

; 345  :                DeletePolygon(polylist,i);

  00844	8b 8d fc fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  0084a	51		 push	 ecx
  0084b	8b 55 14	 mov	 edx, DWORD PTR _polylist$[ebp]
  0084e	52		 push	 edx
  0084f	e8 00 00 00 00	 call	 ?DeletePolygon@@YAXPAVSOL_Polygon@@H@Z ; DeletePolygon
  00854	83 c4 08	 add	 esp, 8

; 346  :                --i;

  00857	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0085d	83 e8 01	 sub	 eax, 1
  00860	89 85 fc fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax

; 347  :                break;

  00866	e9 a6 00 00 00	 jmp	 $L61109
$L61113:

; 348  :             case NAP:
; 349  :                pathEnd = toENTRYtoB;

  0086b	c7 85 04 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR _pathEnd$[ebp], 1

; 350  :                if (opt)

  00875	83 7d 18 00	 cmp	 DWORD PTR _opt$[ebp], 0
  00879	74 38		 je	 SHORT $L61114

; 351  :                   NearPoint(B,polylist[i].polyPoints,polylist[i].n,&entryPoint,True);

  0087b	6a 01		 push	 1
  0087d	8d 8d 10 fc ff
	ff		 lea	 ecx, DWORD PTR _entryPoint$[ebp]
  00883	51		 push	 ecx
  00884	8b 95 fc fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  0088a	6b d2 0c	 imul	 edx, 12			; 0000000cH
  0088d	8b 45 14	 mov	 eax, DWORD PTR _polylist$[ebp]
  00890	8b 4c 10 08	 mov	 ecx, DWORD PTR [eax+edx+8]
  00894	51		 push	 ecx
  00895	8b 95 fc fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  0089b	6b d2 0c	 imul	 edx, 12			; 0000000cH
  0089e	8b 45 14	 mov	 eax, DWORD PTR _polylist$[ebp]
  008a1	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  008a4	51		 push	 ecx
  008a5	8b 55 10	 mov	 edx, DWORD PTR _B$[ebp]
  008a8	52		 push	 edx
  008a9	e8 00 00 00 00	 call	 ?NearPoint@@YAHAAUSCI_Point@@PAU1@H1H@Z ; NearPoint
  008ae	83 c4 14	 add	 esp, 20			; 00000014H

; 352  :                else

  008b1	eb 13		 jmp	 SHORT $L61115
$L61114:

; 353  :                   DeletePolygon(polylist,i);

  008b3	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  008b9	50		 push	 eax
  008ba	8b 4d 14	 mov	 ecx, DWORD PTR _polylist$[ebp]
  008bd	51		 push	 ecx
  008be	e8 00 00 00 00	 call	 ?DeletePolygon@@YAXPAVSOL_Polygon@@H@Z ; DeletePolygon
  008c3	83 c4 08	 add	 esp, 8
$L61115:

; 354  :                break;

  008c6	eb 49		 jmp	 SHORT $L61109
$L61116:

; 355  :             case BAP:
; 356  :                // If pathEnd == toENTRY we must be trying to get out of a CAP
; 357  :                if(pathEnd != toENTRY)

  008c8	83 bd 04 fc ff
	ff 02		 cmp	 DWORD PTR _pathEnd$[ebp], 2
  008cf	74 40		 je	 SHORT $L61117

; 359  :                   pathEnd = toENTRY;

  008d1	c7 85 04 fc ff
	ff 02 00 00 00	 mov	 DWORD PTR _pathEnd$[ebp], 2

; 360  :                   NearPoint(B,polylist[i].polyPoints,polylist[i].n,&entryPoint,True);

  008db	6a 01		 push	 1
  008dd	8d 95 10 fc ff
	ff		 lea	 edx, DWORD PTR _entryPoint$[ebp]
  008e3	52		 push	 edx
  008e4	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  008ea	6b c0 0c	 imul	 eax, 12			; 0000000cH
  008ed	8b 4d 14	 mov	 ecx, DWORD PTR _polylist$[ebp]
  008f0	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  008f4	52		 push	 edx
  008f5	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  008fb	6b c0 0c	 imul	 eax, 12			; 0000000cH
  008fe	8b 4d 14	 mov	 ecx, DWORD PTR _polylist$[ebp]
  00901	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00904	52		 push	 edx
  00905	8b 45 10	 mov	 eax, DWORD PTR _B$[ebp]
  00908	50		 push	 eax
  00909	e8 00 00 00 00	 call	 ?NearPoint@@YAHAAUSCI_Point@@PAU1@H1H@Z ; NearPoint
  0090e	83 c4 14	 add	 esp, 20			; 00000014H
$L61117:
$L61109:

; 365  :    }

  00911	e9 74 fe ff ff	 jmp	 $L61105
$L61106:

; 366  : 
; 367  :    // Change saved CAPs into BAPs
; 368  :    for (i=0;polylist[i].n != 0;++i)

  00916	c7 85 fc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00920	eb 0f		 jmp	 SHORT $L61118
$L61119:
  00922	8b 8d fc fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00928	83 c1 01	 add	 ecx, 1
  0092b	89 8d fc fb ff
	ff		 mov	 DWORD PTR _i$[ebp], ecx
$L61118:
  00931	8b 95 fc fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00937	6b d2 0c	 imul	 edx, 12			; 0000000cH
  0093a	8b 45 14	 mov	 eax, DWORD PTR _polylist$[ebp]
  0093d	83 7c 10 08 00	 cmp	 DWORD PTR [eax+edx+8], 0
  00942	74 2a		 je	 SHORT $L61120

; 370  :       if(polylist[i].type==CAP)

  00944	8b 8d fc fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  0094a	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  0094d	8b 55 14	 mov	 edx, DWORD PTR _polylist$[ebp]
  00950	33 c0		 xor	 eax, eax
  00952	8a 44 0a 04	 mov	 al, BYTE PTR [edx+ecx+4]
  00956	83 f8 03	 cmp	 eax, 3
  00959	75 11		 jne	 SHORT $L61121

; 372  :          polylist[i].type=BAP;

  0095b	8b 8d fc fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00961	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  00964	8b 55 14	 mov	 edx, DWORD PTR _polylist$[ebp]
  00967	c6 44 0a 04 02	 mov	 BYTE PTR [edx+ecx+4], 2
$L61121:

; 374  :    }

  0096c	eb b4		 jmp	 SHORT $L61119
$L61120:

; 375  : 
; 376  :    pathType = (pathStart << 2) + pathEnd;

  0096e	8b 85 0c fc ff
	ff		 mov	 eax, DWORD PTR _pathStart$[ebp]
  00974	8b 8d 04 fc ff
	ff		 mov	 ecx, DWORD PTR _pathEnd$[ebp]
  0097a	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  0097d	89 95 f8 fb ff
	ff		 mov	 DWORD PTR _pathType$[ebp], edx

; 378  :    {

  00983	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _pathType$[ebp]
  00989	89 85 e0 fb ff
	ff		 mov	 DWORD PTR -1056+[ebp], eax
  0098f	83 bd e0 fb ff
	ff 0a		 cmp	 DWORD PTR -1056+[ebp], 10 ; 0000000aH
  00996	0f 87 ed 02 00
	00		 ja	 $L61123
  0099c	8b 8d e0 fb ff
	ff		 mov	 ecx, DWORD PTR -1056+[ebp]
  009a2	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L62353[ecx*4]
$L61126:

; 379  :       case 0:
; 380  :          // fromA ---> toB
; 381  :          AvoidPath(A,B,polylist,opt,path);

  009a9	8d 95 14 fc ff
	ff		 lea	 edx, DWORD PTR _path$[ebp]
  009af	52		 push	 edx
  009b0	8b 45 18	 mov	 eax, DWORD PTR _opt$[ebp]
  009b3	50		 push	 eax
  009b4	8b 4d 14	 mov	 ecx, DWORD PTR _polylist$[ebp]
  009b7	51		 push	 ecx
  009b8	8b 55 10	 mov	 edx, DWORD PTR _B$[ebp]
  009bb	52		 push	 edx
  009bc	8b 45 0c	 mov	 eax, DWORD PTR _A$[ebp]
  009bf	50		 push	 eax
  009c0	e8 00 00 00 00	 call	 ?AvoidPath@@YAXAAUSCI_Point@@0PAVSOL_Polygon@@HPAU1@@Z ; AvoidPath
  009c5	83 c4 14	 add	 esp, 20			; 00000014H

; 382  :          break;

  009c8	e9 bc 02 00 00	 jmp	 $L61123
$L61127:

; 383  :       case 1:
; 384  :          // fromA ---> toENTRYtoB
; 385  :          if (opt)

  009cd	83 7d 18 00	 cmp	 DWORD PTR _opt$[ebp], 0
  009d1	74 37		 je	 SHORT $L61128

; 387  :             AvoidPath(A,entryPoint,polylist,opt,path);

  009d3	8d 8d 14 fc ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  009d9	51		 push	 ecx
  009da	8b 55 18	 mov	 edx, DWORD PTR _opt$[ebp]
  009dd	52		 push	 edx
  009de	8b 45 14	 mov	 eax, DWORD PTR _polylist$[ebp]
  009e1	50		 push	 eax
  009e2	8d 8d 10 fc ff
	ff		 lea	 ecx, DWORD PTR _entryPoint$[ebp]
  009e8	51		 push	 ecx
  009e9	8b 55 0c	 mov	 edx, DWORD PTR _A$[ebp]
  009ec	52		 push	 edx
  009ed	e8 00 00 00 00	 call	 ?AvoidPath@@YAXAAUSCI_Point@@0PAVSOL_Polygon@@HPAU1@@Z ; AvoidPath
  009f2	83 c4 14	 add	 esp, 20			; 00000014H

; 388  :             EndPath(B,path);

  009f5	8d 85 14 fc ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  009fb	50		 push	 eax
  009fc	8b 4d 10	 mov	 ecx, DWORD PTR _B$[ebp]
  009ff	51		 push	 ecx
  00a00	e8 00 00 00 00	 call	 ?EndPath@@YAXAAUSCI_Point@@PAU1@@Z ; EndPath
  00a05	83 c4 08	 add	 esp, 8

; 390  :          else

  00a08	eb 1f		 jmp	 SHORT $L61129
$L61128:

; 392  :             AvoidPath(A,B,polylist,opt,path);

  00a0a	8d 95 14 fc ff
	ff		 lea	 edx, DWORD PTR _path$[ebp]
  00a10	52		 push	 edx
  00a11	8b 45 18	 mov	 eax, DWORD PTR _opt$[ebp]
  00a14	50		 push	 eax
  00a15	8b 4d 14	 mov	 ecx, DWORD PTR _polylist$[ebp]
  00a18	51		 push	 ecx
  00a19	8b 55 10	 mov	 edx, DWORD PTR _B$[ebp]
  00a1c	52		 push	 edx
  00a1d	8b 45 0c	 mov	 eax, DWORD PTR _A$[ebp]
  00a20	50		 push	 eax
  00a21	e8 00 00 00 00	 call	 ?AvoidPath@@YAXAAUSCI_Point@@0PAVSOL_Polygon@@HPAU1@@Z ; AvoidPath
  00a26	83 c4 14	 add	 esp, 20			; 00000014H
$L61129:

; 394  :          break;

  00a29	e9 5b 02 00 00	 jmp	 $L61123
$L61130:

; 395  :       case 2:
; 396  :          // fromA ---> toENTRY
; 397  :          AvoidPath(A,entryPoint,polylist,opt,path);

  00a2e	8d 8d 14 fc ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  00a34	51		 push	 ecx
  00a35	8b 55 18	 mov	 edx, DWORD PTR _opt$[ebp]
  00a38	52		 push	 edx
  00a39	8b 45 14	 mov	 eax, DWORD PTR _polylist$[ebp]
  00a3c	50		 push	 eax
  00a3d	8d 8d 10 fc ff
	ff		 lea	 ecx, DWORD PTR _entryPoint$[ebp]
  00a43	51		 push	 ecx
  00a44	8b 55 0c	 mov	 edx, DWORD PTR _A$[ebp]
  00a47	52		 push	 edx
  00a48	e8 00 00 00 00	 call	 ?AvoidPath@@YAXAAUSCI_Point@@0PAVSOL_Polygon@@HPAU1@@Z ; AvoidPath
  00a4d	83 c4 14	 add	 esp, 20			; 00000014H

; 398  :          break;

  00a50	e9 34 02 00 00	 jmp	 $L61123
$L61131:

; 399  :       case 4:
; 400  :          // fromAtoEXIT ---> toB
; 401  :          if (opt)

  00a55	83 7d 18 00	 cmp	 DWORD PTR _opt$[ebp], 0
  00a59	74 37		 je	 SHORT $L61132

; 403  :             AvoidPath(exitPoint,B,polylist,opt,path);

  00a5b	8d 85 14 fc ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00a61	50		 push	 eax
  00a62	8b 4d 18	 mov	 ecx, DWORD PTR _opt$[ebp]
  00a65	51		 push	 ecx
  00a66	8b 55 14	 mov	 edx, DWORD PTR _polylist$[ebp]
  00a69	52		 push	 edx
  00a6a	8b 45 10	 mov	 eax, DWORD PTR _B$[ebp]
  00a6d	50		 push	 eax
  00a6e	8d 8d 08 fc ff
	ff		 lea	 ecx, DWORD PTR _exitPoint$[ebp]
  00a74	51		 push	 ecx
  00a75	e8 00 00 00 00	 call	 ?AvoidPath@@YAXAAUSCI_Point@@0PAVSOL_Polygon@@HPAU1@@Z ; AvoidPath
  00a7a	83 c4 14	 add	 esp, 20			; 00000014H

; 404  :             StartPath(A,path);

  00a7d	8d 95 14 fc ff
	ff		 lea	 edx, DWORD PTR _path$[ebp]
  00a83	52		 push	 edx
  00a84	8b 45 0c	 mov	 eax, DWORD PTR _A$[ebp]
  00a87	50		 push	 eax
  00a88	e8 00 00 00 00	 call	 ?StartPath@@YAXAAUSCI_Point@@PAU1@@Z ; StartPath
  00a8d	83 c4 08	 add	 esp, 8

; 406  :          else

  00a90	eb 1f		 jmp	 SHORT $L61133
$L61132:

; 408  :             AvoidPath(A,B,polylist,opt,path);

  00a92	8d 8d 14 fc ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  00a98	51		 push	 ecx
  00a99	8b 55 18	 mov	 edx, DWORD PTR _opt$[ebp]
  00a9c	52		 push	 edx
  00a9d	8b 45 14	 mov	 eax, DWORD PTR _polylist$[ebp]
  00aa0	50		 push	 eax
  00aa1	8b 4d 10	 mov	 ecx, DWORD PTR _B$[ebp]
  00aa4	51		 push	 ecx
  00aa5	8b 55 0c	 mov	 edx, DWORD PTR _A$[ebp]
  00aa8	52		 push	 edx
  00aa9	e8 00 00 00 00	 call	 ?AvoidPath@@YAXAAUSCI_Point@@0PAVSOL_Polygon@@HPAU1@@Z ; AvoidPath
  00aae	83 c4 14	 add	 esp, 20			; 00000014H
$L61133:

; 410  :          break;

  00ab1	e9 d3 01 00 00	 jmp	 $L61123
$L61134:

; 411  :       case 5:
; 412  :          // fromAtoEXIT ---> toENTRYtoB
; 413  :          if (opt)

  00ab6	83 7d 18 00	 cmp	 DWORD PTR _opt$[ebp], 0
  00aba	74 4d		 je	 SHORT $L61135

; 415  :             AvoidPath(exitPoint,entryPoint,polylist,opt,path);

  00abc	8d 85 14 fc ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00ac2	50		 push	 eax
  00ac3	8b 4d 18	 mov	 ecx, DWORD PTR _opt$[ebp]
  00ac6	51		 push	 ecx
  00ac7	8b 55 14	 mov	 edx, DWORD PTR _polylist$[ebp]
  00aca	52		 push	 edx
  00acb	8d 85 10 fc ff
	ff		 lea	 eax, DWORD PTR _entryPoint$[ebp]
  00ad1	50		 push	 eax
  00ad2	8d 8d 08 fc ff
	ff		 lea	 ecx, DWORD PTR _exitPoint$[ebp]
  00ad8	51		 push	 ecx
  00ad9	e8 00 00 00 00	 call	 ?AvoidPath@@YAXAAUSCI_Point@@0PAVSOL_Polygon@@HPAU1@@Z ; AvoidPath
  00ade	83 c4 14	 add	 esp, 20			; 00000014H

; 416  :             StartPath(A,path);

  00ae1	8d 95 14 fc ff
	ff		 lea	 edx, DWORD PTR _path$[ebp]
  00ae7	52		 push	 edx
  00ae8	8b 45 0c	 mov	 eax, DWORD PTR _A$[ebp]
  00aeb	50		 push	 eax
  00aec	e8 00 00 00 00	 call	 ?StartPath@@YAXAAUSCI_Point@@PAU1@@Z ; StartPath
  00af1	83 c4 08	 add	 esp, 8

; 417  :             EndPath(B,path);

  00af4	8d 8d 14 fc ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  00afa	51		 push	 ecx
  00afb	8b 55 10	 mov	 edx, DWORD PTR _B$[ebp]
  00afe	52		 push	 edx
  00aff	e8 00 00 00 00	 call	 ?EndPath@@YAXAAUSCI_Point@@PAU1@@Z ; EndPath
  00b04	83 c4 08	 add	 esp, 8

; 419  :          else

  00b07	eb 1f		 jmp	 SHORT $L61136
$L61135:

; 421  :             AvoidPath(A,B,polylist,opt,path);

  00b09	8d 85 14 fc ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00b0f	50		 push	 eax
  00b10	8b 4d 18	 mov	 ecx, DWORD PTR _opt$[ebp]
  00b13	51		 push	 ecx
  00b14	8b 55 14	 mov	 edx, DWORD PTR _polylist$[ebp]
  00b17	52		 push	 edx
  00b18	8b 45 10	 mov	 eax, DWORD PTR _B$[ebp]
  00b1b	50		 push	 eax
  00b1c	8b 4d 0c	 mov	 ecx, DWORD PTR _A$[ebp]
  00b1f	51		 push	 ecx
  00b20	e8 00 00 00 00	 call	 ?AvoidPath@@YAXAAUSCI_Point@@0PAVSOL_Polygon@@HPAU1@@Z ; AvoidPath
  00b25	83 c4 14	 add	 esp, 20			; 00000014H
$L61136:

; 423  :          break;

  00b28	e9 5c 01 00 00	 jmp	 $L61123
$L61137:

; 424  :       case 6:
; 425  :          // fromAtoEXIT ---> toENTRY
; 426  :          if (opt)

  00b2d	83 7d 18 00	 cmp	 DWORD PTR _opt$[ebp], 0
  00b31	74 3a		 je	 SHORT $L61138

; 428  :             AvoidPath(exitPoint,entryPoint,polylist,opt,path);

  00b33	8d 95 14 fc ff
	ff		 lea	 edx, DWORD PTR _path$[ebp]
  00b39	52		 push	 edx
  00b3a	8b 45 18	 mov	 eax, DWORD PTR _opt$[ebp]
  00b3d	50		 push	 eax
  00b3e	8b 4d 14	 mov	 ecx, DWORD PTR _polylist$[ebp]
  00b41	51		 push	 ecx
  00b42	8d 95 10 fc ff
	ff		 lea	 edx, DWORD PTR _entryPoint$[ebp]
  00b48	52		 push	 edx
  00b49	8d 85 08 fc ff
	ff		 lea	 eax, DWORD PTR _exitPoint$[ebp]
  00b4f	50		 push	 eax
  00b50	e8 00 00 00 00	 call	 ?AvoidPath@@YAXAAUSCI_Point@@0PAVSOL_Polygon@@HPAU1@@Z ; AvoidPath
  00b55	83 c4 14	 add	 esp, 20			; 00000014H

; 429  :             StartPath(A,path);

  00b58	8d 8d 14 fc ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  00b5e	51		 push	 ecx
  00b5f	8b 55 0c	 mov	 edx, DWORD PTR _A$[ebp]
  00b62	52		 push	 edx
  00b63	e8 00 00 00 00	 call	 ?StartPath@@YAXAAUSCI_Point@@PAU1@@Z ; StartPath
  00b68	83 c4 08	 add	 esp, 8

; 431  :          else

  00b6b	eb 22		 jmp	 SHORT $L61139
$L61138:

; 433  :             AvoidPath(A,entryPoint,polylist,opt,path);

  00b6d	8d 85 14 fc ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00b73	50		 push	 eax
  00b74	8b 4d 18	 mov	 ecx, DWORD PTR _opt$[ebp]
  00b77	51		 push	 ecx
  00b78	8b 55 14	 mov	 edx, DWORD PTR _polylist$[ebp]
  00b7b	52		 push	 edx
  00b7c	8d 85 10 fc ff
	ff		 lea	 eax, DWORD PTR _entryPoint$[ebp]
  00b82	50		 push	 eax
  00b83	8b 4d 0c	 mov	 ecx, DWORD PTR _A$[ebp]
  00b86	51		 push	 ecx
  00b87	e8 00 00 00 00	 call	 ?AvoidPath@@YAXAAUSCI_Point@@0PAVSOL_Polygon@@HPAU1@@Z ; AvoidPath
  00b8c	83 c4 14	 add	 esp, 20			; 00000014H
$L61139:

; 435  :          break;

  00b8f	e9 f5 00 00 00	 jmp	 $L61123
$L61140:

; 436  :       case 8:
; 437  :          // fromBAPtoEXIT ---> toB
; 438  :          AvoidPath(exitPoint,B,polylist,opt,path);

  00b94	8d 95 14 fc ff
	ff		 lea	 edx, DWORD PTR _path$[ebp]
  00b9a	52		 push	 edx
  00b9b	8b 45 18	 mov	 eax, DWORD PTR _opt$[ebp]
  00b9e	50		 push	 eax
  00b9f	8b 4d 14	 mov	 ecx, DWORD PTR _polylist$[ebp]
  00ba2	51		 push	 ecx
  00ba3	8b 55 10	 mov	 edx, DWORD PTR _B$[ebp]
  00ba6	52		 push	 edx
  00ba7	8d 85 08 fc ff
	ff		 lea	 eax, DWORD PTR _exitPoint$[ebp]
  00bad	50		 push	 eax
  00bae	e8 00 00 00 00	 call	 ?AvoidPath@@YAXAAUSCI_Point@@0PAVSOL_Polygon@@HPAU1@@Z ; AvoidPath
  00bb3	83 c4 14	 add	 esp, 20			; 00000014H

; 439  :          if (opt) StartPath(A,path);

  00bb6	83 7d 18 00	 cmp	 DWORD PTR _opt$[ebp], 0
  00bba	74 13		 je	 SHORT $L61141
  00bbc	8d 8d 14 fc ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  00bc2	51		 push	 ecx
  00bc3	8b 55 0c	 mov	 edx, DWORD PTR _A$[ebp]
  00bc6	52		 push	 edx
  00bc7	e8 00 00 00 00	 call	 ?StartPath@@YAXAAUSCI_Point@@PAU1@@Z ; StartPath
  00bcc	83 c4 08	 add	 esp, 8
$L61141:

; 440  :          break;

  00bcf	e9 b5 00 00 00	 jmp	 $L61123
$L61142:

; 441  :       case 9:
; 442  :          // fromBAPtoEXIT ---> toENTRYtoB
; 443  :          if (opt)

  00bd4	83 7d 18 00	 cmp	 DWORD PTR _opt$[ebp], 0
  00bd8	74 4d		 je	 SHORT $L61143

; 445  :             AvoidPath(exitPoint,entryPoint,polylist,opt,path);

  00bda	8d 85 14 fc ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00be0	50		 push	 eax
  00be1	8b 4d 18	 mov	 ecx, DWORD PTR _opt$[ebp]
  00be4	51		 push	 ecx
  00be5	8b 55 14	 mov	 edx, DWORD PTR _polylist$[ebp]
  00be8	52		 push	 edx
  00be9	8d 85 10 fc ff
	ff		 lea	 eax, DWORD PTR _entryPoint$[ebp]
  00bef	50		 push	 eax
  00bf0	8d 8d 08 fc ff
	ff		 lea	 ecx, DWORD PTR _exitPoint$[ebp]
  00bf6	51		 push	 ecx
  00bf7	e8 00 00 00 00	 call	 ?AvoidPath@@YAXAAUSCI_Point@@0PAVSOL_Polygon@@HPAU1@@Z ; AvoidPath
  00bfc	83 c4 14	 add	 esp, 20			; 00000014H

; 446  :             StartPath(A,path);

  00bff	8d 95 14 fc ff
	ff		 lea	 edx, DWORD PTR _path$[ebp]
  00c05	52		 push	 edx
  00c06	8b 45 0c	 mov	 eax, DWORD PTR _A$[ebp]
  00c09	50		 push	 eax
  00c0a	e8 00 00 00 00	 call	 ?StartPath@@YAXAAUSCI_Point@@PAU1@@Z ; StartPath
  00c0f	83 c4 08	 add	 esp, 8

; 447  :             EndPath(B,path);

  00c12	8d 8d 14 fc ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  00c18	51		 push	 ecx
  00c19	8b 55 10	 mov	 edx, DWORD PTR _B$[ebp]
  00c1c	52		 push	 edx
  00c1d	e8 00 00 00 00	 call	 ?EndPath@@YAXAAUSCI_Point@@PAU1@@Z ; EndPath
  00c22	83 c4 08	 add	 esp, 8

; 449  :          else

  00c25	eb 22		 jmp	 SHORT $L61144
$L61143:

; 451  :             AvoidPath(exitPoint,B,polylist,opt,path);

  00c27	8d 85 14 fc ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00c2d	50		 push	 eax
  00c2e	8b 4d 18	 mov	 ecx, DWORD PTR _opt$[ebp]
  00c31	51		 push	 ecx
  00c32	8b 55 14	 mov	 edx, DWORD PTR _polylist$[ebp]
  00c35	52		 push	 edx
  00c36	8b 45 10	 mov	 eax, DWORD PTR _B$[ebp]
  00c39	50		 push	 eax
  00c3a	8d 8d 08 fc ff
	ff		 lea	 ecx, DWORD PTR _exitPoint$[ebp]
  00c40	51		 push	 ecx
  00c41	e8 00 00 00 00	 call	 ?AvoidPath@@YAXAAUSCI_Point@@0PAVSOL_Polygon@@HPAU1@@Z ; AvoidPath
  00c46	83 c4 14	 add	 esp, 20			; 00000014H
$L61144:

; 453  :          break;

  00c49	eb 3e		 jmp	 SHORT $L61123
$L61145:

; 454  :       case 10:
; 455  :          // fromBAPtoEXIT ---> toENTRY
; 456  :          AvoidPath(exitPoint,entryPoint,polylist,opt,path);

  00c4b	8d 95 14 fc ff
	ff		 lea	 edx, DWORD PTR _path$[ebp]
  00c51	52		 push	 edx
  00c52	8b 45 18	 mov	 eax, DWORD PTR _opt$[ebp]
  00c55	50		 push	 eax
  00c56	8b 4d 14	 mov	 ecx, DWORD PTR _polylist$[ebp]
  00c59	51		 push	 ecx
  00c5a	8d 95 10 fc ff
	ff		 lea	 edx, DWORD PTR _entryPoint$[ebp]
  00c60	52		 push	 edx
  00c61	8d 85 08 fc ff
	ff		 lea	 eax, DWORD PTR _exitPoint$[ebp]
  00c67	50		 push	 eax
  00c68	e8 00 00 00 00	 call	 ?AvoidPath@@YAXAAUSCI_Point@@0PAVSOL_Polygon@@HPAU1@@Z ; AvoidPath
  00c6d	83 c4 14	 add	 esp, 20			; 00000014H

; 457  :          if (opt) StartPath(A,path);

  00c70	83 7d 18 00	 cmp	 DWORD PTR _opt$[ebp], 0
  00c74	74 13		 je	 SHORT $L61146
  00c76	8d 8d 14 fc ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  00c7c	51		 push	 ecx
  00c7d	8b 55 0c	 mov	 edx, DWORD PTR _A$[ebp]
  00c80	52		 push	 edx
  00c81	e8 00 00 00 00	 call	 ?StartPath@@YAXAAUSCI_Point@@PAU1@@Z ; StartPath
  00c86	83 c4 08	 add	 esp, 8
$L61146:
$L61123:

; 460  : 
; 461  :     // Re invert previously inverted polygons
; 462  :    for (i=0;polylist[i].n != 0;++i)

  00c89	c7 85 fc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00c93	eb 0f		 jmp	 SHORT $L61147
$L61148:
  00c95	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00c9b	83 c0 01	 add	 eax, 1
  00c9e	89 85 fc fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$L61147:
  00ca4	8b 8d fc fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00caa	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  00cad	8b 55 14	 mov	 edx, DWORD PTR _polylist$[ebp]
  00cb0	83 7c 0a 08 00	 cmp	 DWORD PTR [edx+ecx+8], 0
  00cb5	74 44		 je	 SHORT $L61149

; 464  :      if(polylist[i].info & INVERTED)

  00cb7	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00cbd	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00cc0	8b 4d 14	 mov	 ecx, DWORD PTR _polylist$[ebp]
  00cc3	33 d2		 xor	 edx, edx
  00cc5	8a 54 01 05	 mov	 dl, BYTE PTR [ecx+eax+5]
  00cc9	83 e2 01	 and	 edx, 1
  00ccc	85 d2		 test	 edx, edx
  00cce	74 29		 je	 SHORT $L61150

; 466  :          InvertPolygon(polylist[i].polyPoints,polylist[i].n);

  00cd0	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00cd6	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00cd9	8b 4d 14	 mov	 ecx, DWORD PTR _polylist$[ebp]
  00cdc	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  00ce0	52		 push	 edx
  00ce1	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00ce7	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00cea	8b 4d 14	 mov	 ecx, DWORD PTR _polylist$[ebp]
  00ced	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00cf0	52		 push	 edx
  00cf1	e8 00 00 00 00	 call	 ?InvertPolygon@@YAXPAUSCI_Point@@H@Z ; InvertPolygon
  00cf6	83 c4 08	 add	 esp, 8
$L61150:

; 468  :    }

  00cf9	eb 9a		 jmp	 SHORT $L61148
$L61149:

; 469  :    // Allocate memory for the return path, put the points
; 470  :    // into the allocation and return the ID
; 471  :    return CopyPath(path);

  00cfb	8d 85 14 fc ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00d01	50		 push	 eax
  00d02	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR $T62351[ebp]
  00d08	51		 push	 ecx
  00d09	e8 00 00 00 00	 call	 ?CopyPath@@YA?AVMemID@@PAUSCI_Point@@@Z ; CopyPath
  00d0e	83 c4 08	 add	 esp, 8
  00d11	50		 push	 eax
  00d12	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00d15	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00d1a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 472  : }

  00d1d	8b e5		 mov	 esp, ebp
  00d1f	5d		 pop	 ebp
  00d20	c3		 ret	 0
$L62352:
  00d21	00 00 00 00	 DD	 $L61093
  00d25	00 00 00 00	 DD	 $L61094
  00d29	00 00 00 00	 DD	 $L61097
  00d2d	00 00 00 00	 DD	 $L61098
$L62353:
  00d31	00 00 00 00	 DD	 $L61126
  00d35	00 00 00 00	 DD	 $L61127
  00d39	00 00 00 00	 DD	 $L61130
  00d3d	00 00 00 00	 DD	 $L61123
  00d41	00 00 00 00	 DD	 $L61131
  00d45	00 00 00 00	 DD	 $L61134
  00d49	00 00 00 00	 DD	 $L61137
  00d4d	00 00 00 00	 DD	 $L61123
  00d51	00 00 00 00	 DD	 $L61140
  00d55	00 00 00 00	 DD	 $L61142
  00d59	00 00 00 00	 DD	 $L61145
?GetPath@@YA?AVMemID@@AAUSCI_Point@@0PAVSOL_Polygon@@H0@Z ENDP ; GetPath
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0MemID@@QAE@ABV0@@Z PROC NEAR				; MemID::MemID, COMDAT

; 19   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  0000d	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00010	66 89 10	 mov	 WORD PTR [eax], dx

; 20   : 	}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0MemID@@QAE@ABV0@@Z ENDP				; MemID::MemID
_TEXT	ENDS
_TEXT	SEGMENT
_A$ = 8
_path$ = 12
_p1$ = -4
_i$ = -8
_p2$61161 = -12
?StartPath@@YAXAAUSCI_Point@@PAU1@@Z PROC NEAR		; StartPath

; 478  : {

  00d5d	55		 push	 ebp
  00d5e	8b ec		 mov	 ebp, esp
  00d60	83 ec 14	 sub	 esp, 20			; 00000014H

; 479  :    SCI_Point p1 = A;

  00d63	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  00d66	50		 push	 eax
  00d67	8d 4d fc	 lea	 ecx, DWORD PTR _p1$[ebp]
  00d6a	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@ABU0@@Z ; SCI_Point::SCI_Point

; 480  :    int i = 0;

  00d6f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$L61159:

; 481  : 
; 482  :    while (path[i].x != ENDOFPATH)

  00d76	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00d79	8b 55 0c	 mov	 edx, DWORD PTR _path$[ebp]
  00d7c	0f bf 04 8a	 movsx	 eax, WORD PTR [edx+ecx*4]
  00d80	3d 77 77 00 00	 cmp	 eax, 30583		; 00007777H
  00d85	74 41		 je	 SHORT $L61160

; 484  :       SCI_Point p2 = path[i];

  00d87	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00d8a	8b 55 0c	 mov	 edx, DWORD PTR _path$[ebp]
  00d8d	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00d90	50		 push	 eax
  00d91	8d 4d f4	 lea	 ecx, DWORD PTR _p2$61161[ebp]
  00d94	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@ABU0@@Z ; SCI_Point::SCI_Point

; 485  :       path[i++] = p1;

  00d99	8d 4d fc	 lea	 ecx, DWORD PTR _p1$[ebp]
  00d9c	51		 push	 ecx
  00d9d	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00da0	8b 45 0c	 mov	 eax, DWORD PTR _path$[ebp]
  00da3	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00da6	89 4d f0	 mov	 DWORD PTR -16+[ebp], ecx
  00da9	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00dac	83 c2 01	 add	 edx, 1
  00daf	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
  00db2	8b 4d f0	 mov	 ecx, DWORD PTR -16+[ebp]
  00db5	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 486  :       p1 = p2;

  00dba	8d 45 f4	 lea	 eax, DWORD PTR _p2$61161[ebp]
  00dbd	50		 push	 eax
  00dbe	8d 4d fc	 lea	 ecx, DWORD PTR _p1$[ebp]
  00dc1	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 487  :    }

  00dc6	eb ae		 jmp	 SHORT $L61159
$L61160:

; 488  :    path[i++] = p1;

  00dc8	8d 4d fc	 lea	 ecx, DWORD PTR _p1$[ebp]
  00dcb	51		 push	 ecx
  00dcc	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00dcf	8b 45 0c	 mov	 eax, DWORD PTR _path$[ebp]
  00dd2	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00dd5	89 4d ec	 mov	 DWORD PTR -20+[ebp], ecx
  00dd8	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00ddb	83 c2 01	 add	 edx, 1
  00dde	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
  00de1	8b 4d ec	 mov	 ecx, DWORD PTR -20+[ebp]
  00de4	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 489  :    path[i].x = ENDOFPATH;

  00de9	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00dec	8b 4d 0c	 mov	 ecx, DWORD PTR _path$[ebp]
  00def	66 c7 04 81 77
	77		 mov	 WORD PTR [ecx+eax*4], 30583 ; 00007777H

; 490  : }

  00df5	8b e5		 mov	 esp, ebp
  00df7	5d		 pop	 ebp
  00df8	c3		 ret	 0
?StartPath@@YAXAAUSCI_Point@@PAU1@@Z ENDP		; StartPath
_B$ = 8
_path$ = 12
_i$ = -4
?EndPath@@YAXAAUSCI_Point@@PAU1@@Z PROC NEAR		; EndPath

; 495  : {

  00df9	55		 push	 ebp
  00dfa	8b ec		 mov	 ebp, esp
  00dfc	83 ec 08	 sub	 esp, 8

; 496  :    int i = 0;

  00dff	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$L61167:

; 498  :       ++i;

  00e06	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00e09	83 c0 01	 add	 eax, 1
  00e0c	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 499  :    while (path[i].x != ENDOFPATH);

  00e0f	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00e12	8b 55 0c	 mov	 edx, DWORD PTR _path$[ebp]
  00e15	0f bf 04 8a	 movsx	 eax, WORD PTR [edx+ecx*4]
  00e19	3d 77 77 00 00	 cmp	 eax, 30583		; 00007777H
  00e1e	75 e6		 jne	 SHORT $L61167

; 500  :    path[i++] = B;

  00e20	8b 4d 08	 mov	 ecx, DWORD PTR _B$[ebp]
  00e23	51		 push	 ecx
  00e24	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00e27	8b 45 0c	 mov	 eax, DWORD PTR _path$[ebp]
  00e2a	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00e2d	89 4d f8	 mov	 DWORD PTR -8+[ebp], ecx
  00e30	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00e33	83 c2 01	 add	 edx, 1
  00e36	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
  00e39	8b 4d f8	 mov	 ecx, DWORD PTR -8+[ebp]
  00e3c	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 501  :    path[i].x = ENDOFPATH;

  00e41	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00e44	8b 4d 0c	 mov	 ecx, DWORD PTR _path$[ebp]
  00e47	66 c7 04 81 77
	77		 mov	 WORD PTR [ecx+eax*4], 30583 ; 00007777H

; 502  : }

  00e4d	8b e5		 mov	 esp, ebp
  00e4f	5d		 pop	 ebp
  00e50	c3		 ret	 0
?EndPath@@YAXAAUSCI_Point@@PAU1@@Z ENDP			; EndPath
_TEXT	ENDS
PUBLIC	??0Array@@QAE@HW4ArrayType@@@Z			; Array::Array
PUBLIC	??1Array@@QAE@XZ				; Array::~Array
PUBLIC	?dataID@Array@@QAE?AVMemID@@XZ			; Array::dataID
EXTRN	?copy@Array@@QAEXHPAXHH@Z:NEAR			; Array::copy
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
xdata$x	SEGMENT
$T62363	DD	019930520H
	DD	01H
	DD	FLAT:$T62366
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T62366	DD	0ffffffffH
	DD	FLAT:$L62359
xdata$x	ENDS
_TEXT	SEGMENT
_path$ = 12
___$ReturnUdt$ = 8
_i$ = -16
_array$ = -20
$T62358 = -24
__$EHRec$ = -12
?CopyPath@@YA?AVMemID@@PAUSCI_Point@@@Z PROC NEAR	; CopyPath

; 506  : {

  00e51	55		 push	 ebp
  00e52	8b ec		 mov	 ebp, esp
  00e54	6a ff		 push	 -1
  00e56	68 00 00 00 00	 push	 $L62364
  00e5b	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00e61	50		 push	 eax
  00e62	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00e69	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 507  :    int   i = 0;

  00e6c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$L61176:

; 508  : 
; 509  :    while  (path[i++].x != ENDOFPATH)

  00e73	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00e76	8b 4d 0c	 mov	 ecx, DWORD PTR _path$[ebp]
  00e79	0f bf 14 81	 movsx	 edx, WORD PTR [ecx+eax*4]
  00e7d	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00e80	83 c0 01	 add	 eax, 1
  00e83	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
  00e86	81 fa 77 77 00
	00		 cmp	 edx, 30583		; 00007777H
  00e8c	74 02		 je	 SHORT $L61177

; 510  : 		;

  00e8e	eb e3		 jmp	 SHORT $L61176
$L61177:

; 511  : 
; 512  :    Array array ( 2 * i, INTARRAY );

  00e90	6a 00		 push	 0
  00e92	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  00e95	d1 e1		 shl	 ecx, 1
  00e97	51		 push	 ecx
  00e98	8d 4d ec	 lea	 ecx, DWORD PTR _array$[ebp]
  00e9b	e8 00 00 00 00	 call	 ??0Array@@QAE@HW4ArrayType@@@Z ; Array::Array
  00ea0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 513  : 	array.copy ( 0, path, 0, 2 * i );

  00ea7	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  00eaa	d1 e2		 shl	 edx, 1
  00eac	52		 push	 edx
  00ead	6a 00		 push	 0
  00eaf	8b 45 0c	 mov	 eax, DWORD PTR _path$[ebp]
  00eb2	50		 push	 eax
  00eb3	6a 00		 push	 0
  00eb5	8d 4d ec	 lea	 ecx, DWORD PTR _array$[ebp]
  00eb8	e8 00 00 00 00	 call	 ?copy@Array@@QAEXHPAXHH@Z ; Array::copy

; 514  : 
; 515  :    return array.dataID();

  00ebd	8d 4d e8	 lea	 ecx, DWORD PTR $T62358[ebp]
  00ec0	51		 push	 ecx
  00ec1	8d 4d ec	 lea	 ecx, DWORD PTR _array$[ebp]
  00ec4	e8 00 00 00 00	 call	 ?dataID@Array@@QAE?AVMemID@@XZ ; Array::dataID
  00ec9	50		 push	 eax
  00eca	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00ecd	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00ed2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00ed9	8d 4d ec	 lea	 ecx, DWORD PTR _array$[ebp]
  00edc	e8 00 00 00 00	 call	 ??1Array@@QAE@XZ	; Array::~Array
  00ee1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 516  : }

  00ee4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00ee7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00eee	8b e5		 mov	 esp, ebp
  00ef0	5d		 pop	 ebp
  00ef1	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L62359:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR _array$[ebp]
  00003	e8 00 00 00 00	 call	 ??1Array@@QAE@XZ	; Array::~Array
  00008	c3		 ret	 0
$L62364:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T62363
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?CopyPath@@YA?AVMemID@@PAUSCI_Point@@@Z ENDP		; CopyPath
PUBLIC	??0MemID@@QAE@XZ				; MemID::MemID
PUBLIC	??0ArrayID@@QAE@HW4ArrayType@@@Z		; ArrayID::ArrayID
PUBLIC	?dataID@Array@@QAEXVMemID@@@Z			; Array::dataID
;	COMDAT ??0Array@@QAE@HW4ArrayType@@@Z
_TEXT	SEGMENT
_count$ = 8
_type$ = 12
_this$ = -12
$T62370 = -8
??0Array@@QAE@HW4ArrayType@@@Z PROC NEAR		; Array::Array, COMDAT

; 84   : 	Array ( int count, ArrayType type ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID

; 85   : 		dataID ( ArrayID ( count, type ) );

  00011	8b 45 0c	 mov	 eax, DWORD PTR _type$[ebp]
  00014	50		 push	 eax
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _count$[ebp]
  00018	51		 push	 ecx
  00019	8d 4d f8	 lea	 ecx, DWORD PTR $T62370[ebp]
  0001c	e8 00 00 00 00	 call	 ??0ArrayID@@QAE@HW4ArrayType@@@Z ; ArrayID::ArrayID
  00021	51		 push	 ecx
  00022	8b cc		 mov	 ecx, esp
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  0002a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?dataID@Array@@QAEXVMemID@@@Z ; Array::dataID

; 86   : 	}

  00032	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
??0Array@@QAE@HW4ArrayType@@@Z ENDP			; Array::Array
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0MemID@@QAE@XZ PROC NEAR				; MemID::MemID, COMDAT

; 15   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 16   : 	}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0MemID@@QAE@XZ ENDP					; MemID::MemID
_TEXT	ENDS
PUBLIC	??0FakeArrayID@@QAE@XZ				; FakeArrayID::FakeArrayID
PUBLIC	??DFakeArrayID@@QBEPAUArrayHeader@@XZ		; FakeArrayID::operator*
PUBLIC	?Get@ArrayID@@QAEXI@Z				; ArrayID::Get
EXTRN	?ArrayElementSize@@3PAHA:BYTE			; ArrayElementSize
;	COMDAT ??0ArrayID@@QAE@HW4ArrayType@@@Z
_TEXT	SEGMENT
_size$ = 8
_type$ = 12
_this$ = -12
_elementSize$ = -8
_array$ = -4
??0ArrayID@@QAE@HW4ArrayType@@@Z PROC NEAR		; ArrayID::ArrayID, COMDAT

; 40   : 	ArrayID ( int size, ArrayType type )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0FakeArrayID@@QAE@XZ	; FakeArrayID::FakeArrayID

; 41   : 	{
; 42   : 		int elementSize = ArrayElementSize[type];

  00011	8b 45 0c	 mov	 eax, DWORD PTR _type$[ebp]
  00014	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ArrayElementSize@@3PAHA[eax*4]
  0001b	89 4d f8	 mov	 DWORD PTR _elementSize$[ebp], ecx

; 43   : 
; 44   : 		// allocate the base array
; 45   : 		Get ( elementSize * size + sizeof ( ArrayHeader ) );

  0001e	8b 55 f8	 mov	 edx, DWORD PTR _elementSize$[ebp]
  00021	0f af 55 08	 imul	 edx, DWORD PTR _size$[ebp]
  00025	83 c2 04	 add	 edx, 4
  00028	52		 push	 edx
  00029	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?Get@ArrayID@@QAEXI@Z	; ArrayID::Get

; 46   : 
; 47   : 		// set the default values for the Array struct that I represent
; 48   : 		ArrayHeader *array = **this;

  00031	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ??DFakeArrayID@@QBEPAUArrayHeader@@XZ ; FakeArrayID::operator*
  00039	89 45 fc	 mov	 DWORD PTR _array$[ebp], eax

; 49   : 		array->elementSize = elementSize;

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _array$[ebp]
  0003f	66 8b 4d f8	 mov	 cx, WORD PTR _elementSize$[ebp]
  00043	66 89 08	 mov	 WORD PTR [eax], cx

; 50   : 		array->size = size;

  00046	8b 55 fc	 mov	 edx, DWORD PTR _array$[ebp]
  00049	66 8b 45 08	 mov	 ax, WORD PTR _size$[ebp]
  0004d	66 89 42 02	 mov	 WORD PTR [edx+2], ax

; 51   : 	}

  00051	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 08 00	 ret	 8
??0ArrayID@@QAE@HW4ArrayType@@@Z ENDP			; ArrayID::ArrayID
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0FakeArrayID@@QAE@XZ PROC NEAR			; FakeArrayID::FakeArrayID, COMDAT

; 34   : FakeTemplateID ( FakeArrayID, ArrayHeader, MemArray )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0FakeArrayID@@QAE@XZ ENDP				; FakeArrayID::FakeArrayID
_TEXT	ENDS
PUBLIC	??DMemID@@QBEPAXXZ				; MemID::operator*
;	COMDAT ??DFakeArrayID@@QBEPAUArrayHeader@@XZ
_TEXT	SEGMENT
_this$ = -4
??DFakeArrayID@@QBEPAUArrayHeader@@XZ PROC NEAR		; FakeArrayID::operator*, COMDAT

; 34   : FakeTemplateID ( FakeArrayID, ArrayHeader, MemArray )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??DFakeArrayID@@QBEPAUArrayHeader@@XZ ENDP		; FakeArrayID::operator*
_TEXT	ENDS
PUBLIC	?GetAddr@MemoryMgr@@QAEPAXG@Z			; MemoryMgr::GetAddr
EXTRN	_memMgr:DWORD
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT
_this$ = -4
??DMemID@@QBEPAXXZ PROC NEAR				; MemID::operator*, COMDAT

; 98   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 99   : 		return memMgr->GetAddr(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr

; 100  : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??DMemID@@QBEPAXXZ ENDP					; MemID::operator*
_TEXT	ENDS
EXTRN	__descPtrTable:BYTE
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -4
?GetAddr@MemoryMgr@@QAEPAXG@Z PROC NEAR			; MemoryMgr::GetAddr, COMDAT

; 462  : 	inline void* MemoryMgr::GetAddr(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : //		CheckValid(theID);
; 464  : 		return _descPtrTable[(unsigned int)((unsigned short)theID)];

  00007	8b 45 08	 mov	 eax, DWORD PTR _theID$[ebp]
  0000a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0000f	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR __descPtrTable[eax*4]

; 465  : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?GetAddr@MemoryMgr@@QAEPAXG@Z ENDP			; MemoryMgr::GetAddr
_TEXT	ENDS
PUBLIC	?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get
;	COMDAT ?Get@ArrayID@@QAEXI@Z
_TEXT	SEGMENT
_size$ = 8
_this$ = -4
?Get@ArrayID@@QAEXI@Z PROC NEAR				; ArrayID::Get, COMDAT

; 55   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 56   : 		// initialize arrays to 0
; 57   : 
; 58   : 		//	include defaulted args because CodeWarrior 1.1.1.2 doesn't
; 59   : 		//	consider enums a separate type and so can't distinguish between
; 60   : 		//	overloaded Get()s.
; 61   : 		MemID::Get(MemArray, size, INITMEMORY | MOVEABLE, 0, 0, 0, IllegalHandle);

  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 00		 push	 0
  0000f	68 00 02 01 00	 push	 66048			; 00010200H
  00014	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  00017	50		 push	 eax
  00018	6a 35		 push	 53			; 00000035H
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get

; 62   : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?Get@ArrayID@@QAEXI@Z ENDP				; ArrayID::Get
_TEXT	ENDS
EXTRN	?Alloc@MemoryMgr@@QAEGIIIPAUMemClient@@DW4ReservedHandle@@@Z:NEAR ; MemoryMgr::Alloc
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT
_type$ = 8
_size$ = 12
_a$ = 16
_num$ = 20
_client$ = 24
_initChar$ = 28
_h$ = 32
_this$ = -4
?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z PROC NEAR ; MemID::Get, COMDAT

; 42   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 43   : 		handle = memMgr->Alloc(type | a, size, num, client, initChar, h);

  00007	8b 45 20	 mov	 eax, DWORD PTR _h$[ebp]
  0000a	50		 push	 eax
  0000b	8a 4d 1c	 mov	 cl, BYTE PTR _initChar$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 18	 mov	 edx, DWORD PTR _client$[ebp]
  00012	52		 push	 edx
  00013	8b 45 14	 mov	 eax, DWORD PTR _num$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 55 08	 mov	 edx, DWORD PTR _type$[ebp]
  0001e	0b 55 10	 or	 edx, DWORD PTR _a$[ebp]
  00021	52		 push	 edx
  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00028	e8 00 00 00 00	 call	 ?Alloc@MemoryMgr@@QAEGIIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemoryMgr::Alloc
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	66 89 01	 mov	 WORD PTR [ecx], ax

; 44   : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 1c 00	 ret	 28			; 0000001cH
?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ENDP ; MemID::Get
_TEXT	ENDS
;	COMDAT ??1Array@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1Array@@QAE@XZ PROC NEAR				; Array::~Array, COMDAT

; 88   : 	~Array() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1Array@@QAE@XZ ENDP					; Array::~Array
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAE?AVMemID@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
?dataID@Array@@QAE?AVMemID@@XZ PROC NEAR		; Array::dataID, COMDAT

; 96   : 	MemID dataID ( void ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 97   : 		return _dataID;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00013	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 98   : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?dataID@Array@@QAE?AVMemID@@XZ ENDP			; Array::dataID
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAEXVMemID@@@Z
_TEXT	SEGMENT
_memID$ = 8
_this$ = -4
?dataID@Array@@QAEXVMemID@@@Z PROC NEAR			; Array::dataID, COMDAT

; 111  : 	void dataID ( MemID memID ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		_dataID = memID;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 4d 08	 mov	 cx, WORD PTR _memID$[ebp]
  0000e	66 89 08	 mov	 WORD PTR [eax], cx

; 113  : 	}

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?dataID@Array@@QAEXVMemID@@@Z ENDP			; Array::dataID
_TEXT	ENDS
_TEXT	SEGMENT
_points$ = 8
_n$ = 12
_i$ = -4
_j$ = -8
_p$61189 = -12
?InvertPolygon@@YAXPAUSCI_Point@@H@Z PROC NEAR		; InvertPolygon

; 520  : {

  00ef2	55		 push	 ebp
  00ef3	8b ec		 mov	 ebp, esp
  00ef5	83 ec 14	 sub	 esp, 20			; 00000014H

; 521  :    int i,j;
; 522  :    for (i = 0,j = n-1;i<j;)

  00ef8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00eff	8b 45 0c	 mov	 eax, DWORD PTR _n$[ebp]
  00f02	83 e8 01	 sub	 eax, 1
  00f05	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
$L61187:
  00f08	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00f0b	3b 4d f8	 cmp	 ecx, DWORD PTR _j$[ebp]
  00f0e	7d 5c		 jge	 SHORT $L61188

; 524  :       SCI_Point p = points[i];

  00f10	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00f13	8b 45 08	 mov	 eax, DWORD PTR _points$[ebp]
  00f16	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00f19	51		 push	 ecx
  00f1a	8d 4d f4	 lea	 ecx, DWORD PTR _p$61189[ebp]
  00f1d	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@ABU0@@Z ; SCI_Point::SCI_Point

; 525  :       points[i++] = points[j];

  00f22	8b 55 f8	 mov	 edx, DWORD PTR _j$[ebp]
  00f25	8b 45 08	 mov	 eax, DWORD PTR _points$[ebp]
  00f28	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00f2b	51		 push	 ecx
  00f2c	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00f2f	8b 45 08	 mov	 eax, DWORD PTR _points$[ebp]
  00f32	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00f35	89 4d f0	 mov	 DWORD PTR -16+[ebp], ecx
  00f38	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00f3b	83 c2 01	 add	 edx, 1
  00f3e	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
  00f41	8b 4d f0	 mov	 ecx, DWORD PTR -16+[ebp]
  00f44	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 526  :       points[j--] = p;

  00f49	8d 45 f4	 lea	 eax, DWORD PTR _p$61189[ebp]
  00f4c	50		 push	 eax
  00f4d	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  00f50	8b 55 08	 mov	 edx, DWORD PTR _points$[ebp]
  00f53	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00f56	89 45 ec	 mov	 DWORD PTR -20+[ebp], eax
  00f59	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  00f5c	83 e9 01	 sub	 ecx, 1
  00f5f	89 4d f8	 mov	 DWORD PTR _j$[ebp], ecx
  00f62	8b 4d ec	 mov	 ecx, DWORD PTR -20+[ebp]
  00f65	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 527  :       }

  00f6a	eb 9c		 jmp	 SHORT $L61187
$L61188:

; 528  : }

  00f6c	8b e5		 mov	 esp, ebp
  00f6e	5d		 pop	 ebp
  00f6f	c3		 ret	 0
?InvertPolygon@@YAXPAUSCI_Point@@H@Z ENDP		; InvertPolygon
_TEXT	ENDS
PUBLIC	??DSCI_Point@@QBEHABU0@@Z			; SCI_Point::operator*
PUBLIC	?DistanceEstimate@@YAHAAUSCI_Point@@0PAH@Z	; DistanceEstimate
_TEXT	SEGMENT
_P$ = 8
_polygon$ = 12
_n$ = 16
_R$ = 20
_Edge$ = 24
_i$ = -20
_d$ = -12
_dot1$ = -28
_dot2$ = -36
_dot3$ = -44
_A$ = -4
_B$ = -8
_tmp1$ = -24
_tmp2$ = -32
_tmp3$ = -40
_tmp4$ = -48
_offScreen$ = -16
$T62384 = -52
$T62385 = -56
$T62386 = -60
?NearPoint@@YAHAAUSCI_Point@@PAU1@H1H@Z PROC NEAR	; NearPoint

; 535  : {

  00f70	55		 push	 ebp
  00f71	8b ec		 mov	 ebp, esp
  00f73	83 ec 44	 sub	 esp, 68			; 00000044H

; 536  :    int         i;
; 537  :    int         d=INT_MAX,dot1,dot2,dot3;

  00f76	c7 45 f4 ff ff
	ff 7f		 mov	 DWORD PTR _d$[ebp], 2147483647 ; 7fffffffH

; 538  :    SCI_Point   A,B,tmp1,tmp2,tmp3,tmp4;

  00f7d	8d 4d fc	 lea	 ecx, DWORD PTR _A$[ebp]
  00f80	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  00f85	8d 4d f8	 lea	 ecx, DWORD PTR _B$[ebp]
  00f88	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  00f8d	8d 4d e8	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  00f90	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  00f95	8d 4d e0	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  00f98	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  00f9d	8d 4d d8	 lea	 ecx, DWORD PTR _tmp3$[ebp]
  00fa0	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  00fa5	8d 4d d0	 lea	 ecx, DWORD PTR _tmp4$[ebp]
  00fa8	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point

; 539  :    Boolean        offScreen;
; 540  : 
; 541  :    for (i=0;i<n;++i)

  00fad	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00fb4	eb 09		 jmp	 SHORT $L61209
$L61210:
  00fb6	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00fb9	83 c0 01	 add	 eax, 1
  00fbc	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$L61209:
  00fbf	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  00fc2	3b 4d 10	 cmp	 ecx, DWORD PTR _n$[ebp]
  00fc5	0f 8d 74 02 00
	00		 jge	 $L61211

; 543  :       A = polygon[i];

  00fcb	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  00fce	8b 45 0c	 mov	 eax, DWORD PTR _polygon$[ebp]
  00fd1	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00fd4	51		 push	 ecx
  00fd5	8d 4d fc	 lea	 ecx, DWORD PTR _A$[ebp]
  00fd8	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 544  :       if (i==n-1)

  00fdd	8b 55 10	 mov	 edx, DWORD PTR _n$[ebp]
  00fe0	83 ea 01	 sub	 edx, 1
  00fe3	39 55 ec	 cmp	 DWORD PTR _i$[ebp], edx
  00fe6	75 0e		 jne	 SHORT $L61212

; 545  :          B = polygon[0];

  00fe8	8b 45 0c	 mov	 eax, DWORD PTR _polygon$[ebp]
  00feb	50		 push	 eax
  00fec	8d 4d f8	 lea	 ecx, DWORD PTR _B$[ebp]
  00fef	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 546  :       else

  00ff4	eb 13		 jmp	 SHORT $L61213
$L61212:

; 547  :          B = polygon[i+1];

  00ff6	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  00ff9	8b 55 0c	 mov	 edx, DWORD PTR _polygon$[ebp]
  00ffc	8d 44 8a 04	 lea	 eax, DWORD PTR [edx+ecx*4+4]
  01000	50		 push	 eax
  01001	8d 4d f8	 lea	 ecx, DWORD PTR _B$[ebp]
  01004	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=
$L61213:

; 550  :             Edge                        
; 551  :          &&
; 552  :             (
; 553  :             (A.x == B.x) && ((A.x == 0) || 
; 554  :             (A.x == planePoly[1].x))    ||
; 555  :             (A.y == B.y) && ((A.y == 0) ||
; 556  :             (A.y == planePoly[2].y))
; 557  :             )
; 558  :          )

  01009	83 7d 18 00	 cmp	 DWORD PTR _Edge$[ebp], 0
  0100d	74 4b		 je	 SHORT $L61214
  0100f	0f bf 4d fc	 movsx	 ecx, WORD PTR _A$[ebp]
  01013	0f bf 55 f8	 movsx	 edx, WORD PTR _B$[ebp]
  01017	3b ca		 cmp	 ecx, edx
  01019	75 17		 jne	 SHORT $L61216
  0101b	0f bf 45 fc	 movsx	 eax, WORD PTR _A$[ebp]
  0101f	85 c0		 test	 eax, eax
  01021	74 32		 je	 SHORT $L61217
  01023	0f bf 4d fc	 movsx	 ecx, WORD PTR _A$[ebp]
  01027	0f bf 15 04 00
	00 00		 movsx	 edx, WORD PTR ?planePoly@@3PAUSCI_Point@@A+4
  0102e	3b ca		 cmp	 ecx, edx
  01030	74 23		 je	 SHORT $L61217
$L61216:
  01032	0f bf 45 fe	 movsx	 eax, WORD PTR _A$[ebp+2]
  01036	0f bf 4d fa	 movsx	 ecx, WORD PTR _B$[ebp+2]
  0103a	3b c1		 cmp	 eax, ecx
  0103c	75 1c		 jne	 SHORT $L61214
  0103e	0f bf 55 fe	 movsx	 edx, WORD PTR _A$[ebp+2]
  01042	85 d2		 test	 edx, edx
  01044	74 0f		 je	 SHORT $L61217
  01046	0f bf 45 fe	 movsx	 eax, WORD PTR _A$[ebp+2]
  0104a	0f bf 0d 0a 00
	00 00		 movsx	 ecx, WORD PTR ?planePoly@@3PAUSCI_Point@@A+10
  01051	3b c1		 cmp	 eax, ecx
  01053	75 05		 jne	 SHORT $L61214
$L61217:

; 563  :       else

  01055	e9 e0 01 00 00	 jmp	 $L61231
$L61214:

; 565  :          // If P is closest to this line save the closest on this line to P
; 566  : 
; 567  :          tmp1 = B - A;

  0105a	8d 55 fc	 lea	 edx, DWORD PTR _A$[ebp]
  0105d	52		 push	 edx
  0105e	8d 45 cc	 lea	 eax, DWORD PTR $T62384[ebp]
  01061	50		 push	 eax
  01062	8d 4d f8	 lea	 ecx, DWORD PTR _B$[ebp]
  01065	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  0106a	50		 push	 eax
  0106b	8d 4d e8	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  0106e	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 568  :          tmp2 = A - P;

  01073	8b 4d 08	 mov	 ecx, DWORD PTR _P$[ebp]
  01076	51		 push	 ecx
  01077	8d 55 c8	 lea	 edx, DWORD PTR $T62385[ebp]
  0107a	52		 push	 edx
  0107b	8d 4d fc	 lea	 ecx, DWORD PTR _A$[ebp]
  0107e	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  01083	50		 push	 eax
  01084	8d 4d e0	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  01087	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 569  :          tmp3 = B - P;

  0108c	8b 45 08	 mov	 eax, DWORD PTR _P$[ebp]
  0108f	50		 push	 eax
  01090	8d 4d c4	 lea	 ecx, DWORD PTR $T62386[ebp]
  01093	51		 push	 ecx
  01094	8d 4d f8	 lea	 ecx, DWORD PTR _B$[ebp]
  01097	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  0109c	50		 push	 eax
  0109d	8d 4d d8	 lea	 ecx, DWORD PTR _tmp3$[ebp]
  010a0	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 570  : 
; 571  :          if (((tmp1*tmp2) <= 0) && ((tmp1*tmp3) >= 0))

  010a5	8d 55 e0	 lea	 edx, DWORD PTR _tmp2$[ebp]
  010a8	52		 push	 edx
  010a9	8d 4d e8	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  010ac	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  010b1	85 c0		 test	 eax, eax
  010b3	0f 8f 1f 01 00
	00		 jg	 $L61222
  010b9	8d 45 d8	 lea	 eax, DWORD PTR _tmp3$[ebp]
  010bc	50		 push	 eax
  010bd	8d 4d e8	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  010c0	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  010c5	85 c0		 test	 eax, eax
  010c7	0f 8c 0b 01 00
	00		 jl	 $L61222

; 598  :             // Distance P-R is:
; 599  :             // ABS{[(B-A)^(0,0,1)]*(A-P)/|B-A|}
; 600  : 
; 601  :             /* Make N = tmp4 normal to A-B */
; 602  :             tmp4.x = tmp1.y;

  010cd	66 8b 4d ea	 mov	 cx, WORD PTR _tmp1$[ebp+2]
  010d1	66 89 4d d0	 mov	 WORD PTR _tmp4$[ebp], cx

; 603  :             tmp4.y = -tmp1.x;

  010d5	0f bf 55 e8	 movsx	 edx, WORD PTR _tmp1$[ebp]
  010d9	f7 da		 neg	 edx
  010db	66 89 55 d2	 mov	 WORD PTR _tmp4$[ebp+2], dx

; 604  :             dot1 = tmp2*tmp4;

  010df	8d 45 d0	 lea	 eax, DWORD PTR _tmp4$[ebp]
  010e2	50		 push	 eax
  010e3	8d 4d e0	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  010e6	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  010eb	89 45 e4	 mov	 DWORD PTR _dot1$[ebp], eax

; 605  :             dot2 = dot1/DistanceEstimate(A,B,&offScreen);

  010ee	8d 4d f0	 lea	 ecx, DWORD PTR _offScreen$[ebp]
  010f1	51		 push	 ecx
  010f2	8d 55 f8	 lea	 edx, DWORD PTR _B$[ebp]
  010f5	52		 push	 edx
  010f6	8d 45 fc	 lea	 eax, DWORD PTR _A$[ebp]
  010f9	50		 push	 eax
  010fa	e8 00 00 00 00	 call	 ?DistanceEstimate@@YAHAAUSCI_Point@@0PAH@Z ; DistanceEstimate
  010ff	83 c4 0c	 add	 esp, 12			; 0000000cH
  01102	8b c8		 mov	 ecx, eax
  01104	8b 45 e4	 mov	 eax, DWORD PTR _dot1$[ebp]
  01107	99		 cdq
  01108	f7 f9		 idiv	 ecx
  0110a	89 45 dc	 mov	 DWORD PTR _dot2$[ebp], eax

; 606  :             if (dot2 <0) dot2 = -dot2;

  0110d	83 7d dc 00	 cmp	 DWORD PTR _dot2$[ebp], 0
  01111	7d 08		 jge	 SHORT $L61223
  01113	8b 55 dc	 mov	 edx, DWORD PTR _dot2$[ebp]
  01116	f7 da		 neg	 edx
  01118	89 55 dc	 mov	 DWORD PTR _dot2$[ebp], edx
$L61223:

; 607  :             if (dot2 < d)

  0111b	8b 45 dc	 mov	 eax, DWORD PTR _dot2$[ebp]
  0111e	3b 45 f4	 cmp	 eax, DWORD PTR _d$[ebp]
  01121	0f 8d af 00 00
	00		 jge	 $L61224

; 609  :                d = dot2;

  01127	8b 4d dc	 mov	 ecx, DWORD PTR _dot2$[ebp]
  0112a	89 4d f4	 mov	 DWORD PTR _d$[ebp], ecx

; 610  :                
; 611  :                // R = P + [(N*(A-P))/(N*N)]N
; 612  :                // round to force point exterior to polygon
; 613  :                dot2 = tmp4*tmp4;

  0112d	8d 55 d0	 lea	 edx, DWORD PTR _tmp4$[ebp]
  01130	52		 push	 edx
  01131	8d 4d d0	 lea	 ecx, DWORD PTR _tmp4$[ebp]
  01134	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  01139	89 45 dc	 mov	 DWORD PTR _dot2$[ebp], eax

; 614  :                dot3 = dot1*(int)tmp4.x;

  0113c	0f bf 45 d0	 movsx	 eax, WORD PTR _tmp4$[ebp]
  01140	8b 4d e4	 mov	 ecx, DWORD PTR _dot1$[ebp]
  01143	0f af c8	 imul	 ecx, eax
  01146	89 4d d4	 mov	 DWORD PTR _dot3$[ebp], ecx

; 615  :                R->x = P.x + (int) 
; 616  :                   (
; 617  :                   (
; 618  :                   dot3 + sign(dot3)*(dot2 - 1)
; 619  :                   )
; 620  :                   /dot2
; 621  :                   );

  01149	83 7d d4 00	 cmp	 DWORD PTR _dot3$[ebp], 0
  0114d	7e 09		 jle	 SHORT $L62387
  0114f	c7 45 c0 01 00
	00 00		 mov	 DWORD PTR -64+[ebp], 1
  01156	eb 0d		 jmp	 SHORT $L62388
$L62387:
  01158	33 d2		 xor	 edx, edx
  0115a	83 7d d4 00	 cmp	 DWORD PTR _dot3$[ebp], 0
  0115e	0f 9d c2	 setge	 dl
  01161	4a		 dec	 edx
  01162	89 55 c0	 mov	 DWORD PTR -64+[ebp], edx
$L62388:
  01165	8b 45 08	 mov	 eax, DWORD PTR _P$[ebp]
  01168	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0116b	8b 55 dc	 mov	 edx, DWORD PTR _dot2$[ebp]
  0116e	83 ea 01	 sub	 edx, 1
  01171	8b 45 c0	 mov	 eax, DWORD PTR -64+[ebp]
  01174	0f af c2	 imul	 eax, edx
  01177	8b 55 d4	 mov	 edx, DWORD PTR _dot3$[ebp]
  0117a	03 c2		 add	 eax, edx
  0117c	99		 cdq
  0117d	f7 7d dc	 idiv	 DWORD PTR _dot2$[ebp]
  01180	03 c8		 add	 ecx, eax
  01182	8b 45 14	 mov	 eax, DWORD PTR _R$[ebp]
  01185	66 89 08	 mov	 WORD PTR [eax], cx

; 622  :                dot1 = dot1*(int)tmp4.y;

  01188	0f bf 4d d2	 movsx	 ecx, WORD PTR _tmp4$[ebp+2]
  0118c	8b 55 e4	 mov	 edx, DWORD PTR _dot1$[ebp]
  0118f	0f af d1	 imul	 edx, ecx
  01192	89 55 e4	 mov	 DWORD PTR _dot1$[ebp], edx

; 623  :                R->y = P.y + (int)
; 624  :                   (
; 625  :                   (
; 626  :                   dot1 + sign(dot1)*(dot2 - 1)
; 627  :                   )
; 628  :                   /dot2
; 629  :                   );

  01195	83 7d e4 00	 cmp	 DWORD PTR _dot1$[ebp], 0
  01199	7e 09		 jle	 SHORT $L62389
  0119b	c7 45 bc 01 00
	00 00		 mov	 DWORD PTR -68+[ebp], 1
  011a2	eb 0d		 jmp	 SHORT $L62390
$L62389:
  011a4	33 c0		 xor	 eax, eax
  011a6	83 7d e4 00	 cmp	 DWORD PTR _dot1$[ebp], 0
  011aa	0f 9d c0	 setge	 al
  011ad	48		 dec	 eax
  011ae	89 45 bc	 mov	 DWORD PTR -68+[ebp], eax
$L62390:
  011b1	8b 4d 08	 mov	 ecx, DWORD PTR _P$[ebp]
  011b4	0f bf 49 02	 movsx	 ecx, WORD PTR [ecx+2]
  011b8	8b 55 dc	 mov	 edx, DWORD PTR _dot2$[ebp]
  011bb	83 ea 01	 sub	 edx, 1
  011be	8b 45 bc	 mov	 eax, DWORD PTR -68+[ebp]
  011c1	0f af c2	 imul	 eax, edx
  011c4	8b 55 e4	 mov	 edx, DWORD PTR _dot1$[ebp]
  011c7	03 c2		 add	 eax, edx
  011c9	99		 cdq
  011ca	f7 7d dc	 idiv	 DWORD PTR _dot2$[ebp]
  011cd	03 c8		 add	 ecx, eax
  011cf	8b 45 14	 mov	 eax, DWORD PTR _R$[ebp]
  011d2	66 89 48 02	 mov	 WORD PTR [eax+2], cx
$L61224:

; 632  :          else

  011d6	eb 62		 jmp	 SHORT $L61231
$L61222:

; 634  :             /* P-R is not normal to A-B, for example 
; 635  :           
; 636  :                  P*
; 637  :                    *
; 638  :                     *
; 639  :                      *
; 640  :                       *
; 641  :                        *
; 642  :                       R * A
; 643  :             ***************************
; 644  :                          *
; 645  :                          *
; 646  :                          *
; 647  :                          *
; 648  :                          *
; 649  :                          *
; 650  :                          *
; 651  :                          *
; 652  :                          *
; 653  :                          *
; 654  :                          *
; 655  :                          *
; 656  :                          *
; 657  :                          * 
; 658  :                          *
; 659  :                          *
; 660  :                          * 
; 661  :             ***************************
; 662  :                          B
; 663  :             */
; 664  : 
; 665  :             dot1 = DistanceEstimate(A,P,&offScreen);

  011d8	8d 4d f0	 lea	 ecx, DWORD PTR _offScreen$[ebp]
  011db	51		 push	 ecx
  011dc	8b 55 08	 mov	 edx, DWORD PTR _P$[ebp]
  011df	52		 push	 edx
  011e0	8d 45 fc	 lea	 eax, DWORD PTR _A$[ebp]
  011e3	50		 push	 eax
  011e4	e8 00 00 00 00	 call	 ?DistanceEstimate@@YAHAAUSCI_Point@@0PAH@Z ; DistanceEstimate
  011e9	83 c4 0c	 add	 esp, 12			; 0000000cH
  011ec	89 45 e4	 mov	 DWORD PTR _dot1$[ebp], eax

; 666  :             dot2 = DistanceEstimate(B,P,&offScreen);

  011ef	8d 4d f0	 lea	 ecx, DWORD PTR _offScreen$[ebp]
  011f2	51		 push	 ecx
  011f3	8b 55 08	 mov	 edx, DWORD PTR _P$[ebp]
  011f6	52		 push	 edx
  011f7	8d 45 f8	 lea	 eax, DWORD PTR _B$[ebp]
  011fa	50		 push	 eax
  011fb	e8 00 00 00 00	 call	 ?DistanceEstimate@@YAHAAUSCI_Point@@0PAH@Z ; DistanceEstimate
  01200	83 c4 0c	 add	 esp, 12			; 0000000cH
  01203	89 45 dc	 mov	 DWORD PTR _dot2$[ebp], eax

; 667  :             if (dot1 < d)

  01206	8b 4d e4	 mov	 ecx, DWORD PTR _dot1$[ebp]
  01209	3b 4d f4	 cmp	 ecx, DWORD PTR _d$[ebp]
  0120c	7d 12		 jge	 SHORT $L61230

; 669  :                d = dot1;

  0120e	8b 55 e4	 mov	 edx, DWORD PTR _dot1$[ebp]
  01211	89 55 f4	 mov	 DWORD PTR _d$[ebp], edx

; 670  :                *R = A;

  01214	8d 45 fc	 lea	 eax, DWORD PTR _A$[ebp]
  01217	50		 push	 eax
  01218	8b 4d 14	 mov	 ecx, DWORD PTR _R$[ebp]
  0121b	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=
$L61230:

; 672  :             if (dot2 < d)

  01220	8b 4d dc	 mov	 ecx, DWORD PTR _dot2$[ebp]
  01223	3b 4d f4	 cmp	 ecx, DWORD PTR _d$[ebp]
  01226	7d 12		 jge	 SHORT $L61231

; 674  :                d = dot2;

  01228	8b 55 dc	 mov	 edx, DWORD PTR _dot2$[ebp]
  0122b	89 55 f4	 mov	 DWORD PTR _d$[ebp], edx

; 675  :                *R = B;

  0122e	8d 45 f8	 lea	 eax, DWORD PTR _B$[ebp]
  01231	50		 push	 eax
  01232	8b 4d 14	 mov	 ecx, DWORD PTR _R$[ebp]
  01235	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=
$L61231:

; 679  :       }

  0123a	e9 77 fd ff ff	 jmp	 $L61210
$L61211:

; 680  :    return(d);

  0123f	8b 45 f4	 mov	 eax, DWORD PTR _d$[ebp]

; 681  : }

  01242	8b e5		 mov	 esp, ebp
  01244	5d		 pop	 ebp
  01245	c3		 ret	 0
?NearPoint@@YAHAAUSCI_Point@@PAU1@H1H@Z ENDP		; NearPoint
_TEXT	ENDS
;	COMDAT ??DSCI_Point@@QBEHABU0@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
??DSCI_Point@@QBEHABU0@@Z PROC NEAR			; SCI_Point::operator*, COMDAT

; 234  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 235  :    return ((int)x*(int)p.x+(int)y*(int)p.y);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f bf 00	 movsx	 eax, WORD PTR [eax]
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00010	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00013	0f af c2	 imul	 eax, edx
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00020	0f bf 49 02	 movsx	 ecx, WORD PTR [ecx+2]
  00024	0f af d1	 imul	 edx, ecx
  00027	03 c2		 add	 eax, edx

; 236  : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??DSCI_Point@@QBEHABU0@@Z ENDP				; SCI_Point::operator*
_TEXT	ENDS
PUBLIC	?TestClockwise@@YAHPAUSCI_Point@@H@Z		; TestClockwise
EXTRN	?ATan@@YAHHHHH@Z:NEAR				; ATan
_TEXT	SEGMENT
_Points$ = 8
_n$ = 12
_i$ = -16
_angle$ = -8
_angleStart$ = -12
_angleIn$ = -4
_angleOut$ = -24
_delta$ = -20
?TestClockwise@@YAHPAUSCI_Point@@H@Z PROC NEAR		; TestClockwise

; 685  : {

  01246	55		 push	 ebp
  01247	8b ec		 mov	 ebp, esp
  01249	83 ec 18	 sub	 esp, 24			; 00000018H

; 686  :    int   i;
; 687  :    int   angle = 0;

  0124c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _angle$[ebp], 0

; 688  :    int   angleStart,angleIn,angleOut,delta;
; 689  :    angleStart = ATan(Points[0].x,Points[0].y,Points[1].x,Points[1].y);

  01253	8b 45 08	 mov	 eax, DWORD PTR _Points$[ebp]
  01256	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0125a	51		 push	 ecx
  0125b	8b 55 08	 mov	 edx, DWORD PTR _Points$[ebp]
  0125e	0f bf 42 04	 movsx	 eax, WORD PTR [edx+4]
  01262	50		 push	 eax
  01263	8b 4d 08	 mov	 ecx, DWORD PTR _Points$[ebp]
  01266	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  0126a	52		 push	 edx
  0126b	8b 45 08	 mov	 eax, DWORD PTR _Points$[ebp]
  0126e	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  01271	51		 push	 ecx
  01272	e8 00 00 00 00	 call	 ?ATan@@YAHHHHH@Z	; ATan
  01277	83 c4 10	 add	 esp, 16			; 00000010H
  0127a	89 45 f4	 mov	 DWORD PTR _angleStart$[ebp], eax

; 690  :    angleIn = angleStart;

  0127d	8b 55 f4	 mov	 edx, DWORD PTR _angleStart$[ebp]
  01280	89 55 fc	 mov	 DWORD PTR _angleIn$[ebp], edx

; 691  :    for (i=1;i<n-1;++i)

  01283	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  0128a	eb 09		 jmp	 SHORT $L61242
$L61243:
  0128c	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0128f	83 c0 01	 add	 eax, 1
  01292	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$L61242:
  01295	8b 4d 0c	 mov	 ecx, DWORD PTR _n$[ebp]
  01298	83 e9 01	 sub	 ecx, 1
  0129b	39 4d f0	 cmp	 DWORD PTR _i$[ebp], ecx
  0129e	0f 8d 80 00 00
	00		 jge	 $L61244

; 693  :       angleOut = ATan(Points[i].x,Points[i].y,Points[i+1].x,Points[i+1].y);

  012a4	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  012a7	8b 45 08	 mov	 eax, DWORD PTR _Points$[ebp]
  012aa	0f bf 4c 90 06	 movsx	 ecx, WORD PTR [eax+edx*4+6]
  012af	51		 push	 ecx
  012b0	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  012b3	8b 45 08	 mov	 eax, DWORD PTR _Points$[ebp]
  012b6	0f bf 4c 90 04	 movsx	 ecx, WORD PTR [eax+edx*4+4]
  012bb	51		 push	 ecx
  012bc	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  012bf	8b 45 08	 mov	 eax, DWORD PTR _Points$[ebp]
  012c2	0f bf 4c 90 02	 movsx	 ecx, WORD PTR [eax+edx*4+2]
  012c7	51		 push	 ecx
  012c8	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  012cb	8b 45 08	 mov	 eax, DWORD PTR _Points$[ebp]
  012ce	0f bf 0c 90	 movsx	 ecx, WORD PTR [eax+edx*4]
  012d2	51		 push	 ecx
  012d3	e8 00 00 00 00	 call	 ?ATan@@YAHHHHH@Z	; ATan
  012d8	83 c4 10	 add	 esp, 16			; 00000010H
  012db	89 45 e8	 mov	 DWORD PTR _angleOut$[ebp], eax

; 694  :       delta = angleOut - angleIn;

  012de	8b 55 e8	 mov	 edx, DWORD PTR _angleOut$[ebp]
  012e1	2b 55 fc	 sub	 edx, DWORD PTR _angleIn$[ebp]
  012e4	89 55 ec	 mov	 DWORD PTR _delta$[ebp], edx

; 695  :       if (delta > 180) delta -= 360;

  012e7	81 7d ec b4 00
	00 00		 cmp	 DWORD PTR _delta$[ebp], 180 ; 000000b4H
  012ee	7e 0b		 jle	 SHORT $L61245
  012f0	8b 45 ec	 mov	 eax, DWORD PTR _delta$[ebp]
  012f3	2d 68 01 00 00	 sub	 eax, 360		; 00000168H
  012f8	89 45 ec	 mov	 DWORD PTR _delta$[ebp], eax
$L61245:

; 696  :       if (delta < -180) delta += 360;

  012fb	81 7d ec 4c ff
	ff ff		 cmp	 DWORD PTR _delta$[ebp], -180 ; ffffff4cH
  01302	7d 0c		 jge	 SHORT $L61246
  01304	8b 4d ec	 mov	 ecx, DWORD PTR _delta$[ebp]
  01307	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  0130d	89 4d ec	 mov	 DWORD PTR _delta$[ebp], ecx
$L61246:

; 697  :       angle += delta;

  01310	8b 55 f8	 mov	 edx, DWORD PTR _angle$[ebp]
  01313	03 55 ec	 add	 edx, DWORD PTR _delta$[ebp]
  01316	89 55 f8	 mov	 DWORD PTR _angle$[ebp], edx

; 698  :       angleIn = angleOut;

  01319	8b 45 e8	 mov	 eax, DWORD PTR _angleOut$[ebp]
  0131c	89 45 fc	 mov	 DWORD PTR _angleIn$[ebp], eax

; 699  :       }

  0131f	e9 68 ff ff ff	 jmp	 $L61243
$L61244:

; 700  :    // next nine lines only needed for initial testing
; 701  :    angleOut = ATan(Points[i].x,Points[i].y,Points[0].x,Points[0].y);

  01324	8b 4d 08	 mov	 ecx, DWORD PTR _Points$[ebp]
  01327	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  0132b	52		 push	 edx
  0132c	8b 45 08	 mov	 eax, DWORD PTR _Points$[ebp]
  0132f	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  01332	51		 push	 ecx
  01333	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  01336	8b 45 08	 mov	 eax, DWORD PTR _Points$[ebp]
  01339	0f bf 4c 90 02	 movsx	 ecx, WORD PTR [eax+edx*4+2]
  0133e	51		 push	 ecx
  0133f	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  01342	8b 45 08	 mov	 eax, DWORD PTR _Points$[ebp]
  01345	0f bf 0c 90	 movsx	 ecx, WORD PTR [eax+edx*4]
  01349	51		 push	 ecx
  0134a	e8 00 00 00 00	 call	 ?ATan@@YAHHHHH@Z	; ATan
  0134f	83 c4 10	 add	 esp, 16			; 00000010H
  01352	89 45 e8	 mov	 DWORD PTR _angleOut$[ebp], eax

; 702  :    delta = angleOut - angleIn;

  01355	8b 55 e8	 mov	 edx, DWORD PTR _angleOut$[ebp]
  01358	2b 55 fc	 sub	 edx, DWORD PTR _angleIn$[ebp]
  0135b	89 55 ec	 mov	 DWORD PTR _delta$[ebp], edx

; 703  :    if (delta > 180) delta -= 360;

  0135e	81 7d ec b4 00
	00 00		 cmp	 DWORD PTR _delta$[ebp], 180 ; 000000b4H
  01365	7e 0b		 jle	 SHORT $L61247
  01367	8b 45 ec	 mov	 eax, DWORD PTR _delta$[ebp]
  0136a	2d 68 01 00 00	 sub	 eax, 360		; 00000168H
  0136f	89 45 ec	 mov	 DWORD PTR _delta$[ebp], eax
$L61247:

; 704  :    if (delta < -180) delta += 360;

  01372	81 7d ec 4c ff
	ff ff		 cmp	 DWORD PTR _delta$[ebp], -180 ; ffffff4cH
  01379	7d 0c		 jge	 SHORT $L61248
  0137b	8b 4d ec	 mov	 ecx, DWORD PTR _delta$[ebp]
  0137e	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  01384	89 4d ec	 mov	 DWORD PTR _delta$[ebp], ecx
$L61248:

; 705  :    angle += delta;

  01387	8b 55 f8	 mov	 edx, DWORD PTR _angle$[ebp]
  0138a	03 55 ec	 add	 edx, DWORD PTR _delta$[ebp]
  0138d	89 55 f8	 mov	 DWORD PTR _angle$[ebp], edx

; 706  :    delta = angleStart - angleOut;

  01390	8b 45 f4	 mov	 eax, DWORD PTR _angleStart$[ebp]
  01393	2b 45 e8	 sub	 eax, DWORD PTR _angleOut$[ebp]
  01396	89 45 ec	 mov	 DWORD PTR _delta$[ebp], eax

; 707  :    if (delta > 180) delta -= 360;

  01399	81 7d ec b4 00
	00 00		 cmp	 DWORD PTR _delta$[ebp], 180 ; 000000b4H
  013a0	7e 0c		 jle	 SHORT $L61249
  013a2	8b 4d ec	 mov	 ecx, DWORD PTR _delta$[ebp]
  013a5	81 e9 68 01 00
	00		 sub	 ecx, 360		; 00000168H
  013ab	89 4d ec	 mov	 DWORD PTR _delta$[ebp], ecx
$L61249:

; 708  :    if (delta < -180) delta += 360;

  013ae	81 7d ec 4c ff
	ff ff		 cmp	 DWORD PTR _delta$[ebp], -180 ; ffffff4cH
  013b5	7d 0c		 jge	 SHORT $L61250
  013b7	8b 55 ec	 mov	 edx, DWORD PTR _delta$[ebp]
  013ba	81 c2 68 01 00
	00		 add	 edx, 360		; 00000168H
  013c0	89 55 ec	 mov	 DWORD PTR _delta$[ebp], edx
$L61250:

; 709  :    angle += delta;

  013c3	8b 45 f8	 mov	 eax, DWORD PTR _angle$[ebp]
  013c6	03 45 ec	 add	 eax, DWORD PTR _delta$[ebp]
  013c9	89 45 f8	 mov	 DWORD PTR _angle$[ebp], eax

; 710  :    // at this point if previous nine lines
; 711  :    // are compiled then angle = +-360
; 712  :    return(angle);

  013cc	8b 45 f8	 mov	 eax, DWORD PTR _angle$[ebp]

; 713  : }

  013cf	8b e5		 mov	 esp, ebp
  013d1	5d		 pop	 ebp
  013d2	c3		 ret	 0
?TestClockwise@@YAHPAUSCI_Point@@H@Z ENDP		; TestClockwise
_TEXT	ENDS
PUBLIC	?AvoidPolygons@@YAPAVPolyNode@@AAUSCI_Point@@0PAVSOL_Polygon@@@Z ; AvoidPolygons
PUBLIC	?FreeNodePath@@YAXPAVPolyNode@@@Z		; FreeNodePath
PUBLIC	?GetPolyDirections@@YAHPAVPolyNode@@@Z		; GetPolyDirections
PUBLIC	?GetPolyDistance@@YAHPAUSCI_Point@@@Z		; GetPolyDistance
PUBLIC	?OptimizePath@@YAXAAUSCI_Point@@0PAU1@PAVPolyNode@@PAVSOL_Polygon@@H@Z ; OptimizePath
PUBLIC	?ReducePolygonList@@YAXPAVSOL_Polygon@@PAVPolyNode@@@Z ; ReducePolygonList
PUBLIC	?SetPolyDirections@@YAXPAVPolyNode@@HH@Z	; SetPolyDirections
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	?Fatal@MsgMgr@@QAAXDPADHHZZ:NEAR		; MsgMgr::Fatal
EXTRN	?msgMgr@@3PAVMsgMgr@@A:DWORD			; msgMgr
_DATA	SEGMENT
$SG61276 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Poly'
	DB	'gon.cpp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_A$ = 8
_B$ = 12
_polylist$ = 16
_opt$ = 20
_path$ = 24
_i$ = -24
_j$ = -28
_startPath$ = -1240
_nodePath$ = -16
_polygonNodePath$ = -1236
_dupPolyList$ = -1232
_totalNodes$ = -20
_polyDirections$ = -12
_firstPolyDirection$ = -1244
_bestPolyDirection$ = -8
_polyDistance$ = -32
_bestPolyDistance$ = -4
$T62394 = -1248
?AvoidPath@@YAXAAUSCI_Point@@0PAVSOL_Polygon@@HPAU1@@Z PROC NEAR ; AvoidPath

; 796  : {

  013d3	55		 push	 ebp
  013d4	8b ec		 mov	 ebp, esp
  013d6	81 ec e0 04 00
	00		 sub	 esp, 1248		; 000004e0H
  013dc	56		 push	 esi

; 797  :    int         i = -1,j = -1;

  013dd	c7 45 e8 ff ff
	ff ff		 mov	 DWORD PTR _i$[ebp], -1
  013e4	c7 45 e4 ff ff
	ff ff		 mov	 DWORD PTR _j$[ebp], -1

; 798  :    SCI_Point   startPath;

  013eb	8d 8d 28 fb ff
	ff		 lea	 ecx, DWORD PTR _startPath$[ebp]
  013f1	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point

; 799  :    PolyNode*   nodePath;
; 800  :    PolyNode*   polygonNodePath;
; 801  : 	SOL_Polygon dupPolyList[MAXPOLYGONS];
; 802  :    int         totalNodes = 0;

  013f6	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _totalNodes$[ebp], 0

; 803  :    int         polyDirections,firstPolyDirection,bestPolyDirection;
; 804  :    int         polyDistance,bestPolyDistance;
; 805  : 
; 806  :    nodePath = 0;

  013fd	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _nodePath$[ebp], 0

; 807  :    // duplicate polylist so that we can eliminate polygons while
; 808  :    // creating unoptimized path yet still retain original polylist
; 809  :    // for optimization pass.
; 810  : 
; 811  :    startPath = A;

  01404	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  01407	50		 push	 eax
  01408	8d 8d 28 fb ff
	ff		 lea	 ecx, DWORD PTR _startPath$[ebp]
  0140e	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=
$L61270:

; 815  :       ++i; ++j;

  01413	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  01416	83 c1 01	 add	 ecx, 1
  01419	89 4d e8	 mov	 DWORD PTR _i$[ebp], ecx
  0141c	8b 55 e4	 mov	 edx, DWORD PTR _j$[ebp]
  0141f	83 c2 01	 add	 edx, 1
  01422	89 55 e4	 mov	 DWORD PTR _j$[ebp], edx

; 816  :       if (polylist[i].type >= MERGED) 

  01425	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  01428	6b c0 0c	 imul	 eax, 12			; 0000000cH
  0142b	8b 4d 10	 mov	 ecx, DWORD PTR _polylist$[ebp]
  0142e	33 d2		 xor	 edx, edx
  01430	8a 54 01 04	 mov	 dl, BYTE PTR [ecx+eax+4]
  01434	83 fa 04	 cmp	 edx, 4
  01437	7c 0b		 jl	 SHORT $L61273

; 817  :          --j;

  01439	8b 45 e4	 mov	 eax, DWORD PTR _j$[ebp]
  0143c	83 e8 01	 sub	 eax, 1
  0143f	89 45 e4	 mov	 DWORD PTR _j$[ebp], eax

; 818  :       else

  01442	eb 28		 jmp	 SHORT $L61274
$L61273:

; 819  :           dupPolyList[j] = polylist[i];

  01444	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  01447	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  0144a	8b 55 10	 mov	 edx, DWORD PTR _polylist$[ebp]
  0144d	03 d1		 add	 edx, ecx
  0144f	8b 45 e4	 mov	 eax, DWORD PTR _j$[ebp]
  01452	6b c0 0c	 imul	 eax, 12			; 0000000cH
  01455	8d 8c 05 30 fb
	ff ff		 lea	 ecx, DWORD PTR _dupPolyList$[ebp+eax]
  0145c	8b 02		 mov	 eax, DWORD PTR [edx]
  0145e	89 01		 mov	 DWORD PTR [ecx], eax
  01460	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01463	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  01466	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  01469	89 51 08	 mov	 DWORD PTR [ecx+8], edx
$L61274:

; 821  :    while (polylist[i].n != 0);

  0146c	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  0146f	6b c0 0c	 imul	 eax, 12			; 0000000cH
  01472	8b 4d 10	 mov	 ecx, DWORD PTR _polylist$[ebp]
  01475	83 7c 01 08 00	 cmp	 DWORD PTR [ecx+eax+8], 0
  0147a	75 97		 jne	 SHORT $L61270

; 822  : 
; 823  :    if (j > MAXPOLYGONS) 

  0147c	83 7d e4 64	 cmp	 DWORD PTR _j$[ebp], 100	; 00000064H
  01480	7e 1d		 jle	 SHORT $L61275

; 824  : 		msgMgr->Fatal(SrcLoc,Msg_TooManyPolygons);

  01482	6a 73		 push	 115			; 00000073H
  01484	68 38 03 00 00	 push	 824			; 00000338H
  01489	68 00 00 00 00	 push	 OFFSET FLAT:$SG61276
  0148e	6a 61		 push	 97			; 00000061H
  01490	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  01496	52		 push	 edx
  01497	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXDPADHHZZ ; MsgMgr::Fatal
  0149c	83 c4 14	 add	 esp, 20			; 00000014H
$L61275:

; 825  : 
; 826  :    while (polygonNodePath = AvoidPolygons(startPath,B,dupPolyList))

  0149f	8d 85 30 fb ff
	ff		 lea	 eax, DWORD PTR _dupPolyList$[ebp]
  014a5	50		 push	 eax
  014a6	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  014a9	51		 push	 ecx
  014aa	8d 95 28 fb ff
	ff		 lea	 edx, DWORD PTR _startPath$[ebp]
  014b0	52		 push	 edx
  014b1	e8 00 00 00 00	 call	 ?AvoidPolygons@@YAPAVPolyNode@@AAUSCI_Point@@0PAVSOL_Polygon@@@Z ; AvoidPolygons
  014b6	83 c4 0c	 add	 esp, 12			; 0000000cH
  014b9	89 85 2c fb ff
	ff		 mov	 DWORD PTR _polygonNodePath$[ebp], eax
  014bf	83 bd 2c fb ff
	ff 00		 cmp	 DWORD PTR _polygonNodePath$[ebp], 0
  014c6	0f 84 b7 00 00
	00		 je	 $L61279

; 828  :       if (polygonNodePath->d == 2)

  014cc	8b 85 2c fb ff
	ff		 mov	 eax, DWORD PTR _polygonNodePath$[ebp]
  014d2	83 78 10 02	 cmp	 DWORD PTR [eax+16], 2
  014d6	75 2f		 jne	 SHORT $L61280

; 830  :          // The obstructing polygon acts as a barrier and can 
; 831  :          // not be transversed.
; 832  :          // We will only go to the direct edge.
; 833  : 
; 834  :          // Calculate a new B point if a polygon acts as a barrier
; 835  :          // A polygon is a barrier if the sides lie along plane borders
; 836  :          // and close off part of the plane and A and B lie on disjoint
; 837  :          // (relative to the polygon) parts of the plane.
; 838  : 
; 839  :          /*
; 840  :          ******************************************************************
; 841  :          *                       *            *                           *
; 842  :          *                       *             *                          *
; 843  :          *                       *              *                         *
; 844  :          *       A               *               *                        *
; 845  :          *        \              *                *                       *
; 846  :          *         \             *                 *                      *
; 847  :          *          \X           *                  *                     *
; 848  :          *       ****\************                   *                    *
; 849  :          *      *     \                               *                   *
; 850  :          *     *       \                                *                 *
; 851  :          *    *         \                                *                *
; 852  :          *   *           \                                *               *
; 853  :          ****             \                                *              *
; 854  :          *                 \                               *              *
; 855  :          *           polygon\                              *              *
; 856  :          *                   \                             *              *
; 857  :          *                    \                            *              *
; 858  :          *                     \                           *              *
; 859  :          *                      \                          *              *
; 860  :          *                       \                         *              *
; 861  :          *          **************\*************************              *
; 862  :          *          *              \                                      *
; 863  :          *          *               \                                     *
; 864  :          *          *                \                                    *
; 865  :          *          *                 B                                   *
; 866  :          *          *                                                     *
; 867  :          *          *                                                     *
; 868  :          ******************************************************************
; 869  : 
; 870  :          In this case the polygon acts as a barrier to getting from A to B
; 871  :          The proper point to go to is X
; 872  :          */
; 873  : 		 
; 874  :          B = polygonNodePath->I1;

  014d8	8b 8d 2c fb ff
	ff		 mov	 ecx, DWORD PTR _polygonNodePath$[ebp]
  014de	83 c1 08	 add	 ecx, 8
  014e1	51		 push	 ecx
  014e2	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  014e5	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 875  :          delete polygonNodePath;

  014ea	8b 95 2c fb ff
	ff		 mov	 edx, DWORD PTR _polygonNodePath$[ebp]
  014f0	89 95 20 fb ff
	ff		 mov	 DWORD PTR $T62394[ebp], edx
  014f6	8b 85 20 fb ff
	ff		 mov	 eax, DWORD PTR $T62394[ebp]
  014fc	50		 push	 eax
  014fd	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  01502	83 c4 04	 add	 esp, 4

; 876  :          break;

  01505	eb 7c		 jmp	 SHORT $L61279
$L61280:

; 878  : 
; 879  :       ++totalNodes;

  01507	8b 4d ec	 mov	 ecx, DWORD PTR _totalNodes$[ebp]
  0150a	83 c1 01	 add	 ecx, 1
  0150d	89 4d ec	 mov	 DWORD PTR _totalNodes$[ebp], ecx

; 880  :       // add first node in polygonNodePath to nodePath
; 881  :       // note that nodePath points to last node until path complete.
; 882  :       if (nodePath)

  01510	83 7d f0 00	 cmp	 DWORD PTR _nodePath$[ebp], 0
  01514	74 17		 je	 SHORT $L61282

; 884  :          nodePath->next = polygonNodePath;

  01516	8b 55 f0	 mov	 edx, DWORD PTR _nodePath$[ebp]
  01519	8b 85 2c fb ff
	ff		 mov	 eax, DWORD PTR _polygonNodePath$[ebp]
  0151f	89 02		 mov	 DWORD PTR [edx], eax

; 885  :          polygonNodePath->prev = nodePath;

  01521	8b 8d 2c fb ff
	ff		 mov	 ecx, DWORD PTR _polygonNodePath$[ebp]
  01527	8b 55 f0	 mov	 edx, DWORD PTR _nodePath$[ebp]
  0152a	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$L61282:

; 887  :       // free any unused nodes
; 888  : 		FreeNodePath(polygonNodePath->next);

  0152d	8b 85 2c fb ff
	ff		 mov	 eax, DWORD PTR _polygonNodePath$[ebp]
  01533	8b 08		 mov	 ecx, DWORD PTR [eax]
  01535	51		 push	 ecx
  01536	e8 00 00 00 00	 call	 ?FreeNodePath@@YAXPAVPolyNode@@@Z ; FreeNodePath
  0153b	83 c4 04	 add	 esp, 4

; 889  :       polygonNodePath->next = 0;

  0153e	8b 95 2c fb ff
	ff		 mov	 edx, DWORD PTR _polygonNodePath$[ebp]
  01544	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 890  :       nodePath = polygonNodePath;

  0154a	8b 85 2c fb ff
	ff		 mov	 eax, DWORD PTR _polygonNodePath$[ebp]
  01550	89 45 f0	 mov	 DWORD PTR _nodePath$[ebp], eax

; 891  :       startPath = polygonNodePath->I2;

  01553	8b 8d 2c fb ff
	ff		 mov	 ecx, DWORD PTR _polygonNodePath$[ebp]
  01559	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0155c	51		 push	 ecx
  0155d	8d 8d 28 fb ff
	ff		 lea	 ecx, DWORD PTR _startPath$[ebp]
  01563	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 892  : 
; 893  : 
; 894  :       // Now reduce list of polygons to only those which can interfere
; 895  :       // with the path starting from the exit of the first polygon and
; 896  :       // going to the point B. We only generate a path around the first
; 897  :       // encountered polygon and then recurse to generate a path around
; 898  :       // the next etc. until there are no more polygons in the way.
; 899  :       
; 900  :       ReducePolygonList(dupPolyList,polygonNodePath);

  01568	8b 95 2c fb ff
	ff		 mov	 edx, DWORD PTR _polygonNodePath$[ebp]
  0156e	52		 push	 edx
  0156f	8d 85 30 fb ff
	ff		 lea	 eax, DWORD PTR _dupPolyList$[ebp]
  01575	50		 push	 eax
  01576	e8 00 00 00 00	 call	 ?ReducePolygonList@@YAXPAVSOL_Polygon@@PAVPolyNode@@@Z ; ReducePolygonList
  0157b	83 c4 08	 add	 esp, 8

; 901  :       }

  0157e	e9 1c ff ff ff	 jmp	 $L61275
$L61279:

; 902  : 
; 903  :    // set nodePath to point to the first node
; 904  :    if (nodePath)

  01583	83 7d f0 00	 cmp	 DWORD PTR _nodePath$[ebp], 0
  01587	74 14		 je	 SHORT $L61286
$L61285:

; 906  :       while (nodePath->prev != 0)

  01589	8b 4d f0	 mov	 ecx, DWORD PTR _nodePath$[ebp]
  0158c	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  01590	74 0b		 je	 SHORT $L61286

; 908  :          nodePath = nodePath->prev;

  01592	8b 55 f0	 mov	 edx, DWORD PTR _nodePath$[ebp]
  01595	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01598	89 45 f0	 mov	 DWORD PTR _nodePath$[ebp], eax

; 909  :          }

  0159b	eb ec		 jmp	 SHORT $L61285
$L61286:

; 911  : 
; 912  :    // Now chain together the paths around the polygons
; 913  :    // and optimize out any unnecessary line segments.
; 914  :    if ((opt>1) && (totalNodes > 1))

  0159d	83 7d 14 01	 cmp	 DWORD PTR _opt$[ebp], 1
  015a1	0f 8e ff 00 00
	00		 jle	 $L61287
  015a7	83 7d ec 01	 cmp	 DWORD PTR _totalNodes$[ebp], 1
  015ab	0f 8e f5 00 00
	00		 jle	 $L61287

; 916  :       // Optimize as much as possible to the level 2**n.
; 917  :       // Set up current path directions and try to improve
; 918  :       // on the total distance from A to B.
; 919  :       if(totalNodes > MAXOPTIMIZEDNODES) totalNodes = MAXOPTIMIZEDNODES;

  015b1	83 7d ec 03	 cmp	 DWORD PTR _totalNodes$[ebp], 3
  015b5	7e 07		 jle	 SHORT $L61288
  015b7	c7 45 ec 03 00
	00 00		 mov	 DWORD PTR _totalNodes$[ebp], 3
$L61288:

; 920  :       polyDirections = GetPolyDirections(nodePath) % (1<<totalNodes);

  015be	8b 4d f0	 mov	 ecx, DWORD PTR _nodePath$[ebp]
  015c1	51		 push	 ecx
  015c2	e8 00 00 00 00	 call	 ?GetPolyDirections@@YAHPAVPolyNode@@@Z ; GetPolyDirections
  015c7	83 c4 04	 add	 esp, 4
  015ca	be 01 00 00 00	 mov	 esi, 1
  015cf	8b 4d ec	 mov	 ecx, DWORD PTR _totalNodes$[ebp]
  015d2	d3 e6		 shl	 esi, cl
  015d4	99		 cdq
  015d5	f7 fe		 idiv	 esi
  015d7	89 55 f4	 mov	 DWORD PTR _polyDirections$[ebp], edx

; 921  :       bestPolyDirection = polyDirections;

  015da	8b 55 f4	 mov	 edx, DWORD PTR _polyDirections$[ebp]
  015dd	89 55 f8	 mov	 DWORD PTR _bestPolyDirection$[ebp], edx

; 922  :       firstPolyDirection = polyDirections;

  015e0	8b 45 f4	 mov	 eax, DWORD PTR _polyDirections$[ebp]
  015e3	89 85 24 fb ff
	ff		 mov	 DWORD PTR _firstPolyDirection$[ebp], eax

; 923  :       OptimizePath(A,B,path,nodePath,polylist,opt);

  015e9	8b 4d 14	 mov	 ecx, DWORD PTR _opt$[ebp]
  015ec	51		 push	 ecx
  015ed	8b 55 10	 mov	 edx, DWORD PTR _polylist$[ebp]
  015f0	52		 push	 edx
  015f1	8b 45 f0	 mov	 eax, DWORD PTR _nodePath$[ebp]
  015f4	50		 push	 eax
  015f5	8b 4d 18	 mov	 ecx, DWORD PTR _path$[ebp]
  015f8	51		 push	 ecx
  015f9	8b 55 0c	 mov	 edx, DWORD PTR _B$[ebp]
  015fc	52		 push	 edx
  015fd	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  01600	50		 push	 eax
  01601	e8 00 00 00 00	 call	 ?OptimizePath@@YAXAAUSCI_Point@@0PAU1@PAVPolyNode@@PAVSOL_Polygon@@H@Z ; OptimizePath
  01606	83 c4 18	 add	 esp, 24			; 00000018H

; 924  :       bestPolyDistance = GetPolyDistance(path);

  01609	8b 4d 18	 mov	 ecx, DWORD PTR _path$[ebp]
  0160c	51		 push	 ecx
  0160d	e8 00 00 00 00	 call	 ?GetPolyDistance@@YAHPAUSCI_Point@@@Z ; GetPolyDistance
  01612	83 c4 04	 add	 esp, 4
  01615	89 45 fc	 mov	 DWORD PTR _bestPolyDistance$[ebp], eax
$L61290:

; 925  :       while (firstPolyDirection != (polyDirections = (polyDirections + 1) % (1<<totalNodes)))

  01618	8b 45 f4	 mov	 eax, DWORD PTR _polyDirections$[ebp]
  0161b	83 c0 01	 add	 eax, 1
  0161e	be 01 00 00 00	 mov	 esi, 1
  01623	8b 4d ec	 mov	 ecx, DWORD PTR _totalNodes$[ebp]
  01626	d3 e6		 shl	 esi, cl
  01628	99		 cdq
  01629	f7 fe		 idiv	 esi
  0162b	89 55 f4	 mov	 DWORD PTR _polyDirections$[ebp], edx
  0162e	8b 95 24 fb ff
	ff		 mov	 edx, DWORD PTR _firstPolyDirection$[ebp]
  01634	3b 55 f4	 cmp	 edx, DWORD PTR _polyDirections$[ebp]
  01637	74 59		 je	 SHORT $L61291

; 927  :          SetPolyDirections(nodePath,polyDirections,totalNodes);

  01639	8b 45 ec	 mov	 eax, DWORD PTR _totalNodes$[ebp]
  0163c	50		 push	 eax
  0163d	8b 4d f4	 mov	 ecx, DWORD PTR _polyDirections$[ebp]
  01640	51		 push	 ecx
  01641	8b 55 f0	 mov	 edx, DWORD PTR _nodePath$[ebp]
  01644	52		 push	 edx
  01645	e8 00 00 00 00	 call	 ?SetPolyDirections@@YAXPAVPolyNode@@HH@Z ; SetPolyDirections
  0164a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 928  :          OptimizePath(A,B,path,nodePath,polylist,opt);

  0164d	8b 45 14	 mov	 eax, DWORD PTR _opt$[ebp]
  01650	50		 push	 eax
  01651	8b 4d 10	 mov	 ecx, DWORD PTR _polylist$[ebp]
  01654	51		 push	 ecx
  01655	8b 55 f0	 mov	 edx, DWORD PTR _nodePath$[ebp]
  01658	52		 push	 edx
  01659	8b 45 18	 mov	 eax, DWORD PTR _path$[ebp]
  0165c	50		 push	 eax
  0165d	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  01660	51		 push	 ecx
  01661	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  01664	52		 push	 edx
  01665	e8 00 00 00 00	 call	 ?OptimizePath@@YAXAAUSCI_Point@@0PAU1@PAVPolyNode@@PAVSOL_Polygon@@H@Z ; OptimizePath
  0166a	83 c4 18	 add	 esp, 24			; 00000018H

; 929  :          polyDistance = GetPolyDistance(path);

  0166d	8b 45 18	 mov	 eax, DWORD PTR _path$[ebp]
  01670	50		 push	 eax
  01671	e8 00 00 00 00	 call	 ?GetPolyDistance@@YAHPAUSCI_Point@@@Z ; GetPolyDistance
  01676	83 c4 04	 add	 esp, 4
  01679	89 45 e0	 mov	 DWORD PTR _polyDistance$[ebp], eax

; 930  :          if (bestPolyDistance > polyDistance)

  0167c	8b 4d fc	 mov	 ecx, DWORD PTR _bestPolyDistance$[ebp]
  0167f	3b 4d e0	 cmp	 ecx, DWORD PTR _polyDistance$[ebp]
  01682	7e 0c		 jle	 SHORT $L61292

; 932  :             bestPolyDirection = polyDirections;

  01684	8b 55 f4	 mov	 edx, DWORD PTR _polyDirections$[ebp]
  01687	89 55 f8	 mov	 DWORD PTR _bestPolyDirection$[ebp], edx

; 933  :             bestPolyDistance = polyDistance;

  0168a	8b 45 e0	 mov	 eax, DWORD PTR _polyDistance$[ebp]
  0168d	89 45 fc	 mov	 DWORD PTR _bestPolyDistance$[ebp], eax
$L61292:

; 935  :          }

  01690	eb 86		 jmp	 SHORT $L61290
$L61291:

; 936  :       SetPolyDirections(nodePath,bestPolyDirection,totalNodes);

  01692	8b 4d ec	 mov	 ecx, DWORD PTR _totalNodes$[ebp]
  01695	51		 push	 ecx
  01696	8b 55 f8	 mov	 edx, DWORD PTR _bestPolyDirection$[ebp]
  01699	52		 push	 edx
  0169a	8b 45 f0	 mov	 eax, DWORD PTR _nodePath$[ebp]
  0169d	50		 push	 eax
  0169e	e8 00 00 00 00	 call	 ?SetPolyDirections@@YAXPAVPolyNode@@HH@Z ; SetPolyDirections
  016a3	83 c4 0c	 add	 esp, 12			; 0000000cH
$L61287:

; 938  :    OptimizePath(A,B,path,nodePath,polylist,opt);

  016a6	8b 4d 14	 mov	 ecx, DWORD PTR _opt$[ebp]
  016a9	51		 push	 ecx
  016aa	8b 55 10	 mov	 edx, DWORD PTR _polylist$[ebp]
  016ad	52		 push	 edx
  016ae	8b 45 f0	 mov	 eax, DWORD PTR _nodePath$[ebp]
  016b1	50		 push	 eax
  016b2	8b 4d 18	 mov	 ecx, DWORD PTR _path$[ebp]
  016b5	51		 push	 ecx
  016b6	8b 55 0c	 mov	 edx, DWORD PTR _B$[ebp]
  016b9	52		 push	 edx
  016ba	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  016bd	50		 push	 eax
  016be	e8 00 00 00 00	 call	 ?OptimizePath@@YAXAAUSCI_Point@@0PAU1@PAVPolyNode@@PAVSOL_Polygon@@H@Z ; OptimizePath
  016c3	83 c4 18	 add	 esp, 24			; 00000018H

; 939  :    FreeNodePath(nodePath);

  016c6	8b 4d f0	 mov	 ecx, DWORD PTR _nodePath$[ebp]
  016c9	51		 push	 ecx
  016ca	e8 00 00 00 00	 call	 ?FreeNodePath@@YAXPAVPolyNode@@@Z ; FreeNodePath
  016cf	83 c4 04	 add	 esp, 4

; 940  : 
; 941  :    return;
; 942  : }

  016d2	5e		 pop	 esi
  016d3	8b e5		 mov	 esp, ebp
  016d5	5d		 pop	 ebp
  016d6	c3		 ret	 0
?AvoidPath@@YAXAAUSCI_Point@@0PAVSOL_Polygon@@HPAU1@@Z ENDP ; AvoidPath
_nodePath$ = 8
_node$ = -4
_tmp$ = -8
$T62396 = -12
?FreeNodePath@@YAXPAVPolyNode@@@Z PROC NEAR		; FreeNodePath

; 946  : {

  016d7	55		 push	 ebp
  016d8	8b ec		 mov	 ebp, esp
  016da	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 947  :    PolyNode*   node;
; 948  :    PolyNode*   tmp;
; 949  :    for (node=nodePath;node != 0;)

  016dd	8b 45 08	 mov	 eax, DWORD PTR _nodePath$[ebp]
  016e0	89 45 fc	 mov	 DWORD PTR _node$[ebp], eax
$L61299:
  016e3	83 7d fc 00	 cmp	 DWORD PTR _node$[ebp], 0
  016e7	74 22		 je	 SHORT $L61300

; 951  :       tmp = node->next;

  016e9	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  016ec	8b 11		 mov	 edx, DWORD PTR [ecx]
  016ee	89 55 f8	 mov	 DWORD PTR _tmp$[ebp], edx

; 952  :       delete node;

  016f1	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  016f4	89 45 f4	 mov	 DWORD PTR $T62396[ebp], eax
  016f7	8b 4d f4	 mov	 ecx, DWORD PTR $T62396[ebp]
  016fa	51		 push	 ecx
  016fb	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  01700	83 c4 04	 add	 esp, 4

; 953  :       node=tmp;

  01703	8b 55 f8	 mov	 edx, DWORD PTR _tmp$[ebp]
  01706	89 55 fc	 mov	 DWORD PTR _node$[ebp], edx

; 954  :       }

  01709	eb d8		 jmp	 SHORT $L61299
$L61300:

; 955  : }

  0170b	8b e5		 mov	 esp, ebp
  0170d	5d		 pop	 ebp
  0170e	c3		 ret	 0
?FreeNodePath@@YAXPAVPolyNode@@@Z ENDP			; FreeNodePath
_TEXT	ENDS
PUBLIC	??9SCI_Point@@QBEHABU0@@Z			; SCI_Point::operator!=
PUBLIC	??0PolyNode@@QAE@USCI_Point@@0HHHPAU1@H@Z	; PolyNode::PolyNode
PUBLIC	?PolygonPath@@YAHAAUSCI_Point@@0PAU1@H11PAH2@Z	; PolygonPath
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	_abs:NEAR
xdata$x	SEGMENT
$T62406	DD	019930520H
	DD	01H
	DD	FLAT:$T62408
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T62408	DD	0ffffffffH
	DD	FLAT:$L62404
xdata$x	ENDS
_TEXT	SEGMENT
_A$ = 8
_B$ = 12
_polylist$ = 16
_n1$ = -48
_n2$ = -20
_i$ = -40
_direction$ = -32
_I1$ = -36
_I2$ = -44
_node$ = -16
_newNode$ = -28
_nodePath$ = -24
$T62398 = -52
$T62399 = -56
$T62400 = -60
$T62401 = -64
__$EHRec$ = -12
?AvoidPolygons@@YAPAVPolyNode@@AAUSCI_Point@@0PAVSOL_Polygon@@@Z PROC NEAR ; AvoidPolygons

; 959  : {

  0170f	55		 push	 ebp
  01710	8b ec		 mov	 ebp, esp
  01712	6a ff		 push	 -1
  01714	68 00 00 00 00	 push	 $L62407
  01719	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0171f	50		 push	 eax
  01720	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  01727	83 ec 38	 sub	 esp, 56			; 00000038H
  0172a	56		 push	 esi

; 960  :    int         n1,n2,i;
; 961  :    int         direction;
; 962  :    SCI_Point   I1,I2;

  0172b	8d 4d dc	 lea	 ecx, DWORD PTR _I1$[ebp]
  0172e	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  01733	8d 4d d4	 lea	 ecx, DWORD PTR _I2$[ebp]
  01736	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point

; 963  :    PolyNode*   node;
; 964  :    PolyNode*   newNode;
; 965  :    PolyNode*   nodePath;
; 966  : 
; 967  :    nodePath = 0;

  0173b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _nodePath$[ebp], 0

; 968  :    if (A != B)

  01742	8b 45 0c	 mov	 eax, DWORD PTR _B$[ebp]
  01745	50		 push	 eax
  01746	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  01749	e8 00 00 00 00	 call	 ??9SCI_Point@@QBEHABU0@@Z ; SCI_Point::operator!=
  0174e	85 c0		 test	 eax, eax
  01750	0f 84 1b 02 00
	00		 je	 $L61319

; 970  :       for (i=0;polylist[i].n != 0;++i)

  01756	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0175d	eb 09		 jmp	 SHORT $L61317
$L61318:
  0175f	8b 4d d8	 mov	 ecx, DWORD PTR _i$[ebp]
  01762	83 c1 01	 add	 ecx, 1
  01765	89 4d d8	 mov	 DWORD PTR _i$[ebp], ecx
$L61317:
  01768	8b 55 d8	 mov	 edx, DWORD PTR _i$[ebp]
  0176b	6b d2 0c	 imul	 edx, 12			; 0000000cH
  0176e	8b 45 10	 mov	 eax, DWORD PTR _polylist$[ebp]
  01771	83 7c 10 08 00	 cmp	 DWORD PTR [eax+edx+8], 0
  01776	0f 84 f5 01 00
	00		 je	 $L61319

; 972  :          if (direction = PolygonPath(A,B,polylist[i].polyPoints,polylist[i].n,&I1,&I2,&n1,&n2))

  0177c	8d 4d ec	 lea	 ecx, DWORD PTR _n2$[ebp]
  0177f	51		 push	 ecx
  01780	8d 55 d0	 lea	 edx, DWORD PTR _n1$[ebp]
  01783	52		 push	 edx
  01784	8d 45 d4	 lea	 eax, DWORD PTR _I2$[ebp]
  01787	50		 push	 eax
  01788	8d 4d dc	 lea	 ecx, DWORD PTR _I1$[ebp]
  0178b	51		 push	 ecx
  0178c	8b 55 d8	 mov	 edx, DWORD PTR _i$[ebp]
  0178f	6b d2 0c	 imul	 edx, 12			; 0000000cH
  01792	8b 45 10	 mov	 eax, DWORD PTR _polylist$[ebp]
  01795	8b 4c 10 08	 mov	 ecx, DWORD PTR [eax+edx+8]
  01799	51		 push	 ecx
  0179a	8b 55 d8	 mov	 edx, DWORD PTR _i$[ebp]
  0179d	6b d2 0c	 imul	 edx, 12			; 0000000cH
  017a0	8b 45 10	 mov	 eax, DWORD PTR _polylist$[ebp]
  017a3	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  017a6	51		 push	 ecx
  017a7	8b 55 0c	 mov	 edx, DWORD PTR _B$[ebp]
  017aa	52		 push	 edx
  017ab	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  017ae	50		 push	 eax
  017af	e8 00 00 00 00	 call	 ?PolygonPath@@YAHAAUSCI_Point@@0PAU1@H11PAH2@Z ; PolygonPath
  017b4	83 c4 20	 add	 esp, 32			; 00000020H
  017b7	89 45 e0	 mov	 DWORD PTR _direction$[ebp], eax
  017ba	83 7d e0 00	 cmp	 DWORD PTR _direction$[ebp], 0
  017be	0f 84 a8 01 00
	00		 je	 $L61338

; 974  :             // this polygon is an obstruction, create path node
; 975  : 
; 976  :             newNode = New PolyNode(I1,
; 977  :                                    I2,
; 978  :                                    direction,
; 979  :                                    n1,
; 980  :                                    n2,
; 981  :                                    polylist[i].polyPoints,
; 982  :                                    polylist[i].n);

  017c4	6a 28		 push	 40			; 00000028H
  017c6	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  017cb	83 c4 04	 add	 esp, 4
  017ce	89 45 c8	 mov	 DWORD PTR $T62399[ebp], eax
  017d1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  017d8	83 7d c8 00	 cmp	 DWORD PTR $T62399[ebp], 0
  017dc	74 52		 je	 SHORT $L62402
  017de	8b 4d d8	 mov	 ecx, DWORD PTR _i$[ebp]
  017e1	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  017e4	8b 55 10	 mov	 edx, DWORD PTR _polylist$[ebp]
  017e7	8b 44 0a 08	 mov	 eax, DWORD PTR [edx+ecx+8]
  017eb	50		 push	 eax
  017ec	8b 4d d8	 mov	 ecx, DWORD PTR _i$[ebp]
  017ef	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  017f2	8b 55 10	 mov	 edx, DWORD PTR _polylist$[ebp]
  017f5	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  017f8	50		 push	 eax
  017f9	8b 4d ec	 mov	 ecx, DWORD PTR _n2$[ebp]
  017fc	51		 push	 ecx
  017fd	8b 55 d0	 mov	 edx, DWORD PTR _n1$[ebp]
  01800	52		 push	 edx
  01801	8b 45 e0	 mov	 eax, DWORD PTR _direction$[ebp]
  01804	50		 push	 eax
  01805	51		 push	 ecx
  01806	8b cc		 mov	 ecx, esp
  01808	89 65 c4	 mov	 DWORD PTR $T62400[ebp], esp
  0180b	8d 55 d4	 lea	 edx, DWORD PTR _I2$[ebp]
  0180e	52		 push	 edx
  0180f	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@ABU0@@Z ; SCI_Point::SCI_Point
  01814	51		 push	 ecx
  01815	8b cc		 mov	 ecx, esp
  01817	89 65 c0	 mov	 DWORD PTR $T62401[ebp], esp
  0181a	8d 45 dc	 lea	 eax, DWORD PTR _I1$[ebp]
  0181d	50		 push	 eax
  0181e	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@ABU0@@Z ; SCI_Point::SCI_Point
  01823	8b 4d c8	 mov	 ecx, DWORD PTR $T62399[ebp]
  01826	e8 00 00 00 00	 call	 ??0PolyNode@@QAE@USCI_Point@@0HHHPAU1@H@Z ; PolyNode::PolyNode
  0182b	89 45 bc	 mov	 DWORD PTR -68+[ebp], eax
  0182e	eb 07		 jmp	 SHORT $L62403
$L62402:
  01830	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR -68+[ebp], 0
$L62403:
  01837	8b 4d bc	 mov	 ecx, DWORD PTR -68+[ebp]
  0183a	89 4d cc	 mov	 DWORD PTR $T62398[ebp], ecx
  0183d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01844	8b 55 cc	 mov	 edx, DWORD PTR $T62398[ebp]
  01847	89 55 e4	 mov	 DWORD PTR _newNode$[ebp], edx

; 983  :             // add path node to list
; 984  :             if (!nodePath)

  0184a	83 7d e8 00	 cmp	 DWORD PTR _nodePath$[ebp], 0
  0184e	75 0b		 jne	 SHORT $L61327

; 987  :                nodePath = newNode;

  01850	8b 45 e4	 mov	 eax, DWORD PTR _newNode$[ebp]
  01853	89 45 e8	 mov	 DWORD PTR _nodePath$[ebp], eax

; 989  :             else

  01856	e9 11 01 00 00	 jmp	 $L61338
$L61327:

; 992  :                for (node = nodePath;True;node = node->next)

  0185b	8b 4d e8	 mov	 ecx, DWORD PTR _nodePath$[ebp]
  0185e	89 4d f0	 mov	 DWORD PTR _node$[ebp], ecx
  01861	eb 08		 jmp	 SHORT $L61329
$L61330:
  01863	8b 55 f0	 mov	 edx, DWORD PTR _node$[ebp]
  01866	8b 02		 mov	 eax, DWORD PTR [edx]
  01868	89 45 f0	 mov	 DWORD PTR _node$[ebp], eax
$L61329:
  0186b	b9 01 00 00 00	 mov	 ecx, 1
  01870	85 c9		 test	 ecx, ecx
  01872	0f 84 db 00 00
	00		 je	 $L61331

; 995  :                      (
; 996  :                      (node->I1.x != A.x) 
; 997  :                      && 
; 998  :                      (abs(newNode->I1.x - A.x) < abs(node->I1.x - A.x))
; 999  :                      )
; 1000 :                      ||
; 1001 :                      (
; 1002 :                      (node->I1.y != A.y) 
; 1003 :                      && 
; 1004 :                      (abs(newNode->I1.y - A.y) < abs(node->I1.y - A.y))
; 1005 :                      )
; 1006 :                      )

  01878	8b 55 f0	 mov	 edx, DWORD PTR _node$[ebp]
  0187b	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  0187f	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  01882	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  01885	3b c2		 cmp	 eax, edx
  01887	74 36		 je	 SHORT $L61334
  01889	8b 45 e4	 mov	 eax, DWORD PTR _newNode$[ebp]
  0188c	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  01890	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  01893	0f bf 02	 movsx	 eax, WORD PTR [edx]
  01896	2b c8		 sub	 ecx, eax
  01898	51		 push	 ecx
  01899	e8 00 00 00 00	 call	 _abs
  0189e	83 c4 04	 add	 esp, 4
  018a1	8b f0		 mov	 esi, eax
  018a3	8b 4d f0	 mov	 ecx, DWORD PTR _node$[ebp]
  018a6	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  018aa	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  018ad	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  018b0	2b d1		 sub	 edx, ecx
  018b2	52		 push	 edx
  018b3	e8 00 00 00 00	 call	 _abs
  018b8	83 c4 04	 add	 esp, 4
  018bb	3b f0		 cmp	 esi, eax
  018bd	7c 4a		 jl	 SHORT $L61333
$L61334:
  018bf	8b 55 f0	 mov	 edx, DWORD PTR _node$[ebp]
  018c2	0f bf 42 0a	 movsx	 eax, WORD PTR [edx+10]
  018c6	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  018c9	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  018cd	3b c2		 cmp	 eax, edx
  018cf	74 73		 je	 SHORT $L61332
  018d1	8b 45 e4	 mov	 eax, DWORD PTR _newNode$[ebp]
  018d4	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  018d8	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  018db	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  018df	2b c8		 sub	 ecx, eax
  018e1	51		 push	 ecx
  018e2	e8 00 00 00 00	 call	 _abs
  018e7	83 c4 04	 add	 esp, 4
  018ea	8b f0		 mov	 esi, eax
  018ec	8b 4d f0	 mov	 ecx, DWORD PTR _node$[ebp]
  018ef	0f bf 51 0a	 movsx	 edx, WORD PTR [ecx+10]
  018f3	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  018f6	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  018fa	2b d1		 sub	 edx, ecx
  018fc	52		 push	 edx
  018fd	e8 00 00 00 00	 call	 _abs
  01902	83 c4 04	 add	 esp, 4
  01905	3b f0		 cmp	 esi, eax
  01907	7d 3b		 jge	 SHORT $L61332
$L61333:

; 1009 :                         newNode->prev = node->prev;

  01909	8b 55 e4	 mov	 edx, DWORD PTR _newNode$[ebp]
  0190c	8b 45 f0	 mov	 eax, DWORD PTR _node$[ebp]
  0190f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01912	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1010 :                         newNode->next = node;

  01915	8b 55 e4	 mov	 edx, DWORD PTR _newNode$[ebp]
  01918	8b 45 f0	 mov	 eax, DWORD PTR _node$[ebp]
  0191b	89 02		 mov	 DWORD PTR [edx], eax

; 1011 :                         node->prev = newNode;

  0191d	8b 4d f0	 mov	 ecx, DWORD PTR _node$[ebp]
  01920	8b 55 e4	 mov	 edx, DWORD PTR _newNode$[ebp]
  01923	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 1012 :                         if (newNode->prev == 0)

  01926	8b 45 e4	 mov	 eax, DWORD PTR _newNode$[ebp]
  01929	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0192d	75 08		 jne	 SHORT $L61335

; 1013 :                            nodePath = newNode;

  0192f	8b 4d e4	 mov	 ecx, DWORD PTR _newNode$[ebp]
  01932	89 4d e8	 mov	 DWORD PTR _nodePath$[ebp], ecx

; 1014 :                         else

  01935	eb 0b		 jmp	 SHORT $L61336
$L61335:

; 1015 :                            (newNode->prev)->next = newNode;

  01937	8b 55 e4	 mov	 edx, DWORD PTR _newNode$[ebp]
  0193a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0193d	8b 4d e4	 mov	 ecx, DWORD PTR _newNode$[ebp]
  01940	89 08		 mov	 DWORD PTR [eax], ecx
$L61336:

; 1016 :                         break;

  01942	eb 0f		 jmp	 SHORT $L61331
$L61332:

; 1018 :                   if (node->next == 0) break;

  01944	8b 55 f0	 mov	 edx, DWORD PTR _node$[ebp]
  01947	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0194a	75 02		 jne	 SHORT $L61337
  0194c	eb 05		 jmp	 SHORT $L61331
$L61337:

; 1019 :                   }

  0194e	e9 10 ff ff ff	 jmp	 $L61330
$L61331:

; 1020 :                if (newNode->next == 0)

  01953	8b 45 e4	 mov	 eax, DWORD PTR _newNode$[ebp]
  01956	83 38 00	 cmp	 DWORD PTR [eax], 0
  01959	75 11		 jne	 SHORT $L61338

; 1023 :                   node->next = newNode;

  0195b	8b 4d f0	 mov	 ecx, DWORD PTR _node$[ebp]
  0195e	8b 55 e4	 mov	 edx, DWORD PTR _newNode$[ebp]
  01961	89 11		 mov	 DWORD PTR [ecx], edx

; 1024 :                   newNode->prev = node;

  01963	8b 45 e4	 mov	 eax, DWORD PTR _newNode$[ebp]
  01966	8b 4d f0	 mov	 ecx, DWORD PTR _node$[ebp]
  01969	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$L61338:

; 1028 :          }

  0196c	e9 ee fd ff ff	 jmp	 $L61318
$L61319:

; 1030 :    return(nodePath);

  01971	8b 45 e8	 mov	 eax, DWORD PTR _nodePath$[ebp]

; 1031 : }

  01974	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01977	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0197e	5e		 pop	 esi
  0197f	8b e5		 mov	 esp, ebp
  01981	5d		 pop	 ebp
  01982	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L62404:
  00013	8b 45 c8	 mov	 eax, DWORD PTR $T62399[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	59		 pop	 ecx
  0001d	c3		 ret	 0
$L62407:
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T62406
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AvoidPolygons@@YAPAVPolyNode@@AAUSCI_Point@@0PAVSOL_Polygon@@@Z ENDP ; AvoidPolygons
;	COMDAT ??9SCI_Point@@QBEHABU0@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
??9SCI_Point@@QBEHABU0@@Z PROC NEAR			; SCI_Point::operator!=, COMDAT

; 280  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 281  : 	return x != p.x  ||  y != p.y;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0000f	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00012	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00015	3b c8		 cmp	 ecx, eax
  00017	75 1b		 jne	 SHORT $L62410
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  00020	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00023	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00027	3b d1		 cmp	 edx, ecx
  00029	75 09		 jne	 SHORT $L62410
  0002b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], 0
  00032	eb 07		 jmp	 SHORT $L62411
$L62410:
  00034	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR -8+[ebp], 1
$L62411:
  0003b	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]

; 282  : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??9SCI_Point@@QBEHABU0@@Z ENDP				; SCI_Point::operator!=
_TEXT	ENDS
;	COMDAT ??0PolyNode@@QAE@USCI_Point@@0HHHPAU1@H@Z
_TEXT	SEGMENT
_theI1$ = 8
_theI2$ = 12
_theD$ = 16
_theN1$ = 20
_theN2$ = 24
_thePoints$ = 28
_theN$ = 32
_this$ = -4
??0PolyNode@@QAE@USCI_Point@@0HHHPAU1@H@Z PROC NEAR	; PolyNode::PolyNode, COMDAT

; 45   :    PolyNode(SCI_Point theI1,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 08	 add	 ecx, 8
  0000d	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00018	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point

; 46   :             SCI_Point theI2,
; 47   :             int theD,
; 48   :             int theN1,
; 49   :             int theN2,
; 50   :             SCI_Point* thePoints,
; 51   :             int theN)
; 52   : 	{
; 53   :       I1 = theI1;

  0001d	8d 45 08	 lea	 eax, DWORD PTR _theI1$[ebp]
  00020	50		 push	 eax
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 08	 add	 ecx, 8
  00027	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 54   :       I2 = theI2;

  0002c	8d 4d 0c	 lea	 ecx, DWORD PTR _theI2$[ebp]
  0002f	51		 push	 ecx
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00036	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 55   :       d = theD;

  0003b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	8b 45 10	 mov	 eax, DWORD PTR _theD$[ebp]
  00041	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 56   :       n1 = theN1;

  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	8b 55 14	 mov	 edx, DWORD PTR _theN1$[ebp]
  0004a	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 57   :       n2 = theN2;

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d 18	 mov	 ecx, DWORD PTR _theN2$[ebp]
  00053	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 58   :       poly = thePoints;

  00056	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00059	8b 45 1c	 mov	 eax, DWORD PTR _thePoints$[ebp]
  0005c	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 59   :       n = theN;

  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	8b 55 20	 mov	 edx, DWORD PTR _theN$[ebp]
  00065	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 60   :       next = 0;

  00068	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 61   :       prev = 0;

  00071	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 62   :    }

  0007b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 1c 00	 ret	 28			; 0000001cH
??0PolyNode@@QAE@USCI_Point@@0HHHPAU1@H@Z ENDP		; PolyNode::PolyNode
_TEXT	ENDS
PUBLIC	?RemoveNode@@YAXPAVSOL_Polygon@@H@Z		; RemoveNode
_TEXT	SEGMENT
_polylist$ = 8
_nodePath$ = 12
_temp$ = -8
_deleted$ = -4
_I1$ = -12
_I2$ = -16
_tmp1$ = -20
_tmp2$ = -24
$T62414 = -28
$T62415 = -32
?ReducePolygonList@@YAXPAVSOL_Polygon@@PAVPolyNode@@@Z PROC NEAR ; ReducePolygonList

; 1035 : {        

  01983	55		 push	 ebp
  01984	8b ec		 mov	 ebp, esp
  01986	83 ec 20	 sub	 esp, 32			; 00000020H

; 1036 :    PolyNode*   temp;
; 1037 :    int         deleted;
; 1038 :    SCI_Point   I1,I2;

  01989	8d 4d f4	 lea	 ecx, DWORD PTR _I1$[ebp]
  0198c	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  01991	8d 4d f0	 lea	 ecx, DWORD PTR _I2$[ebp]
  01994	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point

; 1039 :    SCI_Point   tmp1,tmp2;

  01999	8d 4d ec	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  0199c	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  019a1	8d 4d e8	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  019a4	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point

; 1040 : 
; 1041 :    /* Eliminate any overlaped polygons.
; 1042 :       For example polygon2 can be eliminated in the following case:
; 1043 : 
; 1044 : 
; 1045 :                        ********************
; 1046 :                        *                  *
; 1047 :                        *                  *
; 1048 :                        *     polygon2     *
; 1049 :                         *                 *
; 1050 :                          *               *
; 1051 :                           *             *
; 1052 :                 *********  *           *  **********
; 1053 :                 *        *  *         *  *         *
; 1054 :               I1*         *  *I3   I4*  *          *I2
; 1055 :      A----------*----------*--*-----*--*-----------*---------B
; 1056 :                 *           *  *   *  *            *
; 1057 :                 *            *  * *  *             *
; 1058 :                 *             *  *  *              *
; 1059 :                 *              *   *               *
; 1060 :                 *               * *                *
; 1061 :                 *                *                 *
; 1062 :                 *                                  *
; 1063 :                 *            polygon1              *
; 1064 :                 *                                  *
; 1065 :                 ************************************    
; 1066 :    */
; 1067 :    // First polygon in polylist is checked againest the others to
; 1068 :    // see if any polygons in the list can be eliminated.
; 1069 :    deleted = 0;

  019a9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _deleted$[ebp], 0

; 1070 :    I2 = nodePath->I2;

  019b0	8b 45 0c	 mov	 eax, DWORD PTR _nodePath$[ebp]
  019b3	83 c0 0c	 add	 eax, 12			; 0000000cH
  019b6	50		 push	 eax
  019b7	8d 4d f0	 lea	 ecx, DWORD PTR _I2$[ebp]
  019ba	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1071 :    I1 = nodePath->I1;

  019bf	8b 4d 0c	 mov	 ecx, DWORD PTR _nodePath$[ebp]
  019c2	83 c1 08	 add	 ecx, 8
  019c5	51		 push	 ecx
  019c6	8d 4d f4	 lea	 ecx, DWORD PTR _I1$[ebp]
  019c9	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1072 :    nodePath = nodePath->next;

  019ce	8b 55 0c	 mov	 edx, DWORD PTR _nodePath$[ebp]
  019d1	8b 02		 mov	 eax, DWORD PTR [edx]
  019d3	89 45 0c	 mov	 DWORD PTR _nodePath$[ebp], eax
$L61350:

; 1073 :    while (nodePath)

  019d6	83 7d 0c 00	 cmp	 DWORD PTR _nodePath$[ebp], 0
  019da	74 74		 je	 SHORT $L61351

; 1075 :       temp = nodePath->next;

  019dc	8b 4d 0c	 mov	 ecx, DWORD PTR _nodePath$[ebp]
  019df	8b 11		 mov	 edx, DWORD PTR [ecx]
  019e1	89 55 f8	 mov	 DWORD PTR _temp$[ebp], edx

; 1076 :       tmp1 = I2 - I1;

  019e4	8d 45 f4	 lea	 eax, DWORD PTR _I1$[ebp]
  019e7	50		 push	 eax
  019e8	8d 4d e4	 lea	 ecx, DWORD PTR $T62414[ebp]
  019eb	51		 push	 ecx
  019ec	8d 4d f0	 lea	 ecx, DWORD PTR _I2$[ebp]
  019ef	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  019f4	50		 push	 eax
  019f5	8d 4d ec	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  019f8	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1077 :       tmp2 = I2 - nodePath->I2;

  019fd	8b 55 0c	 mov	 edx, DWORD PTR _nodePath$[ebp]
  01a00	83 c2 0c	 add	 edx, 12			; 0000000cH
  01a03	52		 push	 edx
  01a04	8d 45 e0	 lea	 eax, DWORD PTR $T62415[ebp]
  01a07	50		 push	 eax
  01a08	8d 4d f0	 lea	 ecx, DWORD PTR _I2$[ebp]
  01a0b	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  01a10	50		 push	 eax
  01a11	8d 4d e8	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  01a14	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1078 : 
; 1079 :       if ((tmp1*tmp2) <= 0)      

  01a19	8d 4d e8	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  01a1c	51		 push	 ecx
  01a1d	8d 4d ec	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  01a20	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  01a25	85 c0		 test	 eax, eax
  01a27	7f 1f		 jg	 SHORT $L61354

; 1081 :          // remove nodePath->i polygon from polylist
; 1082 :          RemoveNode(polylist,nodePath->i - deleted);

  01a29	8b 55 0c	 mov	 edx, DWORD PTR _nodePath$[ebp]
  01a2c	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  01a2f	2b 45 fc	 sub	 eax, DWORD PTR _deleted$[ebp]
  01a32	50		 push	 eax
  01a33	8b 4d 08	 mov	 ecx, DWORD PTR _polylist$[ebp]
  01a36	51		 push	 ecx
  01a37	e8 00 00 00 00	 call	 ?RemoveNode@@YAXPAVSOL_Polygon@@H@Z ; RemoveNode
  01a3c	83 c4 08	 add	 esp, 8

; 1083 :          ++deleted;

  01a3f	8b 55 fc	 mov	 edx, DWORD PTR _deleted$[ebp]
  01a42	83 c2 01	 add	 edx, 1
  01a45	89 55 fc	 mov	 DWORD PTR _deleted$[ebp], edx
$L61354:

; 1085 :       nodePath = temp;

  01a48	8b 45 f8	 mov	 eax, DWORD PTR _temp$[ebp]
  01a4b	89 45 0c	 mov	 DWORD PTR _nodePath$[ebp], eax

; 1086 :       }

  01a4e	eb 86		 jmp	 SHORT $L61350
$L61351:

; 1087 :    }

  01a50	8b e5		 mov	 esp, ebp
  01a52	5d		 pop	 ebp
  01a53	c3		 ret	 0
?ReducePolygonList@@YAXPAVSOL_Polygon@@PAVPolyNode@@@Z ENDP ; ReducePolygonList
_polylist$ = 8
_i$ = 12
?RemoveNode@@YAXPAVSOL_Polygon@@H@Z PROC NEAR		; RemoveNode

; 1091 : {

  01a54	55		 push	 ebp
  01a55	8b ec		 mov	 ebp, esp
$L61359:

; 1094 :       polylist[i] = polylist[i+1];

  01a57	8b 45 0c	 mov	 eax, DWORD PTR _i$[ebp]
  01a5a	83 c0 01	 add	 eax, 1
  01a5d	6b c0 0c	 imul	 eax, 12			; 0000000cH
  01a60	8b 4d 08	 mov	 ecx, DWORD PTR _polylist$[ebp]
  01a63	03 c8		 add	 ecx, eax
  01a65	8b 55 0c	 mov	 edx, DWORD PTR _i$[ebp]
  01a68	6b d2 0c	 imul	 edx, 12			; 0000000cH
  01a6b	8b 45 08	 mov	 eax, DWORD PTR _polylist$[ebp]
  01a6e	03 c2		 add	 eax, edx
  01a70	8b 11		 mov	 edx, DWORD PTR [ecx]
  01a72	89 10		 mov	 DWORD PTR [eax], edx
  01a74	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  01a77	89 50 04	 mov	 DWORD PTR [eax+4], edx
  01a7a	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  01a7d	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1095 :       ++i;

  01a80	8b 55 0c	 mov	 edx, DWORD PTR _i$[ebp]
  01a83	83 c2 01	 add	 edx, 1
  01a86	89 55 0c	 mov	 DWORD PTR _i$[ebp], edx

; 1097 :    while (polylist[i].n != 0);

  01a89	8b 45 0c	 mov	 eax, DWORD PTR _i$[ebp]
  01a8c	6b c0 0c	 imul	 eax, 12			; 0000000cH
  01a8f	8b 4d 08	 mov	 ecx, DWORD PTR _polylist$[ebp]
  01a92	83 7c 01 08 00	 cmp	 DWORD PTR [ecx+eax+8], 0
  01a97	75 be		 jne	 SHORT $L61359

; 1098 : }

  01a99	5d		 pop	 ebp
  01a9a	c3		 ret	 0
?RemoveNode@@YAXPAVSOL_Polygon@@H@Z ENDP		; RemoveNode
_nodePath$ = 8
_polyDirections$ = -12
_d$ = -8
_i$ = -16
_node$ = -4
?GetPolyDirections@@YAHPAVPolyNode@@@Z PROC NEAR	; GetPolyDirections

; 1102 : {

  01a9b	55		 push	 ebp
  01a9c	8b ec		 mov	 ebp, esp
  01a9e	83 ec 10	 sub	 esp, 16			; 00000010H

; 1103 :    int        polyDirections = 0;

  01aa1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _polyDirections$[ebp], 0

; 1104 :    int        d,i;
; 1105 :    PolyNode*  node;
; 1106 :    for (node=nodePath,i=0;(node != 0) && (i<=MAXOPTIMIZEDNODES);++i)

  01aa8	8b 45 08	 mov	 eax, DWORD PTR _nodePath$[ebp]
  01aab	89 45 fc	 mov	 DWORD PTR _node$[ebp], eax
  01aae	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  01ab5	eb 09		 jmp	 SHORT $L61369
$L61370:
  01ab7	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  01aba	83 c1 01	 add	 ecx, 1
  01abd	89 4d f0	 mov	 DWORD PTR _i$[ebp], ecx
$L61369:
  01ac0	83 7d fc 00	 cmp	 DWORD PTR _node$[ebp], 0
  01ac4	74 37		 je	 SHORT $L61371
  01ac6	83 7d f0 03	 cmp	 DWORD PTR _i$[ebp], 3
  01aca	7f 31		 jg	 SHORT $L61371

; 1108 :       d = 1;

  01acc	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _d$[ebp], 1

; 1109 :       if(node->d<0) d =0;

  01ad3	8b 55 fc	 mov	 edx, DWORD PTR _node$[ebp]
  01ad6	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  01ada	7d 07		 jge	 SHORT $L61372
  01adc	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _d$[ebp], 0
$L61372:

; 1110 :       polyDirections += (d<<i);

  01ae3	8b 45 f8	 mov	 eax, DWORD PTR _d$[ebp]
  01ae6	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  01ae9	d3 e0		 shl	 eax, cl
  01aeb	8b 4d f4	 mov	 ecx, DWORD PTR _polyDirections$[ebp]
  01aee	03 c8		 add	 ecx, eax
  01af0	89 4d f4	 mov	 DWORD PTR _polyDirections$[ebp], ecx

; 1111 :       node = node->next;

  01af3	8b 55 fc	 mov	 edx, DWORD PTR _node$[ebp]
  01af6	8b 02		 mov	 eax, DWORD PTR [edx]
  01af8	89 45 fc	 mov	 DWORD PTR _node$[ebp], eax

; 1112 :       }

  01afb	eb ba		 jmp	 SHORT $L61370
$L61371:

; 1113 :    return(polyDirections);

  01afd	8b 45 f4	 mov	 eax, DWORD PTR _polyDirections$[ebp]

; 1114 :    }

  01b00	8b e5		 mov	 esp, ebp
  01b02	5d		 pop	 ebp
  01b03	c3		 ret	 0
?GetPolyDirections@@YAHPAVPolyNode@@@Z ENDP		; GetPolyDirections
_path$ = 8
_distance$ = -4
_offScreen$ = -8
_i$ = -12
?GetPolyDistance@@YAHPAUSCI_Point@@@Z PROC NEAR		; GetPolyDistance

; 1118 : {

  01b04	55		 push	 ebp
  01b05	8b ec		 mov	 ebp, esp
  01b07	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1119 :    int   distance = 0,offScreen = 0;

  01b0a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _distance$[ebp], 0
  01b11	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _offScreen$[ebp], 0

; 1120 :    int   i;
; 1121 :    for (i=0;path[i+1].x != ENDOFPATH;++i)

  01b18	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  01b1f	eb 09		 jmp	 SHORT $L61379
$L61380:
  01b21	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  01b24	83 c0 01	 add	 eax, 1
  01b27	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$L61379:
  01b2a	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  01b2d	8b 55 08	 mov	 edx, DWORD PTR _path$[ebp]
  01b30	0f bf 44 8a 04	 movsx	 eax, WORD PTR [edx+ecx*4+4]
  01b35	3d 77 77 00 00	 cmp	 eax, 30583		; 00007777H
  01b3a	74 2b		 je	 SHORT $L61381

; 1123 :       distance += DistanceEstimate(path[i],path[i+1],&offScreen);

  01b3c	8d 4d f8	 lea	 ecx, DWORD PTR _offScreen$[ebp]
  01b3f	51		 push	 ecx
  01b40	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  01b43	8b 45 08	 mov	 eax, DWORD PTR _path$[ebp]
  01b46	8d 4c 90 04	 lea	 ecx, DWORD PTR [eax+edx*4+4]
  01b4a	51		 push	 ecx
  01b4b	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  01b4e	8b 45 08	 mov	 eax, DWORD PTR _path$[ebp]
  01b51	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  01b54	51		 push	 ecx
  01b55	e8 00 00 00 00	 call	 ?DistanceEstimate@@YAHAAUSCI_Point@@0PAH@Z ; DistanceEstimate
  01b5a	83 c4 0c	 add	 esp, 12			; 0000000cH
  01b5d	8b 55 fc	 mov	 edx, DWORD PTR _distance$[ebp]
  01b60	03 d0		 add	 edx, eax
  01b62	89 55 fc	 mov	 DWORD PTR _distance$[ebp], edx

; 1124 :       }

  01b65	eb ba		 jmp	 SHORT $L61380
$L61381:

; 1125 :    if (offScreen) return(INT_MAX);

  01b67	83 7d f8 00	 cmp	 DWORD PTR _offScreen$[ebp], 0
  01b6b	74 07		 je	 SHORT $L61382
  01b6d	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  01b72	eb 03		 jmp	 SHORT $L61375
$L61382:

; 1126 :    return(distance);

  01b74	8b 45 fc	 mov	 eax, DWORD PTR _distance$[ebp]
$L61375:

; 1127 : }

  01b77	8b e5		 mov	 esp, ebp
  01b79	5d		 pop	 ebp
  01b7a	c3		 ret	 0
?GetPolyDistance@@YAHPAUSCI_Point@@@Z ENDP		; GetPolyDistance
_nodePath$ = 8
_polyDirections$ = 12
_totalNodes$ = 16
_node$ = -4
_i$ = -12
_d$ = -8
?SetPolyDirections@@YAXPAVPolyNode@@HH@Z PROC NEAR	; SetPolyDirections

; 1131 : {

  01b7b	55		 push	 ebp
  01b7c	8b ec		 mov	 ebp, esp
  01b7e	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1132 :    PolyNode*   node;
; 1133 :    int         i,d;
; 1134 :    for (node=nodePath,i=0;(node != 0) && (i<totalNodes);++i)

  01b81	8b 45 08	 mov	 eax, DWORD PTR _nodePath$[ebp]
  01b84	89 45 fc	 mov	 DWORD PTR _node$[ebp], eax
  01b87	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  01b8e	eb 09		 jmp	 SHORT $L61391
$L61392:
  01b90	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  01b93	83 c1 01	 add	 ecx, 1
  01b96	89 4d f4	 mov	 DWORD PTR _i$[ebp], ecx
$L61391:
  01b99	83 7d fc 00	 cmp	 DWORD PTR _node$[ebp], 0
  01b9d	0f 84 d6 00 00
	00		 je	 $L61393
  01ba3	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  01ba6	3b 55 10	 cmp	 edx, DWORD PTR _totalNodes$[ebp]
  01ba9	0f 8d ca 00 00
	00		 jge	 $L61393

; 1136 :       d = (polyDirections>>i) & 1;

  01baf	8b 45 0c	 mov	 eax, DWORD PTR _polyDirections$[ebp]
  01bb2	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  01bb5	d3 f8		 sar	 eax, cl
  01bb7	83 e0 01	 and	 eax, 1
  01bba	89 45 f8	 mov	 DWORD PTR _d$[ebp], eax

; 1137 :       if (!d) d = -1;

  01bbd	83 7d f8 00	 cmp	 DWORD PTR _d$[ebp], 0
  01bc1	75 07		 jne	 SHORT $L61394
  01bc3	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _d$[ebp], -1
$L61394:

; 1138 :       if (node->d != d)

  01bca	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  01bcd	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  01bd0	3b 55 f8	 cmp	 edx, DWORD PTR _d$[ebp]
  01bd3	0f 84 93 00 00
	00		 je	 $L61397

; 1140 :          if (node->d == 1)

  01bd9	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  01bdc	83 78 10 01	 cmp	 DWORD PTR [eax+16], 1
  01be0	75 46		 jne	 SHORT $L61396

; 1142 :             node->d = -1;

  01be2	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  01be5	c7 41 10 ff ff
	ff ff		 mov	 DWORD PTR [ecx+16], -1

; 1143 :             node->n1 = (node->n1 - 1 + node->n) % node->n;

  01bec	8b 55 fc	 mov	 edx, DWORD PTR _node$[ebp]
  01bef	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  01bf2	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  01bf5	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  01bf8	8d 44 10 ff	 lea	 eax, DWORD PTR [eax+edx-1]
  01bfc	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  01bff	99		 cdq
  01c00	f7 79 20	 idiv	 DWORD PTR [ecx+32]
  01c03	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  01c06	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 1144 :             node->n2 = (node->n2 + 1 + node->n) % node->n;

  01c09	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  01c0c	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  01c0f	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  01c12	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  01c15	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  01c19	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  01c1c	99		 cdq
  01c1d	f7 79 20	 idiv	 DWORD PTR [ecx+32]
  01c20	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  01c23	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 1146 :          else

  01c26	eb 44		 jmp	 SHORT $L61397
$L61396:

; 1148 :             node->d = 1;

  01c28	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  01c2b	c7 41 10 01 00
	00 00		 mov	 DWORD PTR [ecx+16], 1

; 1149 :             node->n1 = (node->n1 + 1 + node->n) % node->n;

  01c32	8b 55 fc	 mov	 edx, DWORD PTR _node$[ebp]
  01c35	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  01c38	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  01c3b	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  01c3e	8d 44 10 01	 lea	 eax, DWORD PTR [eax+edx+1]
  01c42	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  01c45	99		 cdq
  01c46	f7 79 20	 idiv	 DWORD PTR [ecx+32]
  01c49	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  01c4c	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 1150 :             node->n2 = (node->n2 - 1 + node->n) % node->n;

  01c4f	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  01c52	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  01c55	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  01c58	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  01c5b	8d 44 0a ff	 lea	 eax, DWORD PTR [edx+ecx-1]
  01c5f	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  01c62	99		 cdq
  01c63	f7 79 20	 idiv	 DWORD PTR [ecx+32]
  01c66	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  01c69	89 50 18	 mov	 DWORD PTR [eax+24], edx
$L61397:

; 1153 :       node = node->next;

  01c6c	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  01c6f	8b 11		 mov	 edx, DWORD PTR [ecx]
  01c71	89 55 fc	 mov	 DWORD PTR _node$[ebp], edx

; 1154 :       }

  01c74	e9 17 ff ff ff	 jmp	 $L61392
$L61393:

; 1155 : }

  01c79	8b e5		 mov	 esp, ebp
  01c7b	5d		 pop	 ebp
  01c7c	c3		 ret	 0
?SetPolyDirections@@YAXPAVPolyNode@@HH@Z ENDP		; SetPolyDirections
_TEXT	ENDS
_DATA	SEGMENT
$SG61426 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Poly'
	DB	'gon.cpp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_A$ = 8
_B$ = 12
_path$ = 16
_nodePath$ = 20
_polylist$ = 24
_opt$ = 28
_i$ = -28
_j$ = -36
_k$ = -40
_x$ = -20
_M$ = -52
_P0$ = -16
_PN$ = -12
_PG$ = -44
_node$ = -4
_I1$ = -24
_I2$ = -32
_nodeI1$ = -48
_nodeI2$ = -8
?OptimizePath@@YAXAAUSCI_Point@@0PAU1@PAVPolyNode@@PAVSOL_Polygon@@H@Z PROC NEAR ; OptimizePath

; 1175 :    {

  01c7d	55		 push	 ebp
  01c7e	8b ec		 mov	 ebp, esp
  01c80	83 ec 48	 sub	 esp, 72			; 00000048H
  01c83	56		 push	 esi

; 1176 :    int         i,j,k,x;
; 1177 :    int         M,P0,PN,PG;
; 1178 :    PolyNode*   node;
; 1179 :    SCI_Point   I1,I2;

  01c84	8d 4d e8	 lea	 ecx, DWORD PTR _I1$[ebp]
  01c87	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  01c8c	8d 4d e0	 lea	 ecx, DWORD PTR _I2$[ebp]
  01c8f	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point

; 1180 :    int         nodeI1,nodeI2;
; 1181 : 
; 1182 : 
; 1183 :    // Chain path nodes together to make one large path
; 1184 :    // first point is A
; 1185 :    path[0].x = A.x;

  01c94	8b 45 10	 mov	 eax, DWORD PTR _path$[ebp]
  01c97	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  01c9a	66 8b 11	 mov	 dx, WORD PTR [ecx]
  01c9d	66 89 10	 mov	 WORD PTR [eax], dx

; 1186 :    path[0].y = A.y;

  01ca0	8b 45 10	 mov	 eax, DWORD PTR _path$[ebp]
  01ca3	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  01ca6	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  01caa	66 89 50 02	 mov	 WORD PTR [eax+2], dx

; 1187 : 
; 1188 :    i = 1;

  01cae	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1

; 1189 :    for (node = nodePath;node != 0;)

  01cb5	8b 45 14	 mov	 eax, DWORD PTR _nodePath$[ebp]
  01cb8	89 45 fc	 mov	 DWORD PTR _node$[ebp], eax
$L61420:
  01cbb	83 7d fc 00	 cmp	 DWORD PTR _node$[ebp], 0
  01cbf	0f 84 ce 00 00
	00		 je	 $L61421

; 1191 :       path[i++] = node->I1;

  01cc5	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  01cc8	83 c1 08	 add	 ecx, 8
  01ccb	51		 push	 ecx
  01ccc	8b 55 e4	 mov	 edx, DWORD PTR _i$[ebp]
  01ccf	8b 45 10	 mov	 eax, DWORD PTR _path$[ebp]
  01cd2	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  01cd5	89 4d c8	 mov	 DWORD PTR -56+[ebp], ecx
  01cd8	8b 55 e4	 mov	 edx, DWORD PTR _i$[ebp]
  01cdb	83 c2 01	 add	 edx, 1
  01cde	89 55 e4	 mov	 DWORD PTR _i$[ebp], edx
  01ce1	8b 4d c8	 mov	 ecx, DWORD PTR -56+[ebp]
  01ce4	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1192 :       j = (node->n1 - node->d + node->n) % node->n;

  01ce9	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  01cec	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  01cef	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  01cf2	2b 41 10	 sub	 eax, DWORD PTR [ecx+16]
  01cf5	8b 55 fc	 mov	 edx, DWORD PTR _node$[ebp]
  01cf8	03 42 20	 add	 eax, DWORD PTR [edx+32]
  01cfb	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  01cfe	99		 cdq
  01cff	f7 79 20	 idiv	 DWORD PTR [ecx+32]
  01d02	89 55 dc	 mov	 DWORD PTR _j$[ebp], edx
$L61422:

; 1196 :          j = (j + node->d + node->n) % node->n;

  01d05	8b 55 fc	 mov	 edx, DWORD PTR _node$[ebp]
  01d08	8b 45 dc	 mov	 eax, DWORD PTR _j$[ebp]
  01d0b	03 42 10	 add	 eax, DWORD PTR [edx+16]
  01d0e	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  01d11	03 41 20	 add	 eax, DWORD PTR [ecx+32]
  01d14	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  01d17	99		 cdq
  01d18	f7 79 20	 idiv	 DWORD PTR [ecx+32]
  01d1b	89 55 dc	 mov	 DWORD PTR _j$[ebp], edx

; 1197 :          path[i].x = (node->poly)[j].x;

  01d1e	8b 55 fc	 mov	 edx, DWORD PTR _node$[ebp]
  01d21	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  01d24	8b 4d e4	 mov	 ecx, DWORD PTR _i$[ebp]
  01d27	8b 55 10	 mov	 edx, DWORD PTR _path$[ebp]
  01d2a	8b 75 dc	 mov	 esi, DWORD PTR _j$[ebp]
  01d2d	66 8b 04 b0	 mov	 ax, WORD PTR [eax+esi*4]
  01d31	66 89 04 8a	 mov	 WORD PTR [edx+ecx*4], ax

; 1198 :          path[i++].y = (node->poly)[j].y;

  01d35	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  01d38	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  01d3b	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  01d3e	8b 4d 10	 mov	 ecx, DWORD PTR _path$[ebp]
  01d41	8b 75 dc	 mov	 esi, DWORD PTR _j$[ebp]
  01d44	66 8b 54 b2 02	 mov	 dx, WORD PTR [edx+esi*4+2]
  01d49	66 89 54 81 02	 mov	 WORD PTR [ecx+eax*4+2], dx
  01d4e	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  01d51	83 c0 01	 add	 eax, 1
  01d54	89 45 e4	 mov	 DWORD PTR _i$[ebp], eax

; 1200 :       while (j != node->n2);

  01d57	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  01d5a	8b 55 dc	 mov	 edx, DWORD PTR _j$[ebp]
  01d5d	3b 51 18	 cmp	 edx, DWORD PTR [ecx+24]
  01d60	75 a3		 jne	 SHORT $L61422

; 1201 : 
; 1202 :       path[i++] = node->I2;

  01d62	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  01d65	83 c0 0c	 add	 eax, 12			; 0000000cH
  01d68	50		 push	 eax
  01d69	8b 4d e4	 mov	 ecx, DWORD PTR _i$[ebp]
  01d6c	8b 55 10	 mov	 edx, DWORD PTR _path$[ebp]
  01d6f	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  01d72	89 45 c4	 mov	 DWORD PTR -60+[ebp], eax
  01d75	8b 4d e4	 mov	 ecx, DWORD PTR _i$[ebp]
  01d78	83 c1 01	 add	 ecx, 1
  01d7b	89 4d e4	 mov	 DWORD PTR _i$[ebp], ecx
  01d7e	8b 4d c4	 mov	 ecx, DWORD PTR -60+[ebp]
  01d81	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1203 :       node = node->next;

  01d86	8b 55 fc	 mov	 edx, DWORD PTR _node$[ebp]
  01d89	8b 02		 mov	 eax, DWORD PTR [edx]
  01d8b	89 45 fc	 mov	 DWORD PTR _node$[ebp], eax

; 1204 :       }

  01d8e	e9 28 ff ff ff	 jmp	 $L61420
$L61421:

; 1205 : 
; 1206 :    // last point is B
; 1207 :    path[i++] = B;

  01d93	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  01d96	51		 push	 ecx
  01d97	8b 55 e4	 mov	 edx, DWORD PTR _i$[ebp]
  01d9a	8b 45 10	 mov	 eax, DWORD PTR _path$[ebp]
  01d9d	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  01da0	89 4d c0	 mov	 DWORD PTR -64+[ebp], ecx
  01da3	8b 55 e4	 mov	 edx, DWORD PTR _i$[ebp]
  01da6	83 c2 01	 add	 edx, 1
  01da9	89 55 e4	 mov	 DWORD PTR _i$[ebp], edx
  01dac	8b 4d c0	 mov	 ecx, DWORD PTR -64+[ebp]
  01daf	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1208 :    path[i].x = ENDOFPATH;

  01db4	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  01db7	8b 4d 10	 mov	 ecx, DWORD PTR _path$[ebp]
  01dba	66 c7 04 81 77
	77		 mov	 WORD PTR [ecx+eax*4], 30583 ; 00007777H

; 1209 :    if (i >= MAXPOLYPATH)

  01dc0	81 7d e4 fa 00
	00 00		 cmp	 DWORD PTR _i$[ebp], 250	; 000000faH
  01dc7	7c 1d		 jl	 SHORT $L61425

; 1210 : 		msgMgr->Fatal(SrcLoc,Msg_TooManyPointsInPath);

  01dc9	6a 74		 push	 116			; 00000074H
  01dcb	68 ba 04 00 00	 push	 1210			; 000004baH
  01dd0	68 00 00 00 00	 push	 OFFSET FLAT:$SG61426
  01dd5	6a 61		 push	 97			; 00000061H
  01dd7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  01ddd	52		 push	 edx
  01dde	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXDPADHHZZ ; MsgMgr::Fatal
  01de3	83 c4 14	 add	 esp, 20			; 00000014H
$L61425:

; 1211 : 
; 1212 :    // start optimization of path
; 1213 :    if (!opt || (i < 3))

  01de6	83 7d 1c 00	 cmp	 DWORD PTR _opt$[ebp], 0
  01dea	74 06		 je	 SHORT $L61428
  01dec	83 7d e4 03	 cmp	 DWORD PTR _i$[ebp], 3
  01df0	7d 05		 jge	 SHORT $L61427
$L61428:

; 1215 :       return;

  01df2	e9 00 02 00 00	 jmp	 $L61405
$L61427:

; 1219 :       // get rid of any adjacent dupicate points
; 1220 :       for (j=0;path[j].x != ENDOFPATH;++j)

  01df7	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  01dfe	eb 09		 jmp	 SHORT $L61430
$L61431:
  01e00	8b 45 dc	 mov	 eax, DWORD PTR _j$[ebp]
  01e03	83 c0 01	 add	 eax, 1
  01e06	89 45 dc	 mov	 DWORD PTR _j$[ebp], eax
$L61430:
  01e09	8b 4d dc	 mov	 ecx, DWORD PTR _j$[ebp]
  01e0c	8b 55 10	 mov	 edx, DWORD PTR _path$[ebp]
  01e0f	0f bf 04 8a	 movsx	 eax, WORD PTR [edx+ecx*4]
  01e13	3d 77 77 00 00	 cmp	 eax, 30583		; 00007777H
  01e18	74 72		 je	 SHORT $L61432

; 1222 :          if (path[j] == path[j+1])

  01e1a	8b 4d dc	 mov	 ecx, DWORD PTR _j$[ebp]
  01e1d	8b 55 10	 mov	 edx, DWORD PTR _path$[ebp]
  01e20	8d 44 8a 04	 lea	 eax, DWORD PTR [edx+ecx*4+4]
  01e24	50		 push	 eax
  01e25	8b 4d dc	 mov	 ecx, DWORD PTR _j$[ebp]
  01e28	8b 55 10	 mov	 edx, DWORD PTR _path$[ebp]
  01e2b	8d 0c 8a	 lea	 ecx, DWORD PTR [edx+ecx*4]
  01e2e	e8 00 00 00 00	 call	 ??8SCI_Point@@QBEHABU0@@Z ; SCI_Point::operator==
  01e33	85 c0		 test	 eax, eax
  01e35	74 50		 je	 SHORT $L61433

; 1224 :                for (k=j;path[k].x != ENDOFPATH;++k)

  01e37	8b 45 dc	 mov	 eax, DWORD PTR _j$[ebp]
  01e3a	89 45 d8	 mov	 DWORD PTR _k$[ebp], eax
  01e3d	eb 09		 jmp	 SHORT $L61434
$L61435:
  01e3f	8b 4d d8	 mov	 ecx, DWORD PTR _k$[ebp]
  01e42	83 c1 01	 add	 ecx, 1
  01e45	89 4d d8	 mov	 DWORD PTR _k$[ebp], ecx
$L61434:
  01e48	8b 55 d8	 mov	 edx, DWORD PTR _k$[ebp]
  01e4b	8b 45 10	 mov	 eax, DWORD PTR _path$[ebp]
  01e4e	0f bf 0c 90	 movsx	 ecx, WORD PTR [eax+edx*4]
  01e52	81 f9 77 77 00
	00		 cmp	 ecx, 30583		; 00007777H
  01e58	74 1b		 je	 SHORT $L61436

; 1226 :                   path[k] = path[k+1];

  01e5a	8b 55 d8	 mov	 edx, DWORD PTR _k$[ebp]
  01e5d	8b 45 10	 mov	 eax, DWORD PTR _path$[ebp]
  01e60	8d 4c 90 04	 lea	 ecx, DWORD PTR [eax+edx*4+4]
  01e64	51		 push	 ecx
  01e65	8b 55 d8	 mov	 edx, DWORD PTR _k$[ebp]
  01e68	8b 45 10	 mov	 eax, DWORD PTR _path$[ebp]
  01e6b	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  01e6e	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1227 :                   }

  01e73	eb ca		 jmp	 SHORT $L61435
$L61436:

; 1228 :                --j;

  01e75	8b 4d dc	 mov	 ecx, DWORD PTR _j$[ebp]
  01e78	83 e9 01	 sub	 ecx, 1
  01e7b	89 4d dc	 mov	 DWORD PTR _j$[ebp], ecx

; 1229 :                --i;

  01e7e	8b 55 e4	 mov	 edx, DWORD PTR _i$[ebp]
  01e81	83 ea 01	 sub	 edx, 1
  01e84	89 55 e4	 mov	 DWORD PTR _i$[ebp], edx
$L61433:

; 1231 :          }

  01e87	e9 74 ff ff ff	 jmp	 $L61431
$L61432:

; 1232 : 
; 1233 :       M = i;

  01e8c	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  01e8f	89 45 cc	 mov	 DWORD PTR _M$[ebp], eax

; 1234 :       P0 = 0;

  01e92	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _P0$[ebp], 0

; 1235 :       for (PG = 0,PN = M-1;P0 < M-2;PG = 0 )

  01e99	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _PG$[ebp], 0
  01ea0	8b 4d cc	 mov	 ecx, DWORD PTR _M$[ebp]
  01ea3	83 e9 01	 sub	 ecx, 1
  01ea6	89 4d f4	 mov	 DWORD PTR _PN$[ebp], ecx
  01ea9	eb 07		 jmp	 SHORT $L61437
$L61438:
  01eab	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _PG$[ebp], 0
$L61437:
  01eb2	8b 55 cc	 mov	 edx, DWORD PTR _M$[ebp]
  01eb5	83 ea 02	 sub	 edx, 2
  01eb8	39 55 f0	 cmp	 DWORD PTR _P0$[ebp], edx
  01ebb	0f 8d 36 01 00
	00		 jge	 $L61439

; 1237 :          x = False;

  01ec1	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0

; 1238 :          for (;polylist[PG].n != 0;++PG)

  01ec8	eb 09		 jmp	 SHORT $L61440
$L61441:
  01eca	8b 45 d4	 mov	 eax, DWORD PTR _PG$[ebp]
  01ecd	83 c0 01	 add	 eax, 1
  01ed0	89 45 d4	 mov	 DWORD PTR _PG$[ebp], eax
$L61440:
  01ed3	8b 4d d4	 mov	 ecx, DWORD PTR _PG$[ebp]
  01ed6	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  01ed9	8b 55 18	 mov	 edx, DWORD PTR _polylist$[ebp]
  01edc	83 7c 0a 08 00	 cmp	 DWORD PTR [edx+ecx+8], 0
  01ee1	74 56		 je	 SHORT $L61442

; 1241 :                                  path[PN],
; 1242 :                                  polylist[PG].polyPoints,
; 1243 :                                  polylist[PG].n,
; 1244 :                                  &I1,
; 1245 :                                  &I2,
; 1246 :                                  &nodeI1,
; 1247 :                                  &nodeI2)
; 1248 :                )

  01ee3	8d 45 f8	 lea	 eax, DWORD PTR _nodeI2$[ebp]
  01ee6	50		 push	 eax
  01ee7	8d 4d d0	 lea	 ecx, DWORD PTR _nodeI1$[ebp]
  01eea	51		 push	 ecx
  01eeb	8d 55 e0	 lea	 edx, DWORD PTR _I2$[ebp]
  01eee	52		 push	 edx
  01eef	8d 45 e8	 lea	 eax, DWORD PTR _I1$[ebp]
  01ef2	50		 push	 eax
  01ef3	8b 4d d4	 mov	 ecx, DWORD PTR _PG$[ebp]
  01ef6	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  01ef9	8b 55 18	 mov	 edx, DWORD PTR _polylist$[ebp]
  01efc	8b 44 0a 08	 mov	 eax, DWORD PTR [edx+ecx+8]
  01f00	50		 push	 eax
  01f01	8b 4d d4	 mov	 ecx, DWORD PTR _PG$[ebp]
  01f04	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  01f07	8b 55 18	 mov	 edx, DWORD PTR _polylist$[ebp]
  01f0a	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  01f0d	50		 push	 eax
  01f0e	8b 4d f4	 mov	 ecx, DWORD PTR _PN$[ebp]
  01f11	8b 55 10	 mov	 edx, DWORD PTR _path$[ebp]
  01f14	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  01f17	50		 push	 eax
  01f18	8b 4d f0	 mov	 ecx, DWORD PTR _P0$[ebp]
  01f1b	8b 55 10	 mov	 edx, DWORD PTR _path$[ebp]
  01f1e	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  01f21	50		 push	 eax
  01f22	e8 00 00 00 00	 call	 ?IntersectPolygon@@YAHAAUSCI_Point@@0PAU1@H11PAH2@Z ; IntersectPolygon
  01f27	83 c4 20	 add	 esp, 32			; 00000020H
  01f2a	85 c0		 test	 eax, eax
  01f2c	74 09		 je	 SHORT $L61443

; 1250 :                x = True;

  01f2e	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _x$[ebp], 1

; 1251 :                break;

  01f35	eb 02		 jmp	 SHORT $L61442
$L61443:

; 1253 :             }

  01f37	eb 91		 jmp	 SHORT $L61441
$L61442:

; 1254 :          if (x)

  01f39	83 7d ec 00	 cmp	 DWORD PTR _x$[ebp], 0
  01f3d	74 2d		 je	 SHORT $L61444

; 1256 :             if (PN > P0+2) 

  01f3f	8b 4d f0	 mov	 ecx, DWORD PTR _P0$[ebp]
  01f42	83 c1 02	 add	 ecx, 2
  01f45	39 4d f4	 cmp	 DWORD PTR _PN$[ebp], ecx
  01f48	7e 0b		 jle	 SHORT $L61445

; 1257 :                PN -= 1;

  01f4a	8b 55 f4	 mov	 edx, DWORD PTR _PN$[ebp]
  01f4d	83 ea 01	 sub	 edx, 1
  01f50	89 55 f4	 mov	 DWORD PTR _PN$[ebp], edx

; 1258 :             else

  01f53	eb 12		 jmp	 SHORT $L61446
$L61445:

; 1260 :                P0 += 1;

  01f55	8b 45 f0	 mov	 eax, DWORD PTR _P0$[ebp]
  01f58	83 c0 01	 add	 eax, 1
  01f5b	89 45 f0	 mov	 DWORD PTR _P0$[ebp], eax

; 1261 :                PN = M-1;

  01f5e	8b 4d cc	 mov	 ecx, DWORD PTR _M$[ebp]
  01f61	83 e9 01	 sub	 ecx, 1
  01f64	89 4d f4	 mov	 DWORD PTR _PN$[ebp], ecx
$L61446:

; 1264 :          else

  01f67	e9 86 00 00 00	 jmp	 $L61447
$L61444:

; 1266 :             // eliminate nodes P0+1 through PN-1
; 1267 :             for (i=P0+1,j=PN,k=M-PN+1;k!=0;--k)

  01f6c	8b 55 f0	 mov	 edx, DWORD PTR _P0$[ebp]
  01f6f	83 c2 01	 add	 edx, 1
  01f72	89 55 e4	 mov	 DWORD PTR _i$[ebp], edx
  01f75	8b 45 f4	 mov	 eax, DWORD PTR _PN$[ebp]
  01f78	89 45 dc	 mov	 DWORD PTR _j$[ebp], eax
  01f7b	8b 4d cc	 mov	 ecx, DWORD PTR _M$[ebp]
  01f7e	2b 4d f4	 sub	 ecx, DWORD PTR _PN$[ebp]
  01f81	83 c1 01	 add	 ecx, 1
  01f84	89 4d d8	 mov	 DWORD PTR _k$[ebp], ecx
  01f87	eb 09		 jmp	 SHORT $L61448
$L61449:
  01f89	8b 55 d8	 mov	 edx, DWORD PTR _k$[ebp]
  01f8c	83 ea 01	 sub	 edx, 1
  01f8f	89 55 d8	 mov	 DWORD PTR _k$[ebp], edx
$L61448:
  01f92	83 7d d8 00	 cmp	 DWORD PTR _k$[ebp], 0
  01f96	74 38		 je	 SHORT $L61450

; 1269 :                path[i++] = path[j++];

  01f98	8b 45 dc	 mov	 eax, DWORD PTR _j$[ebp]
  01f9b	8b 4d 10	 mov	 ecx, DWORD PTR _path$[ebp]
  01f9e	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  01fa1	89 55 bc	 mov	 DWORD PTR -68+[ebp], edx
  01fa4	8b 45 bc	 mov	 eax, DWORD PTR -68+[ebp]
  01fa7	50		 push	 eax
  01fa8	8b 4d dc	 mov	 ecx, DWORD PTR _j$[ebp]
  01fab	83 c1 01	 add	 ecx, 1
  01fae	89 4d dc	 mov	 DWORD PTR _j$[ebp], ecx
  01fb1	8b 55 e4	 mov	 edx, DWORD PTR _i$[ebp]
  01fb4	8b 45 10	 mov	 eax, DWORD PTR _path$[ebp]
  01fb7	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  01fba	89 4d b8	 mov	 DWORD PTR -72+[ebp], ecx
  01fbd	8b 55 e4	 mov	 edx, DWORD PTR _i$[ebp]
  01fc0	83 c2 01	 add	 edx, 1
  01fc3	89 55 e4	 mov	 DWORD PTR _i$[ebp], edx
  01fc6	8b 4d b8	 mov	 ecx, DWORD PTR -72+[ebp]
  01fc9	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1270 :                }

  01fce	eb b9		 jmp	 SHORT $L61449
$L61450:

; 1271 :             M = M-PN+P0+1;

  01fd0	8b 45 cc	 mov	 eax, DWORD PTR _M$[ebp]
  01fd3	2b 45 f4	 sub	 eax, DWORD PTR _PN$[ebp]
  01fd6	8b 4d f0	 mov	 ecx, DWORD PTR _P0$[ebp]
  01fd9	8d 54 08 01	 lea	 edx, DWORD PTR [eax+ecx+1]
  01fdd	89 55 cc	 mov	 DWORD PTR _M$[ebp], edx

; 1272 :             PN = M-1;

  01fe0	8b 45 cc	 mov	 eax, DWORD PTR _M$[ebp]
  01fe3	83 e8 01	 sub	 eax, 1
  01fe6	89 45 f4	 mov	 DWORD PTR _PN$[ebp], eax

; 1273 :             P0 += 1;

  01fe9	8b 4d f0	 mov	 ecx, DWORD PTR _P0$[ebp]
  01fec	83 c1 01	 add	 ecx, 1
  01fef	89 4d f0	 mov	 DWORD PTR _P0$[ebp], ecx
$L61447:

; 1275 :          }

  01ff2	e9 b4 fe ff ff	 jmp	 $L61438
$L61439:
$L61405:

; 1277 : }

  01ff7	5e		 pop	 esi
  01ff8	8b e5		 mov	 esp, ebp
  01ffa	5d		 pop	 ebp
  01ffb	c3		 ret	 0
?OptimizePath@@YAXAAUSCI_Point@@0PAU1@PAVPolyNode@@PAVSOL_Polygon@@H@Z ENDP ; OptimizePath
_TEXT	ENDS
PUBLIC	?NodeDistance@@YAHHHHPAUSCI_Point@@HAAU1@1PAH@Z	; NodeDistance
_TEXT	SEGMENT
_A$ = 8
_B$ = 12
_points$ = 16
_n$ = 20
_I1$ = 24
_I2$ = 28
_nodeI1$ = 32
_nodeI2$ = 36
_distA$ = -8
_distB$ = -16
_offScreenA$ = -12
_offScreenB$ = -4
?PolygonPath@@YAHAAUSCI_Point@@0PAU1@H11PAH2@Z PROC NEAR ; PolygonPath

; 1326 : {

  01ffc	55		 push	 ebp
  01ffd	8b ec		 mov	 ebp, esp
  01fff	83 ec 10	 sub	 esp, 16			; 00000010H

; 1327 :    int   distA,distB;
; 1328 :    int   offScreenA=False,offScreenB=False;

  02002	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _offScreenA$[ebp], 0
  02009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _offScreenB$[ebp], 0

; 1329 : 
; 1330 :    if (!IntersectPolygon(A,B,points,n,I1,I2,nodeI1,nodeI2)) return 0;

  02010	8b 45 24	 mov	 eax, DWORD PTR _nodeI2$[ebp]
  02013	50		 push	 eax
  02014	8b 4d 20	 mov	 ecx, DWORD PTR _nodeI1$[ebp]
  02017	51		 push	 ecx
  02018	8b 55 1c	 mov	 edx, DWORD PTR _I2$[ebp]
  0201b	52		 push	 edx
  0201c	8b 45 18	 mov	 eax, DWORD PTR _I1$[ebp]
  0201f	50		 push	 eax
  02020	8b 4d 14	 mov	 ecx, DWORD PTR _n$[ebp]
  02023	51		 push	 ecx
  02024	8b 55 10	 mov	 edx, DWORD PTR _points$[ebp]
  02027	52		 push	 edx
  02028	8b 45 0c	 mov	 eax, DWORD PTR _B$[ebp]
  0202b	50		 push	 eax
  0202c	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  0202f	51		 push	 ecx
  02030	e8 00 00 00 00	 call	 ?IntersectPolygon@@YAHAAUSCI_Point@@0PAU1@H11PAH2@Z ; IntersectPolygon
  02035	83 c4 20	 add	 esp, 32			; 00000020H
  02038	85 c0		 test	 eax, eax
  0203a	75 07		 jne	 SHORT $L61465
  0203c	33 c0		 xor	 eax, eax
  0203e	e9 00 01 00 00	 jmp	 $L61471
$L61465:

; 1331 :    if (*nodeI1 == *nodeI2) return 0;

  02043	8b 55 20	 mov	 edx, DWORD PTR _nodeI1$[ebp]
  02046	8b 45 24	 mov	 eax, DWORD PTR _nodeI2$[ebp]
  02049	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0204b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0204d	75 07		 jne	 SHORT $L61466
  0204f	33 c0		 xor	 eax, eax
  02051	e9 ed 00 00 00	 jmp	 $L61471
$L61466:

; 1332 :    //  nodeI1 = P[0]; first node
; 1333 :    //  nodeI2 = P[n - i]; last node
; 1334 :    distA = NodeDistance(1,*nodeI1 + 1,*nodeI2,points,n,*I1,*I2,&offScreenA); 

  02056	8d 55 f4	 lea	 edx, DWORD PTR _offScreenA$[ebp]
  02059	52		 push	 edx
  0205a	8b 45 1c	 mov	 eax, DWORD PTR _I2$[ebp]
  0205d	50		 push	 eax
  0205e	8b 4d 18	 mov	 ecx, DWORD PTR _I1$[ebp]
  02061	51		 push	 ecx
  02062	8b 55 14	 mov	 edx, DWORD PTR _n$[ebp]
  02065	52		 push	 edx
  02066	8b 45 10	 mov	 eax, DWORD PTR _points$[ebp]
  02069	50		 push	 eax
  0206a	8b 4d 24	 mov	 ecx, DWORD PTR _nodeI2$[ebp]
  0206d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0206f	52		 push	 edx
  02070	8b 45 20	 mov	 eax, DWORD PTR _nodeI1$[ebp]
  02073	8b 08		 mov	 ecx, DWORD PTR [eax]
  02075	83 c1 01	 add	 ecx, 1
  02078	51		 push	 ecx
  02079	6a 01		 push	 1
  0207b	e8 00 00 00 00	 call	 ?NodeDistance@@YAHHHHPAUSCI_Point@@HAAU1@1PAH@Z ; NodeDistance
  02080	83 c4 20	 add	 esp, 32			; 00000020H
  02083	89 45 f8	 mov	 DWORD PTR _distA$[ebp], eax

; 1335 :    distB = NodeDistance(-1,*nodeI1,*nodeI2 + 1,points,n,*I1,*I2,&offScreenB);

  02086	8d 55 fc	 lea	 edx, DWORD PTR _offScreenB$[ebp]
  02089	52		 push	 edx
  0208a	8b 45 1c	 mov	 eax, DWORD PTR _I2$[ebp]
  0208d	50		 push	 eax
  0208e	8b 4d 18	 mov	 ecx, DWORD PTR _I1$[ebp]
  02091	51		 push	 ecx
  02092	8b 55 14	 mov	 edx, DWORD PTR _n$[ebp]
  02095	52		 push	 edx
  02096	8b 45 10	 mov	 eax, DWORD PTR _points$[ebp]
  02099	50		 push	 eax
  0209a	8b 4d 24	 mov	 ecx, DWORD PTR _nodeI2$[ebp]
  0209d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0209f	83 c2 01	 add	 edx, 1
  020a2	52		 push	 edx
  020a3	8b 45 20	 mov	 eax, DWORD PTR _nodeI1$[ebp]
  020a6	8b 08		 mov	 ecx, DWORD PTR [eax]
  020a8	51		 push	 ecx
  020a9	6a ff		 push	 -1
  020ab	e8 00 00 00 00	 call	 ?NodeDistance@@YAHHHHPAUSCI_Point@@HAAU1@1PAH@Z ; NodeDistance
  020b0	83 c4 20	 add	 esp, 32			; 00000020H
  020b3	89 45 f0	 mov	 DWORD PTR _distB$[ebp], eax

; 1336 :    if (offScreenA && (!offScreenB))

  020b6	83 7d f4 00	 cmp	 DWORD PTR _offScreenA$[ebp], 0
  020ba	74 1c		 je	 SHORT $L61467
  020bc	83 7d fc 00	 cmp	 DWORD PTR _offScreenB$[ebp], 0
  020c0	75 16		 jne	 SHORT $L61467

; 1338 :       *nodeI2 = (*nodeI2+1) % n;

  020c2	8b 55 24	 mov	 edx, DWORD PTR _nodeI2$[ebp]
  020c5	8b 02		 mov	 eax, DWORD PTR [edx]
  020c7	83 c0 01	 add	 eax, 1
  020ca	99		 cdq
  020cb	f7 7d 14	 idiv	 DWORD PTR _n$[ebp]
  020ce	8b 45 24	 mov	 eax, DWORD PTR _nodeI2$[ebp]
  020d1	89 10		 mov	 DWORD PTR [eax], edx

; 1339 :       return -1;

  020d3	83 c8 ff	 or	 eax, -1
  020d6	eb 6b		 jmp	 SHORT $L61471
$L61467:

; 1341 :    if ((!offScreenA) && offScreenB)

  020d8	83 7d f4 00	 cmp	 DWORD PTR _offScreenA$[ebp], 0
  020dc	75 1e		 jne	 SHORT $L61468
  020de	83 7d fc 00	 cmp	 DWORD PTR _offScreenB$[ebp], 0
  020e2	74 18		 je	 SHORT $L61468

; 1343 :       *nodeI1 = (*nodeI1+1) % n;

  020e4	8b 4d 20	 mov	 ecx, DWORD PTR _nodeI1$[ebp]
  020e7	8b 01		 mov	 eax, DWORD PTR [ecx]
  020e9	83 c0 01	 add	 eax, 1
  020ec	99		 cdq
  020ed	f7 7d 14	 idiv	 DWORD PTR _n$[ebp]
  020f0	8b 45 20	 mov	 eax, DWORD PTR _nodeI1$[ebp]
  020f3	89 10		 mov	 DWORD PTR [eax], edx

; 1344 :       return 1;

  020f5	b8 01 00 00 00	 mov	 eax, 1
  020fa	eb 47		 jmp	 SHORT $L61471
$L61468:

; 1346 :    if (offScreenA && offScreenB)

  020fc	83 7d f4 00	 cmp	 DWORD PTR _offScreenA$[ebp], 0
  02100	74 0d		 je	 SHORT $L61469
  02102	83 7d fc 00	 cmp	 DWORD PTR _offScreenB$[ebp], 0
  02106	74 07		 je	 SHORT $L61469

; 1347 :       // No way around
; 1348 :       return 2;

  02108	b8 02 00 00 00	 mov	 eax, 2
  0210d	eb 34		 jmp	 SHORT $L61471
$L61469:

; 1349 : 
; 1350 :    if (distA < distB)

  0210f	8b 4d f8	 mov	 ecx, DWORD PTR _distA$[ebp]
  02112	3b 4d f0	 cmp	 ecx, DWORD PTR _distB$[ebp]
  02115	7d 18		 jge	 SHORT $L61470

; 1352 :       *nodeI1 = (*nodeI1+1) % n;

  02117	8b 55 20	 mov	 edx, DWORD PTR _nodeI1$[ebp]
  0211a	8b 02		 mov	 eax, DWORD PTR [edx]
  0211c	83 c0 01	 add	 eax, 1
  0211f	99		 cdq
  02120	f7 7d 14	 idiv	 DWORD PTR _n$[ebp]
  02123	8b 45 20	 mov	 eax, DWORD PTR _nodeI1$[ebp]
  02126	89 10		 mov	 DWORD PTR [eax], edx

; 1353 :       return 1;

  02128	b8 01 00 00 00	 mov	 eax, 1
  0212d	eb 14		 jmp	 SHORT $L61471
$L61470:

; 1357 :       *nodeI2 = (*nodeI2+1) % n;

  0212f	8b 4d 24	 mov	 ecx, DWORD PTR _nodeI2$[ebp]
  02132	8b 01		 mov	 eax, DWORD PTR [ecx]
  02134	83 c0 01	 add	 eax, 1
  02137	99		 cdq
  02138	f7 7d 14	 idiv	 DWORD PTR _n$[ebp]
  0213b	8b 45 24	 mov	 eax, DWORD PTR _nodeI2$[ebp]
  0213e	89 10		 mov	 DWORD PTR [eax], edx

; 1358 :       return -1;

  02140	83 c8 ff	 or	 eax, -1
$L61471:

; 1360 : }

  02143	8b e5		 mov	 esp, ebp
  02145	5d		 pop	 ebp
  02146	c3		 ret	 0
?PolygonPath@@YAHAAUSCI_Point@@0PAU1@H11PAH2@Z ENDP	; PolygonPath
_direction$ = 8
_nodeF$ = 12
_nodeL$ = 16
_points$ = 20
_n$ = 24
_I1$ = 28
_I2$ = 32
_offScreen$ = 36
_distance$ = -4
_nodeM$ = -16
_P1$ = -8
_P2$ = -12
?NodeDistance@@YAHHHHPAUSCI_Point@@HAAU1@1PAH@Z PROC NEAR ; NodeDistance

; 1371 : {

  02147	55		 push	 ebp
  02148	8b ec		 mov	 ebp, esp
  0214a	83 ec 10	 sub	 esp, 16			; 00000010H

; 1372 :    int         distance = 0;

  0214d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _distance$[ebp], 0

; 1373 :    int         nodeM;
; 1374 :    SCI_Point   P1,P2;

  02154	8d 4d f8	 lea	 ecx, DWORD PTR _P1$[ebp]
  02157	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  0215c	8d 4d f4	 lea	 ecx, DWORD PTR _P2$[ebp]
  0215f	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point

; 1375 : 
; 1376 :    nodeM = nodeF = nodeF % n;

  02164	8b 45 0c	 mov	 eax, DWORD PTR _nodeF$[ebp]
  02167	99		 cdq
  02168	f7 7d 18	 idiv	 DWORD PTR _n$[ebp]
  0216b	89 55 0c	 mov	 DWORD PTR _nodeF$[ebp], edx
  0216e	8b 45 0c	 mov	 eax, DWORD PTR _nodeF$[ebp]
  02171	89 45 f0	 mov	 DWORD PTR _nodeM$[ebp], eax

; 1377 :    nodeL = nodeL % n;

  02174	8b 45 10	 mov	 eax, DWORD PTR _nodeL$[ebp]
  02177	99		 cdq
  02178	f7 7d 18	 idiv	 DWORD PTR _n$[ebp]
  0217b	89 55 10	 mov	 DWORD PTR _nodeL$[ebp], edx

; 1378 :    P1 = points[nodeM];

  0217e	8b 4d f0	 mov	 ecx, DWORD PTR _nodeM$[ebp]
  02181	8b 55 14	 mov	 edx, DWORD PTR _points$[ebp]
  02184	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  02187	50		 push	 eax
  02188	8d 4d f8	 lea	 ecx, DWORD PTR _P1$[ebp]
  0218b	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=
$L61487:

; 1379 :    for (;nodeM != nodeL;)

  02190	8b 4d f0	 mov	 ecx, DWORD PTR _nodeM$[ebp]
  02193	3b 4d 10	 cmp	 ecx, DWORD PTR _nodeL$[ebp]
  02196	74 4c		 je	 SHORT $L61488

; 1381 :       // adding n to mod to force nodeM positive
; 1382 :       nodeM = (nodeM + direction + n) % n;

  02198	8b 45 f0	 mov	 eax, DWORD PTR _nodeM$[ebp]
  0219b	03 45 08	 add	 eax, DWORD PTR _direction$[ebp]
  0219e	03 45 18	 add	 eax, DWORD PTR _n$[ebp]
  021a1	99		 cdq
  021a2	f7 7d 18	 idiv	 DWORD PTR _n$[ebp]
  021a5	89 55 f0	 mov	 DWORD PTR _nodeM$[ebp], edx

; 1383 :       P2 = points[nodeM];

  021a8	8b 55 f0	 mov	 edx, DWORD PTR _nodeM$[ebp]
  021ab	8b 45 14	 mov	 eax, DWORD PTR _points$[ebp]
  021ae	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  021b1	51		 push	 ecx
  021b2	8d 4d f4	 lea	 ecx, DWORD PTR _P2$[ebp]
  021b5	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1384 :    // DistanceEstimate is more accurate than the sum 
; 1385 :    // of the squares of the distances for deciding 
; 1386 :    // which way around a polygon is shorter.
; 1387 : 
; 1388 :       distance += DistanceEstimate(P2,P1,offScreen);

  021ba	8b 55 24	 mov	 edx, DWORD PTR _offScreen$[ebp]
  021bd	52		 push	 edx
  021be	8d 45 f8	 lea	 eax, DWORD PTR _P1$[ebp]
  021c1	50		 push	 eax
  021c2	8d 4d f4	 lea	 ecx, DWORD PTR _P2$[ebp]
  021c5	51		 push	 ecx
  021c6	e8 00 00 00 00	 call	 ?DistanceEstimate@@YAHAAUSCI_Point@@0PAH@Z ; DistanceEstimate
  021cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  021ce	8b 55 fc	 mov	 edx, DWORD PTR _distance$[ebp]
  021d1	03 d0		 add	 edx, eax
  021d3	89 55 fc	 mov	 DWORD PTR _distance$[ebp], edx

; 1389 :       P1 = P2;

  021d6	8d 45 f4	 lea	 eax, DWORD PTR _P2$[ebp]
  021d9	50		 push	 eax
  021da	8d 4d f8	 lea	 ecx, DWORD PTR _P1$[ebp]
  021dd	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1390 :       }

  021e2	eb ac		 jmp	 SHORT $L61487
$L61488:

; 1391 :    if (distance>0)

  021e4	83 7d fc 00	 cmp	 DWORD PTR _distance$[ebp], 0
  021e8	7e 46		 jle	 SHORT $L61489

; 1393 :       distance += DistanceEstimate(I1,points[nodeF],offScreen);

  021ea	8b 4d 24	 mov	 ecx, DWORD PTR _offScreen$[ebp]
  021ed	51		 push	 ecx
  021ee	8b 55 0c	 mov	 edx, DWORD PTR _nodeF$[ebp]
  021f1	8b 45 14	 mov	 eax, DWORD PTR _points$[ebp]
  021f4	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  021f7	51		 push	 ecx
  021f8	8b 55 1c	 mov	 edx, DWORD PTR _I1$[ebp]
  021fb	52		 push	 edx
  021fc	e8 00 00 00 00	 call	 ?DistanceEstimate@@YAHAAUSCI_Point@@0PAH@Z ; DistanceEstimate
  02201	83 c4 0c	 add	 esp, 12			; 0000000cH
  02204	8b 4d fc	 mov	 ecx, DWORD PTR _distance$[ebp]
  02207	03 c8		 add	 ecx, eax
  02209	89 4d fc	 mov	 DWORD PTR _distance$[ebp], ecx

; 1394 :       distance += DistanceEstimate(points[nodeL],I2,offScreen);

  0220c	8b 55 24	 mov	 edx, DWORD PTR _offScreen$[ebp]
  0220f	52		 push	 edx
  02210	8b 45 20	 mov	 eax, DWORD PTR _I2$[ebp]
  02213	50		 push	 eax
  02214	8b 4d 10	 mov	 ecx, DWORD PTR _nodeL$[ebp]
  02217	8b 55 14	 mov	 edx, DWORD PTR _points$[ebp]
  0221a	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  0221d	50		 push	 eax
  0221e	e8 00 00 00 00	 call	 ?DistanceEstimate@@YAHAAUSCI_Point@@0PAH@Z ; DistanceEstimate
  02223	83 c4 0c	 add	 esp, 12			; 0000000cH
  02226	8b 4d fc	 mov	 ecx, DWORD PTR _distance$[ebp]
  02229	03 c8		 add	 ecx, eax
  0222b	89 4d fc	 mov	 DWORD PTR _distance$[ebp], ecx

; 1396 :    else

  0222e	eb 44		 jmp	 SHORT $L61490
$L61489:

; 1398 :       distance += DistanceEstimate(I1,points[nodeF],offScreen);

  02230	8b 55 24	 mov	 edx, DWORD PTR _offScreen$[ebp]
  02233	52		 push	 edx
  02234	8b 45 0c	 mov	 eax, DWORD PTR _nodeF$[ebp]
  02237	8b 4d 14	 mov	 ecx, DWORD PTR _points$[ebp]
  0223a	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  0223d	52		 push	 edx
  0223e	8b 45 1c	 mov	 eax, DWORD PTR _I1$[ebp]
  02241	50		 push	 eax
  02242	e8 00 00 00 00	 call	 ?DistanceEstimate@@YAHAAUSCI_Point@@0PAH@Z ; DistanceEstimate
  02247	83 c4 0c	 add	 esp, 12			; 0000000cH
  0224a	8b 4d fc	 mov	 ecx, DWORD PTR _distance$[ebp]
  0224d	03 c8		 add	 ecx, eax
  0224f	89 4d fc	 mov	 DWORD PTR _distance$[ebp], ecx

; 1399 :       distance += DistanceEstimate(points[nodeL],I2,offScreen);

  02252	8b 55 24	 mov	 edx, DWORD PTR _offScreen$[ebp]
  02255	52		 push	 edx
  02256	8b 45 20	 mov	 eax, DWORD PTR _I2$[ebp]
  02259	50		 push	 eax
  0225a	8b 4d 10	 mov	 ecx, DWORD PTR _nodeL$[ebp]
  0225d	8b 55 14	 mov	 edx, DWORD PTR _points$[ebp]
  02260	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  02263	50		 push	 eax
  02264	e8 00 00 00 00	 call	 ?DistanceEstimate@@YAHAAUSCI_Point@@0PAH@Z ; DistanceEstimate
  02269	83 c4 0c	 add	 esp, 12			; 0000000cH
  0226c	8b 4d fc	 mov	 ecx, DWORD PTR _distance$[ebp]
  0226f	03 c8		 add	 ecx, eax
  02271	89 4d fc	 mov	 DWORD PTR _distance$[ebp], ecx
$L61490:

; 1401 :    return(distance);

  02274	8b 45 fc	 mov	 eax, DWORD PTR _distance$[ebp]

; 1402 : }

  02277	8b e5		 mov	 esp, ebp
  02279	5d		 pop	 ebp
  0227a	c3		 ret	 0
?NodeDistance@@YAHHHHPAUSCI_Point@@HAAU1@1PAH@Z ENDP	; NodeDistance
_TEXT	ENDS
PUBLIC	?IntersectSegments@@YAHAAUSCI_Point@@000PAU1@@Z	; IntersectSegments
PUBLIC	?NodeTest@@YAHAAUSCI_Point@@000@Z		; NodeTest
_TEXT	SEGMENT
_A$ = 8
_B$ = 12
_points$ = 16
_n$ = 20
_INT1$ = 24
_INT2$ = 28
_nodeI1$ = 32
_nodeI2$ = 36
_distA$ = -16
_distB$ = -20
_d$ = -12
_N1$ = -80
_N2$ = -88
_P1$ = -24
_P2$ = -32
_P3$ = -40
_W$ = -28
_F1$ = -76
_tmp1$ = -60
_tmp2$ = -64
_tmp3$ = -72
_tmp4$ = -84
_I1$ = -52
_I2$ = -56
_intersection$ = -8
_i$ = -48
_node$ = -4
_nextnode$ = -68
_f1$ = -92
_t1$ = -36
_t2$ = -44
$T62424 = -96
$T62425 = -100
$T62426 = -104
$T62427 = -108
$T62428 = -112
$T62429 = -116
$T62430 = -120
$T62431 = -124
$T62432 = -128
$T62433 = -132
$T62434 = -136
$T62435 = -140
$T62436 = -144
$T62437 = -148
$T62438 = -152
$T62439 = -156
$T62440 = -160
$T62441 = -164
$T62442 = -168
$T62443 = -172
$T62444 = -176
$T62445 = -180
$T62446 = -184
$T62447 = -188
$T62448 = -192
$T62449 = -196
$T62450 = -200
$T62451 = -204
$T62452 = -208
?IntersectPolygon@@YAHAAUSCI_Point@@0PAU1@H11PAH2@Z PROC NEAR ; IntersectPolygon

; 1429 : {

  0227b	55		 push	 ebp
  0227c	8b ec		 mov	 ebp, esp
  0227e	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  02284	56		 push	 esi

; 1430 :    int         distA = INT_MAX,distB = INT_MAX,d;

  02285	c7 45 f0 ff ff
	ff 7f		 mov	 DWORD PTR _distA$[ebp], 2147483647 ; 7fffffffH
  0228c	c7 45 ec ff ff
	ff 7f		 mov	 DWORD PTR _distB$[ebp], 2147483647 ; 7fffffffH

; 1431 :    SCI_Point   N1,N2,P1,P2,P3,W,F1,tmp1,tmp2,tmp3,tmp4,I1,I2;

  02293	8d 4d b0	 lea	 ecx, DWORD PTR _N1$[ebp]
  02296	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  0229b	8d 4d a8	 lea	 ecx, DWORD PTR _N2$[ebp]
  0229e	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  022a3	8d 4d e8	 lea	 ecx, DWORD PTR _P1$[ebp]
  022a6	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  022ab	8d 4d e0	 lea	 ecx, DWORD PTR _P2$[ebp]
  022ae	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  022b3	8d 4d d8	 lea	 ecx, DWORD PTR _P3$[ebp]
  022b6	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  022bb	8d 4d e4	 lea	 ecx, DWORD PTR _W$[ebp]
  022be	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  022c3	8d 4d b4	 lea	 ecx, DWORD PTR _F1$[ebp]
  022c6	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  022cb	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  022ce	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  022d3	8d 4d c0	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  022d6	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  022db	8d 4d b8	 lea	 ecx, DWORD PTR _tmp3$[ebp]
  022de	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  022e3	8d 4d ac	 lea	 ecx, DWORD PTR _tmp4$[ebp]
  022e6	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  022eb	8d 4d cc	 lea	 ecx, DWORD PTR _I1$[ebp]
  022ee	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  022f3	8d 4d c8	 lea	 ecx, DWORD PTR _I2$[ebp]
  022f6	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point

; 1432 :    SCI_Point   intersection;

  022fb	8d 4d f8	 lea	 ecx, DWORD PTR _intersection$[ebp]
  022fe	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point

; 1433 :    int         i,node,nextnode,f1,t1,t2;                             
; 1434 :    N1 = points[0];                                            

  02303	8b 45 10	 mov	 eax, DWORD PTR _points$[ebp]
  02306	50		 push	 eax
  02307	8d 4d b0	 lea	 ecx, DWORD PTR _N1$[ebp]
  0230a	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1435 :    P1 = N1;                                              

  0230f	8d 4d b0	 lea	 ecx, DWORD PTR _N1$[ebp]
  02312	51		 push	 ecx
  02313	8d 4d e8	 lea	 ecx, DWORD PTR _P1$[ebp]
  02316	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1436 :    N2 = points[1];

  0231b	8b 55 10	 mov	 edx, DWORD PTR _points$[ebp]
  0231e	83 c2 04	 add	 edx, 4
  02321	52		 push	 edx
  02322	8d 4d a8	 lea	 ecx, DWORD PTR _N2$[ebp]
  02325	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1437 :    P2 = points[1];

  0232a	8b 45 10	 mov	 eax, DWORD PTR _points$[ebp]
  0232d	83 c0 04	 add	 eax, 4
  02330	50		 push	 eax
  02331	8d 4d e0	 lea	 ecx, DWORD PTR _P2$[ebp]
  02334	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1438 :    P3 = points[2];

  02339	8b 4d 10	 mov	 ecx, DWORD PTR _points$[ebp]
  0233c	83 c1 08	 add	 ecx, 8
  0233f	51		 push	 ecx
  02340	8d 4d d8	 lea	 ecx, DWORD PTR _P3$[ebp]
  02343	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1439 :    i = 0; node = 0; // first three nodes already taken

  02348	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0234f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _node$[ebp], 0

; 1440 :    f1 = IntersectSegments(A,B,P1,P2,&intersection);

  02356	8d 55 f8	 lea	 edx, DWORD PTR _intersection$[ebp]
  02359	52		 push	 edx
  0235a	8d 45 e0	 lea	 eax, DWORD PTR _P2$[ebp]
  0235d	50		 push	 eax
  0235e	8d 4d e8	 lea	 ecx, DWORD PTR _P1$[ebp]
  02361	51		 push	 ecx
  02362	8b 55 0c	 mov	 edx, DWORD PTR _B$[ebp]
  02365	52		 push	 edx
  02366	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  02369	50		 push	 eax
  0236a	e8 00 00 00 00	 call	 ?IntersectSegments@@YAHAAUSCI_Point@@000PAU1@@Z ; IntersectSegments
  0236f	83 c4 14	 add	 esp, 20			; 00000014H
  02372	89 45 a4	 mov	 DWORD PTR _f1$[ebp], eax

; 1441 :    t1 = f1;

  02375	8b 4d a4	 mov	 ecx, DWORD PTR _f1$[ebp]
  02378	89 4d dc	 mov	 DWORD PTR _t1$[ebp], ecx

; 1442 :    F1 = intersection;

  0237b	8d 55 f8	 lea	 edx, DWORD PTR _intersection$[ebp]
  0237e	52		 push	 edx
  0237f	8d 4d b4	 lea	 ecx, DWORD PTR _F1$[ebp]
  02382	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1443 :    nextnode = 2;

  02387	c7 45 bc 02 00
	00 00		 mov	 DWORD PTR _nextnode$[ebp], 2
$start$61524:

; 1444 : 
; 1445 : start:
; 1446 :    t2 = IntersectSegments(A,B,P2,P3,&W);

  0238e	8d 45 e4	 lea	 eax, DWORD PTR _W$[ebp]
  02391	50		 push	 eax
  02392	8d 4d d8	 lea	 ecx, DWORD PTR _P3$[ebp]
  02395	51		 push	 ecx
  02396	8d 55 e0	 lea	 edx, DWORD PTR _P2$[ebp]
  02399	52		 push	 edx
  0239a	8b 45 0c	 mov	 eax, DWORD PTR _B$[ebp]
  0239d	50		 push	 eax
  0239e	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  023a1	51		 push	 ecx
  023a2	e8 00 00 00 00	 call	 ?IntersectSegments@@YAHAAUSCI_Point@@000PAU1@@Z ; IntersectSegments
  023a7	83 c4 14	 add	 esp, 20			; 00000014H
  023aa	89 45 d4	 mov	 DWORD PTR _t2$[ebp], eax

; 1447 :    if ((t1 == NOINTERSECT) || (t1 == INTERSECT+INTERSECTC))

  023ad	83 7d dc ff	 cmp	 DWORD PTR _t1$[ebp], -1
  023b1	74 0a		 je	 SHORT $getnextnode$61527
  023b3	83 7d dc 09	 cmp	 DWORD PTR _t1$[ebp], 9
  023b7	0f 85 dc 00 00
	00		 jne	 $L61525
$getnextnode$61527:

; 1449 : getnextnode:
; 1450 :       t1 = t2;

  023bd	8b 55 d4	 mov	 edx, DWORD PTR _t2$[ebp]
  023c0	89 55 dc	 mov	 DWORD PTR _t1$[ebp], edx

; 1451 :       P1 = P2;

  023c3	8d 45 e0	 lea	 eax, DWORD PTR _P2$[ebp]
  023c6	50		 push	 eax
  023c7	8d 4d e8	 lea	 ecx, DWORD PTR _P1$[ebp]
  023ca	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1452 :       P2 = P3;

  023cf	8d 4d d8	 lea	 ecx, DWORD PTR _P3$[ebp]
  023d2	51		 push	 ecx
  023d3	8d 4d e0	 lea	 ecx, DWORD PTR _P2$[ebp]
  023d6	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1453 :       intersection = W;

  023db	8d 55 e4	 lea	 edx, DWORD PTR _W$[ebp]
  023de	52		 push	 edx
  023df	8d 4d f8	 lea	 ecx, DWORD PTR _intersection$[ebp]
  023e2	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1454 :       ++ node;

  023e7	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  023ea	83 c0 01	 add	 eax, 1
  023ed	89 45 fc	 mov	 DWORD PTR _node$[ebp], eax

; 1455 :       if ((n-1) <= nextnode)

  023f0	8b 4d 14	 mov	 ecx, DWORD PTR _n$[ebp]
  023f3	83 e9 01	 sub	 ecx, 1
  023f6	3b 4d bc	 cmp	 ecx, DWORD PTR _nextnode$[ebp]
  023f9	7f 7e		 jg	 SHORT $L61528

; 1456 :          if (P3.x == N2.x && P3.y == N2.y)

  023fb	0f bf 55 d8	 movsx	 edx, WORD PTR _P3$[ebp]
  023ff	0f bf 45 a8	 movsx	 eax, WORD PTR _N2$[ebp]
  02403	3b d0		 cmp	 edx, eax
  02405	75 2c		 jne	 SHORT $L61529
  02407	0f bf 4d da	 movsx	 ecx, WORD PTR _P3$[ebp+2]
  0240b	0f bf 55 aa	 movsx	 edx, WORD PTR _N2$[ebp+2]
  0240f	3b ca		 cmp	 ecx, edx
  02411	75 20		 jne	 SHORT $L61529

; 1458 :             *INT1 = I1;

  02413	8d 45 cc	 lea	 eax, DWORD PTR _I1$[ebp]
  02416	50		 push	 eax
  02417	8b 4d 18	 mov	 ecx, DWORD PTR _INT1$[ebp]
  0241a	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1459 :             *INT2 = I2;

  0241f	8d 4d c8	 lea	 ecx, DWORD PTR _I2$[ebp]
  02422	51		 push	 ecx
  02423	8b 4d 1c	 mov	 ecx, DWORD PTR _INT2$[ebp]
  02426	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1460 :             return(i);

  0242b	8b 45 d0	 mov	 eax, DWORD PTR _i$[ebp]
  0242e	e9 65 06 00 00	 jmp	 $L61500
$L61529:

; 1463 :             if (P3.x == N1.x && P3.y == N1.y)

  02433	0f bf 55 d8	 movsx	 edx, WORD PTR _P3$[ebp]
  02437	0f bf 45 b0	 movsx	 eax, WORD PTR _N1$[ebp]
  0243b	3b d0		 cmp	 edx, eax
  0243d	75 2c		 jne	 SHORT $L61531
  0243f	0f bf 4d da	 movsx	 ecx, WORD PTR _P3$[ebp+2]
  02443	0f bf 55 b2	 movsx	 edx, WORD PTR _N1$[ebp+2]
  02447	3b ca		 cmp	 ecx, edx
  02449	75 20		 jne	 SHORT $L61531

; 1465 :                P3 = N2;

  0244b	8d 45 a8	 lea	 eax, DWORD PTR _N2$[ebp]
  0244e	50		 push	 eax
  0244f	8d 4d d8	 lea	 ecx, DWORD PTR _P3$[ebp]
  02452	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1466 :                t2 = f1;

  02457	8b 4d a4	 mov	 ecx, DWORD PTR _f1$[ebp]
  0245a	89 4d d4	 mov	 DWORD PTR _t2$[ebp], ecx

; 1467 :                W = F1;

  0245d	8d 55 b4	 lea	 edx, DWORD PTR _F1$[ebp]
  02460	52		 push	 edx
  02461	8d 4d e4	 lea	 ecx, DWORD PTR _W$[ebp]
  02464	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1469 :             else 

  02469	eb 0c		 jmp	 SHORT $L61532
$L61531:

; 1471 :                P3 = N1;

  0246b	8d 45 b0	 lea	 eax, DWORD PTR _N1$[ebp]
  0246e	50		 push	 eax
  0246f	8d 4d d8	 lea	 ecx, DWORD PTR _P3$[ebp]
  02472	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=
$L61532:

; 1473 :       else

  02477	eb 1b		 jmp	 SHORT $L61533
$L61528:

; 1474 :          P3 = points[++nextnode];

  02479	8b 4d bc	 mov	 ecx, DWORD PTR _nextnode$[ebp]
  0247c	83 c1 01	 add	 ecx, 1
  0247f	89 4d bc	 mov	 DWORD PTR _nextnode$[ebp], ecx
  02482	8b 55 bc	 mov	 edx, DWORD PTR _nextnode$[ebp]
  02485	8b 45 10	 mov	 eax, DWORD PTR _points$[ebp]
  02488	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  0248b	51		 push	 ecx
  0248c	8d 4d d8	 lea	 ecx, DWORD PTR _P3$[ebp]
  0248f	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=
$L61533:

; 1475 :       goto start;

  02494	e9 f5 fe ff ff	 jmp	 $start$61524
$L61525:

; 1479 :       if (t1 == COLINEAR)

  02499	83 7d dc 00	 cmp	 DWORD PTR _t1$[ebp], 0
  0249d	0f 85 6c 01 00
	00		 jne	 $L61535

; 1481 :          /* If P1-P2 is colinear with A-B and A-B contains P2, then
; 1482 :             one of the following cases must apply. This is because 
; 1483 :             all polygon must be defined in a mathematical counter
; 1484 :             clockwise direction.
; 1485 :             For example:
; 1486 :             
; 1487 :                P1      P2                           There is an 
; 1488 :          A-----*********----------------------B     intersection at P2
; 1489 :                         *
; 1490 :                          *
; 1491 :                OUTSIDE    *     INSIDE
; 1492 :                            *
; 1493 :                             *
; 1494 :                              *                  
; 1495 :                              P3
; 1496 : 
; 1497 :                
; 1498 : 
; 1499 :                              *
; 1500 :                             *
; 1501 :                INSIDE      *
; 1502 :                           *   OUTSIDE
; 1503 :                          *
; 1504 :                P1     P2*                           There is no 
; 1505 :          A-----*********----------------------B     intersection at P2
; 1506 :                          
; 1507 :                           
; 1508 :                                 
; 1509 :                             
; 1510 : 
; 1511 :              
; 1512 :          IF A=P2 OR B=P2
; 1513 : 
; 1514 : 
; 1515 :                P1      P2,A                         There is an 
; 1516 :                *********----------------------B     intersection at P2
; 1517 :                         *
; 1518 :                          *
; 1519 :                OUTSIDE    *     INSIDE
; 1520 :                            *
; 1521 :                             *
; 1522 :                              *             
; 1523 :                              P3
; 1524 : 
; 1525 :                
; 1526 :                P1      P2,A                         There is no 
; 1527 :          B-----*********                            intersection at P2
; 1528 :                         *
; 1529 :                          *
; 1530 :                OUTSIDE    *     INSIDE
; 1531 :                            *
; 1532 :                             *
; 1533 :                              *                    
; 1534 :                              P3
; 1535 : 
; 1536 : 
; 1537 : 
; 1538 :                P1      P2,B                         There is an 
; 1539 :                *********----------------------A     intersection at P2
; 1540 :                         *
; 1541 :                          *
; 1542 :                OUTSIDE    *     INSIDE
; 1543 :                            *
; 1544 :                             *
; 1545 :                              *                            
; 1546 :                              P3
; 1547 : 
; 1548 :                
; 1549 :                
; 1550 :                              P3
; 1551 :                              *
; 1552 :                             *
; 1553 :                INSIDE      *   OUTSIDE
; 1554 :                           *
; 1555 :                          *
; 1556 :                P1   P2,B*                           There is no 
; 1557 :          A-----*********                            intersection at P2
; 1558 :                          
; 1559 :          */
; 1560 :          // See if A-B contains P2.
; 1561 :          tmp1 = P2 - A;

  024a3	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  024a6	52		 push	 edx
  024a7	8d 45 a0	 lea	 eax, DWORD PTR $T62424[ebp]
  024aa	50		 push	 eax
  024ab	8d 4d e0	 lea	 ecx, DWORD PTR _P2$[ebp]
  024ae	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  024b3	50		 push	 eax
  024b4	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  024b7	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1562 :          tmp2 = P2 - B;

  024bc	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  024bf	51		 push	 ecx
  024c0	8d 55 9c	 lea	 edx, DWORD PTR $T62425[ebp]
  024c3	52		 push	 edx
  024c4	8d 4d e0	 lea	 ecx, DWORD PTR _P2$[ebp]
  024c7	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  024cc	50		 push	 eax
  024cd	8d 4d c0	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  024d0	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1563 :          if ((tmp1*tmp1) <= 2)

  024d5	8d 45 c4	 lea	 eax, DWORD PTR _tmp1$[ebp]
  024d8	50		 push	 eax
  024d9	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  024dc	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  024e1	83 f8 02	 cmp	 eax, 2
  024e4	7f 58		 jg	 SHORT $L61544

; 1568 :             tmp3 = P2 - P1;

  024e6	8d 4d e8	 lea	 ecx, DWORD PTR _P1$[ebp]
  024e9	51		 push	 ecx
  024ea	8d 55 98	 lea	 edx, DWORD PTR $T62426[ebp]
  024ed	52		 push	 edx
  024ee	8d 4d e0	 lea	 ecx, DWORD PTR _P2$[ebp]
  024f1	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  024f6	50		 push	 eax
  024f7	8d 4d b8	 lea	 ecx, DWORD PTR _tmp3$[ebp]
  024fa	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1569 :             tmp4 = B - A;

  024ff	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  02502	50		 push	 eax
  02503	8d 4d 94	 lea	 ecx, DWORD PTR $T62427[ebp]
  02506	51		 push	 ecx
  02507	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  0250a	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  0250f	50		 push	 eax
  02510	8d 4d ac	 lea	 ecx, DWORD PTR _tmp4$[ebp]
  02513	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1570 :             if ((tmp3*tmp4) > 0)

  02518	8d 55 ac	 lea	 edx, DWORD PTR _tmp4$[ebp]
  0251b	52		 push	 edx
  0251c	8d 4d b8	 lea	 ecx, DWORD PTR _tmp3$[ebp]
  0251f	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  02524	85 c0		 test	 eax, eax
  02526	7e 11		 jle	 SHORT $L61541

; 1572 :                intersection = P2;

  02528	8d 45 e0	 lea	 eax, DWORD PTR _P2$[ebp]
  0252b	50		 push	 eax
  0252c	8d 4d f8	 lea	 ecx, DWORD PTR _intersection$[ebp]
  0252f	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1573 :                goto foundIntersection;

  02534	e9 5a 05 00 00	 jmp	 $L61543
$L61541:

; 1577 :                goto getnextnode;

  02539	e9 7f fe ff ff	 jmp	 $getnextnode$61527
$L61544:

; 1580 :          if ((tmp2*tmp2) <= 2)

  0253e	8d 4d c0	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  02541	51		 push	 ecx
  02542	8d 4d c0	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  02545	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  0254a	83 f8 02	 cmp	 eax, 2
  0254d	7f 58		 jg	 SHORT $L61550

; 1585 :             tmp3 = P2 - P1;

  0254f	8d 55 e8	 lea	 edx, DWORD PTR _P1$[ebp]
  02552	52		 push	 edx
  02553	8d 45 90	 lea	 eax, DWORD PTR $T62428[ebp]
  02556	50		 push	 eax
  02557	8d 4d e0	 lea	 ecx, DWORD PTR _P2$[ebp]
  0255a	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  0255f	50		 push	 eax
  02560	8d 4d b8	 lea	 ecx, DWORD PTR _tmp3$[ebp]
  02563	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1586 :             tmp4 = B - A;

  02568	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  0256b	51		 push	 ecx
  0256c	8d 55 8c	 lea	 edx, DWORD PTR $T62429[ebp]
  0256f	52		 push	 edx
  02570	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  02573	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  02578	50		 push	 eax
  02579	8d 4d ac	 lea	 ecx, DWORD PTR _tmp4$[ebp]
  0257c	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1587 :             if ((tmp3*tmp4) < 0)

  02581	8d 45 ac	 lea	 eax, DWORD PTR _tmp4$[ebp]
  02584	50		 push	 eax
  02585	8d 4d b8	 lea	 ecx, DWORD PTR _tmp3$[ebp]
  02588	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  0258d	85 c0		 test	 eax, eax
  0258f	7d 11		 jge	 SHORT $L61548

; 1589 :                intersection = P2;

  02591	8d 4d e0	 lea	 ecx, DWORD PTR _P2$[ebp]
  02594	51		 push	 ecx
  02595	8d 4d f8	 lea	 ecx, DWORD PTR _intersection$[ebp]
  02598	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1590 :                goto foundIntersection;

  0259d	e9 ec 04 00 00	 jmp	 $L61549
$L61548:

; 1594 :                goto getnextnode;

  025a2	e9 16 fe ff ff	 jmp	 $getnextnode$61527
$L61550:

; 1597 :          // If (P2-A)*(P2-B) < 0 then A-B contains P2.
; 1598 :          if ((tmp1*tmp2) < 0)

  025a7	8d 55 c0	 lea	 edx, DWORD PTR _tmp2$[ebp]
  025aa	52		 push	 edx
  025ab	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  025ae	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  025b3	85 c0		 test	 eax, eax
  025b5	7d 53		 jge	 SHORT $L61554

; 1600 :             // If (P2-P1)^(P3-P2) < 0 then P2 is an intersection.
; 1601 :             tmp1 = P2 - P1;

  025b7	8d 45 e8	 lea	 eax, DWORD PTR _P1$[ebp]
  025ba	50		 push	 eax
  025bb	8d 4d 88	 lea	 ecx, DWORD PTR $T62430[ebp]
  025be	51		 push	 ecx
  025bf	8d 4d e0	 lea	 ecx, DWORD PTR _P2$[ebp]
  025c2	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  025c7	50		 push	 eax
  025c8	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  025cb	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1602 :             tmp2 = P3 - P1;

  025d0	8d 55 e8	 lea	 edx, DWORD PTR _P1$[ebp]
  025d3	52		 push	 edx
  025d4	8d 45 84	 lea	 eax, DWORD PTR $T62431[ebp]
  025d7	50		 push	 eax
  025d8	8d 4d d8	 lea	 ecx, DWORD PTR _P3$[ebp]
  025db	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  025e0	50		 push	 eax
  025e1	8d 4d c0	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  025e4	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1603 :             if ((tmp1^tmp2) < 0)

  025e9	8d 4d c0	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  025ec	51		 push	 ecx
  025ed	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  025f0	e8 00 00 00 00	 call	 ??TSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator^
  025f5	85 c0		 test	 eax, eax
  025f7	7d 11		 jge	 SHORT $L61554

; 1605 :                intersection = P2;

  025f9	8d 55 e0	 lea	 edx, DWORD PTR _P2$[ebp]
  025fc	52		 push	 edx
  025fd	8d 4d f8	 lea	 ecx, DWORD PTR _intersection$[ebp]
  02600	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1606 :                goto foundIntersection;

  02605	e9 7f 04 00 00	 jmp	 $L61555
$L61554:

; 1609 :          goto getnextnode;

  0260a	e9 ae fd ff ff	 jmp	 $getnextnode$61527
$L61535:

; 1611 : 
; 1612 :       if (t1 == INTERSECT+INTERSECTD)

  0260f	83 7d dc 11	 cmp	 DWORD PTR _t1$[ebp], 17	; 00000011H
  02613	0f 85 fe 02 00
	00		 jne	 $L61598

; 1614 :          if (t2 == COLINEAR)

  02619	83 7d d4 00	 cmp	 DWORD PTR _t2$[ebp], 0
  0261d	0f 85 b1 00 00
	00		 jne	 $L61566

; 1616 :             /* If intersection at P2, A == P2 and P2-P3 is colinear,
; 1617 :                Then if (P3-P2)*(B-A) < 0 and (P2-P1)^(P3-P2) < 0 then 
; 1618 :                P2 is an intersection.
; 1619 : 
; 1620 :                If intersection at P2, A != P2 and P2-P3 is colinear,
; 1621 :                then if (P2-P1)^(P3-P2) < 0 then P2 is an intersection.
; 1622 : 
; 1623 :                Otherwise D is not an intersection.
; 1624 :                This is because all polygons must be defined in a counter
; 1625 :                clockwise direction.
; 1626 :                For example:
; 1627 : 
; 1628 : 
; 1629 :                           A,P2     P3             There is an no
; 1630 :             B---------------*******               intersection at P2
; 1631 :                            *                      
; 1632 :                           *             
; 1633 :                 OUTSIDE  *   INSIDE    
; 1634 :                         *               
; 1635 :                      P1*           
; 1636 : 
; 1637 : 
; 1638 :                      P1*
; 1639 :                         *   OUTSIDE
; 1640 :                          *
; 1641 :                  INSIDE   *
; 1642 :                            *P2     P3             There is an 
; 1643 :             B---------------*******               intersection at P2
; 1644 :                             A                     
; 1645 : 
; 1646 :                 P1*
; 1647 :                    *
; 1648 :                     *   OUTSIDE
; 1649 :               INSIDE *
; 1650 :                       *P2     P3                  There is no
; 1651 :                        *******-------------B      intersection at P2
; 1652 :                        A                          
; 1653 : 
; 1654 : 
; 1655 :                      A,P2     P3                  There is no
; 1656 :                        *******-------------B      intersection at P2
; 1657 :                       *                           
; 1658 :                      *
; 1659 :             OUTSIDE *   INSIDE
; 1660 :                    *
; 1661 :                 P1*
; 1662 : 
; 1663 : 
; 1664 : 
; 1665 :                 P1*
; 1666 :                    *    OUTSIDE
; 1667 :                     *
; 1668 :              INSIDE  *
; 1669 :                       *P2    P3                   There is an
; 1670 :             A----------*******-------------B      intersection at P2
; 1671 :                                                   
; 1672 : 
; 1673 :                       P2     P3
; 1674 :             A----------*******-------------B      There is no
; 1675 :                       *                           intersection at P2
; 1676 :                      *
; 1677 :             OUTSIDE *   INSIDE
; 1678 :                    *
; 1679 :                 P1*
; 1680 : 
; 1681 :                   *
; 1682 :                    *
; 1683 :                     *  OUTSIDE
; 1684 :               INSIDE *
; 1685 :                       *P2    P3                   There is an
; 1686 :             B----------*******-------------B      intersection at P2
; 1687 :                                                   
; 1688 : 
; 1689 : 
; 1690 :                       P2     P3
; 1691 :             B----------*******-------------B      There is no
; 1692 :                       *                           intersection at P2
; 1693 :                      *
; 1694 :             OUTSIDE *   INSIDE
; 1695 :                    *
; 1696 :                 P1*
; 1697 : 
; 1698 :             */
; 1699 :             // See if P2 == A
; 1700 :             tmp1 = P2 - A;

  02623	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  02626	50		 push	 eax
  02627	8d 4d 80	 lea	 ecx, DWORD PTR $T62432[ebp]
  0262a	51		 push	 ecx
  0262b	8d 4d e0	 lea	 ecx, DWORD PTR _P2$[ebp]
  0262e	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  02633	50		 push	 eax
  02634	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  02637	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1701 :             d = tmp1*tmp1;

  0263c	8d 55 c4	 lea	 edx, DWORD PTR _tmp1$[ebp]
  0263f	52		 push	 edx
  02640	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  02643	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  02648	89 45 f4	 mov	 DWORD PTR _d$[ebp], eax

; 1702 :             tmp1 = P2 - P1;

  0264b	8d 45 e8	 lea	 eax, DWORD PTR _P1$[ebp]
  0264e	50		 push	 eax
  0264f	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T62433[ebp]
  02655	51		 push	 ecx
  02656	8d 4d e0	 lea	 ecx, DWORD PTR _P2$[ebp]
  02659	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  0265e	50		 push	 eax
  0265f	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  02662	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1703 :             tmp2 = P3 - P2;

  02667	8d 55 e0	 lea	 edx, DWORD PTR _P2$[ebp]
  0266a	52		 push	 edx
  0266b	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR $T62434[ebp]
  02671	50		 push	 eax
  02672	8d 4d d8	 lea	 ecx, DWORD PTR _P3$[ebp]
  02675	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  0267a	50		 push	 eax
  0267b	8d 4d c0	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  0267e	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1704 :             if (d <= CLOSETOLINE)

  02683	83 7d f4 02	 cmp	 DWORD PTR _d$[ebp], 2
  02687	7f 31		 jg	 SHORT $L61563

; 1706 :                // if (P3-P2)*(B-A) > 0 no intersection
; 1707 :                tmp3 = B - A;

  02689	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  0268c	51		 push	 ecx
  0268d	8d 95 74 ff ff
	ff		 lea	 edx, DWORD PTR $T62435[ebp]
  02693	52		 push	 edx
  02694	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  02697	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  0269c	50		 push	 eax
  0269d	8d 4d b8	 lea	 ecx, DWORD PTR _tmp3$[ebp]
  026a0	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1708 :                if ((tmp2*tmp3) > 0) goto getnextnode;

  026a5	8d 45 b8	 lea	 eax, DWORD PTR _tmp3$[ebp]
  026a8	50		 push	 eax
  026a9	8d 4d c0	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  026ac	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  026b1	85 c0		 test	 eax, eax
  026b3	7e 05		 jle	 SHORT $L61563
  026b5	e9 03 fd ff ff	 jmp	 $getnextnode$61527
$L61563:

; 1710 :             // If (P2-P1)^(P3-P2) < 0 then P2 is an intersection.
; 1711 :             if ((tmp1^tmp2) < 0)

  026ba	8d 4d c0	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  026bd	51		 push	 ecx
  026be	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  026c1	e8 00 00 00 00	 call	 ??TSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator^
  026c6	85 c0		 test	 eax, eax
  026c8	7d 05		 jge	 SHORT $L61564

; 1712 :                goto foundIntersection;

  026ca	e9 b5 03 00 00	 jmp	 $L61565
$L61564:

; 1714 :                goto getnextnode;

  026cf	e9 e9 fc ff ff	 jmp	 $getnextnode$61527
$L61566:

; 1716 : 
; 1717 : 
; 1718 :          /* If intersection at P2 then check crossing node or not.
; 1719 :             For example:
; 1720 :                                   *P3
; 1721 :                                *    
; 1722 :                             *   
; 1723 :                          *  
; 1724 :                    P2 *     
; 1725 :          A----------*--------------------      Not crossing node
; 1726 :                    *                           
; 1727 :                   *
; 1728 :                  *                     
; 1729 :                 *
; 1730 :              P1*
; 1731 : 
; 1732 :                        P2       
; 1733 :              A----------*--------------------  Crossing node    
; 1734 :                        * *                         
; 1735 :                       *   *            
; 1736 :                      *     *     
; 1737 :                     *       *
; 1738 :                  P1*         * P3
; 1739 :          */
; 1740 :          tmp1 = B - A;

  026d4	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  026d7	52		 push	 edx
  026d8	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR $T62436[ebp]
  026de	50		 push	 eax
  026df	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  026e2	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  026e7	50		 push	 eax
  026e8	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  026eb	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1741 :          tmp2 = P3 - A;

  026f0	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  026f3	51		 push	 ecx
  026f4	8d 95 6c ff ff
	ff		 lea	 edx, DWORD PTR $T62437[ebp]
  026fa	52		 push	 edx
  026fb	8d 4d d8	 lea	 ecx, DWORD PTR _P3$[ebp]
  026fe	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  02703	50		 push	 eax
  02704	8d 4d c0	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  02707	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1742 :          tmp3 = P1 - A;

  0270c	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  0270f	50		 push	 eax
  02710	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR $T62438[ebp]
  02716	51		 push	 ecx
  02717	8d 4d e8	 lea	 ecx, DWORD PTR _P1$[ebp]
  0271a	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  0271f	50		 push	 eax
  02720	8d 4d b8	 lea	 ecx, DWORD PTR _tmp3$[ebp]
  02723	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1743 :          if (((tmp1^tmp2) * (tmp1^tmp3)) > 0)

  02728	8d 55 c0	 lea	 edx, DWORD PTR _tmp2$[ebp]
  0272b	52		 push	 edx
  0272c	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  0272f	e8 00 00 00 00	 call	 ??TSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator^
  02734	8b f0		 mov	 esi, eax
  02736	8d 45 b8	 lea	 eax, DWORD PTR _tmp3$[ebp]
  02739	50		 push	 eax
  0273a	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  0273d	e8 00 00 00 00	 call	 ??TSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator^
  02742	0f af f0	 imul	 esi, eax
  02745	85 f6		 test	 esi, esi
  02747	0f 8e 04 01 00
	00		 jle	 $L61570

; 1745 :             // not crossing node
; 1746 :             tmp4 = P2 - A;

  0274d	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  02750	51		 push	 ecx
  02751	8d 95 64 ff ff
	ff		 lea	 edx, DWORD PTR $T62439[ebp]
  02757	52		 push	 edx
  02758	8d 4d e0	 lea	 ecx, DWORD PTR _P2$[ebp]
  0275b	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  02760	50		 push	 eax
  02761	8d 4d ac	 lea	 ecx, DWORD PTR _tmp4$[ebp]
  02764	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1747 :             if ((tmp4*tmp4) <= 2)

  02769	8d 45 ac	 lea	 eax, DWORD PTR _tmp4$[ebp]
  0276c	50		 push	 eax
  0276d	8d 4d ac	 lea	 ecx, DWORD PTR _tmp4$[ebp]
  02770	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  02775	83 f8 02	 cmp	 eax, 2
  02778	7f 26		 jg	 SHORT $L61575

; 1749 :                /* P2 = A */
; 1750 :                /*
; 1751 :                           P2       
; 1752 :                           A*--------------------      There is an
; 1753 :                           * *                         intersection at P2
; 1754 :                          *   *      INSIDE
; 1755 :                         *     *     
; 1756 :                        *       *
; 1757 :                     P1*         * P3
; 1758 : 
; 1759 :                           P2       
; 1760 :                           A*--------------------      There is no
; 1761 :                           * *                         intersection at P2
; 1762 :                          *   *     OUTSIDE
; 1763 :                         *     *     
; 1764 :                        *       *
; 1765 :                     P3*         * P1
; 1766 :                */
; 1767 :                if (NodeTest(tmp1,P1,P2,P3))

  0277a	8d 4d d8	 lea	 ecx, DWORD PTR _P3$[ebp]
  0277d	51		 push	 ecx
  0277e	8d 55 e0	 lea	 edx, DWORD PTR _P2$[ebp]
  02781	52		 push	 edx
  02782	8d 45 e8	 lea	 eax, DWORD PTR _P1$[ebp]
  02785	50		 push	 eax
  02786	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  02789	51		 push	 ecx
  0278a	e8 00 00 00 00	 call	 ?NodeTest@@YAHAAUSCI_Point@@000@Z ; NodeTest
  0278f	83 c4 10	 add	 esp, 16			; 00000010H
  02792	85 c0		 test	 eax, eax
  02794	74 05		 je	 SHORT $L61573

; 1769 :                   goto foundIntersection;

  02796	e9 e4 02 00 00	 jmp	 $L61574
$L61573:

; 1773 :                   goto getnextnode;

  0279b	e9 1d fc ff ff	 jmp	 $getnextnode$61527
$L61575:

; 1776 :             tmp4 = P2 -B;

  027a0	8b 55 0c	 mov	 edx, DWORD PTR _B$[ebp]
  027a3	52		 push	 edx
  027a4	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR $T62440[ebp]
  027aa	50		 push	 eax
  027ab	8d 4d e0	 lea	 ecx, DWORD PTR _P2$[ebp]
  027ae	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  027b3	50		 push	 eax
  027b4	8d 4d ac	 lea	 ecx, DWORD PTR _tmp4$[ebp]
  027b7	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1777 :             if ((tmp4*tmp4) <= 2)

  027bc	8d 4d ac	 lea	 ecx, DWORD PTR _tmp4$[ebp]
  027bf	51		 push	 ecx
  027c0	8d 4d ac	 lea	 ecx, DWORD PTR _tmp4$[ebp]
  027c3	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  027c8	83 f8 02	 cmp	 eax, 2
  027cb	7f 42		 jg	 SHORT $L61581

; 1779 :                // P2 = B
; 1780 :                /*
; 1781 :                           P2       
; 1782 :                  A--------B*                          There is an
; 1783 :                           * *                         intersection at P2
; 1784 :                          *   *      INSIDE
; 1785 :                         *     *     
; 1786 :                        *       *
; 1787 :                     P1*         * P3
; 1788 : 
; 1789 :                           P2       
; 1790 :                 A---------B*                          There is no
; 1791 :                           * *                         intersection at P2
; 1792 :                          *   *     OUTSIDE
; 1793 :                         *     *     
; 1794 :                        *       *
; 1795 :                     P3*         * P1
; 1796 : 
; 1797 :                */
; 1798 :                tmp1 = A - B;

  027cd	8b 55 0c	 mov	 edx, DWORD PTR _B$[ebp]
  027d0	52		 push	 edx
  027d1	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR $T62441[ebp]
  027d7	50		 push	 eax
  027d8	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  027db	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  027e0	50		 push	 eax
  027e1	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  027e4	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1799 :                if (NodeTest(tmp1,P1,P2,P3))

  027e9	8d 4d d8	 lea	 ecx, DWORD PTR _P3$[ebp]
  027ec	51		 push	 ecx
  027ed	8d 55 e0	 lea	 edx, DWORD PTR _P2$[ebp]
  027f0	52		 push	 edx
  027f1	8d 45 e8	 lea	 eax, DWORD PTR _P1$[ebp]
  027f4	50		 push	 eax
  027f5	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  027f8	51		 push	 ecx
  027f9	e8 00 00 00 00	 call	 ?NodeTest@@YAHAAUSCI_Point@@000@Z ; NodeTest
  027fe	83 c4 10	 add	 esp, 16			; 00000010H
  02801	85 c0		 test	 eax, eax
  02803	74 05		 je	 SHORT $L61579

; 1801 :                   goto foundIntersection;

  02805	e9 70 02 00 00	 jmp	 $L61580
$L61579:

; 1805 :                   goto getnextnode;

  0280a	e9 ae fb ff ff	 jmp	 $getnextnode$61527
$L61581:

; 1808 :             /*
; 1809 :                        P2       
; 1810 :              A----------*--------------------      There is an
; 1811 :                        * *                         intersection at P2
; 1812 :                       *   *      INSIDE
; 1813 :                      *     *     
; 1814 :                     *       *
; 1815 :                  P1*         * P3
; 1816 : 
; 1817 :                        P2       
; 1818 :              A----------*--------------------      There is no
; 1819 :                        * *                         intersection at P2
; 1820 :                       *   *     OUTSIDE
; 1821 :                      *     *     
; 1822 :                     *       *
; 1823 :                  P3*         * P1
; 1824 :             */
; 1825 :             tmp1 = A - P2;

  0280f	8d 55 e0	 lea	 edx, DWORD PTR _P2$[ebp]
  02812	52		 push	 edx
  02813	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR $T62442[ebp]
  02819	50		 push	 eax
  0281a	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  0281d	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  02822	50		 push	 eax
  02823	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  02826	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1826 :             if (NodeTest(tmp1,P1,P2,P3))

  0282b	8d 4d d8	 lea	 ecx, DWORD PTR _P3$[ebp]
  0282e	51		 push	 ecx
  0282f	8d 55 e0	 lea	 edx, DWORD PTR _P2$[ebp]
  02832	52		 push	 edx
  02833	8d 45 e8	 lea	 eax, DWORD PTR _P1$[ebp]
  02836	50		 push	 eax
  02837	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  0283a	51		 push	 ecx
  0283b	e8 00 00 00 00	 call	 ?NodeTest@@YAHAAUSCI_Point@@000@Z ; NodeTest
  02840	83 c4 10	 add	 esp, 16			; 00000010H
  02843	85 c0		 test	 eax, eax
  02845	74 05		 je	 SHORT $L61583

; 1828 :                goto foundIntersection;

  02847	e9 29 02 00 00	 jmp	 $L61584
$L61583:

; 1832 :                goto getnextnode;

  0284c	e9 6c fb ff ff	 jmp	 $getnextnode$61527
$L61570:

; 1837 :             /* Crossing node using known inside determine if there
; 1838 :                is an intersection.
; 1839 :                                       *P3
; 1840 :                                    *    
; 1841 :                 INSIDE          *   
; 1842 :                              *  
; 1843 :                        P2 *     
; 1844 :              A----------*--------------------      There is an
; 1845 :                        *                           intersection at P2
; 1846 :                       *
; 1847 :                      *                     
; 1848 :                     *
; 1849 :                  P1*
; 1850 : 
; 1851 :                        P3*        
; 1852 :                         *   
; 1853 :                        *     OUTSIDE
; 1854 :             INSIDE    *                           There is no       
; 1855 :                    P2*A--------------B            intersection at P2
; 1856 :                      *  
; 1857 :                      *                           
; 1858 :                      *
; 1859 :                    P1*                
; 1860 : 
; 1861 :                              P3*        
; 1862 :                               *   
; 1863 :                              *     OUTSIDE
; 1864 :                   INSIDE    *                     There is an       
; 1865 :               B----------P2*A                     intersection at P2
; 1866 :                            *  
; 1867 :                            *                
; 1868 :                            *
; 1869 :                          P1*               
; 1870 : 
; 1871 :                        P3*        
; 1872 :                         *   
; 1873 :                        *     OUTSIDE
; 1874 :             INSIDE    *                           There is no       
; 1875 :                    P2*B--------------A            intersection at P2
; 1876 :                      *  
; 1877 :                      *                           
; 1878 :                      *
; 1879 :                    P1*                
; 1880 :                              P3*        
; 1881 :                               *   
; 1882 :                              *     OUTSIDE
; 1883 :                   INSIDE    *                     There is an       
; 1884 :               A----------P2*B                     intersection at P2
; 1885 :                            *  
; 1886 :                            *                
; 1887 :                            *
; 1888 :                          P1*               
; 1889 : 
; 1890 :             */
; 1891 : 
; 1892 :             tmp4 = P2 - A;

  02851	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  02854	52		 push	 edx
  02855	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR $T62443[ebp]
  0285b	50		 push	 eax
  0285c	8d 4d e0	 lea	 ecx, DWORD PTR _P2$[ebp]
  0285f	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  02864	50		 push	 eax
  02865	8d 4d ac	 lea	 ecx, DWORD PTR _tmp4$[ebp]
  02868	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1893 :             if ((tmp4*tmp4) <= 2)

  0286d	8d 4d ac	 lea	 ecx, DWORD PTR _tmp4$[ebp]
  02870	51		 push	 ecx
  02871	8d 4d ac	 lea	 ecx, DWORD PTR _tmp4$[ebp]
  02874	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  02879	83 f8 02	 cmp	 eax, 2
  0287c	7f 36		 jg	 SHORT $L61592

; 1895 :                // P2 = A
; 1896 :                // If (P2-P1)^(B-A) > 0 then there is an intersection at P2.
; 1897 :                tmp2 = P2 - P1;

  0287e	8d 55 e8	 lea	 edx, DWORD PTR _P1$[ebp]
  02881	52		 push	 edx
  02882	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR $T62444[ebp]
  02888	50		 push	 eax
  02889	8d 4d e0	 lea	 ecx, DWORD PTR _P2$[ebp]
  0288c	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  02891	50		 push	 eax
  02892	8d 4d c0	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  02895	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1898 :                if ((tmp2^tmp1) > 0)

  0289a	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  0289d	51		 push	 ecx
  0289e	8d 4d c0	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  028a1	e8 00 00 00 00	 call	 ??TSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator^
  028a6	85 c0		 test	 eax, eax
  028a8	7e 05		 jle	 SHORT $L61590

; 1900 :                   goto foundIntersection;

  028aa	e9 c1 01 00 00	 jmp	 $L61591
$L61590:

; 1904 :                   goto getnextnode;

  028af	e9 09 fb ff ff	 jmp	 $getnextnode$61527
$L61592:

; 1907 :             tmp4 = P2 - B;

  028b4	8b 55 0c	 mov	 edx, DWORD PTR _B$[ebp]
  028b7	52		 push	 edx
  028b8	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR $T62445[ebp]
  028be	50		 push	 eax
  028bf	8d 4d e0	 lea	 ecx, DWORD PTR _P2$[ebp]
  028c2	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  028c7	50		 push	 eax
  028c8	8d 4d ac	 lea	 ecx, DWORD PTR _tmp4$[ebp]
  028cb	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1908 :             if ((tmp4*tmp4) <= 2)

  028d0	8d 4d ac	 lea	 ecx, DWORD PTR _tmp4$[ebp]
  028d3	51		 push	 ecx
  028d4	8d 4d ac	 lea	 ecx, DWORD PTR _tmp4$[ebp]
  028d7	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  028dc	83 f8 02	 cmp	 eax, 2
  028df	7f 36		 jg	 SHORT $L61598

; 1910 :                // P2 = B
; 1911 :                // If (P2-P1)^(B-A) < 0 then there is an intersection at P2.
; 1912 :                tmp2 = P2 - P1;

  028e1	8d 55 e8	 lea	 edx, DWORD PTR _P1$[ebp]
  028e4	52		 push	 edx
  028e5	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR $T62446[ebp]
  028eb	50		 push	 eax
  028ec	8d 4d e0	 lea	 ecx, DWORD PTR _P2$[ebp]
  028ef	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  028f4	50		 push	 eax
  028f5	8d 4d c0	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  028f8	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1913 :                if ((tmp2^tmp1) < 0)

  028fd	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  02900	51		 push	 ecx
  02901	8d 4d c0	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  02904	e8 00 00 00 00	 call	 ??TSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator^
  02909	85 c0		 test	 eax, eax
  0290b	7d 05		 jge	 SHORT $L61596

; 1915 :                   goto foundIntersection;

  0290d	e9 59 01 00 00	 jmp	 $L61534
$L61596:

; 1919 :                   goto getnextnode;

  02912	e9 a6 fa ff ff	 jmp	 $getnextnode$61527
$L61598:

; 1924 : 
; 1925 : 
; 1926 :       /* If intersection is at A then see if leaving or
; 1927 :          entering polygon.
; 1928 :          For example:
; 1929 :                         *P2
; 1930 :                        *      
; 1931 :                       *           
; 1932 :                      *           
; 1933 :           INSIDE    *   OUTSIDE
; 1934 :                    *     
; 1935 :                   *   
; 1936 :                  *A-------------------      There is no
; 1937 :                 *                           intersection at P2
; 1938 :                *
; 1939 :               *                     
; 1940 :              *
; 1941 :           P1*         *P2
; 1942 :                      *
; 1943 :                     *
; 1944 :           INSIDE   *    OUTSIDE
; 1945 :                   *      
; 1946 :       -----------*A                         There is an
; 1947 :                 *                           intersection at P2
; 1948 :                *    
; 1949 :               *           
; 1950 :              *        
; 1951 :           P1*              
; 1952 : 
; 1953 :       */
; 1954 :       if (t1 == INTERSECT+INTERSECTA)

  02917	83 7d dc 03	 cmp	 DWORD PTR _t1$[ebp], 3
  0291b	75 4d		 jne	 SHORT $L61602

; 1956 :          tmp1 = P2 - P1;

  0291d	8d 55 e8	 lea	 edx, DWORD PTR _P1$[ebp]
  02920	52		 push	 edx
  02921	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR $T62447[ebp]
  02927	50		 push	 eax
  02928	8d 4d e0	 lea	 ecx, DWORD PTR _P2$[ebp]
  0292b	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  02930	50		 push	 eax
  02931	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  02934	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1957 :          tmp2 = B - A;

  02939	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  0293c	51		 push	 ecx
  0293d	8d 95 40 ff ff
	ff		 lea	 edx, DWORD PTR $T62448[ebp]
  02943	52		 push	 edx
  02944	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  02947	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  0294c	50		 push	 eax
  0294d	8d 4d c0	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  02950	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1958 :          if ((tmp1^tmp2)<=0) goto getnextnode;

  02955	8d 45 c0	 lea	 eax, DWORD PTR _tmp2$[ebp]
  02958	50		 push	 eax
  02959	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  0295c	e8 00 00 00 00	 call	 ??TSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator^
  02961	85 c0		 test	 eax, eax
  02963	7f 05		 jg	 SHORT $L61602
  02965	e9 53 fa ff ff	 jmp	 $getnextnode$61527
$L61602:

; 1960 : 
; 1961 : 
; 1962 :       /* If intersection is at B then see if leaving or
; 1963 :          entering polygon.
; 1964 :          For example:
; 1965 :                         *P2
; 1966 :                        *      
; 1967 :                       *           
; 1968 :                      *           
; 1969 :           INSIDE    *   OUTSIDE
; 1970 :                    *     
; 1971 :                   *   
; 1972 :                  *B-------------------      There is no
; 1973 :                 *                           intersection at P2
; 1974 :                *
; 1975 :               *                     
; 1976 :              *
; 1977 :           P1*         *P2
; 1978 :                      *
; 1979 :                     *
; 1980 :           INSIDE   *    OUTSIDE
; 1981 :                   *      
; 1982 :       -----------*B                         There is an
; 1983 :                 *                           intersection at P2
; 1984 :                *    
; 1985 :               *           
; 1986 :              *        
; 1987 :           P1*              
; 1988 : 
; 1989 :       */
; 1990 :       if (t1 == INTERSECT+INTERSECTB)

  0296a	83 7d dc 05	 cmp	 DWORD PTR _t1$[ebp], 5
  0296e	75 4d		 jne	 SHORT $foundIntersection$61542

; 1992 :          tmp1 = P2 - P1;

  02970	8d 4d e8	 lea	 ecx, DWORD PTR _P1$[ebp]
  02973	51		 push	 ecx
  02974	8d 95 3c ff ff
	ff		 lea	 edx, DWORD PTR $T62449[ebp]
  0297a	52		 push	 edx
  0297b	8d 4d e0	 lea	 ecx, DWORD PTR _P2$[ebp]
  0297e	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  02983	50		 push	 eax
  02984	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  02987	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1993 :          tmp2 = B - A;

  0298c	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  0298f	50		 push	 eax
  02990	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR $T62450[ebp]
  02996	51		 push	 ecx
  02997	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  0299a	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  0299f	50		 push	 eax
  029a0	8d 4d c0	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  029a3	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 1994 :          if ((tmp1^tmp2)>0) goto getnextnode;

  029a8	8d 55 c0	 lea	 edx, DWORD PTR _tmp2$[ebp]
  029ab	52		 push	 edx
  029ac	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  029af	e8 00 00 00 00	 call	 ??TSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator^
  029b4	85 c0		 test	 eax, eax
  029b6	7e 05		 jle	 SHORT $foundIntersection$61542
  029b8	e9 00 fa ff ff	 jmp	 $getnextnode$61527
$foundIntersection$61542:

; 1998 :       // intersection, see if closer to A or B than other intersections
; 1999 :       tmp1 = A - intersection;

  029bd	8d 45 f8	 lea	 eax, DWORD PTR _intersection$[ebp]
  029c0	50		 push	 eax
  029c1	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR $T62451[ebp]
  029c7	51		 push	 ecx
  029c8	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  029cb	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  029d0	50		 push	 eax
  029d1	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  029d4	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 2000 :       if ((tmp1*tmp1) < distA)

  029d9	8d 55 c4	 lea	 edx, DWORD PTR _tmp1$[ebp]
  029dc	52		 push	 edx
  029dd	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  029e0	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  029e5	3b 45 f0	 cmp	 eax, DWORD PTR _distA$[ebp]
  029e8	7d 23		 jge	 SHORT $L61608

; 2002 :          distA = tmp1*tmp1;

  029ea	8d 45 c4	 lea	 eax, DWORD PTR _tmp1$[ebp]
  029ed	50		 push	 eax
  029ee	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  029f1	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  029f6	89 45 f0	 mov	 DWORD PTR _distA$[ebp], eax

; 2003 :          I1 = intersection;

  029f9	8d 4d f8	 lea	 ecx, DWORD PTR _intersection$[ebp]
  029fc	51		 push	 ecx
  029fd	8d 4d cc	 lea	 ecx, DWORD PTR _I1$[ebp]
  02a00	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 2004 :          *nodeI1 = node ;

  02a05	8b 55 20	 mov	 edx, DWORD PTR _nodeI1$[ebp]
  02a08	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  02a0b	89 02		 mov	 DWORD PTR [edx], eax
$L61608:

; 2006 :       tmp1 = B - intersection;

  02a0d	8d 4d f8	 lea	 ecx, DWORD PTR _intersection$[ebp]
  02a10	51		 push	 ecx
  02a11	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR $T62452[ebp]
  02a17	52		 push	 edx
  02a18	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  02a1b	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  02a20	50		 push	 eax
  02a21	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  02a24	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 2007 :       if ((tmp1*tmp1) < distB)

  02a29	8d 45 c4	 lea	 eax, DWORD PTR _tmp1$[ebp]
  02a2c	50		 push	 eax
  02a2d	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  02a30	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  02a35	3b 45 ec	 cmp	 eax, DWORD PTR _distB$[ebp]
  02a38	7d 23		 jge	 SHORT $L61610

; 2009 :          distB = tmp1*tmp1;

  02a3a	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  02a3d	51		 push	 ecx
  02a3e	8d 4d c4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  02a41	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  02a46	89 45 ec	 mov	 DWORD PTR _distB$[ebp], eax

; 2010 :          I2 = intersection;

  02a49	8d 55 f8	 lea	 edx, DWORD PTR _intersection$[ebp]
  02a4c	52		 push	 edx
  02a4d	8d 4d c8	 lea	 ecx, DWORD PTR _I2$[ebp]
  02a50	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 2011 :          *nodeI2 = node ;

  02a55	8b 45 24	 mov	 eax, DWORD PTR _nodeI2$[ebp]
  02a58	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  02a5b	89 08		 mov	 DWORD PTR [eax], ecx
$L61610:

; 2013 :       // count intersections
; 2014 :       ++ i;

  02a5d	8b 55 d0	 mov	 edx, DWORD PTR _i$[ebp]
  02a60	83 c2 01	 add	 edx, 1
  02a63	89 55 d0	 mov	 DWORD PTR _i$[ebp], edx

; 2015 :       goto getnextnode;

  02a66	e9 52 f9 ff ff	 jmp	 $getnextnode$61527
$L61534:

; 2017 : }

  02a6b	e9 4d ff ff ff	 jmp	 $foundIntersection$61542
$L61591:
  02a70	e9 48 ff ff ff	 jmp	 $foundIntersection$61542
$L61584:
  02a75	e9 43 ff ff ff	 jmp	 $foundIntersection$61542
$L61580:
  02a7a	e9 3e ff ff ff	 jmp	 $foundIntersection$61542
$L61574:
  02a7f	e9 39 ff ff ff	 jmp	 $foundIntersection$61542
$L61565:
  02a84	e9 34 ff ff ff	 jmp	 $foundIntersection$61542
$L61555:
  02a89	e9 2f ff ff ff	 jmp	 $foundIntersection$61542
$L61549:
  02a8e	e9 2a ff ff ff	 jmp	 $foundIntersection$61542
$L61543:
  02a93	e9 25 ff ff ff	 jmp	 $foundIntersection$61542
$L61500:
  02a98	5e		 pop	 esi
  02a99	8b e5		 mov	 esp, ebp
  02a9b	5d		 pop	 ebp
  02a9c	c3		 ret	 0
?IntersectPolygon@@YAHAAUSCI_Point@@0PAU1@H11PAH2@Z ENDP ; IntersectPolygon
_V$ = 8
_P1$ = 12
_P2$ = 16
_P3$ = 20
_tmp1$ = -4
_tmp2$ = -8
$T62454 = -12
$T62455 = -16
?NodeTest@@YAHAAUSCI_Point@@000@Z PROC NEAR		; NodeTest

; 2021 : {

  02a9d	55		 push	 ebp
  02a9e	8b ec		 mov	 ebp, esp
  02aa0	83 ec 10	 sub	 esp, 16			; 00000010H

; 2022 :    SCI_Point tmp1,tmp2;

  02aa3	8d 4d fc	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  02aa6	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  02aab	8d 4d f8	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  02aae	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point

; 2023 : 
; 2024 :    /*
; 2025 : 
; 2026 :             P2              V
; 2027 :              *------------------->      There is no
; 2028 :             * *                         intersection at P2
; 2029 :            *   *     OUTSIDE
; 2030 :           *     *     
; 2031 :          *       *
; 2032 :       P3*         * P1
; 2033 : 
; 2034 : 
; 2035 :     V       P2       
; 2036 :    <---------*                          There is an
; 2037 :             * *                         intersection at P2
; 2038 :            *   *      INSIDE
; 2039 :           *     *     
; 2040 :          *       *
; 2041 :       P1*         * P3
; 2042 : 
; 2043 :    */ 
; 2044 :    tmp1 = P3 - P2;   

  02ab3	8b 45 10	 mov	 eax, DWORD PTR _P2$[ebp]
  02ab6	50		 push	 eax
  02ab7	8d 4d f4	 lea	 ecx, DWORD PTR $T62454[ebp]
  02aba	51		 push	 ecx
  02abb	8b 4d 14	 mov	 ecx, DWORD PTR _P3$[ebp]
  02abe	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  02ac3	50		 push	 eax
  02ac4	8d 4d fc	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  02ac7	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 2045 :    tmp2 = P2 - P1;   

  02acc	8b 55 0c	 mov	 edx, DWORD PTR _P1$[ebp]
  02acf	52		 push	 edx
  02ad0	8d 45 f0	 lea	 eax, DWORD PTR $T62455[ebp]
  02ad3	50		 push	 eax
  02ad4	8b 4d 10	 mov	 ecx, DWORD PTR _P2$[ebp]
  02ad7	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  02adc	50		 push	 eax
  02add	8d 4d f8	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  02ae0	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 2046 :    if ((tmp1^tmp2) > 0)

  02ae5	8d 4d f8	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  02ae8	51		 push	 ecx
  02ae9	8d 4d fc	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  02aec	e8 00 00 00 00	 call	 ??TSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator^
  02af1	85 c0		 test	 eax, eax
  02af3	7e 32		 jle	 SHORT $L61621

; 2048 :       if ((tmp1^V) > 0)

  02af5	8b 55 08	 mov	 edx, DWORD PTR _V$[ebp]
  02af8	52		 push	 edx
  02af9	8d 4d fc	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  02afc	e8 00 00 00 00	 call	 ??TSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator^
  02b01	85 c0		 test	 eax, eax
  02b03	7e 07		 jle	 SHORT $L61622

; 2050 :          return (True);

  02b05	b8 01 00 00 00	 mov	 eax, 1
  02b0a	eb 48		 jmp	 SHORT $L61630
$L61622:

; 2054 :          if ((V^tmp2) < 0)

  02b0c	8d 45 f8	 lea	 eax, DWORD PTR _tmp2$[ebp]
  02b0f	50		 push	 eax
  02b10	8b 4d 08	 mov	 ecx, DWORD PTR _V$[ebp]
  02b13	e8 00 00 00 00	 call	 ??TSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator^
  02b18	85 c0		 test	 eax, eax
  02b1a	7d 07		 jge	 SHORT $L61624

; 2056 :             return (True);

  02b1c	b8 01 00 00 00	 mov	 eax, 1
  02b21	eb 31		 jmp	 SHORT $L61630
$L61624:

; 2060 :             return (False);

  02b23	33 c0		 xor	 eax, eax
  02b25	eb 2d		 jmp	 SHORT $L61630
$L61621:

; 2066 :       if ((tmp1^V) > 0)

  02b27	8b 4d 08	 mov	 ecx, DWORD PTR _V$[ebp]
  02b2a	51		 push	 ecx
  02b2b	8d 4d fc	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  02b2e	e8 00 00 00 00	 call	 ??TSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator^
  02b33	85 c0		 test	 eax, eax
  02b35	7e 1b		 jle	 SHORT $L61627

; 2068 :          if ((V^tmp2) < 0)

  02b37	8d 55 f8	 lea	 edx, DWORD PTR _tmp2$[ebp]
  02b3a	52		 push	 edx
  02b3b	8b 4d 08	 mov	 ecx, DWORD PTR _V$[ebp]
  02b3e	e8 00 00 00 00	 call	 ??TSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator^
  02b43	85 c0		 test	 eax, eax
  02b45	7d 07		 jge	 SHORT $L61628

; 2070 :             return (True);

  02b47	b8 01 00 00 00	 mov	 eax, 1
  02b4c	eb 06		 jmp	 SHORT $L61630
$L61628:

; 2074 :             return (False);

  02b4e	33 c0		 xor	 eax, eax
  02b50	eb 02		 jmp	 SHORT $L61630
$L61627:

; 2079 :          return (False);

  02b52	33 c0		 xor	 eax, eax
$L61630:

; 2082 : }

  02b54	8b e5		 mov	 esp, ebp
  02b56	5d		 pop	 ebp
  02b57	c3		 ret	 0
?NodeTest@@YAHAAUSCI_Point@@000@Z ENDP			; NodeTest
_TEXT	ENDS
PUBLIC	??0MemID@@QAE@G@Z				; MemID::MemID
PUBLIC	??BMemID@@QBEGXZ				; MemID::operator unsigned short
PUBLIC	?BuildPolygonList@@YA?AVMemID@@USOL_ListID@@H@Z	; BuildPolygonList
PUBLIC	??0Array@@QAE@VMemID@@@Z			; Array::Array
PUBLIC	??0ObjectID@@QAE@ABV0@@Z			; ObjectID::ObjectID
PUBLIC	??0ObjectID@@QAE@G@Z				; ObjectID::ObjectID
PUBLIC	?GetProperty@ObjectID@@QBEFG@Z			; ObjectID::GetProperty
PUBLIC	?size@SOL_List@@QAEAAHXZ			; SOL_List::size
PUBLIC	??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ		; FakeSOL_ListID::operator->
EXTRN	?calcAddress@Array@@QAEPAXH@Z:NEAR		; Array::calcAddress
EXTRN	?Fatal@MsgMgr@@QAAXPADZZ:NEAR			; MsgMgr::Fatal
EXTRN	?at@SOL_List@@QAEGH@Z:NEAR			; SOL_List::at
_DATA	SEGMENT
$SG61657 DB	'Stepping beyond end of polygon list.', 00H
_DATA	ENDS
xdata$x	SEGMENT
$T62461	DD	019930520H
	DD	01H
	DD	FLAT:$T62463
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T62463	DD	0ffffffffH
	DD	FLAT:$L62459
xdata$x	ENDS
_TEXT	SEGMENT
_theList$ = 12
_listSize$ = 16
___$ReturnUdt$ = 8
_i$ = -24
_polygonListID$ = -20
_polygonList$ = -16
_index$ = -28
_id$61645 = -48
_arrayID$61649 = -44
_pointsArray$61650 = -40
_points$61652 = -36
_size$61654 = -32
$T62457 = -52
$T62458 = -56
__$EHRec$ = -12
?BuildPolygonList@@YA?AVMemID@@USOL_ListID@@H@Z PROC NEAR ; BuildPolygonList

; 2100 : {

  02b58	55		 push	 ebp
  02b59	8b ec		 mov	 ebp, esp
  02b5b	6a ff		 push	 -1
  02b5d	68 00 00 00 00	 push	 $L62462
  02b62	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  02b68	50		 push	 eax
  02b69	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  02b70	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 2101 :    int i = 0;

  02b73	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 2102 :    MemID polygonListID;

  02b7a	8d 4d ec	 lea	 ecx, DWORD PTR _polygonListID$[ebp]
  02b7d	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID

; 2103 : 	polygonListID.Get(MemPolygonList,(listSize+1)*sizeof(SOL_Polygon));

  02b82	6a 00		 push	 0
  02b84	6a 00		 push	 0
  02b86	6a 00		 push	 0
  02b88	6a 00		 push	 0
  02b8a	68 00 02 00 00	 push	 512			; 00000200H
  02b8f	8b 45 10	 mov	 eax, DWORD PTR _listSize$[ebp]
  02b92	83 c0 01	 add	 eax, 1
  02b95	6b c0 0c	 imul	 eax, 12			; 0000000cH
  02b98	50		 push	 eax
  02b99	6a 45		 push	 69			; 00000045H
  02b9b	8d 4d ec	 lea	 ecx, DWORD PTR _polygonListID$[ebp]
  02b9e	e8 00 00 00 00	 call	 ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get

; 2104 : 	SOL_Polygon* polygonList = (SOL_Polygon*) memMgr->GetAddr(polygonListID);

  02ba3	8d 4d ec	 lea	 ecx, DWORD PTR _polygonListID$[ebp]
  02ba6	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  02bab	50		 push	 eax
  02bac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  02bb2	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr
  02bb7	89 45 f0	 mov	 DWORD PTR _polygonList$[ebp], eax

; 2105 : 
; 2106 : 	for ( int index=0; index<theList->size(); index++ ) {

  02bba	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _index$[ebp], 0
  02bc1	eb 09		 jmp	 SHORT $L61642
$L61643:
  02bc3	8b 4d e4	 mov	 ecx, DWORD PTR _index$[ebp]
  02bc6	83 c1 01	 add	 ecx, 1
  02bc9	89 4d e4	 mov	 DWORD PTR _index$[ebp], ecx
$L61642:
  02bcc	8d 4d 0c	 lea	 ecx, DWORD PTR _theList$[ebp]
  02bcf	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  02bd4	8b c8		 mov	 ecx, eax
  02bd6	e8 00 00 00 00	 call	 ?size@SOL_List@@QAEAAHXZ ; SOL_List::size
  02bdb	8b 55 e4	 mov	 edx, DWORD PTR _index$[ebp]
  02bde	3b 10		 cmp	 edx, DWORD PTR [eax]
  02be0	0f 8d 11 01 00
	00		 jge	 $L61644

; 2107 : 	   ObjectID id = (ObjectID)theList->at ( index );

  02be6	8b 45 e4	 mov	 eax, DWORD PTR _index$[ebp]
  02be9	50		 push	 eax
  02bea	8d 4d 0c	 lea	 ecx, DWORD PTR _theList$[ebp]
  02bed	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  02bf2	8b c8		 mov	 ecx, eax
  02bf4	e8 00 00 00 00	 call	 ?at@SOL_List@@QAEGH@Z	; SOL_List::at
  02bf9	50		 push	 eax
  02bfa	8d 4d cc	 lea	 ecx, DWORD PTR $T62457[ebp]
  02bfd	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  02c02	50		 push	 eax
  02c03	8d 4d d0	 lea	 ecx, DWORD PTR _id$61645[ebp]
  02c06	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID

; 2108 : 		polygonList[i].type = (uchar) id.GetProperty(s_type);

  02c0b	6a 2b		 push	 43			; 0000002bH
  02c0d	8d 4d d0	 lea	 ecx, DWORD PTR _id$61645[ebp]
  02c10	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  02c15	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  02c18	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  02c1b	8b 55 f0	 mov	 edx, DWORD PTR _polygonList$[ebp]
  02c1e	88 44 0a 04	 mov	 BYTE PTR [edx+ecx+4], al

; 2109 : 		
; 2110 : 		ObjectID arrayID = id.GetProperty ( s_points );

  02c22	6a 5b		 push	 91			; 0000005bH
  02c24	8d 4d d0	 lea	 ecx, DWORD PTR _id$61645[ebp]
  02c27	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  02c2c	50		 push	 eax
  02c2d	8d 4d d4	 lea	 ecx, DWORD PTR _arrayID$61649[ebp]
  02c30	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID

; 2111 : 		Array pointsArray ( arrayID.GetProperty ( s_data ) );

  02c35	6a 71		 push	 113			; 00000071H
  02c37	8d 4d d4	 lea	 ecx, DWORD PTR _arrayID$61649[ebp]
  02c3a	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  02c3f	51		 push	 ecx
  02c40	8b cc		 mov	 ecx, esp
  02c42	89 65 c8	 mov	 DWORD PTR $T62458[ebp], esp
  02c45	50		 push	 eax
  02c46	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  02c4b	8d 4d d8	 lea	 ecx, DWORD PTR _pointsArray$61650[ebp]
  02c4e	e8 00 00 00 00	 call	 ??0Array@@QAE@VMemID@@@Z ; Array::Array
  02c53	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2112 :       SCI_Point* points = (SCI_Point*) pointsArray.calcAddress ( 0 );

  02c5a	6a 00		 push	 0
  02c5c	8d 4d d8	 lea	 ecx, DWORD PTR _pointsArray$61650[ebp]
  02c5f	e8 00 00 00 00	 call	 ?calcAddress@Array@@QAEPAXH@Z ; Array::calcAddress
  02c64	89 45 dc	 mov	 DWORD PTR _points$61652[ebp], eax

; 2113 : 
; 2114 : 		polygonList[i].polyPoints = &points[0];

  02c67	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  02c6a	6b c0 0c	 imul	 eax, 12			; 0000000cH
  02c6d	8b 4d f0	 mov	 ecx, DWORD PTR _polygonList$[ebp]
  02c70	8b 55 dc	 mov	 edx, DWORD PTR _points$61652[ebp]
  02c73	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 2115 : 
; 2116 : 		int size = id.GetProperty(s_size);

  02c76	6a 5a		 push	 90			; 0000005aH
  02c78	8d 4d d0	 lea	 ecx, DWORD PTR _id$61645[ebp]
  02c7b	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  02c80	0f bf c0	 movsx	 eax, ax
  02c83	89 45 e0	 mov	 DWORD PTR _size$61654[ebp], eax

; 2117 : 
; 2118 :       if (size < 3) {

  02c86	83 7d e0 03	 cmp	 DWORD PTR _size$61654[ebp], 3
  02c8a	7d 14		 jge	 SHORT $L61655

; 2119 : //		   msgMgr->Fatal(SrcLoc,Msg_NotAPolygon);
; 2120 : 			continue;

  02c8c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  02c93	8d 4d d8	 lea	 ecx, DWORD PTR _pointsArray$61650[ebp]
  02c96	e8 00 00 00 00	 call	 ??1Array@@QAE@XZ	; Array::~Array
  02c9b	e9 23 ff ff ff	 jmp	 $L61643
$L61655:

; 2122 : 
; 2123 : 		polygonList[i].n = size;

  02ca0	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  02ca3	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  02ca6	8b 55 f0	 mov	 edx, DWORD PTR _polygonList$[ebp]
  02ca9	8b 45 e0	 mov	 eax, DWORD PTR _size$61654[ebp]
  02cac	89 44 0a 08	 mov	 DWORD PTR [edx+ecx+8], eax

; 2124 : 
; 2125 : 		polygonList[i].info = 0; 

  02cb0	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  02cb3	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  02cb6	8b 55 f0	 mov	 edx, DWORD PTR _polygonList$[ebp]
  02cb9	c6 44 0a 05 00	 mov	 BYTE PTR [edx+ecx+5], 0

; 2126 : 		i++;

  02cbe	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  02cc1	83 c0 01	 add	 eax, 1
  02cc4	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax

; 2127 : 
; 2128 : 		if ( i > listSize )

  02cc7	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  02cca	3b 4d 10	 cmp	 ecx, DWORD PTR _listSize$[ebp]
  02ccd	7e 14		 jle	 SHORT $L61656

; 2129 : 			msgMgr->Fatal ( "Stepping beyond end of polygon list." );

  02ccf	68 00 00 00 00	 push	 OFFSET FLAT:$SG61657
  02cd4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  02cda	52		 push	 edx
  02cdb	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  02ce0	83 c4 08	 add	 esp, 8
$L61656:

; 2130 : 	}

  02ce3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  02cea	8d 4d d8	 lea	 ecx, DWORD PTR _pointsArray$61650[ebp]
  02ced	e8 00 00 00 00	 call	 ??1Array@@QAE@XZ	; Array::~Array
  02cf2	e9 cc fe ff ff	 jmp	 $L61643
$L61644:

; 2131 : 
; 2132 : 	polygonList[i].polyPoints = NULL;

  02cf7	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  02cfa	6b c0 0c	 imul	 eax, 12			; 0000000cH
  02cfd	8b 4d f0	 mov	 ecx, DWORD PTR _polygonList$[ebp]
  02d00	c7 04 01 00 00
	00 00		 mov	 DWORD PTR [ecx+eax], 0

; 2133 : 	polygonList[i].n = 0;

  02d07	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  02d0a	6b d2 0c	 imul	 edx, 12			; 0000000cH
  02d0d	8b 45 f0	 mov	 eax, DWORD PTR _polygonList$[ebp]
  02d10	c7 44 10 08 00
	00 00 00	 mov	 DWORD PTR [eax+edx+8], 0

; 2134 : 	polygonList[i].type = 0;

  02d18	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  02d1b	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  02d1e	8b 55 f0	 mov	 edx, DWORD PTR _polygonList$[ebp]
  02d21	c6 44 0a 04 00	 mov	 BYTE PTR [edx+ecx+4], 0

; 2135 : 	polygonList[i].info = 0; 

  02d26	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  02d29	6b c0 0c	 imul	 eax, 12			; 0000000cH
  02d2c	8b 4d f0	 mov	 ecx, DWORD PTR _polygonList$[ebp]
  02d2f	c6 44 01 05 00	 mov	 BYTE PTR [ecx+eax+5], 0

; 2136 : 
; 2137 :    return(polygonListID);

  02d34	8d 55 ec	 lea	 edx, DWORD PTR _polygonListID$[ebp]
  02d37	52		 push	 edx
  02d38	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  02d3b	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  02d40	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2138 : }

  02d43	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  02d46	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  02d4d	8b e5		 mov	 esp, ebp
  02d4f	5d		 pop	 ebp
  02d50	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L62459:
  00028	8d 4d d8	 lea	 ecx, DWORD PTR _pointsArray$61650[ebp]
  0002b	e8 00 00 00 00	 call	 ??1Array@@QAE@XZ	; Array::~Array
  00030	c3		 ret	 0
$L62462:
  00031	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T62461
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?BuildPolygonList@@YA?AVMemID@@USOL_ListID@@H@Z ENDP	; BuildPolygonList
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0MemID@@QAE@G@Z PROC NEAR				; MemID::MemID, COMDAT

; 23   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 4d 08	 mov	 cx, WORD PTR _h$[ebp]
  0000e	66 89 08	 mov	 WORD PTR [eax], cx

; 24   : 	}

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??0MemID@@QAE@G@Z ENDP					; MemID::MemID
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4
??BMemID@@QBEGXZ PROC NEAR				; MemID::operator unsigned short, COMDAT

; 93   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   : 		return handle;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 00	 mov	 ax, WORD PTR [eax]

; 95   : 	}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??BMemID@@QBEGXZ ENDP					; MemID::operator unsigned short
_TEXT	ENDS
;	COMDAT ??0Array@@QAE@VMemID@@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -8
??0Array@@QAE@VMemID@@@Z PROC NEAR			; Array::Array, COMDAT

; 79   : 	Array ( MemID id ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID

; 80   : 		dataID ( id );

  00011	51		 push	 ecx
  00012	8b cc		 mov	 ecx, esp
  00014	8d 45 08	 lea	 eax, DWORD PTR _id$[ebp]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?dataID@Array@@QAEXVMemID@@@Z ; Array::dataID

; 81   : 	}

  00025	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??0Array@@QAE@VMemID@@@Z ENDP				; Array::Array
_TEXT	ENDS
;	COMDAT ?size@SOL_List@@QAEAAHXZ
_TEXT	SEGMENT
_this$ = -4
?size@SOL_List@@QAEAAHXZ PROC NEAR			; SOL_List::size, COMDAT

; 24   : 	inline int &size ( void ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 25   : 		return _size;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4

; 26   : 	}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?size@SOL_List@@QAEAAHXZ ENDP				; SOL_List::size
_TEXT	ENDS
;	COMDAT ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ
_TEXT	SEGMENT
_this$ = -4
??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ PROC NEAR		; FakeSOL_ListID::operator->, COMDAT

; 84   : FakeTemplateID(FakeSOL_ListID, SOL_List, MemList)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ENDP		; FakeSOL_ListID::operator->
_TEXT	ENDS
PUBLIC	??0FakeObjectID@@QAE@ABVMemID@@@Z		; FakeObjectID::FakeObjectID
;	COMDAT ??0ObjectID@@QAE@ABV0@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0ObjectID@@QAE@ABV0@@Z PROC NEAR			; ObjectID::ObjectID, COMDAT

; 229  : 	ObjectID(const ObjectID& id) : FakeObjectID((MemID&) id) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0FakeObjectID@@QAE@ABVMemID@@@Z ; FakeObjectID::FakeObjectID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0ObjectID@@QAE@ABV0@@Z ENDP				; ObjectID::ObjectID
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0FakeObjectID@@QAE@ABVMemID@@@Z PROC NEAR		; FakeObjectID::FakeObjectID, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0FakeObjectID@@QAE@ABVMemID@@@Z ENDP			; FakeObjectID::FakeObjectID
_TEXT	ENDS
PUBLIC	??0FakeObjectID@@QAE@G@Z			; FakeObjectID::FakeObjectID
;	COMDAT ??0ObjectID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0ObjectID@@QAE@G@Z PROC NEAR				; ObjectID::ObjectID, COMDAT

; 230  : 	ObjectID(SOL_Handle h) : FakeObjectID(h) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	66 8b 45 08	 mov	 ax, WORD PTR _h$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0FakeObjectID@@QAE@G@Z ; FakeObjectID::FakeObjectID
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0ObjectID@@QAE@G@Z ENDP				; ObjectID::ObjectID
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0FakeObjectID@@QAE@G@Z PROC NEAR			; FakeObjectID::FakeObjectID, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	66 8b 45 08	 mov	 ax, WORD PTR _h$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0FakeObjectID@@QAE@G@Z ENDP				; FakeObjectID::FakeObjectID
_TEXT	ENDS
PUBLIC	?GetProperty@Object@@QAEFG@Z			; Object::GetProperty
PUBLIC	??CFakeObjectID@@QBEPAUObject@@XZ		; FakeObjectID::operator->
PUBLIC	?AssureValid@ObjectID@@QBEXXZ			; ObjectID::AssureValid
;	COMDAT ?GetProperty@ObjectID@@QBEFG@Z
_TEXT	SEGMENT
_selector$ = 8
_this$ = -4
?GetProperty@ObjectID@@QBEFG@Z PROC NEAR		; ObjectID::GetProperty, COMDAT

; 290  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 291  : 		//	get a property given a selector
; 292  : 		AssureValid();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?AssureValid@ObjectID@@QBEXXZ ; ObjectID::AssureValid

; 293  : 		return (*this)->GetProperty(selector);

  0000f	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  00013	50		 push	 eax
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  0001c	8b c8		 mov	 ecx, eax
  0001e	e8 00 00 00 00	 call	 ?GetProperty@Object@@QAEFG@Z ; Object::GetProperty

; 294  : 	}

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?GetProperty@ObjectID@@QBEFG@Z ENDP			; ObjectID::GetProperty
_TEXT	ENDS
PUBLIC	?GetPropAddrCheck@Object@@QAEPAFG@Z		; Object::GetPropAddrCheck
;	COMDAT ?GetProperty@Object@@QAEFG@Z
_TEXT	SEGMENT
_selector$ = 8
_this$ = -4
?GetProperty@Object@@QAEFG@Z PROC NEAR			; Object::GetProperty, COMDAT

; 170  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 171  : 		//	get a property given a selector
; 172  : 		return *GetPropAddrCheck(selector);

  00007	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?GetPropAddrCheck@Object@@QAEPAFG@Z ; Object::GetPropAddrCheck
  00014	66 8b 00	 mov	 ax, WORD PTR [eax]

; 173  : 	}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?GetProperty@Object@@QAEFG@Z ENDP			; Object::GetProperty
_TEXT	ENDS
PUBLIC	?GetPropAddr@Object@@QAEPAFG@Z			; Object::GetPropAddr
EXTRN	?Fatal@MsgMgr@@QAAXHZZ:NEAR			; MsgMgr::Fatal
;	COMDAT ?GetPropAddrCheck@Object@@QAEPAFG@Z
_TEXT	SEGMENT
_selector$ = 8
_this$ = -8
_property$ = -4
?GetPropAddrCheck@Object@@QAEPAFG@Z PROC NEAR		; Object::GetPropAddrCheck, COMDAT

; 153  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 154  : 		//	get a property's address, checking for valid property
; 155  : 		Property* property = GetPropAddr(selector);

  00009	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?GetPropAddr@Object@@QAEPAFG@Z ; Object::GetPropAddr
  00016	89 45 fc	 mov	 DWORD PTR _property$[ebp], eax

; 156  : 		if (!property)

  00019	83 7d fc 00	 cmp	 DWORD PTR _property$[ebp], 0
  0001d	75 1b		 jne	 SHORT $L57796

; 157  : 			msgMgr->Fatal(Msg_InvalidProperty, selector);

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _selector$[ebp]
  00022	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00028	51		 push	 ecx
  00029	6a 29		 push	 41			; 00000029H
  0002b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXHZZ	; MsgMgr::Fatal
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
$L57796:

; 158  : 		return property;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _property$[ebp]

; 159  : 	}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
?GetPropAddrCheck@Object@@QAEPAFG@Z ENDP		; Object::GetPropAddrCheck
_TEXT	ENDS
PUBLIC	?selectorDict@Object@@QAEPAVSelectorDict@@XZ	; Object::selectorDict
PUBLIC	??AObject@@QAEAAFH@Z				; Object::operator[]
EXTRN	?get@SelectorDict@@QAEHG@Z:NEAR			; SelectorDict::get
;	COMDAT ?GetPropAddr@Object@@QAEPAFG@Z
_TEXT	SEGMENT
_selector$ = 8
_this$ = -8
_index$ = -4
?GetPropAddr@Object@@QAEPAFG@Z PROC NEAR		; Object::GetPropAddr, COMDAT

; 127  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 128  : 		int index = selectorDict()->get ( selector );

  00009	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?selectorDict@Object@@QAEPAVSelectorDict@@XZ ; Object::selectorDict
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 ?get@SelectorDict@@QAEHG@Z ; SelectorDict::get
  0001d	89 45 fc	 mov	 DWORD PTR _index$[ebp], eax

; 129  : 
; 130  : 		if ( index != -1 && !selectorDict()->script )

  00020	83 7d fc ff	 cmp	 DWORD PTR _index$[ebp], -1
  00024	74 2b		 je	 SHORT $L57787
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?selectorDict@Object@@QAEPAVSelectorDict@@XZ ; Object::selectorDict
  0002e	33 c9		 xor	 ecx, ecx
  00030	66 8b 48 16	 mov	 cx, WORD PTR [eax+22]
  00034	85 c9		 test	 ecx, ecx
  00036	75 19		 jne	 SHORT $L57787

; 131  : 			return &(*this)[selectorDict()->offset]; 

  00038	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?selectorDict@Object@@QAEPAVSelectorDict@@XZ ; Object::selectorDict
  00040	33 d2		 xor	 edx, edx
  00042	66 8b 50 14	 mov	 dx, WORD PTR [eax+20]
  00046	52		 push	 edx
  00047	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ??AObject@@QAEAAFH@Z	; Object::operator[]
  0004f	eb 02		 jmp	 SHORT $L57785
$L57787:

; 132  : 
; 133  : 		return 0;

  00051	33 c0		 xor	 eax, eax
$L57785:

; 134  : 	}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
?GetPropAddr@Object@@QAEPAFG@Z ENDP			; Object::GetPropAddr
_TEXT	ENDS
;	COMDAT ?selectorDict@Object@@QAEPAVSelectorDict@@XZ
_TEXT	SEGMENT
_this$ = -4
?selectorDict@Object@@QAEPAVSelectorDict@@XZ PROC NEAR	; Object::selectorDict, COMDAT

; 102  : 	SelectorDict *selectorDict ( void ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 103  : 		return _selectorDict;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 104  : 	};

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?selectorDict@Object@@QAEPAVSelectorDict@@XZ ENDP	; Object::selectorDict
_TEXT	ENDS
;	COMDAT ??AObject@@QAEAAFH@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
??AObject@@QAEAAFH@Z PROC NEAR				; Object::operator[], COMDAT

; 117  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 118  : 		//	get a reference to a property given the number of the property
; 119  : 		return ((Property*) this)[index];

  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]

; 120  : 	}

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??AObject@@QAEAAFH@Z ENDP				; Object::operator[]
_TEXT	ENDS
;	COMDAT ??CFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT
_this$ = -4
??CFakeObjectID@@QBEPAUObject@@XZ PROC NEAR		; FakeObjectID::operator->, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??CFakeObjectID@@QBEPAUObject@@XZ ENDP			; FakeObjectID::operator->
_TEXT	ENDS
PUBLIC	?IsObject@ObjectID@@QBEHXZ			; ObjectID::IsObject
;	COMDAT ?AssureValid@ObjectID@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4
?AssureValid@ObjectID@@QBEXXZ PROC NEAR			; ObjectID::AssureValid, COMDAT

; 238  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 239  : 		if (!IsObject())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?IsObject@ObjectID@@QBEHXZ ; ObjectID::IsObject
  0000f	85 c0		 test	 eax, eax
  00011	75 1e		 jne	 SHORT $L57955

; 240  : 			msgMgr->Fatal(Msg_NotObject, (int) *this);

  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  0001b	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00020	50		 push	 eax
  00021	6a 2f		 push	 47			; 0000002fH
  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXHZZ	; MsgMgr::Fatal
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L57955:

; 241  : 	}

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?AssureValid@ObjectID@@QBEXXZ ENDP			; ObjectID::AssureValid
_TEXT	ENDS
PUBLIC	?IsValid@MemID@@QBEHXZ				; MemID::IsValid
EXTRN	?GetMemType@MemID@@QBE?AW4MemType@@XZ:NEAR	; MemID::GetMemType
;	COMDAT ?IsObject@ObjectID@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsObject@ObjectID@@QBEHXZ PROC NEAR			; ObjectID::IsObject, COMDAT

; 247  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 248  : 		return IsValid() && GetMemType() == MemObject;

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  00011	85 c0		 test	 eax, eax
  00013	74 16		 je	 SHORT $L62483
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  0001d	83 f8 34	 cmp	 eax, 52			; 00000034H
  00020	75 09		 jne	 SHORT $L62483
  00022	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR -8+[ebp], 1
  00029	eb 07		 jmp	 SHORT $L62484
$L62483:
  0002b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], 0
$L62484:
  00032	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]

; 249  : 	}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?IsObject@ObjectID@@QBEHXZ ENDP				; ObjectID::IsObject
_TEXT	ENDS
PUBLIC	?IsValid@MemoryMgr@@QAEHG@Z			; MemoryMgr::IsValid
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsValid@MemID@@QBEHXZ PROC NEAR			; MemID::IsValid, COMDAT

; 62   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 63   : 		return memMgr->IsValid(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?IsValid@MemoryMgr@@QAEHG@Z ; MemoryMgr::IsValid

; 64   : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?IsValid@MemID@@QBEHXZ ENDP				; MemID::IsValid
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -8
_tempID$ = -4
?IsValid@MemoryMgr@@QAEHG@Z PROC NEAR			; MemoryMgr::IsValid, COMDAT

; 475  : 	inline Bool MemoryMgr::IsValid(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 476  : 		unsigned short tempID = (unsigned short)theID;

  00009	66 8b 45 08	 mov	 ax, WORD PTR _theID$[ebp]
  0000d	66 89 45 fc	 mov	 WORD PTR _tempID$[ebp], ax

; 477  : 
; 478  : 		return(
; 479  : 				(tempID)															&&
; 480  : 				(tempID < maxDescriptors)									&&
; 481  : 				(desc[tempID].memInfo.bits.freeDescriptor == False)	&&
; 482  : 				(desc[tempID].memInfo.bits.freeMemory == False)
; 483  : 				);

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _tempID$[ebp]
  00014	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 58		 je	 SHORT $L62487
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _tempID$[ebp]
  00021	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  0002d	73 47		 jae	 SHORT $L62487
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _tempID$[ebp]
  00032	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00038	c1 e1 04	 shl	 ecx, 4
  0003b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00041	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00044	c1 e1 0e	 shl	 ecx, 14			; 0000000eH
  00047	c1 f9 1f	 sar	 ecx, 31			; 0000001fH
  0004a	85 c9		 test	 ecx, ecx
  0004c	75 28		 jne	 SHORT $L62487
  0004e	8b 55 fc	 mov	 edx, DWORD PTR _tempID$[ebp]
  00051	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00057	c1 e2 04	 shl	 edx, 4
  0005a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00060	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00063	c1 e2 14	 shl	 edx, 20			; 00000014H
  00066	c1 fa 1f	 sar	 edx, 31			; 0000001fH
  00069	85 d2		 test	 edx, edx
  0006b	75 09		 jne	 SHORT $L62487
  0006d	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR -12+[ebp], 1
  00074	eb 07		 jmp	 SHORT $L62488
$L62487:
  00076	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR -12+[ebp], 0
$L62488:
  0007d	8b 45 f4	 mov	 eax, DWORD PTR -12+[ebp]

; 484  : 	}

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 04 00	 ret	 4
?IsValid@MemoryMgr@@QAEHG@Z ENDP			; MemoryMgr::IsValid
_TEXT	ENDS
_TEXT	SEGMENT
_polylist$ = 8
_i$ = 12
?DeletePolygon@@YAXPAVSOL_Polygon@@H@Z PROC NEAR	; DeletePolygon

; 2143 : {

  02d51	55		 push	 ebp
  02d52	8b ec		 mov	 ebp, esp

; 2144 :    for (;polylist[i].n != 0;++i)

  02d54	eb 09		 jmp	 SHORT $L61662
$L61663:
  02d56	8b 45 0c	 mov	 eax, DWORD PTR _i$[ebp]
  02d59	83 c0 01	 add	 eax, 1
  02d5c	89 45 0c	 mov	 DWORD PTR _i$[ebp], eax
$L61662:
  02d5f	8b 4d 0c	 mov	 ecx, DWORD PTR _i$[ebp]
  02d62	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  02d65	8b 55 08	 mov	 edx, DWORD PTR _polylist$[ebp]
  02d68	83 7c 0a 08 00	 cmp	 DWORD PTR [edx+ecx+8], 0
  02d6d	74 2b		 je	 SHORT $L61664

; 2146 :       polylist[i] = polylist[i+1];

  02d6f	8b 45 0c	 mov	 eax, DWORD PTR _i$[ebp]
  02d72	83 c0 01	 add	 eax, 1
  02d75	6b c0 0c	 imul	 eax, 12			; 0000000cH
  02d78	8b 4d 08	 mov	 ecx, DWORD PTR _polylist$[ebp]
  02d7b	03 c8		 add	 ecx, eax
  02d7d	8b 55 0c	 mov	 edx, DWORD PTR _i$[ebp]
  02d80	6b d2 0c	 imul	 edx, 12			; 0000000cH
  02d83	8b 45 08	 mov	 eax, DWORD PTR _polylist$[ebp]
  02d86	03 c2		 add	 eax, edx
  02d88	8b 11		 mov	 edx, DWORD PTR [ecx]
  02d8a	89 10		 mov	 DWORD PTR [eax], edx
  02d8c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  02d8f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  02d92	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  02d95	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 2147 :       }

  02d98	eb bc		 jmp	 SHORT $L61663
$L61664:

; 2148 : }

  02d9a	5d		 pop	 ebp
  02d9b	c3		 ret	 0
?DeletePolygon@@YAXPAVSOL_Polygon@@H@Z ENDP		; DeletePolygon
_TEXT	ENDS
PUBLIC	?AddPolygon@@YAXVMemID@@PAUSCI_Point@@HE@Z	; AddPolygon
_TEXT	SEGMENT
_polyListID$ = 8
_points$ = 12
_size$ = 16
_type$ = 20
_i$ = -8
_polyList$ = -4
?AddPolygon@@YAXVMemID@@PAUSCI_Point@@HE@Z PROC NEAR	; AddPolygon

; 2153 : {

  02d9c	55		 push	 ebp
  02d9d	8b ec		 mov	 ebp, esp
  02d9f	83 ec 08	 sub	 esp, 8

; 2154 : 	int i;
; 2155 : 	SOL_Polygon* polyList = (SOL_Polygon*) memMgr->GetAddr(polyListID);

  02da2	8d 4d 08	 lea	 ecx, DWORD PTR _polyListID$[ebp]
  02da5	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  02daa	50		 push	 eax
  02dab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  02db1	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr
  02db6	89 45 fc	 mov	 DWORD PTR _polyList$[ebp], eax

; 2156 : 
; 2157 : 	// Assumes the polylist is large enough to add another entry
; 2158 :    for (i=0;polyList[i].n != 0;++i)

  02db9	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  02dc0	eb 09		 jmp	 SHORT $L61674
$L61675:
  02dc2	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  02dc5	83 c0 01	 add	 eax, 1
  02dc8	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L61674:
  02dcb	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  02dce	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  02dd1	8b 55 fc	 mov	 edx, DWORD PTR _polyList$[ebp]
  02dd4	83 7c 0a 08 00	 cmp	 DWORD PTR [edx+ecx+8], 0
  02dd9	74 02		 je	 SHORT $L61676

; 2159 :       {}

  02ddb	eb e5		 jmp	 SHORT $L61675
$L61676:

; 2160 : 
; 2161 : 	polyList[i].polyPoints = points;

  02ddd	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  02de0	6b c0 0c	 imul	 eax, 12			; 0000000cH
  02de3	8b 4d fc	 mov	 ecx, DWORD PTR _polyList$[ebp]
  02de6	8b 55 0c	 mov	 edx, DWORD PTR _points$[ebp]
  02de9	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 2162 : 	polyList[i].n = size;

  02dec	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  02def	6b c0 0c	 imul	 eax, 12			; 0000000cH
  02df2	8b 4d fc	 mov	 ecx, DWORD PTR _polyList$[ebp]
  02df5	8b 55 10	 mov	 edx, DWORD PTR _size$[ebp]
  02df8	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx

; 2163 : 	polyList[i].type = type;

  02dfc	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  02dff	6b c0 0c	 imul	 eax, 12			; 0000000cH
  02e02	8b 4d fc	 mov	 ecx, DWORD PTR _polyList$[ebp]
  02e05	8a 55 14	 mov	 dl, BYTE PTR _type$[ebp]
  02e08	88 54 01 04	 mov	 BYTE PTR [ecx+eax+4], dl

; 2164 : 	polyList[i++].info = 0; 

  02e0c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  02e0f	6b c0 0c	 imul	 eax, 12			; 0000000cH
  02e12	8b 4d fc	 mov	 ecx, DWORD PTR _polyList$[ebp]
  02e15	c6 44 01 05 00	 mov	 BYTE PTR [ecx+eax+5], 0
  02e1a	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  02e1d	83 c2 01	 add	 edx, 1
  02e20	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx

; 2165 : 
; 2166 : 	polyList[i].polyPoints = NULL;

  02e23	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  02e26	6b c0 0c	 imul	 eax, 12			; 0000000cH
  02e29	8b 4d fc	 mov	 ecx, DWORD PTR _polyList$[ebp]
  02e2c	c7 04 01 00 00
	00 00		 mov	 DWORD PTR [ecx+eax], 0

; 2167 : 	polyList[i].n = 0;

  02e33	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  02e36	6b d2 0c	 imul	 edx, 12			; 0000000cH
  02e39	8b 45 fc	 mov	 eax, DWORD PTR _polyList$[ebp]
  02e3c	c7 44 10 08 00
	00 00 00	 mov	 DWORD PTR [eax+edx+8], 0

; 2168 : 	polyList[i].type = 0;

  02e44	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  02e47	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  02e4a	8b 55 fc	 mov	 edx, DWORD PTR _polyList$[ebp]
  02e4d	c6 44 0a 04 00	 mov	 BYTE PTR [edx+ecx+4], 0

; 2169 : 	polyList[i].info = 0; 

  02e52	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  02e55	6b c0 0c	 imul	 eax, 12			; 0000000cH
  02e58	8b 4d fc	 mov	 ecx, DWORD PTR _polyList$[ebp]
  02e5b	c6 44 01 05 00	 mov	 BYTE PTR [ecx+eax+5], 0

; 2170 : 
; 2171 : }

  02e60	8b e5		 mov	 esp, ebp
  02e62	5d		 pop	 ebp
  02e63	c3		 ret	 0
?AddPolygon@@YAXVMemID@@PAUSCI_Point@@HE@Z ENDP		; AddPolygon
_TEXT	ENDS
PUBLIC	??ZSCI_Point@@QAEAAU0@ABU0@@Z			; SCI_Point::operator-=
PUBLIC	??HSCI_Point@@QBE?AU0@ABU0@@Z			; SCI_Point::operator+
_TEXT	SEGMENT
$T62492 = -60
$T62493 = -64
$T62494 = -68
$T62495 = -72
$T62496 = -76
$T62497 = -80
$T62510 = -84
$T62511 = -88
_A$ = 8
_B$ = 12
_C$ = 16
_D$ = 20
_intersection$ = 24
_x1$ = -20
_x2$ = -24
_dot1$ = -32
_dot2$ = -40
_dot3$ = -48
_d$ = -12
_U$ = -16
_tmp1$ = -28
_tmp2$ = -36
_tmp3$ = -44
_tmp4$ = -52
_tmp5$ = -56
_tmp6$ = -4
_tmp7$ = -8
?IntersectSegments@@YAHAAUSCI_Point@@000PAU1@@Z PROC NEAR ; IntersectSegments

; 2196 : {

  02e64	55		 push	 ebp
  02e65	8b ec		 mov	 ebp, esp
  02e67	83 ec 70	 sub	 esp, 112		; 00000070H

; 2197 :    int         x1,x2;
; 2198 :    int         dot1,dot2,dot3,d;
; 2199 :    SCI_Point   U,tmp1,tmp2,tmp3,tmp4,tmp5,tmp6,tmp7;

  02e6a	8d 4d f0	 lea	 ecx, DWORD PTR _U$[ebp]
  02e6d	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  02e72	8d 4d e4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  02e75	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  02e7a	8d 4d dc	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  02e7d	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  02e82	8d 4d d4	 lea	 ecx, DWORD PTR _tmp3$[ebp]
  02e85	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  02e8a	8d 4d cc	 lea	 ecx, DWORD PTR _tmp4$[ebp]
  02e8d	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  02e92	8d 4d c8	 lea	 ecx, DWORD PTR _tmp5$[ebp]
  02e95	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  02e9a	8d 4d fc	 lea	 ecx, DWORD PTR _tmp6$[ebp]
  02e9d	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  02ea2	8d 4d f8	 lea	 ecx, DWORD PTR _tmp7$[ebp]
  02ea5	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point

; 2200 : 
; 2201 :    tmp1 = B - A;

  02eaa	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  02ead	50		 push	 eax
  02eae	8d 4d c4	 lea	 ecx, DWORD PTR $T62492[ebp]
  02eb1	51		 push	 ecx
  02eb2	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  02eb5	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  02eba	50		 push	 eax
  02ebb	8d 4d e4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  02ebe	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 2202 :    tmp2 = C - A;

  02ec3	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  02ec6	52		 push	 edx
  02ec7	8d 45 c0	 lea	 eax, DWORD PTR $T62493[ebp]
  02eca	50		 push	 eax
  02ecb	8b 4d 10	 mov	 ecx, DWORD PTR _C$[ebp]
  02ece	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  02ed3	50		 push	 eax
  02ed4	8d 4d dc	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  02ed7	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 2203 :    tmp3 = D - A;

  02edc	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  02edf	51		 push	 ecx
  02ee0	8d 55 bc	 lea	 edx, DWORD PTR $T62494[ebp]
  02ee3	52		 push	 edx
  02ee4	8b 4d 14	 mov	 ecx, DWORD PTR _D$[ebp]
  02ee7	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  02eec	50		 push	 eax
  02eed	8d 4d d4	 lea	 ecx, DWORD PTR _tmp3$[ebp]
  02ef0	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 2204 :    tmp4 = C - D;

  02ef5	8b 45 14	 mov	 eax, DWORD PTR _D$[ebp]
  02ef8	50		 push	 eax
  02ef9	8d 4d b8	 lea	 ecx, DWORD PTR $T62495[ebp]
  02efc	51		 push	 ecx
  02efd	8b 4d 10	 mov	 ecx, DWORD PTR _C$[ebp]
  02f00	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  02f05	50		 push	 eax
  02f06	8d 4d cc	 lea	 ecx, DWORD PTR _tmp4$[ebp]
  02f09	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 2205 :    dot3 = tmp4*tmp4;

  02f0e	8d 55 cc	 lea	 edx, DWORD PTR _tmp4$[ebp]
  02f11	52		 push	 edx
  02f12	8d 4d cc	 lea	 ecx, DWORD PTR _tmp4$[ebp]
  02f15	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  02f1a	89 45 d0	 mov	 DWORD PTR _dot3$[ebp], eax

; 2206 :    if (dot3==0)

  02f1d	83 7d d0 00	 cmp	 DWORD PTR _dot3$[ebp], 0
  02f21	75 08		 jne	 SHORT $L61702

; 2208 :       return(NOINTERSECT);

  02f23	83 c8 ff	 or	 eax, -1
  02f26	e9 c2 05 00 00	 jmp	 $L61683
$L61702:

; 2210 : 
; 2211 :    x1 = tmp1^tmp2;

  02f2b	8d 45 dc	 lea	 eax, DWORD PTR _tmp2$[ebp]
  02f2e	50		 push	 eax
  02f2f	8d 4d e4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  02f32	e8 00 00 00 00	 call	 ??TSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator^
  02f37	89 45 ec	 mov	 DWORD PTR _x1$[ebp], eax

; 2212 :    x2 = tmp1^tmp3;

  02f3a	8d 4d d4	 lea	 ecx, DWORD PTR _tmp3$[ebp]
  02f3d	51		 push	 ecx
  02f3e	8d 4d e4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  02f41	e8 00 00 00 00	 call	 ??TSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator^
  02f46	89 45 e8	 mov	 DWORD PTR _x2$[ebp], eax

; 2213 : 
; 2214 :    // check for colinear
; 2215 :    if (x1 == 0 && x2 == 0)

  02f49	83 7d ec 00	 cmp	 DWORD PTR _x1$[ebp], 0
  02f4d	75 0d		 jne	 SHORT $L61703
  02f4f	83 7d e8 00	 cmp	 DWORD PTR _x2$[ebp], 0
  02f53	75 07		 jne	 SHORT $L61703

; 2218 :       return(COLINEAR);

  02f55	33 c0		 xor	 eax, eax
  02f57	e9 91 05 00 00	 jmp	 $L61683
$L61703:

; 2220 : 
; 2221 :    // check for intersection at C
; 2222 :    if (x1 == 0)

  02f5c	83 7d ec 00	 cmp	 DWORD PTR _x1$[ebp], 0
  02f60	0f 85 c6 00 00
	00		 jne	 $L61710

; 2223 :       // C lies on the line through A-B find out
; 2224 :       // if it is in the line segment A-B.
; 2225 :       if (A.x == B.x)

  02f66	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  02f69	0f bf 02	 movsx	 eax, WORD PTR [edx]
  02f6c	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  02f6f	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  02f72	3b c2		 cmp	 eax, edx
  02f74	75 60		 jne	 SHORT $L61705

; 2228 :                (
; 2229 :                (A.y <= C.y)    &&
; 2230 :                (C.y <= B.y)
; 2231 :                )
; 2232 :                ||
; 2233 :                (
; 2234 :                (B.y <= C.y)    &&
; 2235 :                (C.y <= A.y)
; 2236 :                )
; 2237 :             )

  02f76	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  02f79	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  02f7d	8b 55 10	 mov	 edx, DWORD PTR _C$[ebp]
  02f80	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  02f84	3b c8		 cmp	 ecx, eax
  02f86	7f 12		 jg	 SHORT $L61708
  02f88	8b 4d 10	 mov	 ecx, DWORD PTR _C$[ebp]
  02f8b	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  02f8f	8b 45 0c	 mov	 eax, DWORD PTR _B$[ebp]
  02f92	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  02f96	3b d1		 cmp	 edx, ecx
  02f98	7e 24		 jle	 SHORT $L61707
$L61708:
  02f9a	8b 55 0c	 mov	 edx, DWORD PTR _B$[ebp]
  02f9d	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  02fa1	8b 4d 10	 mov	 ecx, DWORD PTR _C$[ebp]
  02fa4	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  02fa8	3b c2		 cmp	 eax, edx
  02faa	7f 28		 jg	 SHORT $L61706
  02fac	8b 45 10	 mov	 eax, DWORD PTR _C$[ebp]
  02faf	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  02fb3	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  02fb6	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  02fba	3b c8		 cmp	 ecx, eax
  02fbc	7f 16		 jg	 SHORT $L61706
$L61707:

; 2239 :             *intersection = C;

  02fbe	8b 4d 10	 mov	 ecx, DWORD PTR _C$[ebp]
  02fc1	51		 push	 ecx
  02fc2	8b 4d 18	 mov	 ecx, DWORD PTR _intersection$[ebp]
  02fc5	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 2240 :             return(INTERSECT+INTERSECTC);

  02fca	b8 09 00 00 00	 mov	 eax, 9
  02fcf	e9 19 05 00 00	 jmp	 $L61683
$L61706:

; 2243 :       else

  02fd4	eb 56		 jmp	 SHORT $L61710
$L61705:

; 2246 :                (
; 2247 :                (A.x <= C.x)    &&
; 2248 :                (C.x <= B.x)
; 2249 :                )
; 2250 :                ||
; 2251 :                (
; 2252 :                (B.x <= C.x)    &&
; 2253 :                (C.x <= A.x)
; 2254 :                )
; 2255 :             )

  02fd6	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  02fd9	0f bf 02	 movsx	 eax, WORD PTR [edx]
  02fdc	8b 4d 10	 mov	 ecx, DWORD PTR _C$[ebp]
  02fdf	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  02fe2	3b c2		 cmp	 eax, edx
  02fe4	7f 10		 jg	 SHORT $L61712
  02fe6	8b 45 10	 mov	 eax, DWORD PTR _C$[ebp]
  02fe9	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  02fec	8b 55 0c	 mov	 edx, DWORD PTR _B$[ebp]
  02fef	0f bf 02	 movsx	 eax, WORD PTR [edx]
  02ff2	3b c8		 cmp	 ecx, eax
  02ff4	7e 20		 jle	 SHORT $L61711
$L61712:
  02ff6	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  02ff9	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  02ffc	8b 45 10	 mov	 eax, DWORD PTR _C$[ebp]
  02fff	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  03002	3b d1		 cmp	 edx, ecx
  03004	7f 26		 jg	 SHORT $L61710
  03006	8b 55 10	 mov	 edx, DWORD PTR _C$[ebp]
  03009	0f bf 02	 movsx	 eax, WORD PTR [edx]
  0300c	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  0300f	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  03012	3b c2		 cmp	 eax, edx
  03014	7f 16		 jg	 SHORT $L61710
$L61711:

; 2257 :             *intersection = C;

  03016	8b 45 10	 mov	 eax, DWORD PTR _C$[ebp]
  03019	50		 push	 eax
  0301a	8b 4d 18	 mov	 ecx, DWORD PTR _intersection$[ebp]
  0301d	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 2258 :             return(INTERSECT+INTERSECTC);

  03022	b8 09 00 00 00	 mov	 eax, 9
  03027	e9 c1 04 00 00	 jmp	 $L61683
$L61710:

; 2261 : 
; 2262 :    // check for intersection at D
; 2263 :    if (x2 == 0)

  0302c	83 7d e8 00	 cmp	 DWORD PTR _x2$[ebp], 0
  03030	0f 85 c6 00 00
	00		 jne	 $L61719

; 2264 :       // D lies on the line through A-B find out
; 2265 :       // if it is in the line segment A-B.
; 2266 :       if (A.x == B.x)

  03036	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  03039	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  0303c	8b 45 0c	 mov	 eax, DWORD PTR _B$[ebp]
  0303f	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  03042	3b d1		 cmp	 edx, ecx
  03044	75 60		 jne	 SHORT $L61714

; 2269 :                (
; 2270 :                (A.y <= D.y)    &&
; 2271 :                (D.y <= B.y)
; 2272 :                )
; 2273 :                ||
; 2274 :                (
; 2275 :                (B.y <= D.y)    &&
; 2276 :                (D.y <= A.y)
; 2277 :                )
; 2278 :             )

  03046	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  03049	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  0304d	8b 4d 14	 mov	 ecx, DWORD PTR _D$[ebp]
  03050	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  03054	3b c2		 cmp	 eax, edx
  03056	7f 12		 jg	 SHORT $L61717
  03058	8b 45 14	 mov	 eax, DWORD PTR _D$[ebp]
  0305b	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  0305f	8b 55 0c	 mov	 edx, DWORD PTR _B$[ebp]
  03062	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  03066	3b c8		 cmp	 ecx, eax
  03068	7e 24		 jle	 SHORT $L61716
$L61717:
  0306a	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  0306d	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  03071	8b 45 14	 mov	 eax, DWORD PTR _D$[ebp]
  03074	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  03078	3b d1		 cmp	 edx, ecx
  0307a	7f 28		 jg	 SHORT $L61715
  0307c	8b 55 14	 mov	 edx, DWORD PTR _D$[ebp]
  0307f	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  03083	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  03086	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  0308a	3b c2		 cmp	 eax, edx
  0308c	7f 16		 jg	 SHORT $L61715
$L61716:

; 2280 :             *intersection = D;

  0308e	8b 45 14	 mov	 eax, DWORD PTR _D$[ebp]
  03091	50		 push	 eax
  03092	8b 4d 18	 mov	 ecx, DWORD PTR _intersection$[ebp]
  03095	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 2281 :             return(INTERSECT+INTERSECTD);

  0309a	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  0309f	e9 49 04 00 00	 jmp	 $L61683
$L61715:

; 2284 :       else

  030a4	eb 56		 jmp	 SHORT $L61719
$L61714:

; 2287 :                (
; 2288 :                (A.x <= D.x)    &&
; 2289 :                (D.x <= B.x)
; 2290 :                )
; 2291 :                ||
; 2292 :                (
; 2293 :                (B.x <= D.x)    &&
; 2294 :                (D.x <= A.x)
; 2295 :                )
; 2296 :             )

  030a6	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  030a9	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  030ac	8b 45 14	 mov	 eax, DWORD PTR _D$[ebp]
  030af	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  030b2	3b d1		 cmp	 edx, ecx
  030b4	7f 10		 jg	 SHORT $L61721
  030b6	8b 55 14	 mov	 edx, DWORD PTR _D$[ebp]
  030b9	0f bf 02	 movsx	 eax, WORD PTR [edx]
  030bc	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  030bf	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  030c2	3b c2		 cmp	 eax, edx
  030c4	7e 20		 jle	 SHORT $L61720
$L61721:
  030c6	8b 45 0c	 mov	 eax, DWORD PTR _B$[ebp]
  030c9	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  030cc	8b 55 14	 mov	 edx, DWORD PTR _D$[ebp]
  030cf	0f bf 02	 movsx	 eax, WORD PTR [edx]
  030d2	3b c8		 cmp	 ecx, eax
  030d4	7f 26		 jg	 SHORT $L61719
  030d6	8b 4d 14	 mov	 ecx, DWORD PTR _D$[ebp]
  030d9	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  030dc	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  030df	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  030e2	3b d1		 cmp	 edx, ecx
  030e4	7f 16		 jg	 SHORT $L61719
$L61720:

; 2298 :             *intersection =  D; 

  030e6	8b 55 14	 mov	 edx, DWORD PTR _D$[ebp]
  030e9	52		 push	 edx
  030ea	8b 4d 18	 mov	 ecx, DWORD PTR _intersection$[ebp]
  030ed	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 2299 :             return(INTERSECT+INTERSECTD);

  030f2	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  030f7	e9 f1 03 00 00	 jmp	 $L61683
$L61719:

; 2302 : 
; 2303 :    // check for intersection at A
; 2304 :    //tmp4 = C - D;
; 2305 :    tmp5 = B - C;

  030fc	8b 45 10	 mov	 eax, DWORD PTR _C$[ebp]
  030ff	50		 push	 eax
  03100	8d 4d b4	 lea	 ecx, DWORD PTR $T62496[ebp]
  03103	51		 push	 ecx
  03104	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  03107	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  0310c	50		 push	 eax
  0310d	8d 4d c8	 lea	 ecx, DWORD PTR _tmp5$[ebp]
  03110	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 2306 :    tmp6 = B - D;

  03115	8b 55 14	 mov	 edx, DWORD PTR _D$[ebp]
  03118	52		 push	 edx
  03119	8d 45 b0	 lea	 eax, DWORD PTR $T62497[ebp]
  0311c	50		 push	 eax
  0311d	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  03120	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  03125	50		 push	 eax
  03126	8d 4d fc	 lea	 ecx, DWORD PTR _tmp6$[ebp]
  03129	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 2307 :    //dot3 = tmp4*tmp4;
; 2308 : //   if (dot3==0)
; 2309 : //		msgMgr->Fatal(SrcLoc,"Polygon contains identical points at x:%d,y:%d\n",C.x,C.y);
; 2310 : //		msgMgr->Fatal(SrcLoc,Msg_GetPathInternalError);
; 2311 :    if ( ((d = (tmp4*tmp2)) >= 0) && ((tmp4*tmp3) <= 0) )

  0312e	8d 4d dc	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  03131	51		 push	 ecx
  03132	8d 4d cc	 lea	 ecx, DWORD PTR _tmp4$[ebp]
  03135	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  0313a	89 45 f4	 mov	 DWORD PTR _d$[ebp], eax
  0313d	83 7d f4 00	 cmp	 DWORD PTR _d$[ebp], 0
  03141	0f 8c b1 00 00
	00		 jl	 $L61724
  03147	8d 55 d4	 lea	 edx, DWORD PTR _tmp3$[ebp]
  0314a	52		 push	 edx
  0314b	8d 4d cc	 lea	 ecx, DWORD PTR _tmp4$[ebp]
  0314e	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  03153	85 c0		 test	 eax, eax
  03155	0f 8f 9d 00 00
	00		 jg	 $L61724

; 2313 :       tmp7.x = ((d*(int)tmp4.x + (int) (sign(tmp4.x)*dot3/2))/dot3);

  0315b	0f bf 45 cc	 movsx	 eax, WORD PTR _tmp4$[ebp]
  0315f	85 c0		 test	 eax, eax
  03161	7e 09		 jle	 SHORT $L62498
  03163	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR -92+[ebp], 1
  0316a	eb 0f		 jmp	 SHORT $L62499
$L62498:
  0316c	0f bf 4d cc	 movsx	 ecx, WORD PTR _tmp4$[ebp]
  03170	33 d2		 xor	 edx, edx
  03172	85 c9		 test	 ecx, ecx
  03174	0f 9d c2	 setge	 dl
  03177	4a		 dec	 edx
  03178	89 55 a4	 mov	 DWORD PTR -92+[ebp], edx
$L62499:
  0317b	0f bf 45 cc	 movsx	 eax, WORD PTR _tmp4$[ebp]
  0317f	8b 4d f4	 mov	 ecx, DWORD PTR _d$[ebp]
  03182	0f af c8	 imul	 ecx, eax
  03185	8b 45 a4	 mov	 eax, DWORD PTR -92+[ebp]
  03188	0f af 45 d0	 imul	 eax, DWORD PTR _dot3$[ebp]
  0318c	99		 cdq
  0318d	2b c2		 sub	 eax, edx
  0318f	d1 f8		 sar	 eax, 1
  03191	03 c1		 add	 eax, ecx
  03193	99		 cdq
  03194	f7 7d d0	 idiv	 DWORD PTR _dot3$[ebp]
  03197	66 89 45 f8	 mov	 WORD PTR _tmp7$[ebp], ax

; 2314 :       tmp7.y = ((d*(int)tmp4.y + (int) (sign(tmp4.y)*dot3/2))/dot3);

  0319b	0f bf 55 ce	 movsx	 edx, WORD PTR _tmp4$[ebp+2]
  0319f	85 d2		 test	 edx, edx
  031a1	7e 09		 jle	 SHORT $L62500
  031a3	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR -96+[ebp], 1
  031aa	eb 0f		 jmp	 SHORT $L62501
$L62500:
  031ac	0f bf 45 ce	 movsx	 eax, WORD PTR _tmp4$[ebp+2]
  031b0	33 c9		 xor	 ecx, ecx
  031b2	85 c0		 test	 eax, eax
  031b4	0f 9d c1	 setge	 cl
  031b7	49		 dec	 ecx
  031b8	89 4d a0	 mov	 DWORD PTR -96+[ebp], ecx
$L62501:
  031bb	0f bf 55 ce	 movsx	 edx, WORD PTR _tmp4$[ebp+2]
  031bf	8b 4d f4	 mov	 ecx, DWORD PTR _d$[ebp]
  031c2	0f af ca	 imul	 ecx, edx
  031c5	8b 45 a0	 mov	 eax, DWORD PTR -96+[ebp]
  031c8	0f af 45 d0	 imul	 eax, DWORD PTR _dot3$[ebp]
  031cc	99		 cdq
  031cd	2b c2		 sub	 eax, edx
  031cf	d1 f8		 sar	 eax, 1
  031d1	03 c1		 add	 eax, ecx
  031d3	99		 cdq
  031d4	f7 7d d0	 idiv	 DWORD PTR _dot3$[ebp]
  031d7	66 89 45 fa	 mov	 WORD PTR _tmp7$[ebp+2], ax

; 2315 :       tmp7 -= tmp2;

  031db	8d 55 dc	 lea	 edx, DWORD PTR _tmp2$[ebp]
  031de	52		 push	 edx
  031df	8d 4d f8	 lea	 ecx, DWORD PTR _tmp7$[ebp]
  031e2	e8 00 00 00 00	 call	 ??ZSCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator-=

; 2316 :       d = tmp7*tmp7;

  031e7	8d 45 f8	 lea	 eax, DWORD PTR _tmp7$[ebp]
  031ea	50		 push	 eax
  031eb	8d 4d f8	 lea	 ecx, DWORD PTR _tmp7$[ebp]
  031ee	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  031f3	89 45 f4	 mov	 DWORD PTR _d$[ebp], eax

; 2318 :    else

  031f6	eb 34		 jmp	 SHORT $L61731
$L61724:

; 2320 :       if ((dot1 = (tmp2*tmp2)) <= (dot2 = (tmp3*tmp3)))

  031f8	8d 4d dc	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  031fb	51		 push	 ecx
  031fc	8d 4d dc	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  031ff	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  03204	89 45 e0	 mov	 DWORD PTR _dot1$[ebp], eax
  03207	8d 55 d4	 lea	 edx, DWORD PTR _tmp3$[ebp]
  0320a	52		 push	 edx
  0320b	8d 4d d4	 lea	 ecx, DWORD PTR _tmp3$[ebp]
  0320e	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  03213	89 45 d8	 mov	 DWORD PTR _dot2$[ebp], eax
  03216	8b 45 e0	 mov	 eax, DWORD PTR _dot1$[ebp]
  03219	3b 45 d8	 cmp	 eax, DWORD PTR _dot2$[ebp]
  0321c	7f 08		 jg	 SHORT $L61730

; 2321 :          d = dot1; 

  0321e	8b 4d e0	 mov	 ecx, DWORD PTR _dot1$[ebp]
  03221	89 4d f4	 mov	 DWORD PTR _d$[ebp], ecx

; 2322 :       else

  03224	eb 06		 jmp	 SHORT $L61731
$L61730:

; 2323 :          d = dot2; 

  03226	8b 55 d8	 mov	 edx, DWORD PTR _dot2$[ebp]
  03229	89 55 f4	 mov	 DWORD PTR _d$[ebp], edx
$L61731:

; 2325 :    if (d <= CLOSETOLINE)

  0322c	83 7d f4 02	 cmp	 DWORD PTR _d$[ebp], 2
  03230	7f 16		 jg	 SHORT $L61732

; 2327 :       *intersection =  A; 

  03232	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  03235	50		 push	 eax
  03236	8b 4d 18	 mov	 ecx, DWORD PTR _intersection$[ebp]
  03239	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 2328 :       return(INTERSECT+INTERSECTA);

  0323e	b8 03 00 00 00	 mov	 eax, 3
  03243	e9 a5 02 00 00	 jmp	 $L61683
$L61732:

; 2330 : 
; 2331 :    // check for intersection at B
; 2332 :    if ( ((d = (tmp4*tmp6)) >= 0) && ((tmp4*tmp5) <= 0) )

  03248	8d 4d fc	 lea	 ecx, DWORD PTR _tmp6$[ebp]
  0324b	51		 push	 ecx
  0324c	8d 4d cc	 lea	 ecx, DWORD PTR _tmp4$[ebp]
  0324f	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  03254	89 45 f4	 mov	 DWORD PTR _d$[ebp], eax
  03257	83 7d f4 00	 cmp	 DWORD PTR _d$[ebp], 0
  0325b	0f 8c b1 00 00
	00		 jl	 $L61733
  03261	8d 55 c8	 lea	 edx, DWORD PTR _tmp5$[ebp]
  03264	52		 push	 edx
  03265	8d 4d cc	 lea	 ecx, DWORD PTR _tmp4$[ebp]
  03268	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  0326d	85 c0		 test	 eax, eax
  0326f	0f 8f 9d 00 00
	00		 jg	 $L61733

; 2334 :       tmp7.x = ((d*(int)tmp4.x + (int) (sign(tmp4.x)*dot3/2))/dot3);

  03275	0f bf 45 cc	 movsx	 eax, WORD PTR _tmp4$[ebp]
  03279	85 c0		 test	 eax, eax
  0327b	7e 09		 jle	 SHORT $L62502
  0327d	c7 45 9c 01 00
	00 00		 mov	 DWORD PTR -100+[ebp], 1
  03284	eb 0f		 jmp	 SHORT $L62503
$L62502:
  03286	0f bf 4d cc	 movsx	 ecx, WORD PTR _tmp4$[ebp]
  0328a	33 d2		 xor	 edx, edx
  0328c	85 c9		 test	 ecx, ecx
  0328e	0f 9d c2	 setge	 dl
  03291	4a		 dec	 edx
  03292	89 55 9c	 mov	 DWORD PTR -100+[ebp], edx
$L62503:
  03295	0f bf 45 cc	 movsx	 eax, WORD PTR _tmp4$[ebp]
  03299	8b 4d f4	 mov	 ecx, DWORD PTR _d$[ebp]
  0329c	0f af c8	 imul	 ecx, eax
  0329f	8b 45 9c	 mov	 eax, DWORD PTR -100+[ebp]
  032a2	0f af 45 d0	 imul	 eax, DWORD PTR _dot3$[ebp]
  032a6	99		 cdq
  032a7	2b c2		 sub	 eax, edx
  032a9	d1 f8		 sar	 eax, 1
  032ab	03 c1		 add	 eax, ecx
  032ad	99		 cdq
  032ae	f7 7d d0	 idiv	 DWORD PTR _dot3$[ebp]
  032b1	66 89 45 f8	 mov	 WORD PTR _tmp7$[ebp], ax

; 2335 :       tmp7.y = ((d*(int)tmp4.y + (int) (sign(tmp4.y)*dot3/2))/dot3);

  032b5	0f bf 55 ce	 movsx	 edx, WORD PTR _tmp4$[ebp+2]
  032b9	85 d2		 test	 edx, edx
  032bb	7e 09		 jle	 SHORT $L62504
  032bd	c7 45 98 01 00
	00 00		 mov	 DWORD PTR -104+[ebp], 1
  032c4	eb 0f		 jmp	 SHORT $L62505
$L62504:
  032c6	0f bf 45 ce	 movsx	 eax, WORD PTR _tmp4$[ebp+2]
  032ca	33 c9		 xor	 ecx, ecx
  032cc	85 c0		 test	 eax, eax
  032ce	0f 9d c1	 setge	 cl
  032d1	49		 dec	 ecx
  032d2	89 4d 98	 mov	 DWORD PTR -104+[ebp], ecx
$L62505:
  032d5	0f bf 55 ce	 movsx	 edx, WORD PTR _tmp4$[ebp+2]
  032d9	8b 4d f4	 mov	 ecx, DWORD PTR _d$[ebp]
  032dc	0f af ca	 imul	 ecx, edx
  032df	8b 45 98	 mov	 eax, DWORD PTR -104+[ebp]
  032e2	0f af 45 d0	 imul	 eax, DWORD PTR _dot3$[ebp]
  032e6	99		 cdq
  032e7	2b c2		 sub	 eax, edx
  032e9	d1 f8		 sar	 eax, 1
  032eb	03 c1		 add	 eax, ecx
  032ed	99		 cdq
  032ee	f7 7d d0	 idiv	 DWORD PTR _dot3$[ebp]
  032f1	66 89 45 fa	 mov	 WORD PTR _tmp7$[ebp+2], ax

; 2336 :       tmp7 -= tmp6;

  032f5	8d 55 fc	 lea	 edx, DWORD PTR _tmp6$[ebp]
  032f8	52		 push	 edx
  032f9	8d 4d f8	 lea	 ecx, DWORD PTR _tmp7$[ebp]
  032fc	e8 00 00 00 00	 call	 ??ZSCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator-=

; 2337 :       d = tmp7*tmp7;

  03301	8d 45 f8	 lea	 eax, DWORD PTR _tmp7$[ebp]
  03304	50		 push	 eax
  03305	8d 4d f8	 lea	 ecx, DWORD PTR _tmp7$[ebp]
  03308	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  0330d	89 45 f4	 mov	 DWORD PTR _d$[ebp], eax

; 2339 :    else

  03310	eb 34		 jmp	 SHORT $L61740
$L61733:

; 2341 :       if ((dot1 = (tmp5*tmp5)) <= (dot2 = (tmp6*tmp6)))

  03312	8d 4d c8	 lea	 ecx, DWORD PTR _tmp5$[ebp]
  03315	51		 push	 ecx
  03316	8d 4d c8	 lea	 ecx, DWORD PTR _tmp5$[ebp]
  03319	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  0331e	89 45 e0	 mov	 DWORD PTR _dot1$[ebp], eax
  03321	8d 55 fc	 lea	 edx, DWORD PTR _tmp6$[ebp]
  03324	52		 push	 edx
  03325	8d 4d fc	 lea	 ecx, DWORD PTR _tmp6$[ebp]
  03328	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  0332d	89 45 d8	 mov	 DWORD PTR _dot2$[ebp], eax
  03330	8b 45 e0	 mov	 eax, DWORD PTR _dot1$[ebp]
  03333	3b 45 d8	 cmp	 eax, DWORD PTR _dot2$[ebp]
  03336	7f 08		 jg	 SHORT $L61739

; 2342 :          d = dot1; 

  03338	8b 4d e0	 mov	 ecx, DWORD PTR _dot1$[ebp]
  0333b	89 4d f4	 mov	 DWORD PTR _d$[ebp], ecx

; 2343 :       else

  0333e	eb 06		 jmp	 SHORT $L61740
$L61739:

; 2344 :          d = dot2; 

  03340	8b 55 d8	 mov	 edx, DWORD PTR _dot2$[ebp]
  03343	89 55 f4	 mov	 DWORD PTR _d$[ebp], edx
$L61740:

; 2346 :    if (d <= CLOSETOLINE) 

  03346	83 7d f4 02	 cmp	 DWORD PTR _d$[ebp], 2
  0334a	7f 16		 jg	 SHORT $L61741

; 2348 :       *intersection =  B; 

  0334c	8b 45 0c	 mov	 eax, DWORD PTR _B$[ebp]
  0334f	50		 push	 eax
  03350	8b 4d 18	 mov	 ecx, DWORD PTR _intersection$[ebp]
  03353	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 2349 :       return(INTERSECT+INTERSECTB);

  03358	b8 05 00 00 00	 mov	 eax, 5
  0335d	e9 8b 01 00 00	 jmp	 $L61683
$L61741:

; 2351 : 
; 2352 :    // check that C,D on opposite side of line through A-B
; 2353 :    if (x1*x2 >= 0)

  03362	8b 4d ec	 mov	 ecx, DWORD PTR _x1$[ebp]
  03365	0f af 4d e8	 imul	 ecx, DWORD PTR _x2$[ebp]
  03369	85 c9		 test	 ecx, ecx
  0336b	7c 08		 jl	 SHORT $L61742

; 2355 :       return(NOINTERSECT);

  0336d	83 c8 ff	 or	 eax, -1
  03370	e9 78 01 00 00	 jmp	 $L61683
$L61742:

; 2357 : 
; 2358 :    // check that A,B on opposite side of line through C-D
; 2359 :    x1 = tmp2^tmp4;

  03375	8d 55 cc	 lea	 edx, DWORD PTR _tmp4$[ebp]
  03378	52		 push	 edx
  03379	8d 4d dc	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  0337c	e8 00 00 00 00	 call	 ??TSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator^
  03381	89 45 ec	 mov	 DWORD PTR _x1$[ebp], eax

; 2360 :    x2 = tmp4^tmp5;

  03384	8d 45 c8	 lea	 eax, DWORD PTR _tmp5$[ebp]
  03387	50		 push	 eax
  03388	8d 4d cc	 lea	 ecx, DWORD PTR _tmp4$[ebp]
  0338b	e8 00 00 00 00	 call	 ??TSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator^
  03390	89 45 e8	 mov	 DWORD PTR _x2$[ebp], eax

; 2361 :    if (x1*x2 >= 0)

  03393	8b 4d ec	 mov	 ecx, DWORD PTR _x1$[ebp]
  03396	0f af 4d e8	 imul	 ecx, DWORD PTR _x2$[ebp]
  0339a	85 c9		 test	 ecx, ecx
  0339c	7c 08		 jl	 SHORT $L61743

; 2363 :       return(NOINTERSECT);

  0339e	83 c8 ff	 or	 eax, -1
  033a1	e9 47 01 00 00	 jmp	 $L61683
$L61743:

; 2365 : 
; 2366 :    // Intersection interior to both line
; 2367 :    // segments calculate intersection point.
; 2368 : 
; 2369 :    // U is normal to C-D pointing toward the outside of the polygon
; 2370 :    U.x = -tmp4.y;

  033a6	0f bf 55 ce	 movsx	 edx, WORD PTR _tmp4$[ebp+2]
  033aa	f7 da		 neg	 edx
  033ac	66 89 55 f0	 mov	 WORD PTR _U$[ebp], dx

; 2371 :    U.y = tmp4.x;

  033b0	66 8b 45 cc	 mov	 ax, WORD PTR _tmp4$[ebp]
  033b4	66 89 45 f2	 mov	 WORD PTR _U$[ebp+2], ax

; 2372 :    // U dot (A-C)
; 2373 :    dot1 = U*tmp2;

  033b8	8d 4d dc	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  033bb	51		 push	 ecx
  033bc	8d 4d f0	 lea	 ecx, DWORD PTR _U$[ebp]
  033bf	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  033c4	89 45 e0	 mov	 DWORD PTR _dot1$[ebp], eax

; 2374 :    // U dot (A-B)
; 2375 :    dot2 = U*tmp1;

  033c7	8d 55 e4	 lea	 edx, DWORD PTR _tmp1$[ebp]
  033ca	52		 push	 edx
  033cb	8d 4d f0	 lea	 ecx, DWORD PTR _U$[ebp]
  033ce	e8 00 00 00 00	 call	 ??DSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator*
  033d3	89 45 d8	 mov	 DWORD PTR _dot2$[ebp], eax

; 2376 :    dot3 = dot2;

  033d6	8b 45 d8	 mov	 eax, DWORD PTR _dot2$[ebp]
  033d9	89 45 d0	 mov	 DWORD PTR _dot3$[ebp], eax

; 2377 :    if (dot1 < 0) 

  033dc	83 7d e0 00	 cmp	 DWORD PTR _dot1$[ebp], 0
  033e0	7d 08		 jge	 SHORT $L61744

; 2378 :       dot1 = - dot1;

  033e2	8b 4d e0	 mov	 ecx, DWORD PTR _dot1$[ebp]
  033e5	f7 d9		 neg	 ecx
  033e7	89 4d e0	 mov	 DWORD PTR _dot1$[ebp], ecx
$L61744:

; 2379 :    if (dot2 < 0) 

  033ea	83 7d d8 00	 cmp	 DWORD PTR _dot2$[ebp], 0
  033ee	7d 08		 jge	 SHORT $L61745

; 2380 :       dot2 = - dot2;

  033f0	8b 55 d8	 mov	 edx, DWORD PTR _dot2$[ebp]
  033f3	f7 da		 neg	 edx
  033f5	89 55 d8	 mov	 DWORD PTR _dot2$[ebp], edx
$L61745:

; 2381 : 
; 2382 :    if (dot3>0)

  033f8	83 7d d0 00	 cmp	 DWORD PTR _dot3$[ebp], 0
  033fc	0f 8e 95 00 00
	00		 jle	 $L61746

; 2384 :       // round toward outside of polygon
; 2385 :       tmp6.x = (((int) tmp1.x*dot1 + (int) sign(tmp1.x)*(dot2-1))/dot2);

  03402	0f bf 45 e4	 movsx	 eax, WORD PTR _tmp1$[ebp]
  03406	85 c0		 test	 eax, eax
  03408	7e 09		 jle	 SHORT $L62506
  0340a	c7 45 94 01 00
	00 00		 mov	 DWORD PTR -108+[ebp], 1
  03411	eb 0f		 jmp	 SHORT $L62507
$L62506:
  03413	0f bf 4d e4	 movsx	 ecx, WORD PTR _tmp1$[ebp]
  03417	33 d2		 xor	 edx, edx
  03419	85 c9		 test	 ecx, ecx
  0341b	0f 9d c2	 setge	 dl
  0341e	4a		 dec	 edx
  0341f	89 55 94	 mov	 DWORD PTR -108+[ebp], edx
$L62507:
  03422	0f bf 45 e4	 movsx	 eax, WORD PTR _tmp1$[ebp]
  03426	0f af 45 e0	 imul	 eax, DWORD PTR _dot1$[ebp]
  0342a	8b 4d d8	 mov	 ecx, DWORD PTR _dot2$[ebp]
  0342d	83 e9 01	 sub	 ecx, 1
  03430	8b 55 94	 mov	 edx, DWORD PTR -108+[ebp]
  03433	0f af d1	 imul	 edx, ecx
  03436	03 c2		 add	 eax, edx
  03438	99		 cdq
  03439	f7 7d d8	 idiv	 DWORD PTR _dot2$[ebp]
  0343c	66 89 45 fc	 mov	 WORD PTR _tmp6$[ebp], ax

; 2386 :       tmp6.y = (((int) tmp1.y*dot1 + (int) sign(tmp1.y)*(dot2-1))/dot2);

  03440	0f bf 45 e6	 movsx	 eax, WORD PTR _tmp1$[ebp+2]
  03444	85 c0		 test	 eax, eax
  03446	7e 09		 jle	 SHORT $L62508
  03448	c7 45 90 01 00
	00 00		 mov	 DWORD PTR -112+[ebp], 1
  0344f	eb 0f		 jmp	 SHORT $L62509
$L62508:
  03451	0f bf 4d e6	 movsx	 ecx, WORD PTR _tmp1$[ebp+2]
  03455	33 d2		 xor	 edx, edx
  03457	85 c9		 test	 ecx, ecx
  03459	0f 9d c2	 setge	 dl
  0345c	4a		 dec	 edx
  0345d	89 55 90	 mov	 DWORD PTR -112+[ebp], edx
$L62509:
  03460	0f bf 45 e6	 movsx	 eax, WORD PTR _tmp1$[ebp+2]
  03464	0f af 45 e0	 imul	 eax, DWORD PTR _dot1$[ebp]
  03468	8b 4d d8	 mov	 ecx, DWORD PTR _dot2$[ebp]
  0346b	83 e9 01	 sub	 ecx, 1
  0346e	8b 55 90	 mov	 edx, DWORD PTR -112+[ebp]
  03471	0f af d1	 imul	 edx, ecx
  03474	03 c2		 add	 eax, edx
  03476	99		 cdq
  03477	f7 7d d8	 idiv	 DWORD PTR _dot2$[ebp]
  0347a	66 89 45 fe	 mov	 WORD PTR _tmp6$[ebp+2], ax

; 2387 :       *intersection = A + tmp6;

  0347e	8d 45 fc	 lea	 eax, DWORD PTR _tmp6$[ebp]
  03481	50		 push	 eax
  03482	8d 4d ac	 lea	 ecx, DWORD PTR $T62510[ebp]
  03485	51		 push	 ecx
  03486	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  03489	e8 00 00 00 00	 call	 ??HSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator+
  0348e	50		 push	 eax
  0348f	8b 4d 18	 mov	 ecx, DWORD PTR _intersection$[ebp]
  03492	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=
$L61746:

; 2389 :    if (dot3<0)

  03497	83 7d d0 00	 cmp	 DWORD PTR _dot3$[ebp], 0
  0349b	7d 39		 jge	 SHORT $L61752

; 2391 :       // truncate so that intersection is outside polygon
; 2392 :       tmp6.x = ((((int) tmp1.x)*dot1)/dot2) ;

  0349d	0f bf 45 e4	 movsx	 eax, WORD PTR _tmp1$[ebp]
  034a1	0f af 45 e0	 imul	 eax, DWORD PTR _dot1$[ebp]
  034a5	99		 cdq
  034a6	f7 7d d8	 idiv	 DWORD PTR _dot2$[ebp]
  034a9	66 89 45 fc	 mov	 WORD PTR _tmp6$[ebp], ax

; 2393 :       tmp6.y = ((((int) tmp1.y)*dot1)/dot2) ;

  034ad	0f bf 45 e6	 movsx	 eax, WORD PTR _tmp1$[ebp+2]
  034b1	0f af 45 e0	 imul	 eax, DWORD PTR _dot1$[ebp]
  034b5	99		 cdq
  034b6	f7 7d d8	 idiv	 DWORD PTR _dot2$[ebp]
  034b9	66 89 45 fe	 mov	 WORD PTR _tmp6$[ebp+2], ax

; 2394 :       *intersection = A + tmp6;

  034bd	8d 55 fc	 lea	 edx, DWORD PTR _tmp6$[ebp]
  034c0	52		 push	 edx
  034c1	8d 45 a8	 lea	 eax, DWORD PTR $T62511[ebp]
  034c4	50		 push	 eax
  034c5	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  034c8	e8 00 00 00 00	 call	 ??HSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator+
  034cd	50		 push	 eax
  034ce	8b 4d 18	 mov	 ecx, DWORD PTR _intersection$[ebp]
  034d1	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=
$L61752:

; 2396 :    if (dot3==0)

  034d6	83 7d d0 00	 cmp	 DWORD PTR _dot3$[ebp], 0
  034da	75 0c		 jne	 SHORT $L61756

; 2398 :       *intersection = C;

  034dc	8b 4d 10	 mov	 ecx, DWORD PTR _C$[ebp]
  034df	51		 push	 ecx
  034e0	8b 4d 18	 mov	 ecx, DWORD PTR _intersection$[ebp]
  034e3	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=
$L61756:

; 2400 :    return(INTERSECT+INTERSECTI);

  034e8	b8 21 00 00 00	 mov	 eax, 33			; 00000021H
$L61683:

; 2401 : }

  034ed	8b e5		 mov	 esp, ebp
  034ef	5d		 pop	 ebp
  034f0	c3		 ret	 0
?IntersectSegments@@YAHAAUSCI_Point@@000PAU1@@Z ENDP	; IntersectSegments
_TEXT	ENDS
;	COMDAT ??HSCI_Point@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
$T62513 = -4
_p$ = 12
___$ReturnUdt$ = 8
_this$ = -8
??HSCI_Point@@QBE?AU0@ABU0@@Z PROC NEAR			; SCI_Point::operator+, COMDAT

; 208  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 209  :    return SCI_Point(x+p.x,y+p.y);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00010	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp]
  00013	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  00017	03 c8		 add	 ecx, eax
  00019	51		 push	 ecx
  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00020	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  00023	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00026	03 d1		 add	 edx, ecx
  00028	52		 push	 edx
  00029	8d 4d fc	 lea	 ecx, DWORD PTR $T62513[ebp]
  0002c	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@HH@Z	; SCI_Point::SCI_Point
  00031	50		 push	 eax
  00032	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00035	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@ABU0@@Z ; SCI_Point::SCI_Point
  0003a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 210  : }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
??HSCI_Point@@QBE?AU0@ABU0@@Z ENDP			; SCI_Point::operator+
_TEXT	ENDS
;	COMDAT ??ZSCI_Point@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
??ZSCI_Point@@QAEAAU0@ABU0@@Z PROC NEAR			; SCI_Point::operator-=, COMDAT

; 266  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 267  : 	x -= p.x;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0000d	66 8b 10	 mov	 dx, WORD PTR [eax]
  00010	66 2b 11	 sub	 dx, WORD PTR [ecx]
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	66 89 10	 mov	 WORD PTR [eax], dx

; 268  : 	y -= p.y;

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  0001f	66 8b 41 02	 mov	 ax, WORD PTR [ecx+2]
  00023	66 2b 42 02	 sub	 ax, WORD PTR [edx+2]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 269  : 	return *this;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 270  : }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
??ZSCI_Point@@QAEAAU0@ABU0@@Z ENDP			; SCI_Point::operator-=
_TEXT	ENDS
PUBLIC	?RemoveColinearLines@@YAXPAUSCI_Point@@PAH@Z	; RemoveColinearLines
_TEXT	SEGMENT
$T62516 = -36
$T62517 = -40
_P$ = 8
_n$ = 12
_i$ = -20
_j$ = -24
_nodes$ = -4
_P1$ = -8
_P2$ = -12
_P3$ = -16
_tmp1$ = -28
_tmp2$ = -32
?RemoveColinearLines@@YAXPAUSCI_Point@@PAH@Z PROC NEAR	; RemoveColinearLines

; 2405 : {

  034f1	55		 push	 ebp
  034f2	8b ec		 mov	 ebp, esp
  034f4	83 ec 28	 sub	 esp, 40			; 00000028H

; 2406 :    int  i,j;
; 2407 :    int  nodes;
; 2408 :    SCI_Point P1,P2,P3,tmp1,tmp2;

  034f7	8d 4d f8	 lea	 ecx, DWORD PTR _P1$[ebp]
  034fa	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  034ff	8d 4d f4	 lea	 ecx, DWORD PTR _P2$[ebp]
  03502	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  03507	8d 4d f0	 lea	 ecx, DWORD PTR _P3$[ebp]
  0350a	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  0350f	8d 4d e4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  03512	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point
  03517	8d 4d e0	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  0351a	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@XZ	; SCI_Point::SCI_Point

; 2409 : 
; 2410 :    nodes = *n;

  0351f	8b 45 0c	 mov	 eax, DWORD PTR _n$[ebp]
  03522	8b 08		 mov	 ecx, DWORD PTR [eax]
  03524	89 4d fc	 mov	 DWORD PTR _nodes$[ebp], ecx

; 2411 :    P1 = P[0];                                            

  03527	8b 55 08	 mov	 edx, DWORD PTR _P$[ebp]
  0352a	52		 push	 edx
  0352b	8d 4d f8	 lea	 ecx, DWORD PTR _P1$[ebp]
  0352e	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 2412 :    P2 = P[1];

  03533	8b 45 08	 mov	 eax, DWORD PTR _P$[ebp]
  03536	83 c0 04	 add	 eax, 4
  03539	50		 push	 eax
  0353a	8d 4d f4	 lea	 ecx, DWORD PTR _P2$[ebp]
  0353d	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 2413 :    P3 = P[2];

  03542	8b 4d 08	 mov	 ecx, DWORD PTR _P$[ebp]
  03545	83 c1 08	 add	 ecx, 8
  03548	51		 push	 ecx
  03549	8d 4d f0	 lea	 ecx, DWORD PTR _P3$[ebp]
  0354c	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 2414 :    for (i=3;i<(nodes+2);++i)

  03551	c7 45 ec 03 00
	00 00		 mov	 DWORD PTR _i$[ebp], 3
  03558	eb 09		 jmp	 SHORT $L61769
$L61770:
  0355a	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  0355d	83 c2 01	 add	 edx, 1
  03560	89 55 ec	 mov	 DWORD PTR _i$[ebp], edx
$L61769:
  03563	8b 45 fc	 mov	 eax, DWORD PTR _nodes$[ebp]
  03566	83 c0 02	 add	 eax, 2
  03569	39 45 ec	 cmp	 DWORD PTR _i$[ebp], eax
  0356c	0f 8d da 00 00
	00		 jge	 $L61771

; 2416 :       tmp1 = P2 - P1;

  03572	8d 4d f8	 lea	 ecx, DWORD PTR _P1$[ebp]
  03575	51		 push	 ecx
  03576	8d 55 dc	 lea	 edx, DWORD PTR $T62516[ebp]
  03579	52		 push	 edx
  0357a	8d 4d f4	 lea	 ecx, DWORD PTR _P2$[ebp]
  0357d	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  03582	50		 push	 eax
  03583	8d 4d e4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  03586	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 2417 :       tmp2 = P3 - P2;

  0358b	8d 45 f4	 lea	 eax, DWORD PTR _P2$[ebp]
  0358e	50		 push	 eax
  0358f	8d 4d d8	 lea	 ecx, DWORD PTR $T62517[ebp]
  03592	51		 push	 ecx
  03593	8d 4d f0	 lea	 ecx, DWORD PTR _P3$[ebp]
  03596	e8 00 00 00 00	 call	 ??GSCI_Point@@QBE?AU0@ABU0@@Z ; SCI_Point::operator-
  0359b	50		 push	 eax
  0359c	8d 4d e0	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  0359f	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 2418 :       if ((tmp1^tmp2) == 0)

  035a4	8d 55 e0	 lea	 edx, DWORD PTR _tmp2$[ebp]
  035a7	52		 push	 edx
  035a8	8d 4d e4	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  035ab	e8 00 00 00 00	 call	 ??TSCI_Point@@QBEHABU0@@Z ; SCI_Point::operator^
  035b0	85 c0		 test	 eax, eax
  035b2	75 65		 jne	 SHORT $L61774

; 2420 :          // eliminate the extra node
; 2421 :          --*n;

  035b4	8b 45 0c	 mov	 eax, DWORD PTR _n$[ebp]
  035b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  035b9	83 e9 01	 sub	 ecx, 1
  035bc	8b 55 0c	 mov	 edx, DWORD PTR _n$[ebp]
  035bf	89 0a		 mov	 DWORD PTR [edx], ecx

; 2422 :          for (j=i;j<(nodes+1);++j)

  035c1	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  035c4	89 45 e8	 mov	 DWORD PTR _j$[ebp], eax
  035c7	eb 09		 jmp	 SHORT $L61775
$L61776:
  035c9	8b 4d e8	 mov	 ecx, DWORD PTR _j$[ebp]
  035cc	83 c1 01	 add	 ecx, 1
  035cf	89 4d e8	 mov	 DWORD PTR _j$[ebp], ecx
$L61775:
  035d2	8b 55 fc	 mov	 edx, DWORD PTR _nodes$[ebp]
  035d5	83 c2 01	 add	 edx, 1
  035d8	39 55 e8	 cmp	 DWORD PTR _j$[ebp], edx
  035db	7d 1c		 jge	 SHORT $L61777

; 2424 :             P[j-2] = P[j-1];

  035dd	8b 45 e8	 mov	 eax, DWORD PTR _j$[ebp]
  035e0	8b 4d 08	 mov	 ecx, DWORD PTR _P$[ebp]
  035e3	8d 54 81 fc	 lea	 edx, DWORD PTR [ecx+eax*4-4]
  035e7	52		 push	 edx
  035e8	8b 45 e8	 mov	 eax, DWORD PTR _j$[ebp]
  035eb	8b 4d 08	 mov	 ecx, DWORD PTR _P$[ebp]
  035ee	8d 4c 81 f8	 lea	 ecx, DWORD PTR [ecx+eax*4-8]
  035f2	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 2425 :             }

  035f7	eb d0		 jmp	 SHORT $L61776
$L61777:

; 2426 :          --nodes;

  035f9	8b 55 fc	 mov	 edx, DWORD PTR _nodes$[ebp]
  035fc	83 ea 01	 sub	 edx, 1
  035ff	89 55 fc	 mov	 DWORD PTR _nodes$[ebp], edx

; 2427 :          // retry this node
; 2428 :          --i;

  03602	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  03605	83 e8 01	 sub	 eax, 1
  03608	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax

; 2429 :          P2 = P3;

  0360b	8d 4d f0	 lea	 ecx, DWORD PTR _P3$[ebp]
  0360e	51		 push	 ecx
  0360f	8d 4d f4	 lea	 ecx, DWORD PTR _P2$[ebp]
  03612	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 2431 :       else

  03617	eb 18		 jmp	 SHORT $L61778
$L61774:

; 2433 :          P1 = P2;

  03619	8d 55 f4	 lea	 edx, DWORD PTR _P2$[ebp]
  0361c	52		 push	 edx
  0361d	8d 4d f8	 lea	 ecx, DWORD PTR _P1$[ebp]
  03620	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 2434 :          P2 = P3;

  03625	8d 45 f0	 lea	 eax, DWORD PTR _P3$[ebp]
  03628	50		 push	 eax
  03629	8d 4d f4	 lea	 ecx, DWORD PTR _P2$[ebp]
  0362c	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=
$L61778:

; 2436 :       P3 = P[i % nodes];

  03631	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  03634	99		 cdq
  03635	f7 7d fc	 idiv	 DWORD PTR _nodes$[ebp]
  03638	8b 4d 08	 mov	 ecx, DWORD PTR _P$[ebp]
  0363b	8d 14 91	 lea	 edx, DWORD PTR [ecx+edx*4]
  0363e	52		 push	 edx
  0363f	8d 4d f0	 lea	 ecx, DWORD PTR _P3$[ebp]
  03642	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 2437 :       }

  03647	e9 0e ff ff ff	 jmp	 $L61770
$L61771:

; 2438 : }

  0364c	8b e5		 mov	 esp, ebp
  0364e	5d		 pop	 ebp
  0364f	c3		 ret	 0
?RemoveColinearLines@@YAXPAUSCI_Point@@PAH@Z ENDP	; RemoveColinearLines
_TEXT	ENDS
PUBLIC	?LineOnPlaneEdge@@YAHAAUSCI_Point@@0@Z		; LineOnPlaneEdge
_TEXT	SEGMENT
_P2$ = 8
_P1$ = 12
_offScreen$ = 16
_deltaX$ = -8
_deltaY$ = -12
_temp$ = -4
?DistanceEstimate@@YAHAAUSCI_Point@@0PAH@Z PROC NEAR	; DistanceEstimate

; 2442 : {

  03650	55		 push	 ebp
  03651	8b ec		 mov	 ebp, esp
  03653	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2443 :    int   deltaX,deltaY,temp;
; 2444 :    // if line lies on screen edge offScreen set to True
; 2445 :    if (LineOnPlaneEdge(P1,P2))  *offScreen = True;

  03656	8b 45 08	 mov	 eax, DWORD PTR _P2$[ebp]
  03659	50		 push	 eax
  0365a	8b 4d 0c	 mov	 ecx, DWORD PTR _P1$[ebp]
  0365d	51		 push	 ecx
  0365e	e8 00 00 00 00	 call	 ?LineOnPlaneEdge@@YAHAAUSCI_Point@@0@Z ; LineOnPlaneEdge
  03663	83 c4 08	 add	 esp, 8
  03666	85 c0		 test	 eax, eax
  03668	74 09		 je	 SHORT $L61787
  0366a	8b 55 10	 mov	 edx, DWORD PTR _offScreen$[ebp]
  0366d	c7 02 01 00 00
	00		 mov	 DWORD PTR [edx], 1
$L61787:

; 2446 :    // Estimate distance by the formula:
; 2447 :    // If max(deltaX,deltaY) <= (10*min(deltaX,deltaY))/6)
; 2448 :    //    then use (13*max(deltaX,deltaY))/10
; 2449 :    //    else use max(deltaX,deltaY)
; 2450 :    // This formula guarantees the max error is less than
; 2451 :    // 11% and the average error is about 5%.
; 2452 : 
; 2453 :    deltaX = abs(P2.x - P1.x);

  03673	8b 45 08	 mov	 eax, DWORD PTR _P2$[ebp]
  03676	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  03679	8b 55 0c	 mov	 edx, DWORD PTR _P1$[ebp]
  0367c	0f bf 02	 movsx	 eax, WORD PTR [edx]
  0367f	2b c8		 sub	 ecx, eax
  03681	51		 push	 ecx
  03682	e8 00 00 00 00	 call	 _abs
  03687	83 c4 04	 add	 esp, 4
  0368a	89 45 f8	 mov	 DWORD PTR _deltaX$[ebp], eax

; 2454 :    deltaY = abs(P2.y - P1.y);

  0368d	8b 4d 08	 mov	 ecx, DWORD PTR _P2$[ebp]
  03690	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  03694	8b 45 0c	 mov	 eax, DWORD PTR _P1$[ebp]
  03697	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  0369b	2b d1		 sub	 edx, ecx
  0369d	52		 push	 edx
  0369e	e8 00 00 00 00	 call	 _abs
  036a3	83 c4 04	 add	 esp, 4
  036a6	89 45 f4	 mov	 DWORD PTR _deltaY$[ebp], eax

; 2455 :    if (deltaX > deltaY)

  036a9	8b 55 f8	 mov	 edx, DWORD PTR _deltaX$[ebp]
  036ac	3b 55 f4	 cmp	 edx, DWORD PTR _deltaY$[ebp]
  036af	7e 12		 jle	 SHORT $L61788

; 2457 :       temp = deltaX;

  036b1	8b 45 f8	 mov	 eax, DWORD PTR _deltaX$[ebp]
  036b4	89 45 fc	 mov	 DWORD PTR _temp$[ebp], eax

; 2458 :       deltaX = deltaY;

  036b7	8b 4d f4	 mov	 ecx, DWORD PTR _deltaY$[ebp]
  036ba	89 4d f8	 mov	 DWORD PTR _deltaX$[ebp], ecx

; 2459 :       deltaY = temp;

  036bd	8b 55 fc	 mov	 edx, DWORD PTR _temp$[ebp]
  036c0	89 55 f4	 mov	 DWORD PTR _deltaY$[ebp], edx
$L61788:

; 2461 :    if (((deltaX*10)/6) >= deltaY)

  036c3	8b 45 f8	 mov	 eax, DWORD PTR _deltaX$[ebp]
  036c6	6b c0 0a	 imul	 eax, 10			; 0000000aH
  036c9	99		 cdq
  036ca	b9 06 00 00 00	 mov	 ecx, 6
  036cf	f7 f9		 idiv	 ecx
  036d1	3b 45 f4	 cmp	 eax, DWORD PTR _deltaY$[ebp]
  036d4	7c 10		 jl	 SHORT $L61789

; 2462 :       return(((13*deltaY)/10));

  036d6	8b 45 f4	 mov	 eax, DWORD PTR _deltaY$[ebp]
  036d9	6b c0 0d	 imul	 eax, 13			; 0000000dH
  036dc	99		 cdq
  036dd	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  036e2	f7 f9		 idiv	 ecx
  036e4	eb 03		 jmp	 SHORT $L61790
$L61789:

; 2464 :       return(deltaY);

  036e6	8b 45 f4	 mov	 eax, DWORD PTR _deltaY$[ebp]
$L61790:

; 2465 : }

  036e9	8b e5		 mov	 esp, ebp
  036eb	5d		 pop	 ebp
  036ec	c3		 ret	 0
?DistanceEstimate@@YAHAAUSCI_Point@@0PAH@Z ENDP		; DistanceEstimate
_P1$ = 8
_P2$ = 12
?LineOnPlaneEdge@@YAHAAUSCI_Point@@0@Z PROC NEAR	; LineOnPlaneEdge

; 2469 : {  

  036ed	55		 push	 ebp
  036ee	8b ec		 mov	 ebp, esp

; 2470 : 	if ( !gCheckPlaneEdge )

  036f0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gCheckPlaneEdge@@3HA, 0 ; gCheckPlaneEdge
  036f7	75 07		 jne	 SHORT $L61795

; 2471 : 		return 0;

  036f9	33 c0		 xor	 eax, eax
  036fb	e9 9a 00 00 00	 jmp	 $L61794
$L61795:

; 2472 : 
; 2473 : 	if ( gCheckPlaneEdge & _CHECK_VERT ) {

  03700	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gCheckPlaneEdge@@3HA ; gCheckPlaneEdge
  03705	83 e0 01	 and	 eax, 1
  03708	85 c0		 test	 eax, eax
  0370a	74 3e		 je	 SHORT $L61799

; 2474 : 		if ( P1.x <= 0 || P1.x >= 639 )

  0370c	8b 4d 08	 mov	 ecx, DWORD PTR _P1$[ebp]
  0370f	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  03712	85 d2		 test	 edx, edx
  03714	7e 0e		 jle	 SHORT $L61798
  03716	8b 45 08	 mov	 eax, DWORD PTR _P1$[ebp]
  03719	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0371c	81 f9 7f 02 00
	00		 cmp	 ecx, 639		; 0000027fH
  03722	7c 07		 jl	 SHORT $L61797
$L61798:

; 2475 : 			return 1;

  03724	b8 01 00 00 00	 mov	 eax, 1
  03729	eb 6f		 jmp	 SHORT $L61794
$L61797:

; 2476 : 
; 2477 : 		if ( P2.x <= 0 || P2.x >= 639 )

  0372b	8b 55 0c	 mov	 edx, DWORD PTR _P2$[ebp]
  0372e	0f bf 02	 movsx	 eax, WORD PTR [edx]
  03731	85 c0		 test	 eax, eax
  03733	7e 0e		 jle	 SHORT $L61800
  03735	8b 4d 0c	 mov	 ecx, DWORD PTR _P2$[ebp]
  03738	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  0373b	81 fa 7f 02 00
	00		 cmp	 edx, 639		; 0000027fH
  03741	7c 07		 jl	 SHORT $L61799
$L61800:

; 2478 : 			return 1;

  03743	b8 01 00 00 00	 mov	 eax, 1
  03748	eb 50		 jmp	 SHORT $L61794
$L61799:

; 2480 : 
; 2481 : 	if ( gCheckPlaneEdge & _CHECK_HORIZ ) {

  0374a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gCheckPlaneEdge@@3HA ; gCheckPlaneEdge
  0374f	83 e0 02	 and	 eax, 2
  03752	85 c0		 test	 eax, eax
  03754	74 42		 je	 SHORT $L61804

; 2482 : 		if ( P1.y <= 0 || P1.y >= 317 )

  03756	8b 4d 08	 mov	 ecx, DWORD PTR _P1$[ebp]
  03759	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  0375d	85 d2		 test	 edx, edx
  0375f	7e 0f		 jle	 SHORT $L61803
  03761	8b 45 08	 mov	 eax, DWORD PTR _P1$[ebp]
  03764	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  03768	81 f9 3d 01 00
	00		 cmp	 ecx, 317		; 0000013dH
  0376e	7c 07		 jl	 SHORT $L61802
$L61803:

; 2483 : 			return 1;

  03770	b8 01 00 00 00	 mov	 eax, 1
  03775	eb 23		 jmp	 SHORT $L61794
$L61802:

; 2484 : 
; 2485 : 		if ( P2.y <= 0 || P2.y >= 317 )

  03777	8b 55 0c	 mov	 edx, DWORD PTR _P2$[ebp]
  0377a	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  0377e	85 c0		 test	 eax, eax
  03780	7e 0f		 jle	 SHORT $L61805
  03782	8b 4d 0c	 mov	 ecx, DWORD PTR _P2$[ebp]
  03785	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  03789	81 fa 3d 01 00
	00		 cmp	 edx, 317		; 0000013dH
  0378f	7c 07		 jl	 SHORT $L61804
$L61805:

; 2486 : 			return 1;

  03791	b8 01 00 00 00	 mov	 eax, 1
  03796	eb 02		 jmp	 SHORT $L61794
$L61804:

; 2488 : 
; 2489 :    return(0);

  03798	33 c0		 xor	 eax, eax
$L61794:

; 2490 : }

  0379a	5d		 pop	 ebp
  0379b	c3		 ret	 0
?LineOnPlaneEdge@@YAHAAUSCI_Point@@0@Z ENDP		; LineOnPlaneEdge
_TEXT	ENDS
PUBLIC	?RemoveDuplicatePoints@@YAXPAUSCI_Point@@PAH@Z	; RemoveDuplicatePoints
_TEXT	SEGMENT
_P$ = 8
_n$ = 12
_i$ = -4
_j$61815 = -8
?RemoveDuplicatePoints@@YAXPAUSCI_Point@@PAH@Z PROC NEAR ; RemoveDuplicatePoints

; 2494 : {

  0379c	55		 push	 ebp
  0379d	8b ec		 mov	 ebp, esp
  0379f	83 ec 08	 sub	 esp, 8

; 2495 : 	int i;
; 2496 :    // Get rid of duplicate points
; 2497 :    for (i=0;P[i].x != ENDOFPATH;++i) 

  037a2	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  037a9	eb 09		 jmp	 SHORT $L61811
$L61812:
  037ab	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  037ae	83 c0 01	 add	 eax, 1
  037b1	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L61811:
  037b4	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  037b7	8b 55 08	 mov	 edx, DWORD PTR _P$[ebp]
  037ba	0f bf 04 8a	 movsx	 eax, WORD PTR [edx+ecx*4]
  037be	3d 77 77 00 00	 cmp	 eax, 30583		; 00007777H
  037c3	74 6c		 je	 SHORT $L61813

; 2499 :    	if(P[i] == P[i+1])

  037c5	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  037c8	8b 55 08	 mov	 edx, DWORD PTR _P$[ebp]
  037cb	8d 44 8a 04	 lea	 eax, DWORD PTR [edx+ecx*4+4]
  037cf	50		 push	 eax
  037d0	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  037d3	8b 55 08	 mov	 edx, DWORD PTR _P$[ebp]
  037d6	8d 0c 8a	 lea	 ecx, DWORD PTR [edx+ecx*4]
  037d9	e8 00 00 00 00	 call	 ??8SCI_Point@@QBEHABU0@@Z ; SCI_Point::operator==
  037de	85 c0		 test	 eax, eax
  037e0	74 4a		 je	 SHORT $L61814

; 2501 :       	for (int j=i+1;P[j].x != ENDOFPATH;++j) 

  037e2	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  037e5	83 c0 01	 add	 eax, 1
  037e8	89 45 f8	 mov	 DWORD PTR _j$61815[ebp], eax
  037eb	eb 09		 jmp	 SHORT $L61816
$L61817:
  037ed	8b 4d f8	 mov	 ecx, DWORD PTR _j$61815[ebp]
  037f0	83 c1 01	 add	 ecx, 1
  037f3	89 4d f8	 mov	 DWORD PTR _j$61815[ebp], ecx
$L61816:
  037f6	8b 55 f8	 mov	 edx, DWORD PTR _j$61815[ebp]
  037f9	8b 45 08	 mov	 eax, DWORD PTR _P$[ebp]
  037fc	0f bf 0c 90	 movsx	 ecx, WORD PTR [eax+edx*4]
  03800	81 f9 77 77 00
	00		 cmp	 ecx, 30583		; 00007777H
  03806	74 1b		 je	 SHORT $L61818

; 2502 :          	P[j] = P[j+1];

  03808	8b 55 f8	 mov	 edx, DWORD PTR _j$61815[ebp]
  0380b	8b 45 08	 mov	 eax, DWORD PTR _P$[ebp]
  0380e	8d 4c 90 04	 lea	 ecx, DWORD PTR [eax+edx*4+4]
  03812	51		 push	 ecx
  03813	8b 55 f8	 mov	 edx, DWORD PTR _j$61815[ebp]
  03816	8b 45 08	 mov	 eax, DWORD PTR _P$[ebp]
  03819	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  0381c	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=
  03821	eb ca		 jmp	 SHORT $L61817
$L61818:

; 2503 :             --i;

  03823	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  03826	83 e9 01	 sub	 ecx, 1
  03829	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L61814:

; 2505 :    }

  0382c	e9 7a ff ff ff	 jmp	 $L61812
$L61813:

; 2506 :    *n = i;

  03831	8b 55 0c	 mov	 edx, DWORD PTR _n$[ebp]
  03834	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  03837	89 02		 mov	 DWORD PTR [edx], eax

; 2507 : }

  03839	8b e5		 mov	 esp, ebp
  0383b	5d		 pop	 ebp
  0383c	c3		 ret	 0
?RemoveDuplicatePoints@@YAXPAUSCI_Point@@PAH@Z ENDP	; RemoveDuplicatePoints
_TEXT	ENDS
PUBLIC	??4FPoint@@QAEAAV0@ABUSCI_Point@@@Z		; FPoint::operator=
PUBLIC	?BuildPolygonListF@@YA?AVMemID@@USOL_ListID@@H@Z ; BuildPolygonListF
EXTRN	_memset:NEAR
_DATA	SEGMENT
	ORG $+3
$SG61827 DB	'BuildPolygonListF: actual list size %d does not match pa'
	DB	'ssed size %d.', 00H
_DATA	ENDS
xdata$x	SEGMENT
$T62526	DD	019930520H
	DD	01H
	DD	FLAT:$T62528
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T62528	DD	0ffffffffH
	DD	FLAT:$L62524
xdata$x	ENDS
_TEXT	SEGMENT
$T62522 = -68
$T62523 = -72
__$EHRec$ = -12
_theList$ = 12
_listSize$ = 16
___$ReturnUdt$ = 8
_i$ = -24
_polygonListID$ = -20
_polygonList$ = -16
_fPointsID$ = -28
_index$ = -32
_id$61838 = -48
_theType$61841 = -44
_size$61842 = -36
_arrayID$61844 = -40
_pointsArray$61846 = -64
_points$61849 = -60
_fPoints$61851 = -52
_j$61853 = -56
?BuildPolygonListF@@YA?AVMemID@@USOL_ListID@@H@Z PROC NEAR ; BuildPolygonListF

; 2521 : {

  0383d	55		 push	 ebp
  0383e	8b ec		 mov	 ebp, esp
  03840	6a ff		 push	 -1
  03842	68 00 00 00 00	 push	 $L62527
  03847	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0384d	50		 push	 eax
  0384e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  03855	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 2522 :    int i = 0;

  03858	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 2523 :    MemID polygonListID;

  0385f	8d 4d ec	 lea	 ecx, DWORD PTR _polygonListID$[ebp]
  03862	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID

; 2524 : 
; 2525 : 	if ( theList->size() != listSize )

  03867	8d 4d 0c	 lea	 ecx, DWORD PTR _theList$[ebp]
  0386a	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  0386f	8b c8		 mov	 ecx, eax
  03871	e8 00 00 00 00	 call	 ?size@SOL_List@@QAEAAHXZ ; SOL_List::size
  03876	8b 00		 mov	 eax, DWORD PTR [eax]
  03878	3b 45 10	 cmp	 eax, DWORD PTR _listSize$[ebp]
  0387b	74 29		 je	 SHORT $L61826

; 2526 : 		msgMgr->Fatal ( "BuildPolygonListF: actual list size %d does not match passed size %d.", theList->size(), listSize );

  0387d	8b 4d 10	 mov	 ecx, DWORD PTR _listSize$[ebp]
  03880	51		 push	 ecx
  03881	8d 4d 0c	 lea	 ecx, DWORD PTR _theList$[ebp]
  03884	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  03889	8b c8		 mov	 ecx, eax
  0388b	e8 00 00 00 00	 call	 ?size@SOL_List@@QAEAAHXZ ; SOL_List::size
  03890	8b 10		 mov	 edx, DWORD PTR [eax]
  03892	52		 push	 edx
  03893	68 00 00 00 00	 push	 OFFSET FLAT:$SG61827
  03898	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  0389d	50		 push	 eax
  0389e	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  038a3	83 c4 10	 add	 esp, 16			; 00000010H
$L61826:

; 2527 : 
; 2528 : 	polygonListID.Get(MemPolygonList,(listSize+1)*sizeof(SOL_PolygonF));

  038a6	6a 00		 push	 0
  038a8	6a 00		 push	 0
  038aa	6a 00		 push	 0
  038ac	6a 00		 push	 0
  038ae	68 00 02 00 00	 push	 512			; 00000200H
  038b3	8b 4d 10	 mov	 ecx, DWORD PTR _listSize$[ebp]
  038b6	83 c1 01	 add	 ecx, 1
  038b9	c1 e1 04	 shl	 ecx, 4
  038bc	51		 push	 ecx
  038bd	6a 45		 push	 69			; 00000045H
  038bf	8d 4d ec	 lea	 ecx, DWORD PTR _polygonListID$[ebp]
  038c2	e8 00 00 00 00	 call	 ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get

; 2529 : 	SOL_PolygonF* polygonList = (SOL_PolygonF*) memMgr->GetAddr(polygonListID);

  038c7	8d 4d ec	 lea	 ecx, DWORD PTR _polygonListID$[ebp]
  038ca	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  038cf	50		 push	 eax
  038d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  038d6	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr
  038db	89 45 f0	 mov	 DWORD PTR _polygonList$[ebp], eax

; 2530 : 
; 2531 : 	memset ( (void *)polygonList, 0, (listSize + 1) * sizeof ( SOL_PolygonF ) );

  038de	8b 55 10	 mov	 edx, DWORD PTR _listSize$[ebp]
  038e1	83 c2 01	 add	 edx, 1
  038e4	c1 e2 04	 shl	 edx, 4
  038e7	52		 push	 edx
  038e8	6a 00		 push	 0
  038ea	8b 45 f0	 mov	 eax, DWORD PTR _polygonList$[ebp]
  038ed	50		 push	 eax
  038ee	e8 00 00 00 00	 call	 _memset
  038f3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2532 : 
; 2533 : 	MemID fPointsID;

  038f6	8d 4d e4	 lea	 ecx, DWORD PTR _fPointsID$[ebp]
  038f9	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID

; 2534 : 
; 2535 : 	for ( int index=0; index<theList->size(); index++ ) {

  038fe	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _index$[ebp], 0
  03905	eb 09		 jmp	 SHORT $L61835
$L61836:
  03907	8b 4d e0	 mov	 ecx, DWORD PTR _index$[ebp]
  0390a	83 c1 01	 add	 ecx, 1
  0390d	89 4d e0	 mov	 DWORD PTR _index$[ebp], ecx
$L61835:
  03910	8d 4d 0c	 lea	 ecx, DWORD PTR _theList$[ebp]
  03913	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  03918	8b c8		 mov	 ecx, eax
  0391a	e8 00 00 00 00	 call	 ?size@SOL_List@@QAEAAHXZ ; SOL_List::size
  0391f	8b 55 e0	 mov	 edx, DWORD PTR _index$[ebp]
  03922	3b 10		 cmp	 edx, DWORD PTR [eax]
  03924	0f 8d 60 01 00
	00		 jge	 $L61837

; 2536 : 	   ObjectID id = (ObjectID)theList->at ( index );

  0392a	8b 45 e0	 mov	 eax, DWORD PTR _index$[ebp]
  0392d	50		 push	 eax
  0392e	8d 4d 0c	 lea	 ecx, DWORD PTR _theList$[ebp]
  03931	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  03936	8b c8		 mov	 ecx, eax
  03938	e8 00 00 00 00	 call	 ?at@SOL_List@@QAEGH@Z	; SOL_List::at
  0393d	50		 push	 eax
  0393e	8d 4d bc	 lea	 ecx, DWORD PTR $T62522[ebp]
  03941	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  03946	50		 push	 eax
  03947	8d 4d d0	 lea	 ecx, DWORD PTR _id$61838[ebp]
  0394a	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID

; 2537 : 
; 2538 : 		uchar theType = id.GetProperty ( s_type );

  0394f	6a 2b		 push	 43			; 0000002bH
  03951	8d 4d d0	 lea	 ecx, DWORD PTR _id$61838[ebp]
  03954	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  03959	88 45 d4	 mov	 BYTE PTR _theType$61841[ebp], al

; 2539 : 		polygonList[i].type = theType;

  0395c	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  0395f	c1 e1 04	 shl	 ecx, 4
  03962	8b 55 f0	 mov	 edx, DWORD PTR _polygonList$[ebp]
  03965	8a 45 d4	 mov	 al, BYTE PTR _theType$61841[ebp]
  03968	88 44 0a 04	 mov	 BYTE PTR [edx+ecx+4], al

; 2540 : 
; 2541 : 		int size = id.GetProperty(s_size);

  0396c	6a 5a		 push	 90			; 0000005aH
  0396e	8d 4d d0	 lea	 ecx, DWORD PTR _id$61838[ebp]
  03971	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  03976	0f bf c8	 movsx	 ecx, ax
  03979	89 4d dc	 mov	 DWORD PTR _size$61842[ebp], ecx

; 2542 : 
; 2543 :       if (size < 3) {

  0397c	83 7d dc 03	 cmp	 DWORD PTR _size$61842[ebp], 3
  03980	7d 02		 jge	 SHORT $L61843

; 2544 : //		   msgMgr->Fatal(SrcLoc,Msg_NotAPolygon);
; 2545 : 			continue;

  03982	eb 83		 jmp	 SHORT $L61836
$L61843:

; 2547 : 		
; 2548 : 		ObjectID arrayID = id.GetProperty ( s_points );

  03984	6a 5b		 push	 91			; 0000005bH
  03986	8d 4d d0	 lea	 ecx, DWORD PTR _id$61838[ebp]
  03989	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  0398e	50		 push	 eax
  0398f	8d 4d d8	 lea	 ecx, DWORD PTR _arrayID$61844[ebp]
  03992	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID

; 2549 : 
; 2550 : 		if ( arrayID ) {

  03997	8d 4d d8	 lea	 ecx, DWORD PTR _arrayID$61844[ebp]
  0399a	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  0399f	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  039a4	85 c0		 test	 eax, eax
  039a6	0f 84 d9 00 00
	00		 je	 $L61845

; 2551 : 			Array pointsArray ( arrayID.GetProperty ( s_data ) );

  039ac	6a 71		 push	 113			; 00000071H
  039ae	8d 4d d8	 lea	 ecx, DWORD PTR _arrayID$61844[ebp]
  039b1	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  039b6	51		 push	 ecx
  039b7	8b cc		 mov	 ecx, esp
  039b9	89 65 b8	 mov	 DWORD PTR $T62523[ebp], esp
  039bc	50		 push	 eax
  039bd	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  039c2	8d 4d c0	 lea	 ecx, DWORD PTR _pointsArray$61846[ebp]
  039c5	e8 00 00 00 00	 call	 ??0Array@@QAE@VMemID@@@Z ; Array::Array
  039ca	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2552 : 
; 2553 : 			// Make a copy of the points
; 2554 : 			fPointsID.Get(MemPointList,sizeof(FPoint)*size);

  039d1	6a 00		 push	 0
  039d3	6a 00		 push	 0
  039d5	6a 00		 push	 0
  039d7	6a 00		 push	 0
  039d9	68 00 02 00 00	 push	 512			; 00000200H
  039de	8b 55 dc	 mov	 edx, DWORD PTR _size$61842[ebp]
  039e1	c1 e2 04	 shl	 edx, 4
  039e4	52		 push	 edx
  039e5	6a 46		 push	 70			; 00000046H
  039e7	8d 4d e4	 lea	 ecx, DWORD PTR _fPointsID$[ebp]
  039ea	e8 00 00 00 00	 call	 ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get

; 2555 : 
; 2556 :       	SCI_Point* points = (SCI_Point*) pointsArray.calcAddress ( 0 );

  039ef	6a 00		 push	 0
  039f1	8d 4d c0	 lea	 ecx, DWORD PTR _pointsArray$61846[ebp]
  039f4	e8 00 00 00 00	 call	 ?calcAddress@Array@@QAEPAXH@Z ; Array::calcAddress
  039f9	89 45 c4	 mov	 DWORD PTR _points$61849[ebp], eax

; 2557 : 			FPoint* fPoints = (FPoint*) *fPointsID;

  039fc	8d 4d e4	 lea	 ecx, DWORD PTR _fPointsID$[ebp]
  039ff	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  03a04	89 45 cc	 mov	 DWORD PTR _fPoints$61851[ebp], eax

; 2558 : 
; 2559 : 			for (int j=0;j<size;++j)

  03a07	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _j$61853[ebp], 0
  03a0e	eb 09		 jmp	 SHORT $L61854
$L61855:
  03a10	8b 45 c8	 mov	 eax, DWORD PTR _j$61853[ebp]
  03a13	83 c0 01	 add	 eax, 1
  03a16	89 45 c8	 mov	 DWORD PTR _j$61853[ebp], eax
$L61854:
  03a19	8b 4d c8	 mov	 ecx, DWORD PTR _j$61853[ebp]
  03a1c	3b 4d dc	 cmp	 ecx, DWORD PTR _size$61842[ebp]
  03a1f	7d 1c		 jge	 SHORT $L61856

; 2560 : 				fPoints[j] = points[j];

  03a21	8b 55 c8	 mov	 edx, DWORD PTR _j$61853[ebp]
  03a24	8b 45 c4	 mov	 eax, DWORD PTR _points$61849[ebp]
  03a27	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  03a2a	51		 push	 ecx
  03a2b	8b 55 c8	 mov	 edx, DWORD PTR _j$61853[ebp]
  03a2e	c1 e2 04	 shl	 edx, 4
  03a31	8b 4d cc	 mov	 ecx, DWORD PTR _fPoints$61851[ebp]
  03a34	03 ca		 add	 ecx, edx
  03a36	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABUSCI_Point@@@Z ; FPoint::operator=
  03a3b	eb d3		 jmp	 SHORT $L61855
$L61856:

; 2561 : 
; 2562 : 			polygonList[i].polyPointsID = fPointsID;

  03a3d	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  03a40	c1 e0 04	 shl	 eax, 4
  03a43	8b 4d f0	 mov	 ecx, DWORD PTR _polygonList$[ebp]
  03a46	66 8b 55 e4	 mov	 dx, WORD PTR _fPointsID$[ebp]
  03a4a	66 89 54 01 0c	 mov	 WORD PTR [ecx+eax+12], dx

; 2563 : 			polygonList[i].n = size;

  03a4f	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  03a52	c1 e0 04	 shl	 eax, 4
  03a55	8b 4d f0	 mov	 ecx, DWORD PTR _polygonList$[ebp]
  03a58	8b 55 dc	 mov	 edx, DWORD PTR _size$61842[ebp]
  03a5b	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx

; 2564 : 			polygonList[i].info = 0; 

  03a5f	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  03a62	c1 e0 04	 shl	 eax, 4
  03a65	8b 4d f0	 mov	 ecx, DWORD PTR _polygonList$[ebp]
  03a68	c6 44 01 05 00	 mov	 BYTE PTR [ecx+eax+5], 0

; 2565 : 
; 2566 : 			i++;

  03a6d	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  03a70	83 c2 01	 add	 edx, 1
  03a73	89 55 e8	 mov	 DWORD PTR _i$[ebp], edx

; 2567 : 		}

  03a76	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  03a7d	8d 4d c0	 lea	 ecx, DWORD PTR _pointsArray$61846[ebp]
  03a80	e8 00 00 00 00	 call	 ??1Array@@QAE@XZ	; Array::~Array
$L61845:

; 2568 : 	}

  03a85	e9 7d fe ff ff	 jmp	 $L61836
$L61837:

; 2569 : 
; 2570 : 	polygonList[i].polyPoints = NULL;

  03a8a	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  03a8d	c1 e0 04	 shl	 eax, 4
  03a90	8b 4d f0	 mov	 ecx, DWORD PTR _polygonList$[ebp]
  03a93	c7 04 01 00 00
	00 00		 mov	 DWORD PTR [ecx+eax], 0

; 2571 : 	polygonList[i].n = 0;

  03a9a	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  03a9d	c1 e2 04	 shl	 edx, 4
  03aa0	8b 45 f0	 mov	 eax, DWORD PTR _polygonList$[ebp]
  03aa3	c7 44 10 08 00
	00 00 00	 mov	 DWORD PTR [eax+edx+8], 0

; 2572 : 	polygonList[i].type = 0;

  03aab	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  03aae	c1 e1 04	 shl	 ecx, 4
  03ab1	8b 55 f0	 mov	 edx, DWORD PTR _polygonList$[ebp]
  03ab4	c6 44 0a 04 00	 mov	 BYTE PTR [edx+ecx+4], 0

; 2573 : 	polygonList[i].info = 0; 

  03ab9	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  03abc	c1 e0 04	 shl	 eax, 4
  03abf	8b 4d f0	 mov	 ecx, DWORD PTR _polygonList$[ebp]
  03ac2	c6 44 01 05 00	 mov	 BYTE PTR [ecx+eax+5], 0

; 2574 : 
; 2575 : 	for (i=0;polygonList[i].n;++i) {

  03ac7	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  03ace	eb 09		 jmp	 SHORT $L61857
$L61858:
  03ad0	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  03ad3	83 c2 01	 add	 edx, 1
  03ad6	89 55 e8	 mov	 DWORD PTR _i$[ebp], edx
$L61857:
  03ad9	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  03adc	c1 e0 04	 shl	 eax, 4
  03adf	8b 4d f0	 mov	 ecx, DWORD PTR _polygonList$[ebp]
  03ae2	83 7c 01 08 00	 cmp	 DWORD PTR [ecx+eax+8], 0
  03ae7	74 3b		 je	 SHORT $L61859

; 2576 : 		if ( polygonList[i].polyPointsID )

  03ae9	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  03aec	c1 e2 04	 shl	 edx, 4
  03aef	8b 45 f0	 mov	 eax, DWORD PTR _polygonList$[ebp]
  03af2	8d 4c 10 0c	 lea	 ecx, DWORD PTR [eax+edx+12]
  03af6	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  03afb	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  03b00	85 c0		 test	 eax, eax
  03b02	74 1e		 je	 SHORT $L61860

; 2577 : 			polygonList[i].polyPoints = (FPoint*) *polygonList[i].polyPointsID;

  03b04	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  03b07	c1 e1 04	 shl	 ecx, 4
  03b0a	8b 55 f0	 mov	 edx, DWORD PTR _polygonList$[ebp]
  03b0d	8d 4c 0a 0c	 lea	 ecx, DWORD PTR [edx+ecx+12]
  03b11	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  03b16	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  03b19	c1 e1 04	 shl	 ecx, 4
  03b1c	8b 55 f0	 mov	 edx, DWORD PTR _polygonList$[ebp]
  03b1f	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax
$L61860:

; 2578 : 	}

  03b22	eb ac		 jmp	 SHORT $L61858
$L61859:

; 2579 : 
; 2580 :    return(polygonListID);

  03b24	8d 45 ec	 lea	 eax, DWORD PTR _polygonListID$[ebp]
  03b27	50		 push	 eax
  03b28	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  03b2b	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  03b30	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2581 : }

  03b33	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  03b36	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  03b3d	8b e5		 mov	 esp, ebp
  03b3f	5d		 pop	 ebp
  03b40	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L62524:
  0003b	8d 4d c0	 lea	 ecx, DWORD PTR _pointsArray$61846[ebp]
  0003e	e8 00 00 00 00	 call	 ??1Array@@QAE@XZ	; Array::~Array
  00043	c3		 ret	 0
$L62527:
  00044	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T62526
  00049	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?BuildPolygonListF@@YA?AVMemID@@USOL_ListID@@H@Z ENDP	; BuildPolygonListF
EXTRN	__fltused:NEAR
;	COMDAT ??4FPoint@@QAEAAV0@ABUSCI_Point@@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
??4FPoint@@QAEAAV0@ABUSCI_Point@@@Z PROC NEAR		; FPoint::operator=, COMDAT

; 322  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 323  : 	x = (double) p.x;

  00009	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0000c	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0000f	89 4d f8	 mov	 DWORD PTR -8+[ebp], ecx
  00012	db 45 f8	 fild	 DWORD PTR -8+[ebp]
  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	dd 1a		 fstp	 QWORD PTR [edx]

; 324  : 	y = (double) p.y;

  0001a	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0001d	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00021	89 4d f4	 mov	 DWORD PTR -12+[ebp], ecx
  00024	db 45 f4	 fild	 DWORD PTR -12+[ebp]
  00027	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002a	dd 5a 08	 fstp	 QWORD PTR [edx+8]

; 325  : 	return *this;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 326  : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??4FPoint@@QAEAAV0@ABUSCI_Point@@@Z ENDP		; FPoint::operator=
_TEXT	ENDS
PUBLIC	__real@8@3ffe8000000000000000
PUBLIC	__real@8@00000000000000000000
PUBLIC	__real@8@3fff8000000000000000
PUBLIC	??4FPoint@@QAEAAV0@ABV0@@Z			; FPoint::operator=
PUBLIC	?RemoveDuplicatePointsF@@YAXPAVFPoint@@PAH@Z	; RemoveDuplicatePointsF
EXTRN	__ftol:NEAR
;	COMDAT __real@8@3ffe8000000000000000
; File \\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Polygon.cpp
CONST	SEGMENT
__real@8@3ffe8000000000000000 DQ 03fe0000000000000r ; 0.5
CONST	ENDS
;	COMDAT __real@8@00000000000000000000
CONST	SEGMENT
__real@8@00000000000000000000 DQ 00000000000000000r ; 0
CONST	ENDS
;	COMDAT __real@8@3fff8000000000000000
CONST	SEGMENT
__real@8@3fff8000000000000000 DQ 03ff0000000000000r ; 1
CONST	ENDS
_TEXT	SEGMENT
_P$ = 8
_n$ = 12
_i$ = -4
_j$ = -8
_k$61879 = -12
?RemoveDuplicatePointsF@@YAXPAVFPoint@@PAH@Z PROC NEAR	; RemoveDuplicatePointsF

; 2585 : {

  03b41	55		 push	 ebp
  03b42	8b ec		 mov	 ebp, esp
  03b44	83 ec 24	 sub	 esp, 36			; 00000024H
  03b47	56		 push	 esi

; 2586 : 	int i;
; 2587 : 	// Round to nearest integer
; 2588 :    for (i=0;i<*n;++i) 

  03b48	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  03b4f	eb 09		 jmp	 SHORT $L61867
$L61868:
  03b51	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  03b54	83 c0 01	 add	 eax, 1
  03b57	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L61867:
  03b5a	8b 4d 0c	 mov	 ecx, DWORD PTR _n$[ebp]
  03b5d	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  03b60	3b 11		 cmp	 edx, DWORD PTR [ecx]
  03b62	7d 56		 jge	 SHORT $L61869

; 2590 : 		P[i].x = (double) (int) (P[i].x + 0.5);

  03b64	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  03b67	c1 e0 04	 shl	 eax, 4
  03b6a	8b 4d 08	 mov	 ecx, DWORD PTR _P$[ebp]
  03b6d	dd 04 01	 fld	 QWORD PTR [ecx+eax]
  03b70	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@8@3ffe8000000000000000
  03b76	e8 00 00 00 00	 call	 __ftol
  03b7b	89 45 f0	 mov	 DWORD PTR -16+[ebp], eax
  03b7e	db 45 f0	 fild	 DWORD PTR -16+[ebp]
  03b81	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  03b84	c1 e2 04	 shl	 edx, 4
  03b87	8b 45 08	 mov	 eax, DWORD PTR _P$[ebp]
  03b8a	dd 1c 10	 fstp	 QWORD PTR [eax+edx]

; 2591 : 		P[i].y = (double) (int) (P[i].y + 0.5);

  03b8d	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  03b90	c1 e1 04	 shl	 ecx, 4
  03b93	8b 55 08	 mov	 edx, DWORD PTR _P$[ebp]
  03b96	dd 44 0a 08	 fld	 QWORD PTR [edx+ecx+8]
  03b9a	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@8@3ffe8000000000000000
  03ba0	e8 00 00 00 00	 call	 __ftol
  03ba5	89 45 ec	 mov	 DWORD PTR -20+[ebp], eax
  03ba8	db 45 ec	 fild	 DWORD PTR -20+[ebp]
  03bab	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  03bae	c1 e0 04	 shl	 eax, 4
  03bb1	8b 4d 08	 mov	 ecx, DWORD PTR _P$[ebp]
  03bb4	dd 5c 01 08	 fstp	 QWORD PTR [ecx+eax+8]

; 2592 : 
; 2593 :    }

  03bb8	eb 97		 jmp	 SHORT $L61868
$L61869:

; 2594 :    // Get rid of duplicate points
; 2595 :    for (int j=0;j<i;++j) 

  03bba	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  03bc1	eb 09		 jmp	 SHORT $L61875
$L61876:
  03bc3	8b 55 f8	 mov	 edx, DWORD PTR _j$[ebp]
  03bc6	83 c2 01	 add	 edx, 1
  03bc9	89 55 f8	 mov	 DWORD PTR _j$[ebp], edx
$L61875:
  03bcc	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  03bcf	3b 45 fc	 cmp	 eax, DWORD PTR _i$[ebp]
  03bd2	0f 8d 66 01 00
	00		 jge	 $L61877

; 2598 :          (Abs(P[j].x - P[(j+1)%i].x) <= CLOSETOF) && 
; 2599 :          (Abs(P[j].y - P[(j+1)%i].y) <= CLOSETOF)
; 2600 :          )

  03bd8	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  03bdb	c1 e1 04	 shl	 ecx, 4
  03bde	8b 75 08	 mov	 esi, DWORD PTR _P$[ebp]
  03be1	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  03be4	83 c0 01	 add	 eax, 1
  03be7	99		 cdq
  03be8	f7 7d fc	 idiv	 DWORD PTR _i$[ebp]
  03beb	c1 e2 04	 shl	 edx, 4
  03bee	8b 45 08	 mov	 eax, DWORD PTR _P$[ebp]
  03bf1	dd 04 0e	 fld	 QWORD PTR [esi+ecx]
  03bf4	dc 24 10	 fsub	 QWORD PTR [eax+edx]
  03bf7	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@00000000000000000000
  03bfd	df e0		 fnstsw	 ax
  03bff	f6 c4 01	 test	 ah, 1
  03c02	74 26		 je	 SHORT $L62532
  03c04	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  03c07	c1 e1 04	 shl	 ecx, 4
  03c0a	8b 75 08	 mov	 esi, DWORD PTR _P$[ebp]
  03c0d	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  03c10	83 c0 01	 add	 eax, 1
  03c13	99		 cdq
  03c14	f7 7d fc	 idiv	 DWORD PTR _i$[ebp]
  03c17	c1 e2 04	 shl	 edx, 4
  03c1a	8b 45 08	 mov	 eax, DWORD PTR _P$[ebp]
  03c1d	dd 04 0e	 fld	 QWORD PTR [esi+ecx]
  03c20	dc 24 10	 fsub	 QWORD PTR [eax+edx]
  03c23	d9 e0		 fchs
  03c25	dd 5d e4	 fstp	 QWORD PTR -28+[ebp]
  03c28	eb 22		 jmp	 SHORT $L62533
$L62532:
  03c2a	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  03c2d	c1 e1 04	 shl	 ecx, 4
  03c30	8b 75 08	 mov	 esi, DWORD PTR _P$[ebp]
  03c33	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  03c36	83 c0 01	 add	 eax, 1
  03c39	99		 cdq
  03c3a	f7 7d fc	 idiv	 DWORD PTR _i$[ebp]
  03c3d	c1 e2 04	 shl	 edx, 4
  03c40	8b 45 08	 mov	 eax, DWORD PTR _P$[ebp]
  03c43	dd 04 0e	 fld	 QWORD PTR [esi+ecx]
  03c46	dc 24 10	 fsub	 QWORD PTR [eax+edx]
  03c49	dd 5d e4	 fstp	 QWORD PTR -28+[ebp]
$L62533:
  03c4c	dd 45 e4	 fld	 QWORD PTR -28+[ebp]
  03c4f	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@3fff8000000000000000
  03c55	df e0		 fnstsw	 ax
  03c57	f6 c4 41	 test	 ah, 65			; 00000041H
  03c5a	0f 84 d9 00 00
	00		 je	 $L61878
  03c60	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  03c63	c1 e1 04	 shl	 ecx, 4
  03c66	8b 75 08	 mov	 esi, DWORD PTR _P$[ebp]
  03c69	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  03c6c	83 c0 01	 add	 eax, 1
  03c6f	99		 cdq
  03c70	f7 7d fc	 idiv	 DWORD PTR _i$[ebp]
  03c73	c1 e2 04	 shl	 edx, 4
  03c76	8b 45 08	 mov	 eax, DWORD PTR _P$[ebp]
  03c79	dd 44 0e 08	 fld	 QWORD PTR [esi+ecx+8]
  03c7d	dc 64 10 08	 fsub	 QWORD PTR [eax+edx+8]
  03c81	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@00000000000000000000
  03c87	df e0		 fnstsw	 ax
  03c89	f6 c4 01	 test	 ah, 1
  03c8c	74 28		 je	 SHORT $L62534
  03c8e	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  03c91	c1 e1 04	 shl	 ecx, 4
  03c94	8b 75 08	 mov	 esi, DWORD PTR _P$[ebp]
  03c97	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  03c9a	83 c0 01	 add	 eax, 1
  03c9d	99		 cdq
  03c9e	f7 7d fc	 idiv	 DWORD PTR _i$[ebp]
  03ca1	c1 e2 04	 shl	 edx, 4
  03ca4	8b 45 08	 mov	 eax, DWORD PTR _P$[ebp]
  03ca7	dd 44 0e 08	 fld	 QWORD PTR [esi+ecx+8]
  03cab	dc 64 10 08	 fsub	 QWORD PTR [eax+edx+8]
  03caf	d9 e0		 fchs
  03cb1	dd 5d dc	 fstp	 QWORD PTR -36+[ebp]
  03cb4	eb 24		 jmp	 SHORT $L62535
$L62534:
  03cb6	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  03cb9	c1 e1 04	 shl	 ecx, 4
  03cbc	8b 75 08	 mov	 esi, DWORD PTR _P$[ebp]
  03cbf	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  03cc2	83 c0 01	 add	 eax, 1
  03cc5	99		 cdq
  03cc6	f7 7d fc	 idiv	 DWORD PTR _i$[ebp]
  03cc9	c1 e2 04	 shl	 edx, 4
  03ccc	8b 45 08	 mov	 eax, DWORD PTR _P$[ebp]
  03ccf	dd 44 0e 08	 fld	 QWORD PTR [esi+ecx+8]
  03cd3	dc 64 10 08	 fsub	 QWORD PTR [eax+edx+8]
  03cd7	dd 5d dc	 fstp	 QWORD PTR -36+[ebp]
$L62535:
  03cda	dd 45 dc	 fld	 QWORD PTR -36+[ebp]
  03cdd	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@3fff8000000000000000
  03ce3	df e0		 fnstsw	 ax
  03ce5	f6 c4 41	 test	 ah, 65			; 00000041H
  03ce8	74 4f		 je	 SHORT $L61878

; 2602 :       	for (int k=j;k<i-1;++k) 

  03cea	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  03ced	89 4d f4	 mov	 DWORD PTR _k$61879[ebp], ecx
  03cf0	eb 09		 jmp	 SHORT $L61880
$L61881:
  03cf2	8b 55 f4	 mov	 edx, DWORD PTR _k$61879[ebp]
  03cf5	83 c2 01	 add	 edx, 1
  03cf8	89 55 f4	 mov	 DWORD PTR _k$61879[ebp], edx
$L61880:
  03cfb	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  03cfe	83 e8 01	 sub	 eax, 1
  03d01	39 45 f4	 cmp	 DWORD PTR _k$61879[ebp], eax
  03d04	7d 21		 jge	 SHORT $L61882

; 2603 :          	P[k] = P[k+1];

  03d06	8b 4d f4	 mov	 ecx, DWORD PTR _k$61879[ebp]
  03d09	83 c1 01	 add	 ecx, 1
  03d0c	c1 e1 04	 shl	 ecx, 4
  03d0f	8b 55 08	 mov	 edx, DWORD PTR _P$[ebp]
  03d12	03 d1		 add	 edx, ecx
  03d14	52		 push	 edx
  03d15	8b 45 f4	 mov	 eax, DWORD PTR _k$61879[ebp]
  03d18	c1 e0 04	 shl	 eax, 4
  03d1b	8b 4d 08	 mov	 ecx, DWORD PTR _P$[ebp]
  03d1e	03 c8		 add	 ecx, eax
  03d20	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=
  03d25	eb cb		 jmp	 SHORT $L61881
$L61882:

; 2604 :             --i;

  03d27	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  03d2a	83 e9 01	 sub	 ecx, 1
  03d2d	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx

; 2605 :             --j;

  03d30	8b 55 f8	 mov	 edx, DWORD PTR _j$[ebp]
  03d33	83 ea 01	 sub	 edx, 1
  03d36	89 55 f8	 mov	 DWORD PTR _j$[ebp], edx
$L61878:

; 2607 :    }

  03d39	e9 85 fe ff ff	 jmp	 $L61876
$L61877:

; 2608 :    *n = i;

  03d3e	8b 45 0c	 mov	 eax, DWORD PTR _n$[ebp]
  03d41	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  03d44	89 08		 mov	 DWORD PTR [eax], ecx

; 2609 : }

  03d46	5e		 pop	 esi
  03d47	8b e5		 mov	 esp, ebp
  03d49	5d		 pop	 ebp
  03d4a	c3		 ret	 0
?RemoveDuplicatePointsF@@YAXPAVFPoint@@PAH@Z ENDP	; RemoveDuplicatePointsF
_TEXT	ENDS
;	COMDAT ??4FPoint@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
??4FPoint@@QAEAAV0@ABV0@@Z PROC NEAR			; FPoint::operator=, COMDAT

; 314  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 315  : 	x = p.x;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 316  : 	y = p.y;

  00017	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00020	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00023	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  00026	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 317  : 	return *this;

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 318  : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
??4FPoint@@QAEAAV0@ABV0@@Z ENDP				; FPoint::operator=
_TEXT	ENDS
PUBLIC	??0FPoint@@QAE@XZ				; FPoint::FPoint
PUBLIC	__real@8@3ff1d1b71758e2196800
PUBLIC	??HFPoint@@QBE?AV0@ABV0@@Z			; FPoint::operator+
PUBLIC	??GFPoint@@QBE?AV0@ABV0@@Z			; FPoint::operator-
PUBLIC	??DFPoint@@QBENABV0@@Z				; FPoint::operator*
PUBLIC	??TFPoint@@QBEHABV0@@Z				; FPoint::operator^
PUBLIC	?IntersectSegmentsF@@YAHAAVFPoint@@000PAV1@H@Z	; IntersectSegmentsF
;	COMDAT __real@8@3ff1d1b71758e2196800
; File \\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Polygon.cpp
CONST	SEGMENT
__real@8@3ff1d1b71758e2196800 DQ 03f1a36e2eb1c432dr ; 0.0001
CONST	ENDS
_TEXT	SEGMENT
$T62545 = -184
$T62546 = -200
$T62547 = -216
$T62548 = -232
$T62549 = -248
$T62550 = -264
$T62559 = -280
$T62560 = -296
_A$ = 8
_B$ = 12
_C$ = 16
_D$ = 20
_intersection$ = 24
_external$ = 28
_x1$ = -116
_x2$ = -120
_x3$ = -124
_x4$ = -136
_dot1$ = -132
_dot2$ = -144
_dot3$ = -152
_wrk1$ = -168
_wrk2$ = -16
_wrk3$ = -32
_wrk4$ = -48
_wrk5$ = -64
_wrk6$ = -80
_wrk7$ = -112
_U$ = -96
?IntersectSegmentsF@@YAHAAVFPoint@@000PAV1@H@Z PROC NEAR ; IntersectSegmentsF

; 2635 : {

  03d4b	55		 push	 ebp
  03d4c	8b ec		 mov	 ebp, esp
  03d4e	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H

; 2636 :    int         x1,x2,x3,x4;
; 2637 :    double      dot1,dot2,dot3;
; 2638 :    FPoint   wrk1,wrk2,wrk3,wrk4,wrk5,wrk6,wrk7;

  03d54	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _wrk1$[ebp]
  03d5a	e8 00 00 00 00	 call	 ??0FPoint@@QAE@XZ	; FPoint::FPoint
  03d5f	8d 4d f0	 lea	 ecx, DWORD PTR _wrk2$[ebp]
  03d62	e8 00 00 00 00	 call	 ??0FPoint@@QAE@XZ	; FPoint::FPoint
  03d67	8d 4d e0	 lea	 ecx, DWORD PTR _wrk3$[ebp]
  03d6a	e8 00 00 00 00	 call	 ??0FPoint@@QAE@XZ	; FPoint::FPoint
  03d6f	8d 4d d0	 lea	 ecx, DWORD PTR _wrk4$[ebp]
  03d72	e8 00 00 00 00	 call	 ??0FPoint@@QAE@XZ	; FPoint::FPoint
  03d77	8d 4d c0	 lea	 ecx, DWORD PTR _wrk5$[ebp]
  03d7a	e8 00 00 00 00	 call	 ??0FPoint@@QAE@XZ	; FPoint::FPoint
  03d7f	8d 4d b0	 lea	 ecx, DWORD PTR _wrk6$[ebp]
  03d82	e8 00 00 00 00	 call	 ??0FPoint@@QAE@XZ	; FPoint::FPoint
  03d87	8d 4d 90	 lea	 ecx, DWORD PTR _wrk7$[ebp]
  03d8a	e8 00 00 00 00	 call	 ??0FPoint@@QAE@XZ	; FPoint::FPoint

; 2639 :    FPoint   U;

  03d8f	8d 4d a0	 lea	 ecx, DWORD PTR _U$[ebp]
  03d92	e8 00 00 00 00	 call	 ??0FPoint@@QAE@XZ	; FPoint::FPoint

; 2640 : 
; 2641 :    wrk1 = B - A;

  03d97	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  03d9a	50		 push	 eax
  03d9b	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR $T62545[ebp]
  03da1	51		 push	 ecx
  03da2	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  03da5	e8 00 00 00 00	 call	 ??GFPoint@@QBE?AV0@ABV0@@Z ; FPoint::operator-
  03daa	50		 push	 eax
  03dab	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _wrk1$[ebp]
  03db1	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 2642 :    wrk2 = C - A;

  03db6	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  03db9	52		 push	 edx
  03dba	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR $T62546[ebp]
  03dc0	50		 push	 eax
  03dc1	8b 4d 10	 mov	 ecx, DWORD PTR _C$[ebp]
  03dc4	e8 00 00 00 00	 call	 ??GFPoint@@QBE?AV0@ABV0@@Z ; FPoint::operator-
  03dc9	50		 push	 eax
  03dca	8d 4d f0	 lea	 ecx, DWORD PTR _wrk2$[ebp]
  03dcd	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 2643 :    wrk3 = D - A;

  03dd2	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  03dd5	51		 push	 ecx
  03dd6	8d 95 28 ff ff
	ff		 lea	 edx, DWORD PTR $T62547[ebp]
  03ddc	52		 push	 edx
  03ddd	8b 4d 14	 mov	 ecx, DWORD PTR _D$[ebp]
  03de0	e8 00 00 00 00	 call	 ??GFPoint@@QBE?AV0@ABV0@@Z ; FPoint::operator-
  03de5	50		 push	 eax
  03de6	8d 4d e0	 lea	 ecx, DWORD PTR _wrk3$[ebp]
  03de9	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 2644 :    wrk4 = D - C;

  03dee	8b 45 10	 mov	 eax, DWORD PTR _C$[ebp]
  03df1	50		 push	 eax
  03df2	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR $T62548[ebp]
  03df8	51		 push	 ecx
  03df9	8b 4d 14	 mov	 ecx, DWORD PTR _D$[ebp]
  03dfc	e8 00 00 00 00	 call	 ??GFPoint@@QBE?AV0@ABV0@@Z ; FPoint::operator-
  03e01	50		 push	 eax
  03e02	8d 4d d0	 lea	 ecx, DWORD PTR _wrk4$[ebp]
  03e05	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 2645 : //   wrk4 = C - D;
; 2646 :    wrk5 = B - C;

  03e0a	8b 55 10	 mov	 edx, DWORD PTR _C$[ebp]
  03e0d	52		 push	 edx
  03e0e	8d 85 08 ff ff
	ff		 lea	 eax, DWORD PTR $T62549[ebp]
  03e14	50		 push	 eax
  03e15	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  03e18	e8 00 00 00 00	 call	 ??GFPoint@@QBE?AV0@ABV0@@Z ; FPoint::operator-
  03e1d	50		 push	 eax
  03e1e	8d 4d c0	 lea	 ecx, DWORD PTR _wrk5$[ebp]
  03e21	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 2647 :    dot3 = wrk4*wrk4;

  03e26	8d 4d d0	 lea	 ecx, DWORD PTR _wrk4$[ebp]
  03e29	51		 push	 ecx
  03e2a	8d 4d d0	 lea	 ecx, DWORD PTR _wrk4$[ebp]
  03e2d	e8 00 00 00 00	 call	 ??DFPoint@@QBENABV0@@Z	; FPoint::operator*
  03e32	dd 9d 68 ff ff
	ff		 fstp	 QWORD PTR _dot3$[ebp]

; 2648 :    if (dot3==0.0)

  03e38	dd 85 68 ff ff
	ff		 fld	 QWORD PTR _dot3$[ebp]
  03e3e	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@00000000000000000000
  03e44	df e0		 fnstsw	 ax
  03e46	f6 c4 40	 test	 ah, 64			; 00000040H
  03e49	74 08		 je	 SHORT $L61911

; 2650 : //      #ifdef DEBUG
; 2651 : //	   msgMgr->Alert(SrcLoc,"A Polygon contains identical points at x:%d,y:%d\n",C.x,C.y);
; 2652 : //      #endif
; 2653 :       return(NOINTERSECT);

  03e4b	83 c8 ff	 or	 eax, -1
  03e4e	e9 1e 07 00 00	 jmp	 $L61890
$L61911:

; 2655 : 
; 2656 :    x1 = wrk1^wrk2;

  03e53	8d 55 f0	 lea	 edx, DWORD PTR _wrk2$[ebp]
  03e56	52		 push	 edx
  03e57	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _wrk1$[ebp]
  03e5d	e8 00 00 00 00	 call	 ??TFPoint@@QBEHABV0@@Z	; FPoint::operator^
  03e62	89 45 8c	 mov	 DWORD PTR _x1$[ebp], eax

; 2657 :    x2 = wrk1^wrk3;

  03e65	8d 45 e0	 lea	 eax, DWORD PTR _wrk3$[ebp]
  03e68	50		 push	 eax
  03e69	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _wrk1$[ebp]
  03e6f	e8 00 00 00 00	 call	 ??TFPoint@@QBEHABV0@@Z	; FPoint::operator^
  03e74	89 45 88	 mov	 DWORD PTR _x2$[ebp], eax

; 2658 :    x3 = wrk3^wrk4;

  03e77	8d 4d d0	 lea	 ecx, DWORD PTR _wrk4$[ebp]
  03e7a	51		 push	 ecx
  03e7b	8d 4d e0	 lea	 ecx, DWORD PTR _wrk3$[ebp]
  03e7e	e8 00 00 00 00	 call	 ??TFPoint@@QBEHABV0@@Z	; FPoint::operator^
  03e83	89 45 84	 mov	 DWORD PTR _x3$[ebp], eax

; 2659 :    x4 = wrk4^wrk5;

  03e86	8d 55 c0	 lea	 edx, DWORD PTR _wrk5$[ebp]
  03e89	52		 push	 edx
  03e8a	8d 4d d0	 lea	 ecx, DWORD PTR _wrk4$[ebp]
  03e8d	e8 00 00 00 00	 call	 ??TFPoint@@QBEHABV0@@Z	; FPoint::operator^
  03e92	89 85 78 ff ff
	ff		 mov	 DWORD PTR _x4$[ebp], eax

; 2660 : 
; 2661 :    // check for colinear
; 2662 :    if (x1 == 0.0 && x2 == 0.0)

  03e98	db 45 8c	 fild	 DWORD PTR _x1$[ebp]
  03e9b	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@00000000000000000000
  03ea1	df e0		 fnstsw	 ax
  03ea3	f6 c4 40	 test	 ah, 64			; 00000040H
  03ea6	74 61		 je	 SHORT $L61912
  03ea8	db 45 88	 fild	 DWORD PTR _x2$[ebp]
  03eab	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@00000000000000000000
  03eb1	df e0		 fnstsw	 ax
  03eb3	f6 c4 40	 test	 ah, 64			; 00000040H
  03eb6	74 51		 je	 SHORT $L61912

; 2664 :       // COLINEAR LINE SEGMENTS
; 2665 :       // Make sure that they really intersect
; 2666 :       if ((wrk2*wrk5 >= 0.0) || (wrk3*(D-B) <= 0.0))

  03eb8	8d 45 c0	 lea	 eax, DWORD PTR _wrk5$[ebp]
  03ebb	50		 push	 eax
  03ebc	8d 4d f0	 lea	 ecx, DWORD PTR _wrk2$[ebp]
  03ebf	e8 00 00 00 00	 call	 ??DFPoint@@QBENABV0@@Z	; FPoint::operator*
  03ec4	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@00000000000000000000
  03eca	df e0		 fnstsw	 ax
  03ecc	f6 c4 01	 test	 ah, 1
  03ecf	74 29		 je	 SHORT $L61915
  03ed1	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  03ed4	51		 push	 ecx
  03ed5	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR $T62550[ebp]
  03edb	52		 push	 edx
  03edc	8b 4d 14	 mov	 ecx, DWORD PTR _D$[ebp]
  03edf	e8 00 00 00 00	 call	 ??GFPoint@@QBE?AV0@ABV0@@Z ; FPoint::operator-
  03ee4	50		 push	 eax
  03ee5	8d 4d e0	 lea	 ecx, DWORD PTR _wrk3$[ebp]
  03ee8	e8 00 00 00 00	 call	 ??DFPoint@@QBENABV0@@Z	; FPoint::operator*
  03eed	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@00000000000000000000
  03ef3	df e0		 fnstsw	 ax
  03ef5	f6 c4 41	 test	 ah, 65			; 00000041H
  03ef8	74 07		 je	 SHORT $L61914
$L61915:

; 2667 :          return(COLINEAR);

  03efa	33 c0		 xor	 eax, eax
  03efc	e9 70 06 00 00	 jmp	 $L61890
$L61914:

; 2668 :       // disjoint
; 2669 :       return(NOINTERSECT);

  03f01	83 c8 ff	 or	 eax, -1
  03f04	e9 68 06 00 00	 jmp	 $L61890
$L61912:

; 2671 : 
; 2672 :    // check for intersection at C
; 2673 :    if (x1 == 0)

  03f09	83 7d 8c 00	 cmp	 DWORD PTR _x1$[ebp], 0
  03f0d	0f 85 cf 00 00
	00		 jne	 $L61922

; 2675 :       // C lies on the line through A-B find out
; 2676 :       // if it is in the line segment A-B.
; 2677 :       if (A.x == B.x)

  03f13	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  03f16	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  03f19	dd 00		 fld	 QWORD PTR [eax]
  03f1b	dc 19		 fcomp	 QWORD PTR [ecx]
  03f1d	df e0		 fnstsw	 ax
  03f1f	f6 c4 40	 test	 ah, 64			; 00000040H
  03f22	74 64		 je	 SHORT $L61917

; 2680 :             ((A.y <= C.y) && (C.y <= B.y))
; 2681 :             ||
; 2682 :             ((B.y <= C.y) && (C.y <= A.y))
; 2683 :             )

  03f24	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  03f27	8b 45 10	 mov	 eax, DWORD PTR _C$[ebp]
  03f2a	dd 42 08	 fld	 QWORD PTR [edx+8]
  03f2d	dc 58 08	 fcomp	 QWORD PTR [eax+8]
  03f30	df e0		 fnstsw	 ax
  03f32	f6 c4 41	 test	 ah, 65			; 00000041H
  03f35	74 13		 je	 SHORT $L61920
  03f37	8b 4d 10	 mov	 ecx, DWORD PTR _C$[ebp]
  03f3a	8b 55 0c	 mov	 edx, DWORD PTR _B$[ebp]
  03f3d	dd 41 08	 fld	 QWORD PTR [ecx+8]
  03f40	dc 5a 08	 fcomp	 QWORD PTR [edx+8]
  03f43	df e0		 fnstsw	 ax
  03f45	f6 c4 41	 test	 ah, 65			; 00000041H
  03f48	75 26		 jne	 SHORT $L61919
$L61920:
  03f4a	8b 45 0c	 mov	 eax, DWORD PTR _B$[ebp]
  03f4d	8b 4d 10	 mov	 ecx, DWORD PTR _C$[ebp]
  03f50	dd 40 08	 fld	 QWORD PTR [eax+8]
  03f53	dc 59 08	 fcomp	 QWORD PTR [ecx+8]
  03f56	df e0		 fnstsw	 ax
  03f58	f6 c4 41	 test	 ah, 65			; 00000041H
  03f5b	74 29		 je	 SHORT $L61918
  03f5d	8b 55 10	 mov	 edx, DWORD PTR _C$[ebp]
  03f60	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  03f63	dd 42 08	 fld	 QWORD PTR [edx+8]
  03f66	dc 58 08	 fcomp	 QWORD PTR [eax+8]
  03f69	df e0		 fnstsw	 ax
  03f6b	f6 c4 41	 test	 ah, 65			; 00000041H
  03f6e	74 16		 je	 SHORT $L61918
$L61919:

; 2685 :             *intersection = C;

  03f70	8b 4d 10	 mov	 ecx, DWORD PTR _C$[ebp]
  03f73	51		 push	 ecx
  03f74	8b 4d 18	 mov	 ecx, DWORD PTR _intersection$[ebp]
  03f77	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 2686 :             return(INTERSECT+INTERSECTC);

  03f7c	b8 09 00 00 00	 mov	 eax, 9
  03f81	e9 eb 05 00 00	 jmp	 $L61890
$L61918:

; 2689 :       else

  03f86	eb 5a		 jmp	 SHORT $L61922
$L61917:

; 2692 :             ((A.x <= C.x) && (C.x <= B.x))
; 2693 :             ||
; 2694 :             ((B.x <= C.x) && (C.x <= A.x))
; 2695 :             )

  03f88	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  03f8b	8b 45 10	 mov	 eax, DWORD PTR _C$[ebp]
  03f8e	dd 02		 fld	 QWORD PTR [edx]
  03f90	dc 18		 fcomp	 QWORD PTR [eax]
  03f92	df e0		 fnstsw	 ax
  03f94	f6 c4 41	 test	 ah, 65			; 00000041H
  03f97	74 11		 je	 SHORT $L61924
  03f99	8b 4d 10	 mov	 ecx, DWORD PTR _C$[ebp]
  03f9c	8b 55 0c	 mov	 edx, DWORD PTR _B$[ebp]
  03f9f	dd 01		 fld	 QWORD PTR [ecx]
  03fa1	dc 1a		 fcomp	 QWORD PTR [edx]
  03fa3	df e0		 fnstsw	 ax
  03fa5	f6 c4 41	 test	 ah, 65			; 00000041H
  03fa8	75 22		 jne	 SHORT $L61923
$L61924:
  03faa	8b 45 0c	 mov	 eax, DWORD PTR _B$[ebp]
  03fad	8b 4d 10	 mov	 ecx, DWORD PTR _C$[ebp]
  03fb0	dd 00		 fld	 QWORD PTR [eax]
  03fb2	dc 19		 fcomp	 QWORD PTR [ecx]
  03fb4	df e0		 fnstsw	 ax
  03fb6	f6 c4 41	 test	 ah, 65			; 00000041H
  03fb9	74 27		 je	 SHORT $L61922
  03fbb	8b 55 10	 mov	 edx, DWORD PTR _C$[ebp]
  03fbe	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  03fc1	dd 02		 fld	 QWORD PTR [edx]
  03fc3	dc 18		 fcomp	 QWORD PTR [eax]
  03fc5	df e0		 fnstsw	 ax
  03fc7	f6 c4 41	 test	 ah, 65			; 00000041H
  03fca	74 16		 je	 SHORT $L61922
$L61923:

; 2697 :             *intersection = C;

  03fcc	8b 4d 10	 mov	 ecx, DWORD PTR _C$[ebp]
  03fcf	51		 push	 ecx
  03fd0	8b 4d 18	 mov	 ecx, DWORD PTR _intersection$[ebp]
  03fd3	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 2698 :             return(INTERSECT+INTERSECTC);

  03fd8	b8 09 00 00 00	 mov	 eax, 9
  03fdd	e9 8f 05 00 00	 jmp	 $L61890
$L61922:

; 2702 : 
; 2703 :    // check for intersection at D
; 2704 :    if (x2 == 0)

  03fe2	83 7d 88 00	 cmp	 DWORD PTR _x2$[ebp], 0
  03fe6	0f 85 cf 00 00
	00		 jne	 $L61931

; 2706 :       // D lies on the line through A-B find out
; 2707 :       // if it is in the line segment A-B.
; 2708 :       if (A.x == B.x)

  03fec	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  03fef	8b 45 0c	 mov	 eax, DWORD PTR _B$[ebp]
  03ff2	dd 02		 fld	 QWORD PTR [edx]
  03ff4	dc 18		 fcomp	 QWORD PTR [eax]
  03ff6	df e0		 fnstsw	 ax
  03ff8	f6 c4 40	 test	 ah, 64			; 00000040H
  03ffb	74 64		 je	 SHORT $L61926

; 2711 :             ((A.y <= D.y) && (D.y <= B.y))
; 2712 :             ||
; 2713 :             ((B.y <= D.y) && (D.y <= A.y))
; 2714 :             )

  03ffd	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  04000	8b 55 14	 mov	 edx, DWORD PTR _D$[ebp]
  04003	dd 41 08	 fld	 QWORD PTR [ecx+8]
  04006	dc 5a 08	 fcomp	 QWORD PTR [edx+8]
  04009	df e0		 fnstsw	 ax
  0400b	f6 c4 41	 test	 ah, 65			; 00000041H
  0400e	74 13		 je	 SHORT $L61929
  04010	8b 45 14	 mov	 eax, DWORD PTR _D$[ebp]
  04013	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  04016	dd 40 08	 fld	 QWORD PTR [eax+8]
  04019	dc 59 08	 fcomp	 QWORD PTR [ecx+8]
  0401c	df e0		 fnstsw	 ax
  0401e	f6 c4 41	 test	 ah, 65			; 00000041H
  04021	75 26		 jne	 SHORT $L61928
$L61929:
  04023	8b 55 0c	 mov	 edx, DWORD PTR _B$[ebp]
  04026	8b 45 14	 mov	 eax, DWORD PTR _D$[ebp]
  04029	dd 42 08	 fld	 QWORD PTR [edx+8]
  0402c	dc 58 08	 fcomp	 QWORD PTR [eax+8]
  0402f	df e0		 fnstsw	 ax
  04031	f6 c4 41	 test	 ah, 65			; 00000041H
  04034	74 29		 je	 SHORT $L61927
  04036	8b 4d 14	 mov	 ecx, DWORD PTR _D$[ebp]
  04039	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  0403c	dd 41 08	 fld	 QWORD PTR [ecx+8]
  0403f	dc 5a 08	 fcomp	 QWORD PTR [edx+8]
  04042	df e0		 fnstsw	 ax
  04044	f6 c4 41	 test	 ah, 65			; 00000041H
  04047	74 16		 je	 SHORT $L61927
$L61928:

; 2716 :             *intersection = D;

  04049	8b 45 14	 mov	 eax, DWORD PTR _D$[ebp]
  0404c	50		 push	 eax
  0404d	8b 4d 18	 mov	 ecx, DWORD PTR _intersection$[ebp]
  04050	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 2717 :             return(INTERSECT+INTERSECTD);

  04055	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  0405a	e9 12 05 00 00	 jmp	 $L61890
$L61927:

; 2720 :       else

  0405f	eb 5a		 jmp	 SHORT $L61931
$L61926:

; 2723 :             ((A.x <= D.x) && (D.x <= B.x))
; 2724 :             ||
; 2725 :             ((B.x <= D.x) && (D.x <= A.x))
; 2726 :             )

  04061	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  04064	8b 55 14	 mov	 edx, DWORD PTR _D$[ebp]
  04067	dd 01		 fld	 QWORD PTR [ecx]
  04069	dc 1a		 fcomp	 QWORD PTR [edx]
  0406b	df e0		 fnstsw	 ax
  0406d	f6 c4 41	 test	 ah, 65			; 00000041H
  04070	74 11		 je	 SHORT $L61933
  04072	8b 45 14	 mov	 eax, DWORD PTR _D$[ebp]
  04075	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  04078	dd 00		 fld	 QWORD PTR [eax]
  0407a	dc 19		 fcomp	 QWORD PTR [ecx]
  0407c	df e0		 fnstsw	 ax
  0407e	f6 c4 41	 test	 ah, 65			; 00000041H
  04081	75 22		 jne	 SHORT $L61932
$L61933:
  04083	8b 55 0c	 mov	 edx, DWORD PTR _B$[ebp]
  04086	8b 45 14	 mov	 eax, DWORD PTR _D$[ebp]
  04089	dd 02		 fld	 QWORD PTR [edx]
  0408b	dc 18		 fcomp	 QWORD PTR [eax]
  0408d	df e0		 fnstsw	 ax
  0408f	f6 c4 41	 test	 ah, 65			; 00000041H
  04092	74 27		 je	 SHORT $L61931
  04094	8b 4d 14	 mov	 ecx, DWORD PTR _D$[ebp]
  04097	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  0409a	dd 01		 fld	 QWORD PTR [ecx]
  0409c	dc 1a		 fcomp	 QWORD PTR [edx]
  0409e	df e0		 fnstsw	 ax
  040a0	f6 c4 41	 test	 ah, 65			; 00000041H
  040a3	74 16		 je	 SHORT $L61931
$L61932:

; 2728 :             *intersection =  D; 

  040a5	8b 45 14	 mov	 eax, DWORD PTR _D$[ebp]
  040a8	50		 push	 eax
  040a9	8b 4d 18	 mov	 ecx, DWORD PTR _intersection$[ebp]
  040ac	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 2729 :             return(INTERSECT+INTERSECTD);

  040b1	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  040b6	e9 b6 04 00 00	 jmp	 $L61890
$L61931:

; 2733 : 
; 2734 :    // check for intersection at A
; 2735 :    if (x3 == 0)

  040bb	83 7d 84 00	 cmp	 DWORD PTR _x3$[ebp], 0
  040bf	0f 85 cf 00 00
	00		 jne	 $L61940

; 2737 :       // A lies on the line through C-D find out
; 2738 :       // if it is in the line segment C-D.
; 2739 :       if (C.x == D.x)

  040c5	8b 4d 10	 mov	 ecx, DWORD PTR _C$[ebp]
  040c8	8b 55 14	 mov	 edx, DWORD PTR _D$[ebp]
  040cb	dd 01		 fld	 QWORD PTR [ecx]
  040cd	dc 1a		 fcomp	 QWORD PTR [edx]
  040cf	df e0		 fnstsw	 ax
  040d1	f6 c4 40	 test	 ah, 64			; 00000040H
  040d4	74 64		 je	 SHORT $L61935

; 2742 :             ((C.y <= A.y) && (A.y <= D.y))
; 2743 :             ||
; 2744 :             ((D.y <= A.y) && (A.y <= C.y))
; 2745 :             )

  040d6	8b 45 10	 mov	 eax, DWORD PTR _C$[ebp]
  040d9	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  040dc	dd 40 08	 fld	 QWORD PTR [eax+8]
  040df	dc 59 08	 fcomp	 QWORD PTR [ecx+8]
  040e2	df e0		 fnstsw	 ax
  040e4	f6 c4 41	 test	 ah, 65			; 00000041H
  040e7	74 13		 je	 SHORT $L61938
  040e9	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  040ec	8b 45 14	 mov	 eax, DWORD PTR _D$[ebp]
  040ef	dd 42 08	 fld	 QWORD PTR [edx+8]
  040f2	dc 58 08	 fcomp	 QWORD PTR [eax+8]
  040f5	df e0		 fnstsw	 ax
  040f7	f6 c4 41	 test	 ah, 65			; 00000041H
  040fa	75 26		 jne	 SHORT $L61937
$L61938:
  040fc	8b 4d 14	 mov	 ecx, DWORD PTR _D$[ebp]
  040ff	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  04102	dd 41 08	 fld	 QWORD PTR [ecx+8]
  04105	dc 5a 08	 fcomp	 QWORD PTR [edx+8]
  04108	df e0		 fnstsw	 ax
  0410a	f6 c4 41	 test	 ah, 65			; 00000041H
  0410d	74 29		 je	 SHORT $L61936
  0410f	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  04112	8b 4d 10	 mov	 ecx, DWORD PTR _C$[ebp]
  04115	dd 40 08	 fld	 QWORD PTR [eax+8]
  04118	dc 59 08	 fcomp	 QWORD PTR [ecx+8]
  0411b	df e0		 fnstsw	 ax
  0411d	f6 c4 41	 test	 ah, 65			; 00000041H
  04120	74 16		 je	 SHORT $L61936
$L61937:

; 2747 :             *intersection = A;

  04122	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  04125	52		 push	 edx
  04126	8b 4d 18	 mov	 ecx, DWORD PTR _intersection$[ebp]
  04129	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 2748 :             return(INTERSECT+INTERSECTA);

  0412e	b8 03 00 00 00	 mov	 eax, 3
  04133	e9 39 04 00 00	 jmp	 $L61890
$L61936:

; 2751 :       else

  04138	eb 5a		 jmp	 SHORT $L61940
$L61935:

; 2754 :             ((C.x <= A.x) && (A.x <= D.x))
; 2755 :             ||
; 2756 :             ((D.x <= A.x) && (A.x <= C.x))
; 2757 :             )

  0413a	8b 45 10	 mov	 eax, DWORD PTR _C$[ebp]
  0413d	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  04140	dd 00		 fld	 QWORD PTR [eax]
  04142	dc 19		 fcomp	 QWORD PTR [ecx]
  04144	df e0		 fnstsw	 ax
  04146	f6 c4 41	 test	 ah, 65			; 00000041H
  04149	74 11		 je	 SHORT $L61942
  0414b	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  0414e	8b 45 14	 mov	 eax, DWORD PTR _D$[ebp]
  04151	dd 02		 fld	 QWORD PTR [edx]
  04153	dc 18		 fcomp	 QWORD PTR [eax]
  04155	df e0		 fnstsw	 ax
  04157	f6 c4 41	 test	 ah, 65			; 00000041H
  0415a	75 22		 jne	 SHORT $L61941
$L61942:
  0415c	8b 4d 14	 mov	 ecx, DWORD PTR _D$[ebp]
  0415f	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  04162	dd 01		 fld	 QWORD PTR [ecx]
  04164	dc 1a		 fcomp	 QWORD PTR [edx]
  04166	df e0		 fnstsw	 ax
  04168	f6 c4 41	 test	 ah, 65			; 00000041H
  0416b	74 27		 je	 SHORT $L61940
  0416d	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  04170	8b 4d 10	 mov	 ecx, DWORD PTR _C$[ebp]
  04173	dd 00		 fld	 QWORD PTR [eax]
  04175	dc 19		 fcomp	 QWORD PTR [ecx]
  04177	df e0		 fnstsw	 ax
  04179	f6 c4 41	 test	 ah, 65			; 00000041H
  0417c	74 16		 je	 SHORT $L61940
$L61941:

; 2759 :             *intersection =  A; 

  0417e	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  04181	52		 push	 edx
  04182	8b 4d 18	 mov	 ecx, DWORD PTR _intersection$[ebp]
  04185	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 2760 :             return(INTERSECT+INTERSECTA);

  0418a	b8 03 00 00 00	 mov	 eax, 3
  0418f	e9 dd 03 00 00	 jmp	 $L61890
$L61940:

; 2764 : 
; 2765 :    // check for intersection at B
; 2766 :    if (x4 == 0)

  04194	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR _x4$[ebp], 0
  0419b	0f 85 cf 00 00
	00		 jne	 $L61949

; 2768 :       // B lies on the line through C-D find out
; 2769 :       // if it is in the line segment C-D.
; 2770 :       if (C.x == D.x)

  041a1	8b 45 10	 mov	 eax, DWORD PTR _C$[ebp]
  041a4	8b 4d 14	 mov	 ecx, DWORD PTR _D$[ebp]
  041a7	dd 00		 fld	 QWORD PTR [eax]
  041a9	dc 19		 fcomp	 QWORD PTR [ecx]
  041ab	df e0		 fnstsw	 ax
  041ad	f6 c4 40	 test	 ah, 64			; 00000040H
  041b0	74 64		 je	 SHORT $L61944

; 2773 :             ((C.y <= B.y) && (B.y <= D.y))
; 2774 :             ||
; 2775 :             ((D.y <= B.y) && (B.y <= C.y))
; 2776 :             )

  041b2	8b 55 10	 mov	 edx, DWORD PTR _C$[ebp]
  041b5	8b 45 0c	 mov	 eax, DWORD PTR _B$[ebp]
  041b8	dd 42 08	 fld	 QWORD PTR [edx+8]
  041bb	dc 58 08	 fcomp	 QWORD PTR [eax+8]
  041be	df e0		 fnstsw	 ax
  041c0	f6 c4 41	 test	 ah, 65			; 00000041H
  041c3	74 13		 je	 SHORT $L61947
  041c5	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  041c8	8b 55 14	 mov	 edx, DWORD PTR _D$[ebp]
  041cb	dd 41 08	 fld	 QWORD PTR [ecx+8]
  041ce	dc 5a 08	 fcomp	 QWORD PTR [edx+8]
  041d1	df e0		 fnstsw	 ax
  041d3	f6 c4 41	 test	 ah, 65			; 00000041H
  041d6	75 26		 jne	 SHORT $L61946
$L61947:
  041d8	8b 45 14	 mov	 eax, DWORD PTR _D$[ebp]
  041db	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  041de	dd 40 08	 fld	 QWORD PTR [eax+8]
  041e1	dc 59 08	 fcomp	 QWORD PTR [ecx+8]
  041e4	df e0		 fnstsw	 ax
  041e6	f6 c4 41	 test	 ah, 65			; 00000041H
  041e9	74 29		 je	 SHORT $L61945
  041eb	8b 55 0c	 mov	 edx, DWORD PTR _B$[ebp]
  041ee	8b 45 10	 mov	 eax, DWORD PTR _C$[ebp]
  041f1	dd 42 08	 fld	 QWORD PTR [edx+8]
  041f4	dc 58 08	 fcomp	 QWORD PTR [eax+8]
  041f7	df e0		 fnstsw	 ax
  041f9	f6 c4 41	 test	 ah, 65			; 00000041H
  041fc	74 16		 je	 SHORT $L61945
$L61946:

; 2778 :             *intersection = B;

  041fe	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  04201	51		 push	 ecx
  04202	8b 4d 18	 mov	 ecx, DWORD PTR _intersection$[ebp]
  04205	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 2779 :             return(INTERSECT+INTERSECTB);

  0420a	b8 05 00 00 00	 mov	 eax, 5
  0420f	e9 5d 03 00 00	 jmp	 $L61890
$L61945:

; 2782 :       else

  04214	eb 5a		 jmp	 SHORT $L61949
$L61944:

; 2785 :             ((C.x <= B.x) && (B.x <= D.x))
; 2786 :             ||
; 2787 :             ((D.x <= B.x) && (B.x <= C.x))
; 2788 :             )

  04216	8b 55 10	 mov	 edx, DWORD PTR _C$[ebp]
  04219	8b 45 0c	 mov	 eax, DWORD PTR _B$[ebp]
  0421c	dd 02		 fld	 QWORD PTR [edx]
  0421e	dc 18		 fcomp	 QWORD PTR [eax]
  04220	df e0		 fnstsw	 ax
  04222	f6 c4 41	 test	 ah, 65			; 00000041H
  04225	74 11		 je	 SHORT $L61951
  04227	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  0422a	8b 55 14	 mov	 edx, DWORD PTR _D$[ebp]
  0422d	dd 01		 fld	 QWORD PTR [ecx]
  0422f	dc 1a		 fcomp	 QWORD PTR [edx]
  04231	df e0		 fnstsw	 ax
  04233	f6 c4 41	 test	 ah, 65			; 00000041H
  04236	75 22		 jne	 SHORT $L61950
$L61951:
  04238	8b 45 14	 mov	 eax, DWORD PTR _D$[ebp]
  0423b	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  0423e	dd 00		 fld	 QWORD PTR [eax]
  04240	dc 19		 fcomp	 QWORD PTR [ecx]
  04242	df e0		 fnstsw	 ax
  04244	f6 c4 41	 test	 ah, 65			; 00000041H
  04247	74 27		 je	 SHORT $L61949
  04249	8b 55 0c	 mov	 edx, DWORD PTR _B$[ebp]
  0424c	8b 45 10	 mov	 eax, DWORD PTR _C$[ebp]
  0424f	dd 02		 fld	 QWORD PTR [edx]
  04251	dc 18		 fcomp	 QWORD PTR [eax]
  04253	df e0		 fnstsw	 ax
  04255	f6 c4 41	 test	 ah, 65			; 00000041H
  04258	74 16		 je	 SHORT $L61949
$L61950:

; 2790 :             *intersection =  B; 

  0425a	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  0425d	51		 push	 ecx
  0425e	8b 4d 18	 mov	 ecx, DWORD PTR _intersection$[ebp]
  04261	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 2791 :             return(INTERSECT+INTERSECTB);

  04266	b8 05 00 00 00	 mov	 eax, 5
  0426b	e9 01 03 00 00	 jmp	 $L61890
$L61949:

; 2795 : 
; 2796 :    // check that C,D on opposite side of line through A-B
; 2797 :    if (x1*x2 >= 0)

  04270	8b 55 8c	 mov	 edx, DWORD PTR _x1$[ebp]
  04273	0f af 55 88	 imul	 edx, DWORD PTR _x2$[ebp]
  04277	85 d2		 test	 edx, edx
  04279	7c 08		 jl	 SHORT $L61952

; 2798 :       return(NOINTERSECT);

  0427b	83 c8 ff	 or	 eax, -1
  0427e	e9 ee 02 00 00	 jmp	 $L61890
$L61952:

; 2799 : 
; 2800 :    // check that A,B on opposite side of line through C-D
; 2801 :    x1 = wrk2^wrk4;

  04283	8d 45 d0	 lea	 eax, DWORD PTR _wrk4$[ebp]
  04286	50		 push	 eax
  04287	8d 4d f0	 lea	 ecx, DWORD PTR _wrk2$[ebp]
  0428a	e8 00 00 00 00	 call	 ??TFPoint@@QBEHABV0@@Z	; FPoint::operator^
  0428f	89 45 8c	 mov	 DWORD PTR _x1$[ebp], eax

; 2802 :    x2 = wrk4^wrk5;

  04292	8d 4d c0	 lea	 ecx, DWORD PTR _wrk5$[ebp]
  04295	51		 push	 ecx
  04296	8d 4d d0	 lea	 ecx, DWORD PTR _wrk4$[ebp]
  04299	e8 00 00 00 00	 call	 ??TFPoint@@QBEHABV0@@Z	; FPoint::operator^
  0429e	89 45 88	 mov	 DWORD PTR _x2$[ebp], eax

; 2803 :    if (x1*x2 >= 0)

  042a1	8b 55 8c	 mov	 edx, DWORD PTR _x1$[ebp]
  042a4	0f af 55 88	 imul	 edx, DWORD PTR _x2$[ebp]
  042a8	85 d2		 test	 edx, edx
  042aa	7c 08		 jl	 SHORT $L61953

; 2804 :       return(NOINTERSECT);

  042ac	83 c8 ff	 or	 eax, -1
  042af	e9 bd 02 00 00	 jmp	 $L61890
$L61953:

; 2805 : 
; 2806 :    // Intersection interior to both line
; 2807 :    // segments calculate intersection point.
; 2808 : 
; 2809 :    // U is normal to C-D pointing toward the outside of the polygon
; 2810 :    U.x = wrk4.y;

  042b4	8b 45 d8	 mov	 eax, DWORD PTR _wrk4$[ebp+8]
  042b7	89 45 a0	 mov	 DWORD PTR _U$[ebp], eax
  042ba	8b 4d dc	 mov	 ecx, DWORD PTR _wrk4$[ebp+12]
  042bd	89 4d a4	 mov	 DWORD PTR _U$[ebp+4], ecx

; 2811 :    U.y = -wrk4.x;

  042c0	dd 45 d0	 fld	 QWORD PTR _wrk4$[ebp]
  042c3	d9 e0		 fchs
  042c5	dd 5d a8	 fstp	 QWORD PTR _U$[ebp+8]

; 2812 :    // U dot (A-C)
; 2813 :    dot1 = U*wrk2;

  042c8	8d 55 f0	 lea	 edx, DWORD PTR _wrk2$[ebp]
  042cb	52		 push	 edx
  042cc	8d 4d a0	 lea	 ecx, DWORD PTR _U$[ebp]
  042cf	e8 00 00 00 00	 call	 ??DFPoint@@QBENABV0@@Z	; FPoint::operator*
  042d4	dd 9d 7c ff ff
	ff		 fstp	 QWORD PTR _dot1$[ebp]

; 2814 :    // U dot (A-B)
; 2815 :    dot2 = U*wrk1;

  042da	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _wrk1$[ebp]
  042e0	50		 push	 eax
  042e1	8d 4d a0	 lea	 ecx, DWORD PTR _U$[ebp]
  042e4	e8 00 00 00 00	 call	 ??DFPoint@@QBENABV0@@Z	; FPoint::operator*
  042e9	dd 9d 70 ff ff
	ff		 fstp	 QWORD PTR _dot2$[ebp]

; 2816 :    dot3 = dot2;

  042ef	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _dot2$[ebp]
  042f5	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _dot3$[ebp], ecx
  042fb	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _dot2$[ebp+4]
  04301	89 95 6c ff ff
	ff		 mov	 DWORD PTR _dot3$[ebp+4], edx

; 2817 :    if (dot1 < 0) 

  04307	dd 85 7c ff ff
	ff		 fld	 QWORD PTR _dot1$[ebp]
  0430d	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@00000000000000000000
  04313	df e0		 fnstsw	 ax
  04315	f6 c4 01	 test	 ah, 1
  04318	74 0e		 je	 SHORT $L61954

; 2818 :       dot1 = - dot1;

  0431a	dd 85 7c ff ff
	ff		 fld	 QWORD PTR _dot1$[ebp]
  04320	d9 e0		 fchs
  04322	dd 9d 7c ff ff
	ff		 fstp	 QWORD PTR _dot1$[ebp]
$L61954:

; 2819 :    if (dot2 < 0) 

  04328	dd 85 70 ff ff
	ff		 fld	 QWORD PTR _dot2$[ebp]
  0432e	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@00000000000000000000
  04334	df e0		 fnstsw	 ax
  04336	f6 c4 01	 test	 ah, 1
  04339	74 0e		 je	 SHORT $L61955

; 2820 :       dot2 = - dot2;

  0433b	dd 85 70 ff ff
	ff		 fld	 QWORD PTR _dot2$[ebp]
  04341	d9 e0		 fchs
  04343	dd 9d 70 ff ff
	ff		 fstp	 QWORD PTR _dot2$[ebp]
$L61955:

; 2821 : 
; 2822 :    if (dot3>0)

  04349	dd 85 68 ff ff
	ff		 fld	 QWORD PTR _dot3$[ebp]
  0434f	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@00000000000000000000
  04355	df e0		 fnstsw	 ax
  04357	f6 c4 41	 test	 ah, 65			; 00000041H
  0435a	0f 85 94 01 00
	00		 jne	 $L61956

; 2824 :       if (external)

  04360	83 7d 1c 00	 cmp	 DWORD PTR _external$[ebp], 0
  04364	0f 84 44 01 00
	00		 je	 $L61957

; 2826 : 	      // Make sure that the intersection is on the outside of the polygon
; 2827 :          wrk6.x = (wrk1.x*dot1)/dot2 + signF(wrk1.x)*PUSHEXTERNAL;

  0436a	dd 85 58 ff ff
	ff		 fld	 QWORD PTR _wrk1$[ebp]
  04370	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@00000000000000000000
  04376	df e0		 fnstsw	 ax
  04378	f6 c4 41	 test	 ah, 65			; 00000041H
  0437b	75 16		 jne	 SHORT $L62553
  0437d	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR -304+[ebp], 0
  04387	c7 85 d4 fe ff
	ff 00 00 f0 3f	 mov	 DWORD PTR -304+[ebp+4], 1072693248 ; 3ff00000H
  04391	eb 55		 jmp	 SHORT $L62554
$L62553:
  04393	dd 85 58 ff ff
	ff		 fld	 QWORD PTR _wrk1$[ebp]
  04399	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@00000000000000000000
  0439f	df e0		 fnstsw	 ax
  043a1	f6 c4 01	 test	 ah, 1
  043a4	74 16		 je	 SHORT $L62551
  043a6	c7 85 c8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR -312+[ebp], 0
  043b0	c7 85 cc fe ff
	ff 00 00 f0 bf	 mov	 DWORD PTR -312+[ebp+4], -1074790400 ; bff00000H
  043ba	eb 14		 jmp	 SHORT $L62552
$L62551:
  043bc	c7 85 c8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR -312+[ebp], 0
  043c6	c7 85 cc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR -312+[ebp+4], 0
$L62552:
  043d0	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR -312+[ebp]
  043d6	89 85 d0 fe ff
	ff		 mov	 DWORD PTR -304+[ebp], eax
  043dc	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR -312+[ebp+4]
  043e2	89 8d d4 fe ff
	ff		 mov	 DWORD PTR -304+[ebp+4], ecx
$L62554:
  043e8	dd 85 58 ff ff
	ff		 fld	 QWORD PTR _wrk1$[ebp]
  043ee	dc 8d 7c ff ff
	ff		 fmul	 QWORD PTR _dot1$[ebp]
  043f4	dc b5 70 ff ff
	ff		 fdiv	 QWORD PTR _dot2$[ebp]
  043fa	dd 85 d0 fe ff
	ff		 fld	 QWORD PTR -304+[ebp]
  04400	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@8@3ff1d1b71758e2196800
  04406	de c1		 faddp	 ST(1), ST(0)
  04408	dd 5d b0	 fstp	 QWORD PTR _wrk6$[ebp]

; 2828 :          wrk6.y = (wrk1.y*dot1)/dot2 + signF(wrk1.y)*PUSHEXTERNAL;

  0440b	dd 85 60 ff ff
	ff		 fld	 QWORD PTR _wrk1$[ebp+8]
  04411	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@00000000000000000000
  04417	df e0		 fnstsw	 ax
  04419	f6 c4 41	 test	 ah, 65			; 00000041H
  0441c	75 16		 jne	 SHORT $L62557
  0441e	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR -320+[ebp], 0
  04428	c7 85 c4 fe ff
	ff 00 00 f0 3f	 mov	 DWORD PTR -320+[ebp+4], 1072693248 ; 3ff00000H
  04432	eb 55		 jmp	 SHORT $L62558
$L62557:
  04434	dd 85 60 ff ff
	ff		 fld	 QWORD PTR _wrk1$[ebp+8]
  0443a	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@00000000000000000000
  04440	df e0		 fnstsw	 ax
  04442	f6 c4 01	 test	 ah, 1
  04445	74 16		 je	 SHORT $L62555
  04447	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR -328+[ebp], 0
  04451	c7 85 bc fe ff
	ff 00 00 f0 bf	 mov	 DWORD PTR -328+[ebp+4], -1074790400 ; bff00000H
  0445b	eb 14		 jmp	 SHORT $L62556
$L62555:
  0445d	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR -328+[ebp], 0
  04467	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR -328+[ebp+4], 0
$L62556:
  04471	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR -328+[ebp]
  04477	89 95 c0 fe ff
	ff		 mov	 DWORD PTR -320+[ebp], edx
  0447d	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR -328+[ebp+4]
  04483	89 85 c4 fe ff
	ff		 mov	 DWORD PTR -320+[ebp+4], eax
$L62558:
  04489	dd 85 60 ff ff
	ff		 fld	 QWORD PTR _wrk1$[ebp+8]
  0448f	dc 8d 7c ff ff
	ff		 fmul	 QWORD PTR _dot1$[ebp]
  04495	dc b5 70 ff ff
	ff		 fdiv	 QWORD PTR _dot2$[ebp]
  0449b	dd 85 c0 fe ff
	ff		 fld	 QWORD PTR -320+[ebp]
  044a1	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@8@3ff1d1b71758e2196800
  044a7	de c1		 faddp	 ST(1), ST(0)
  044a9	dd 5d b8	 fstp	 QWORD PTR _wrk6$[ebp+8]

; 2830 :       else

  044ac	eb 2a		 jmp	 SHORT $L61958
$L61957:

; 2832 :          wrk6.x = (wrk1.x*dot1)/dot2;

  044ae	dd 85 58 ff ff
	ff		 fld	 QWORD PTR _wrk1$[ebp]
  044b4	dc 8d 7c ff ff
	ff		 fmul	 QWORD PTR _dot1$[ebp]
  044ba	dc b5 70 ff ff
	ff		 fdiv	 QWORD PTR _dot2$[ebp]
  044c0	dd 5d b0	 fstp	 QWORD PTR _wrk6$[ebp]

; 2833 :          wrk6.y = (wrk1.y*dot1)/dot2;

  044c3	dd 85 60 ff ff
	ff		 fld	 QWORD PTR _wrk1$[ebp+8]
  044c9	dc 8d 7c ff ff
	ff		 fmul	 QWORD PTR _dot1$[ebp]
  044cf	dc b5 70 ff ff
	ff		 fdiv	 QWORD PTR _dot2$[ebp]
  044d5	dd 5d b8	 fstp	 QWORD PTR _wrk6$[ebp+8]
$L61958:

; 2835 :       *intersection = A + wrk6;

  044d8	8d 4d b0	 lea	 ecx, DWORD PTR _wrk6$[ebp]
  044db	51		 push	 ecx
  044dc	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR $T62559[ebp]
  044e2	52		 push	 edx
  044e3	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  044e6	e8 00 00 00 00	 call	 ??HFPoint@@QBE?AV0@ABV0@@Z ; FPoint::operator+
  044eb	50		 push	 eax
  044ec	8b 4d 18	 mov	 ecx, DWORD PTR _intersection$[ebp]
  044ef	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=
$L61956:

; 2837 :    if (dot3<0)

  044f4	dd 85 68 ff ff
	ff		 fld	 QWORD PTR _dot3$[ebp]
  044fa	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@00000000000000000000
  04500	df e0		 fnstsw	 ax
  04502	f6 c4 01	 test	 ah, 1
  04505	74 46		 je	 SHORT $L61960

; 2839 :       // truncate so that intersection is outside polygon
; 2840 :       wrk6.x = (wrk1.x*dot1)/dot2;

  04507	dd 85 58 ff ff
	ff		 fld	 QWORD PTR _wrk1$[ebp]
  0450d	dc 8d 7c ff ff
	ff		 fmul	 QWORD PTR _dot1$[ebp]
  04513	dc b5 70 ff ff
	ff		 fdiv	 QWORD PTR _dot2$[ebp]
  04519	dd 5d b0	 fstp	 QWORD PTR _wrk6$[ebp]

; 2841 :       wrk6.y = (wrk1.y*dot1)/dot2;

  0451c	dd 85 60 ff ff
	ff		 fld	 QWORD PTR _wrk1$[ebp+8]
  04522	dc 8d 7c ff ff
	ff		 fmul	 QWORD PTR _dot1$[ebp]
  04528	dc b5 70 ff ff
	ff		 fdiv	 QWORD PTR _dot2$[ebp]
  0452e	dd 5d b8	 fstp	 QWORD PTR _wrk6$[ebp+8]

; 2842 :       *intersection = A + wrk6;

  04531	8d 45 b0	 lea	 eax, DWORD PTR _wrk6$[ebp]
  04534	50		 push	 eax
  04535	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR $T62560[ebp]
  0453b	51		 push	 ecx
  0453c	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  0453f	e8 00 00 00 00	 call	 ??HFPoint@@QBE?AV0@ABV0@@Z ; FPoint::operator+
  04544	50		 push	 eax
  04545	8b 4d 18	 mov	 ecx, DWORD PTR _intersection$[ebp]
  04548	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=
$L61960:

; 2844 :    if (dot3==0)

  0454d	dd 85 68 ff ff
	ff		 fld	 QWORD PTR _dot3$[ebp]
  04553	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@00000000000000000000
  04559	df e0		 fnstsw	 ax
  0455b	f6 c4 40	 test	 ah, 64			; 00000040H
  0455e	74 0c		 je	 SHORT $L61962

; 2845 :       *intersection = C;

  04560	8b 55 10	 mov	 edx, DWORD PTR _C$[ebp]
  04563	52		 push	 edx
  04564	8b 4d 18	 mov	 ecx, DWORD PTR _intersection$[ebp]
  04567	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=
$L61962:

; 2846 :    return(INTERSECT+INTERSECTI);

  0456c	b8 21 00 00 00	 mov	 eax, 33			; 00000021H
$L61890:

; 2847 : }

  04571	8b e5		 mov	 esp, ebp
  04573	5d		 pop	 ebp
  04574	c3		 ret	 0
?IntersectSegmentsF@@YAHAAVFPoint@@000PAV1@H@Z ENDP	; IntersectSegmentsF
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0FPoint@@QAE@XZ PROC NEAR				; FPoint::FPoint, COMDAT

; 87   : 	FPoint() : x(DefaultCoord), y(DefaultCoord) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	c7 40 04 00 61
	be 40		 mov	 DWORD PTR [eax+4], 1086218496 ; 40be6100H
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00021	c7 41 0c 00 61
	be 40		 mov	 DWORD PTR [ecx+12], 1086218496 ; 40be6100H
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??0FPoint@@QAE@XZ ENDP					; FPoint::FPoint
_TEXT	ENDS
PUBLIC	??0FPoint@@QAE@NN@Z				; FPoint::FPoint
PUBLIC	??0FPoint@@QAE@ABV0@@Z				; FPoint::FPoint
;	COMDAT ??HFPoint@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
$T62565 = -16
_p$ = 12
___$ReturnUdt$ = 8
_this$ = -20
??HFPoint@@QBE?AV0@ABV0@@Z PROC NEAR			; FPoint::operator+, COMDAT

; 330  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 331  :    return FPoint(x+p.x,y+p.y);

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _p$[ebp]
  0000f	dd 40 08	 fld	 QWORD PTR [eax+8]
  00012	dc 41 08	 fadd	 QWORD PTR [ecx+8]
  00015	83 ec 08	 sub	 esp, 8
  00018	dd 1c 24	 fstp	 QWORD PTR [esp]
  0001b	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  00021	dd 02		 fld	 QWORD PTR [edx]
  00023	dc 00		 fadd	 QWORD PTR [eax]
  00025	83 ec 08	 sub	 esp, 8
  00028	dd 1c 24	 fstp	 QWORD PTR [esp]
  0002b	8d 4d f0	 lea	 ecx, DWORD PTR $T62565[ebp]
  0002e	e8 00 00 00 00	 call	 ??0FPoint@@QAE@NN@Z	; FPoint::FPoint
  00033	50		 push	 eax
  00034	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00037	e8 00 00 00 00	 call	 ??0FPoint@@QAE@ABV0@@Z	; FPoint::FPoint
  0003c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 332  : }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
??HFPoint@@QBE?AV0@ABV0@@Z ENDP				; FPoint::operator+
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@NN@Z
_TEXT	SEGMENT
_x$ = 8
_y$ = 16
_this$ = -4
??0FPoint@@QAE@NN@Z PROC NEAR				; FPoint::FPoint, COMDAT

; 88   : 	FPoint(double x, double y) : x(x), y(y) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp+4]
  00012	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  0001b	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0001e	8b 55 14	 mov	 edx, DWORD PTR _y$[ebp+4]
  00021	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 10 00	 ret	 16			; 00000010H
??0FPoint@@QAE@NN@Z ENDP				; FPoint::FPoint
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@ABV0@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
??0FPoint@@QAE@ABV0@@Z PROC NEAR			; FPoint::FPoint, COMDAT

; 89   : 	FPoint(const FPoint& p) : x(p.x), y(p.y) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00020	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00023	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  00026	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
??0FPoint@@QAE@ABV0@@Z ENDP				; FPoint::FPoint
_TEXT	ENDS
;	COMDAT ??GFPoint@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
$T62569 = -16
_p$ = 12
___$ReturnUdt$ = 8
_this$ = -20
??GFPoint@@QBE?AV0@ABV0@@Z PROC NEAR			; FPoint::operator-, COMDAT

; 336  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 337  :    return FPoint(x-p.x,y-p.y);

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _p$[ebp]
  0000f	dd 40 08	 fld	 QWORD PTR [eax+8]
  00012	dc 61 08	 fsub	 QWORD PTR [ecx+8]
  00015	83 ec 08	 sub	 esp, 8
  00018	dd 1c 24	 fstp	 QWORD PTR [esp]
  0001b	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  00021	dd 02		 fld	 QWORD PTR [edx]
  00023	dc 20		 fsub	 QWORD PTR [eax]
  00025	83 ec 08	 sub	 esp, 8
  00028	dd 1c 24	 fstp	 QWORD PTR [esp]
  0002b	8d 4d f0	 lea	 ecx, DWORD PTR $T62569[ebp]
  0002e	e8 00 00 00 00	 call	 ??0FPoint@@QAE@NN@Z	; FPoint::FPoint
  00033	50		 push	 eax
  00034	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00037	e8 00 00 00 00	 call	 ??0FPoint@@QAE@ABV0@@Z	; FPoint::FPoint
  0003c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 338  : }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
??GFPoint@@QBE?AV0@ABV0@@Z ENDP				; FPoint::operator-
_TEXT	ENDS
;	COMDAT ??DFPoint@@QBENABV0@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
??DFPoint@@QBENABV0@@Z PROC NEAR			; FPoint::operator*, COMDAT

; 356  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 357  :    return x*p.x+y*p.y;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0000d	dd 00		 fld	 QWORD PTR [eax]
  0000f	dc 09		 fmul	 QWORD PTR [ecx]
  00011	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00014	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00017	dd 42 08	 fld	 QWORD PTR [edx+8]
  0001a	dc 48 08	 fmul	 QWORD PTR [eax+8]
  0001d	de c1		 faddp	 ST(1), ST(0)

; 358  : }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??DFPoint@@QBENABV0@@Z ENDP				; FPoint::operator*
_TEXT	ENDS
;	COMDAT ??TFPoint@@QBEHABV0@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -12
_direction$ = -8
??TFPoint@@QBEHABV0@@Z PROC NEAR			; FPoint::operator^, COMDAT

; 364  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 365  :    double direction = x*p.y - y*p.x;

  00009	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0000c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	dd 01		 fld	 QWORD PTR [ecx]
  00011	dc 48 08	 fmul	 QWORD PTR [eax+8]
  00014	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00017	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0001a	dd 42 08	 fld	 QWORD PTR [edx+8]
  0001d	dc 08		 fmul	 QWORD PTR [eax]
  0001f	de e9		 fsubp	 ST(1), ST(0)
  00021	dd 5d f8	 fstp	 QWORD PTR _direction$[ebp]

; 366  :    if (direction < 0.0)

  00024	dd 45 f8	 fld	 QWORD PTR _direction$[ebp]
  00027	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@00000000000000000000
  0002d	df e0		 fnstsw	 ax
  0002f	f6 c4 01	 test	 ah, 1
  00032	74 05		 je	 SHORT $L58693

; 367  :       return(-1);

  00034	83 c8 ff	 or	 eax, -1
  00037	eb 19		 jmp	 SHORT $L58691
$L58693:

; 368  :    if (direction > 0.0)

  00039	dd 45 f8	 fld	 QWORD PTR _direction$[ebp]
  0003c	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@00000000000000000000
  00042	df e0		 fnstsw	 ax
  00044	f6 c4 41	 test	 ah, 65			; 00000041H
  00047	75 07		 jne	 SHORT $L58694

; 369  :       return(1);

  00049	b8 01 00 00 00	 mov	 eax, 1
  0004e	eb 02		 jmp	 SHORT $L58691
$L58694:

; 370  :    return(0);

  00050	33 c0		 xor	 eax, eax
$L58691:

; 371  : }

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
??TFPoint@@QBEHABV0@@Z ENDP				; FPoint::operator^
_TEXT	ENDS
PUBLIC	?RemoveColinearLinesF@@YAXPAVFPoint@@PAH@Z	; RemoveColinearLinesF
_TEXT	SEGMENT
$T62573 = -108
$T62574 = -124
_P$ = 8
_n$ = 12
_i$ = -72
_j$ = -76
_nodes$ = -20
_P1$ = -36
_P2$ = -52
_P3$ = -68
_wrk1$ = -92
_wrk2$ = -16
?RemoveColinearLinesF@@YAXPAVFPoint@@PAH@Z PROC NEAR	; RemoveColinearLinesF

; 2851 : {

  04575	55		 push	 ebp
  04576	8b ec		 mov	 ebp, esp
  04578	83 ec 7c	 sub	 esp, 124		; 0000007cH

; 2852 :    int  i,j;
; 2853 :    int  nodes;
; 2854 :    FPoint P1,P2,P3,wrk1,wrk2;

  0457b	8d 4d dc	 lea	 ecx, DWORD PTR _P1$[ebp]
  0457e	e8 00 00 00 00	 call	 ??0FPoint@@QAE@XZ	; FPoint::FPoint
  04583	8d 4d cc	 lea	 ecx, DWORD PTR _P2$[ebp]
  04586	e8 00 00 00 00	 call	 ??0FPoint@@QAE@XZ	; FPoint::FPoint
  0458b	8d 4d bc	 lea	 ecx, DWORD PTR _P3$[ebp]
  0458e	e8 00 00 00 00	 call	 ??0FPoint@@QAE@XZ	; FPoint::FPoint
  04593	8d 4d a4	 lea	 ecx, DWORD PTR _wrk1$[ebp]
  04596	e8 00 00 00 00	 call	 ??0FPoint@@QAE@XZ	; FPoint::FPoint
  0459b	8d 4d f0	 lea	 ecx, DWORD PTR _wrk2$[ebp]
  0459e	e8 00 00 00 00	 call	 ??0FPoint@@QAE@XZ	; FPoint::FPoint

; 2855 : 
; 2856 :    nodes = *n;

  045a3	8b 45 0c	 mov	 eax, DWORD PTR _n$[ebp]
  045a6	8b 08		 mov	 ecx, DWORD PTR [eax]
  045a8	89 4d ec	 mov	 DWORD PTR _nodes$[ebp], ecx

; 2857 :    P1 = P[0];                                            

  045ab	8b 55 08	 mov	 edx, DWORD PTR _P$[ebp]
  045ae	52		 push	 edx
  045af	8d 4d dc	 lea	 ecx, DWORD PTR _P1$[ebp]
  045b2	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 2858 :    P2 = P[1];

  045b7	8b 45 08	 mov	 eax, DWORD PTR _P$[ebp]
  045ba	83 c0 10	 add	 eax, 16			; 00000010H
  045bd	50		 push	 eax
  045be	8d 4d cc	 lea	 ecx, DWORD PTR _P2$[ebp]
  045c1	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 2859 :    P3 = P[2];

  045c6	8b 4d 08	 mov	 ecx, DWORD PTR _P$[ebp]
  045c9	83 c1 20	 add	 ecx, 32			; 00000020H
  045cc	51		 push	 ecx
  045cd	8d 4d bc	 lea	 ecx, DWORD PTR _P3$[ebp]
  045d0	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 2860 :    for (i=3;i<(nodes+3);++i)

  045d5	c7 45 b8 03 00
	00 00		 mov	 DWORD PTR _i$[ebp], 3
  045dc	eb 09		 jmp	 SHORT $L61975
$L61976:
  045de	8b 55 b8	 mov	 edx, DWORD PTR _i$[ebp]
  045e1	83 c2 01	 add	 edx, 1
  045e4	89 55 b8	 mov	 DWORD PTR _i$[ebp], edx
$L61975:
  045e7	8b 45 ec	 mov	 eax, DWORD PTR _nodes$[ebp]
  045ea	83 c0 03	 add	 eax, 3
  045ed	39 45 b8	 cmp	 DWORD PTR _i$[ebp], eax
  045f0	0f 8d fb 00 00
	00		 jge	 $L61977

; 2862 : 		if ( !nodes )

  045f6	83 7d ec 00	 cmp	 DWORD PTR _nodes$[ebp], 0
  045fa	75 05		 jne	 SHORT $L61978

; 2863 : 			return;

  045fc	e9 f0 00 00 00	 jmp	 $L61966
$L61978:

; 2864 : 
; 2865 :       wrk1 = P2 - P1;

  04601	8d 4d dc	 lea	 ecx, DWORD PTR _P1$[ebp]
  04604	51		 push	 ecx
  04605	8d 55 94	 lea	 edx, DWORD PTR $T62573[ebp]
  04608	52		 push	 edx
  04609	8d 4d cc	 lea	 ecx, DWORD PTR _P2$[ebp]
  0460c	e8 00 00 00 00	 call	 ??GFPoint@@QBE?AV0@ABV0@@Z ; FPoint::operator-
  04611	50		 push	 eax
  04612	8d 4d a4	 lea	 ecx, DWORD PTR _wrk1$[ebp]
  04615	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 2866 :       wrk2 = P3 - P2;

  0461a	8d 45 cc	 lea	 eax, DWORD PTR _P2$[ebp]
  0461d	50		 push	 eax
  0461e	8d 4d 84	 lea	 ecx, DWORD PTR $T62574[ebp]
  04621	51		 push	 ecx
  04622	8d 4d bc	 lea	 ecx, DWORD PTR _P3$[ebp]
  04625	e8 00 00 00 00	 call	 ??GFPoint@@QBE?AV0@ABV0@@Z ; FPoint::operator-
  0462a	50		 push	 eax
  0462b	8d 4d f0	 lea	 ecx, DWORD PTR _wrk2$[ebp]
  0462e	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 2867 :       if ((wrk1^wrk2) == 0)

  04633	8d 55 f0	 lea	 edx, DWORD PTR _wrk2$[ebp]
  04636	52		 push	 edx
  04637	8d 4d a4	 lea	 ecx, DWORD PTR _wrk1$[ebp]
  0463a	e8 00 00 00 00	 call	 ??TFPoint@@QBEHABV0@@Z	; FPoint::operator^
  0463f	85 c0		 test	 eax, eax
  04641	75 71		 jne	 SHORT $L61981

; 2869 :          // eliminate the extra node
; 2870 :          --*n;

  04643	8b 45 0c	 mov	 eax, DWORD PTR _n$[ebp]
  04646	8b 08		 mov	 ecx, DWORD PTR [eax]
  04648	83 e9 01	 sub	 ecx, 1
  0464b	8b 55 0c	 mov	 edx, DWORD PTR _n$[ebp]
  0464e	89 0a		 mov	 DWORD PTR [edx], ecx

; 2871 :          for (j=(i-2)%nodes;j<nodes-1;++j)

  04650	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  04653	83 e8 02	 sub	 eax, 2
  04656	99		 cdq
  04657	f7 7d ec	 idiv	 DWORD PTR _nodes$[ebp]
  0465a	89 55 b4	 mov	 DWORD PTR _j$[ebp], edx
  0465d	eb 09		 jmp	 SHORT $L61982
$L61983:
  0465f	8b 45 b4	 mov	 eax, DWORD PTR _j$[ebp]
  04662	83 c0 01	 add	 eax, 1
  04665	89 45 b4	 mov	 DWORD PTR _j$[ebp], eax
$L61982:
  04668	8b 4d ec	 mov	 ecx, DWORD PTR _nodes$[ebp]
  0466b	83 e9 01	 sub	 ecx, 1
  0466e	39 4d b4	 cmp	 DWORD PTR _j$[ebp], ecx
  04671	7d 21		 jge	 SHORT $L61984

; 2872 :             P[j] = P[j+1];

  04673	8b 55 b4	 mov	 edx, DWORD PTR _j$[ebp]
  04676	83 c2 01	 add	 edx, 1
  04679	c1 e2 04	 shl	 edx, 4
  0467c	8b 45 08	 mov	 eax, DWORD PTR _P$[ebp]
  0467f	03 c2		 add	 eax, edx
  04681	50		 push	 eax
  04682	8b 4d b4	 mov	 ecx, DWORD PTR _j$[ebp]
  04685	c1 e1 04	 shl	 ecx, 4
  04688	8b 55 08	 mov	 edx, DWORD PTR _P$[ebp]
  0468b	03 ca		 add	 ecx, edx
  0468d	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=
  04692	eb cb		 jmp	 SHORT $L61983
$L61984:

; 2873 :          --nodes;

  04694	8b 45 ec	 mov	 eax, DWORD PTR _nodes$[ebp]
  04697	83 e8 01	 sub	 eax, 1
  0469a	89 45 ec	 mov	 DWORD PTR _nodes$[ebp], eax

; 2874 :          // retry this node
; 2875 :          --i;

  0469d	8b 4d b8	 mov	 ecx, DWORD PTR _i$[ebp]
  046a0	83 e9 01	 sub	 ecx, 1
  046a3	89 4d b8	 mov	 DWORD PTR _i$[ebp], ecx

; 2876 :          P2 = P3;

  046a6	8d 55 bc	 lea	 edx, DWORD PTR _P3$[ebp]
  046a9	52		 push	 edx
  046aa	8d 4d cc	 lea	 ecx, DWORD PTR _P2$[ebp]
  046ad	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 2878 :       else

  046b2	eb 18		 jmp	 SHORT $L61985
$L61981:

; 2880 :          P1 = P2;

  046b4	8d 45 cc	 lea	 eax, DWORD PTR _P2$[ebp]
  046b7	50		 push	 eax
  046b8	8d 4d dc	 lea	 ecx, DWORD PTR _P1$[ebp]
  046bb	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 2881 :          P2 = P3;

  046c0	8d 4d bc	 lea	 ecx, DWORD PTR _P3$[ebp]
  046c3	51		 push	 ecx
  046c4	8d 4d cc	 lea	 ecx, DWORD PTR _P2$[ebp]
  046c7	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=
$L61985:

; 2883 : 
; 2884 : 		if ( !nodes )

  046cc	83 7d ec 00	 cmp	 DWORD PTR _nodes$[ebp], 0
  046d0	75 02		 jne	 SHORT $L61986

; 2885 : 			return;

  046d2	eb 1d		 jmp	 SHORT $L61966
$L61986:

; 2886 : 
; 2887 :       P3 = P[i % nodes];

  046d4	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  046d7	99		 cdq
  046d8	f7 7d ec	 idiv	 DWORD PTR _nodes$[ebp]
  046db	c1 e2 04	 shl	 edx, 4
  046de	8b 45 08	 mov	 eax, DWORD PTR _P$[ebp]
  046e1	03 c2		 add	 eax, edx
  046e3	50		 push	 eax
  046e4	8d 4d bc	 lea	 ecx, DWORD PTR _P3$[ebp]
  046e7	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 2888 :    }

  046ec	e9 ed fe ff ff	 jmp	 $L61976
$L61977:
$L61966:

; 2889 : }

  046f1	8b e5		 mov	 esp, ebp
  046f3	5d		 pop	 ebp
  046f4	c3		 ret	 0
?RemoveColinearLinesF@@YAXPAVFPoint@@PAH@Z ENDP		; RemoveColinearLinesF
_TEXT	ENDS
PUBLIC	?PointInteriorF@@YAHAAVFPoint@@PAV1@H@Z		; PointInteriorF
PUBLIC	?PolyIsInPolyF@@YAHPAVFPoint@@H0H@Z		; PolyIsInPolyF
_TEXT	SEGMENT
_P$ = 8
_Ppoints$ = 12
_Q$ = 16
_Qpoints$ = 20
_intersectResult$ = -4
_P_U$ = -24
_i$ = -8
_j$62004 = -28
_j$62017 = -32
?PolyIsInPolyF@@YAHPAVFPoint@@H0H@Z PROC NEAR		; PolyIsInPolyF

; 2893 : {

  046f5	55		 push	 ebp
  046f6	8b ec		 mov	 ebp, esp
  046f8	83 ec 20	 sub	 esp, 32			; 00000020H

; 2894 :    int intersectResult;
; 2895 :    FPoint P_U;

  046fb	8d 4d e8	 lea	 ecx, DWORD PTR _P_U$[ebp]
  046fe	e8 00 00 00 00	 call	 ??0FPoint@@QAE@XZ	; FPoint::FPoint

; 2896 :    int i;
; 2897 :    // Check PContainsQ first and this will eliminate duplicate polygons.		
; 2898 :    for (i=0;i<Qpoints;++i)

  04703	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0470a	eb 09		 jmp	 SHORT $L61996
$L61997:
  0470c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0470f	83 c0 01	 add	 eax, 1
  04712	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L61996:
  04715	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  04718	3b 4d 14	 cmp	 ecx, DWORD PTR _Qpoints$[ebp]
  0471b	7d 24		 jge	 SHORT $L61998

; 2900 :       if (!PointInteriorF(Q[i],P,Ppoints))

  0471d	8b 55 0c	 mov	 edx, DWORD PTR _Ppoints$[ebp]
  04720	52		 push	 edx
  04721	8b 45 08	 mov	 eax, DWORD PTR _P$[ebp]
  04724	50		 push	 eax
  04725	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  04728	c1 e1 04	 shl	 ecx, 4
  0472b	8b 55 10	 mov	 edx, DWORD PTR _Q$[ebp]
  0472e	03 d1		 add	 edx, ecx
  04730	52		 push	 edx
  04731	e8 00 00 00 00	 call	 ?PointInteriorF@@YAHAAVFPoint@@PAV1@H@Z ; PointInteriorF
  04736	83 c4 0c	 add	 esp, 12			; 0000000cH
  04739	85 c0		 test	 eax, eax
  0473b	75 02		 jne	 SHORT $L61999

; 2901 :          break;

  0473d	eb 02		 jmp	 SHORT $L61998
$L61999:

; 2902 :    }

  0473f	eb cb		 jmp	 SHORT $L61997
$L61998:

; 2903 :    if (i == Qpoints)

  04741	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  04744	3b 45 14	 cmp	 eax, DWORD PTR _Qpoints$[ebp]
  04747	0f 85 a1 00 00
	00		 jne	 $L62000

; 2905 :       // make sure there are no intersections
; 2906 :       for (i=0;i<Qpoints;++i)

  0474d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  04754	eb 09		 jmp	 SHORT $L62001
$L62002:
  04756	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  04759	83 c1 01	 add	 ecx, 1
  0475c	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
$L62001:
  0475f	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  04762	3b 55 14	 cmp	 edx, DWORD PTR _Qpoints$[ebp]
  04765	7d 7d		 jge	 SHORT $L62003

; 2908 :          for (int j=0;j<Ppoints;++j)

  04767	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _j$62004[ebp], 0
  0476e	eb 09		 jmp	 SHORT $L62005
$L62006:
  04770	8b 45 e4	 mov	 eax, DWORD PTR _j$62004[ebp]
  04773	83 c0 01	 add	 eax, 1
  04776	89 45 e4	 mov	 DWORD PTR _j$62004[ebp], eax
$L62005:
  04779	8b 4d e4	 mov	 ecx, DWORD PTR _j$62004[ebp]
  0477c	3b 4d 0c	 cmp	 ecx, DWORD PTR _Ppoints$[ebp]
  0477f	7d 5e		 jge	 SHORT $L62007

; 2910 :             intersectResult = IntersectSegmentsF(P[j],
; 2911 : 															 P[(j+1) % Ppoints],
; 2912 : 															 Q[i],
; 2913 : 															 Q[(i+1) % Qpoints],
; 2914 : 															 &P_U);

  04781	6a 00		 push	 0
  04783	8d 55 e8	 lea	 edx, DWORD PTR _P_U$[ebp]
  04786	52		 push	 edx
  04787	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0478a	83 c0 01	 add	 eax, 1
  0478d	99		 cdq
  0478e	f7 7d 14	 idiv	 DWORD PTR _Qpoints$[ebp]
  04791	c1 e2 04	 shl	 edx, 4
  04794	8b 45 10	 mov	 eax, DWORD PTR _Q$[ebp]
  04797	03 c2		 add	 eax, edx
  04799	50		 push	 eax
  0479a	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0479d	c1 e1 04	 shl	 ecx, 4
  047a0	8b 55 10	 mov	 edx, DWORD PTR _Q$[ebp]
  047a3	03 d1		 add	 edx, ecx
  047a5	52		 push	 edx
  047a6	8b 45 e4	 mov	 eax, DWORD PTR _j$62004[ebp]
  047a9	83 c0 01	 add	 eax, 1
  047ac	99		 cdq
  047ad	f7 7d 0c	 idiv	 DWORD PTR _Ppoints$[ebp]
  047b0	c1 e2 04	 shl	 edx, 4
  047b3	8b 45 08	 mov	 eax, DWORD PTR _P$[ebp]
  047b6	03 c2		 add	 eax, edx
  047b8	50		 push	 eax
  047b9	8b 4d e4	 mov	 ecx, DWORD PTR _j$62004[ebp]
  047bc	c1 e1 04	 shl	 ecx, 4
  047bf	8b 55 08	 mov	 edx, DWORD PTR _P$[ebp]
  047c2	03 d1		 add	 edx, ecx
  047c4	52		 push	 edx
  047c5	e8 00 00 00 00	 call	 ?IntersectSegmentsF@@YAHAAVFPoint@@000PAV1@H@Z ; IntersectSegmentsF
  047ca	83 c4 18	 add	 esp, 24			; 00000018H
  047cd	89 45 fc	 mov	 DWORD PTR _intersectResult$[ebp], eax

; 2915 :             if (intersectResult == INTERSECT + INTERSECTI)

  047d0	83 7d fc 21	 cmp	 DWORD PTR _intersectResult$[ebp], 33 ; 00000021H
  047d4	75 07		 jne	 SHORT $L62008

; 2916 :                return NotContained;

  047d6	33 c0		 xor	 eax, eax
  047d8	e9 f8 00 00 00	 jmp	 $L61992
$L62008:

; 2917 :          }

  047dd	eb 91		 jmp	 SHORT $L62006
$L62007:

; 2918 :       }

  047df	e9 72 ff ff ff	 jmp	 $L62002
$L62003:

; 2919 :       return PContainsQ;

  047e4	b8 01 00 00 00	 mov	 eax, 1
  047e9	e9 e7 00 00 00	 jmp	 $L61992
$L62000:

; 2921 : 
; 2922 :    for (i=0;i<Ppoints;++i)

  047ee	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  047f5	eb 09		 jmp	 SHORT $L62009
$L62010:
  047f7	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  047fa	83 c0 01	 add	 eax, 1
  047fd	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L62009:
  04800	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  04803	3b 4d 0c	 cmp	 ecx, DWORD PTR _Ppoints$[ebp]
  04806	7d 24		 jge	 SHORT $L62011

; 2924 :       if (!PointInteriorF(P[i],Q,Qpoints))

  04808	8b 55 14	 mov	 edx, DWORD PTR _Qpoints$[ebp]
  0480b	52		 push	 edx
  0480c	8b 45 10	 mov	 eax, DWORD PTR _Q$[ebp]
  0480f	50		 push	 eax
  04810	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  04813	c1 e1 04	 shl	 ecx, 4
  04816	8b 55 08	 mov	 edx, DWORD PTR _P$[ebp]
  04819	03 d1		 add	 edx, ecx
  0481b	52		 push	 edx
  0481c	e8 00 00 00 00	 call	 ?PointInteriorF@@YAHAAVFPoint@@PAV1@H@Z ; PointInteriorF
  04821	83 c4 0c	 add	 esp, 12			; 0000000cH
  04824	85 c0		 test	 eax, eax
  04826	75 02		 jne	 SHORT $L62012

; 2925 :          break;

  04828	eb 02		 jmp	 SHORT $L62011
$L62012:

; 2926 :    }

  0482a	eb cb		 jmp	 SHORT $L62010
$L62011:

; 2927 :    if (i == Ppoints)

  0482c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0482f	3b 45 0c	 cmp	 eax, DWORD PTR _Ppoints$[ebp]
  04832	0f 85 9b 00 00
	00		 jne	 $L62013

; 2929 :       // make sure there are no intersections
; 2930 :       for (i=0;i<Qpoints;++i)

  04838	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0483f	eb 09		 jmp	 SHORT $L62014
$L62015:
  04841	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  04844	83 c1 01	 add	 ecx, 1
  04847	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
$L62014:
  0484a	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0484d	3b 55 14	 cmp	 edx, DWORD PTR _Qpoints$[ebp]
  04850	7d 7a		 jge	 SHORT $L62016

; 2932 :          for (int j=0;j<Ppoints;++j)

  04852	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _j$62017[ebp], 0
  04859	eb 09		 jmp	 SHORT $L62018
$L62019:
  0485b	8b 45 e0	 mov	 eax, DWORD PTR _j$62017[ebp]
  0485e	83 c0 01	 add	 eax, 1
  04861	89 45 e0	 mov	 DWORD PTR _j$62017[ebp], eax
$L62018:
  04864	8b 4d e0	 mov	 ecx, DWORD PTR _j$62017[ebp]
  04867	3b 4d 0c	 cmp	 ecx, DWORD PTR _Ppoints$[ebp]
  0486a	7d 5b		 jge	 SHORT $L62020

; 2934 :             intersectResult = IntersectSegmentsF(P[j],
; 2935 : 															 P[(j+1) % Ppoints],
; 2936 : 															 Q[i],
; 2937 : 															 Q[(i+1) % Qpoints],
; 2938 : 															 &P_U);

  0486c	6a 00		 push	 0
  0486e	8d 55 e8	 lea	 edx, DWORD PTR _P_U$[ebp]
  04871	52		 push	 edx
  04872	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  04875	83 c0 01	 add	 eax, 1
  04878	99		 cdq
  04879	f7 7d 14	 idiv	 DWORD PTR _Qpoints$[ebp]
  0487c	c1 e2 04	 shl	 edx, 4
  0487f	8b 45 10	 mov	 eax, DWORD PTR _Q$[ebp]
  04882	03 c2		 add	 eax, edx
  04884	50		 push	 eax
  04885	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  04888	c1 e1 04	 shl	 ecx, 4
  0488b	8b 55 10	 mov	 edx, DWORD PTR _Q$[ebp]
  0488e	03 d1		 add	 edx, ecx
  04890	52		 push	 edx
  04891	8b 45 e0	 mov	 eax, DWORD PTR _j$62017[ebp]
  04894	83 c0 01	 add	 eax, 1
  04897	99		 cdq
  04898	f7 7d 0c	 idiv	 DWORD PTR _Ppoints$[ebp]
  0489b	c1 e2 04	 shl	 edx, 4
  0489e	8b 45 08	 mov	 eax, DWORD PTR _P$[ebp]
  048a1	03 c2		 add	 eax, edx
  048a3	50		 push	 eax
  048a4	8b 4d e0	 mov	 ecx, DWORD PTR _j$62017[ebp]
  048a7	c1 e1 04	 shl	 ecx, 4
  048aa	8b 55 08	 mov	 edx, DWORD PTR _P$[ebp]
  048ad	03 d1		 add	 edx, ecx
  048af	52		 push	 edx
  048b0	e8 00 00 00 00	 call	 ?IntersectSegmentsF@@YAHAAVFPoint@@000PAV1@H@Z ; IntersectSegmentsF
  048b5	83 c4 18	 add	 esp, 24			; 00000018H
  048b8	89 45 fc	 mov	 DWORD PTR _intersectResult$[ebp], eax

; 2939 :             if (intersectResult == INTERSECT + INTERSECTI)

  048bb	83 7d fc 21	 cmp	 DWORD PTR _intersectResult$[ebp], 33 ; 00000021H
  048bf	75 04		 jne	 SHORT $L62021

; 2940 :                return NotContained;

  048c1	33 c0		 xor	 eax, eax
  048c3	eb 10		 jmp	 SHORT $L61992
$L62021:

; 2941 :          }

  048c5	eb 94		 jmp	 SHORT $L62019
$L62020:

; 2942 :       }

  048c7	e9 75 ff ff ff	 jmp	 $L62015
$L62016:

; 2943 :       return QContainsP;

  048cc	b8 02 00 00 00	 mov	 eax, 2
  048d1	eb 02		 jmp	 SHORT $L61992
$L62013:

; 2945 : 
; 2946 :    return NotContained;

  048d3	33 c0		 xor	 eax, eax
$L61992:

; 2947 : }

  048d5	8b e5		 mov	 esp, ebp
  048d7	5d		 pop	 ebp
  048d8	c3		 ret	 0
?PolyIsInPolyF@@YAHPAVFPoint@@H0H@Z ENDP		; PolyIsInPolyF
_TEXT	ENDS
PUBLIC	??8FPoint@@QBEHABV0@@Z				; FPoint::operator==
PUBLIC	??GFPoint@@QBE?AV0@XZ				; FPoint::operator-
_TEXT	SEGMENT
$T62577 = -136
$T62578 = -152
$T62579 = -168
$T62580 = -184
$T62581 = -200
_M$ = 8
_polygon$ = 12
_n$ = 16
_N3$ = -120
_P1$ = -20
_P2$ = -36
_P3$ = -52
_P4$ = -68
_tmp1$ = -84
_tmp2$ = -100
_nextnode$ = -104
_interior$ = -4
?PointInteriorF@@YAHAAVFPoint@@PAV1@H@Z PROC NEAR	; PointInteriorF

; 2951 : {

  048d9	55		 push	 ebp
  048da	8b ec		 mov	 ebp, esp
  048dc	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  048e2	56		 push	 esi

; 2952 :    FPoint   N3,P1,P2,P3,P4;

  048e3	8d 4d 88	 lea	 ecx, DWORD PTR _N3$[ebp]
  048e6	e8 00 00 00 00	 call	 ??0FPoint@@QAE@XZ	; FPoint::FPoint
  048eb	8d 4d ec	 lea	 ecx, DWORD PTR _P1$[ebp]
  048ee	e8 00 00 00 00	 call	 ??0FPoint@@QAE@XZ	; FPoint::FPoint
  048f3	8d 4d dc	 lea	 ecx, DWORD PTR _P2$[ebp]
  048f6	e8 00 00 00 00	 call	 ??0FPoint@@QAE@XZ	; FPoint::FPoint
  048fb	8d 4d cc	 lea	 ecx, DWORD PTR _P3$[ebp]
  048fe	e8 00 00 00 00	 call	 ??0FPoint@@QAE@XZ	; FPoint::FPoint
  04903	8d 4d bc	 lea	 ecx, DWORD PTR _P4$[ebp]
  04906	e8 00 00 00 00	 call	 ??0FPoint@@QAE@XZ	; FPoint::FPoint

; 2953 :    FPoint   tmp1,tmp2;

  0490b	8d 4d ac	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  0490e	e8 00 00 00 00	 call	 ??0FPoint@@QAE@XZ	; FPoint::FPoint
  04913	8d 4d 9c	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  04916	e8 00 00 00 00	 call	 ??0FPoint@@QAE@XZ	; FPoint::FPoint

; 2954 :    int      nextnode,interior = 0;

  0491b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _interior$[ebp], 0

; 2955 : 
; 2956 :    P1 = polygon[0];

  04922	8b 45 0c	 mov	 eax, DWORD PTR _polygon$[ebp]
  04925	50		 push	 eax
  04926	8d 4d ec	 lea	 ecx, DWORD PTR _P1$[ebp]
  04929	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 2957 :    P2 = polygon[1];

  0492e	8b 4d 0c	 mov	 ecx, DWORD PTR _polygon$[ebp]
  04931	83 c1 10	 add	 ecx, 16			; 00000010H
  04934	51		 push	 ecx
  04935	8d 4d dc	 lea	 ecx, DWORD PTR _P2$[ebp]
  04938	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 2958 :    nextnode = 3;

  0493d	c7 45 98 03 00
	00 00		 mov	 DWORD PTR _nextnode$[ebp], 3

; 2959 :    P3 = N3 = polygon[2];

  04944	8b 55 0c	 mov	 edx, DWORD PTR _polygon$[ebp]
  04947	83 c2 20	 add	 edx, 32			; 00000020H
  0494a	52		 push	 edx
  0494b	8d 4d 88	 lea	 ecx, DWORD PTR _N3$[ebp]
  0494e	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=
  04953	50		 push	 eax
  04954	8d 4d cc	 lea	 ecx, DWORD PTR _P3$[ebp]
  04957	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 2960 :    if (n>3)

  0495c	83 7d 10 03	 cmp	 DWORD PTR _n$[ebp], 3
  04960	7e 11		 jle	 SHORT $L62036

; 2961 :       P4 = polygon[3];

  04962	8b 45 0c	 mov	 eax, DWORD PTR _polygon$[ebp]
  04965	83 c0 30	 add	 eax, 48			; 00000030H
  04968	50		 push	 eax
  04969	8d 4d bc	 lea	 ecx, DWORD PTR _P4$[ebp]
  0496c	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 2962 :    else

  04971	eb 0c		 jmp	 SHORT $L62037
$L62036:

; 2963 :       P4 = polygon[0];

  04973	8b 4d 0c	 mov	 ecx, DWORD PTR _polygon$[ebp]
  04976	51		 push	 ecx
  04977	8d 4d bc	 lea	 ecx, DWORD PTR _P4$[ebp]
  0497a	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=
$L62037:

; 2964 :    while (True)

  0497f	ba 01 00 00 00	 mov	 edx, 1
  04984	85 d2		 test	 edx, edx
  04986	0f 84 6f 02 00
	00		 je	 $L62040

; 2969 :             (
; 2970 :                (
; 2971 :                (P1.y<=M.y)        &&
; 2972 :                (M.y<=P2.y) 
; 2973 :                )
; 2974 :             ||
; 2975 :                (
; 2976 :                (P2.y<=M.y)        &&
; 2977 :                (M.y<=P1.y)
; 2978 :                )
; 2979 :             )
; 2980 :          &&
; 2981 :             (
; 2982 :                (
; 2983 :                (P1.x<=M.x)        &&
; 2984 :                (M.x<=P2.x) 
; 2985 :                )
; 2986 :             ||
; 2987 :                (
; 2988 :                (P2.x<=M.x)        &&
; 2989 :                (M.x<=P1.x)
; 2990 :                )
; 2991 :             )
; 2992 :          )

  0498c	8b 45 08	 mov	 eax, DWORD PTR _M$[ebp]
  0498f	dd 45 f4	 fld	 QWORD PTR _P1$[ebp+8]
  04992	dc 58 08	 fcomp	 QWORD PTR [eax+8]
  04995	df e0		 fnstsw	 ax
  04997	f6 c4 41	 test	 ah, 65			; 00000041H
  0499a	74 10		 je	 SHORT $L62043
  0499c	8b 4d 08	 mov	 ecx, DWORD PTR _M$[ebp]
  0499f	dd 41 08	 fld	 QWORD PTR [ecx+8]
  049a2	dc 5d e4	 fcomp	 QWORD PTR _P2$[ebp+8]
  049a5	df e0		 fnstsw	 ax
  049a7	f6 c4 41	 test	 ah, 65			; 00000041H
  049aa	75 28		 jne	 SHORT $L62042
$L62043:
  049ac	8b 55 08	 mov	 edx, DWORD PTR _M$[ebp]
  049af	dd 45 e4	 fld	 QWORD PTR _P2$[ebp+8]
  049b2	dc 5a 08	 fcomp	 QWORD PTR [edx+8]
  049b5	df e0		 fnstsw	 ax
  049b7	f6 c4 41	 test	 ah, 65			; 00000041H
  049ba	0f 84 a2 00 00
	00		 je	 $L62048
  049c0	8b 45 08	 mov	 eax, DWORD PTR _M$[ebp]
  049c3	dd 40 08	 fld	 QWORD PTR [eax+8]
  049c6	dc 5d f4	 fcomp	 QWORD PTR _P1$[ebp+8]
  049c9	df e0		 fnstsw	 ax
  049cb	f6 c4 41	 test	 ah, 65			; 00000041H
  049ce	0f 84 8e 00 00
	00		 je	 $L62048
$L62042:
  049d4	8b 4d 08	 mov	 ecx, DWORD PTR _M$[ebp]
  049d7	dd 45 ec	 fld	 QWORD PTR _P1$[ebp]
  049da	dc 19		 fcomp	 QWORD PTR [ecx]
  049dc	df e0		 fnstsw	 ax
  049de	f6 c4 41	 test	 ah, 65			; 00000041H
  049e1	74 0f		 je	 SHORT $L62045
  049e3	8b 55 08	 mov	 edx, DWORD PTR _M$[ebp]
  049e6	dd 02		 fld	 QWORD PTR [edx]
  049e8	dc 5d dc	 fcomp	 QWORD PTR _P2$[ebp]
  049eb	df e0		 fnstsw	 ax
  049ed	f6 c4 41	 test	 ah, 65			; 00000041H
  049f0	75 1e		 jne	 SHORT $L62044
$L62045:
  049f2	8b 45 08	 mov	 eax, DWORD PTR _M$[ebp]
  049f5	dd 45 dc	 fld	 QWORD PTR _P2$[ebp]
  049f8	dc 18		 fcomp	 QWORD PTR [eax]
  049fa	df e0		 fnstsw	 ax
  049fc	f6 c4 41	 test	 ah, 65			; 00000041H
  049ff	74 61		 je	 SHORT $L62048
  04a01	8b 4d 08	 mov	 ecx, DWORD PTR _M$[ebp]
  04a04	dd 01		 fld	 QWORD PTR [ecx]
  04a06	dc 5d ec	 fcomp	 QWORD PTR _P1$[ebp]
  04a09	df e0		 fnstsw	 ax
  04a0b	f6 c4 41	 test	 ah, 65			; 00000041H
  04a0e	74 52		 je	 SHORT $L62048
$L62044:

; 2995 :          tmp1 = M - P1;

  04a10	8d 55 ec	 lea	 edx, DWORD PTR _P1$[ebp]
  04a13	52		 push	 edx
  04a14	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR $T62577[ebp]
  04a1a	50		 push	 eax
  04a1b	8b 4d 08	 mov	 ecx, DWORD PTR _M$[ebp]
  04a1e	e8 00 00 00 00	 call	 ??GFPoint@@QBE?AV0@ABV0@@Z ; FPoint::operator-
  04a23	50		 push	 eax
  04a24	8d 4d ac	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  04a27	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 2996 :          tmp2 = M - P2;

  04a2c	8d 4d dc	 lea	 ecx, DWORD PTR _P2$[ebp]
  04a2f	51		 push	 ecx
  04a30	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR $T62578[ebp]
  04a36	52		 push	 edx
  04a37	8b 4d 08	 mov	 ecx, DWORD PTR _M$[ebp]
  04a3a	e8 00 00 00 00	 call	 ??GFPoint@@QBE?AV0@ABV0@@Z ; FPoint::operator-
  04a3f	50		 push	 eax
  04a40	8d 4d 9c	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  04a43	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 2997 :          if ((tmp1^tmp2) == 0) return(True);

  04a48	8d 45 9c	 lea	 eax, DWORD PTR _tmp2$[ebp]
  04a4b	50		 push	 eax
  04a4c	8d 4d ac	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  04a4f	e8 00 00 00 00	 call	 ??TFPoint@@QBEHABV0@@Z	; FPoint::operator^
  04a54	85 c0		 test	 eax, eax
  04a56	75 0a		 jne	 SHORT $L62048
  04a58	b8 01 00 00 00	 mov	 eax, 1
  04a5d	e9 ac 01 00 00	 jmp	 $L62069
$L62048:

; 3008 :             (
; 3009 :             (P1.y<M.y)        &&
; 3010 :             (M.y<P2.y) 
; 3011 :             )
; 3012 :          ||
; 3013 :             (
; 3014 :             (P2.y<M.y)        &&
; 3015 :             (M.y<P1.y)
; 3016 :             )
; 3017 :          )

  04a62	8b 4d 08	 mov	 ecx, DWORD PTR _M$[ebp]
  04a65	dd 45 f4	 fld	 QWORD PTR _P1$[ebp+8]
  04a68	dc 59 08	 fcomp	 QWORD PTR [ecx+8]
  04a6b	df e0		 fnstsw	 ax
  04a6d	f6 c4 01	 test	 ah, 1
  04a70	74 10		 je	 SHORT $L62051
  04a72	8b 55 08	 mov	 edx, DWORD PTR _M$[ebp]
  04a75	dd 42 08	 fld	 QWORD PTR [edx+8]
  04a78	dc 5d e4	 fcomp	 QWORD PTR _P2$[ebp+8]
  04a7b	df e0		 fnstsw	 ax
  04a7d	f6 c4 01	 test	 ah, 1
  04a80	75 24		 jne	 SHORT $L62050
$L62051:
  04a82	8b 45 08	 mov	 eax, DWORD PTR _M$[ebp]
  04a85	dd 45 e4	 fld	 QWORD PTR _P2$[ebp+8]
  04a88	dc 58 08	 fcomp	 QWORD PTR [eax+8]
  04a8b	df e0		 fnstsw	 ax
  04a8d	f6 c4 01	 test	 ah, 1
  04a90	0f 84 8b 00 00
	00		 je	 $L62049
  04a96	8b 4d 08	 mov	 ecx, DWORD PTR _M$[ebp]
  04a99	dd 41 08	 fld	 QWORD PTR [ecx+8]
  04a9c	dc 5d f4	 fcomp	 QWORD PTR _P1$[ebp+8]
  04a9f	df e0		 fnstsw	 ax
  04aa1	f6 c4 01	 test	 ah, 1
  04aa4	74 7b		 je	 SHORT $L62049
$L62050:

; 3020 :          // If P1-P2 or P2-P1 is chosen so that the y delta is 
; 3021 :          // positive and this vector is crossed with the vector
; 3022 :          // P1-M then the z component is positive if M lies on
; 3023 :          // the negative side of P1-P2 and negative if M lies
; 3024 :          // on the positive side of P1-P2.
; 3025 :          tmp1 = P2 - P1;

  04aa6	8d 55 ec	 lea	 edx, DWORD PTR _P1$[ebp]
  04aa9	52		 push	 edx
  04aaa	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR $T62579[ebp]
  04ab0	50		 push	 eax
  04ab1	8d 4d dc	 lea	 ecx, DWORD PTR _P2$[ebp]
  04ab4	e8 00 00 00 00	 call	 ??GFPoint@@QBE?AV0@ABV0@@Z ; FPoint::operator-
  04ab9	50		 push	 eax
  04aba	8d 4d ac	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  04abd	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 3026 :          if (tmp1.y < 0 ) tmp1 = -tmp1;

  04ac2	dd 45 b4	 fld	 QWORD PTR _tmp1$[ebp+8]
  04ac5	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@00000000000000000000
  04acb	df e0		 fnstsw	 ax
  04acd	f6 c4 01	 test	 ah, 1
  04ad0	74 18		 je	 SHORT $L62053
  04ad2	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR $T62580[ebp]
  04ad8	51		 push	 ecx
  04ad9	8d 4d ac	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  04adc	e8 00 00 00 00	 call	 ??GFPoint@@QBE?AV0@XZ	; FPoint::operator-
  04ae1	50		 push	 eax
  04ae2	8d 4d ac	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  04ae5	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=
$L62053:

; 3027 :          tmp2 = M - P1;

  04aea	8d 55 ec	 lea	 edx, DWORD PTR _P1$[ebp]
  04aed	52		 push	 edx
  04aee	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR $T62581[ebp]
  04af4	50		 push	 eax
  04af5	8b 4d 08	 mov	 ecx, DWORD PTR _M$[ebp]
  04af8	e8 00 00 00 00	 call	 ??GFPoint@@QBE?AV0@ABV0@@Z ; FPoint::operator-
  04afd	50		 push	 eax
  04afe	8d 4d 9c	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  04b01	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 3028 :          if ((tmp1^tmp2) > 0) ++interior;

  04b06	8d 4d 9c	 lea	 ecx, DWORD PTR _tmp2$[ebp]
  04b09	51		 push	 ecx
  04b0a	8d 4d ac	 lea	 ecx, DWORD PTR _tmp1$[ebp]
  04b0d	e8 00 00 00 00	 call	 ??TFPoint@@QBEHABV0@@Z	; FPoint::operator^
  04b12	85 c0		 test	 eax, eax
  04b14	7e 09		 jle	 SHORT $L62056
  04b16	8b 55 fc	 mov	 edx, DWORD PTR _interior$[ebp]
  04b19	83 c2 01	 add	 edx, 1
  04b1c	89 55 fc	 mov	 DWORD PTR _interior$[ebp], edx
$L62056:

; 3030 :       else

  04b1f	eb 7e		 jmp	 SHORT $L62066
$L62049:

; 3040 :             (P2.y == M.y) &&
; 3041 :             (M.x < P2.x)
; 3042 :             )

  04b21	8b 45 08	 mov	 eax, DWORD PTR _M$[ebp]
  04b24	dd 45 e4	 fld	 QWORD PTR _P2$[ebp+8]
  04b27	dc 58 08	 fcomp	 QWORD PTR [eax+8]
  04b2a	df e0		 fnstsw	 ax
  04b2c	f6 c4 40	 test	 ah, 64			; 00000040H
  04b2f	74 6e		 je	 SHORT $L62066
  04b31	8b 4d 08	 mov	 ecx, DWORD PTR _M$[ebp]
  04b34	dd 01		 fld	 QWORD PTR [ecx]
  04b36	dc 5d dc	 fcomp	 QWORD PTR _P2$[ebp]
  04b39	df e0		 fnstsw	 ax
  04b3b	f6 c4 01	 test	 ah, 1
  04b3e	74 5f		 je	 SHORT $L62066

; 3044 :             /* types of intersections checked here:
; 3045 : 
; 3046 :                *           *       *    *             *            *
; 3047 :                 *           *     *      *             *          *
; 3048 :                  *           *   *        *             *        *
; 3049 :                   *           * *          *             *      *
; 3050 :             <------*-----------*------------*****---------******----------M
; 3051 :                    *                             *
; 3052 :                    *                              *
; 3053 :                    *                               *           
; 3054 :                    *                                *
; 3055 :                    *                                 *
; 3056 : 
; 3057 :                   intersection?
; 3058 :                   yes          no             yes           no          
; 3059 :             */
; 3060 : 
; 3061 : 
; 3062 : 
; 3063 :             if (P3.y != P2.y)

  04b40	dd 45 d4	 fld	 QWORD PTR _P3$[ebp+8]
  04b43	dc 5d e4	 fcomp	 QWORD PTR _P2$[ebp+8]
  04b46	df e0		 fnstsw	 ax
  04b48	f6 c4 40	 test	 ah, 64			; 00000040H
  04b4b	75 2a		 jne	 SHORT $L62059

; 3065 :                if ((int)(P2.y-P1.y)*(int)(P3.y-P2.y) > 0) ++interior;

  04b4d	dd 45 e4	 fld	 QWORD PTR _P2$[ebp+8]
  04b50	dc 65 f4	 fsub	 QWORD PTR _P1$[ebp+8]
  04b53	e8 00 00 00 00	 call	 __ftol
  04b58	8b f0		 mov	 esi, eax
  04b5a	dd 45 d4	 fld	 QWORD PTR _P3$[ebp+8]
  04b5d	dc 65 e4	 fsub	 QWORD PTR _P2$[ebp+8]
  04b60	e8 00 00 00 00	 call	 __ftol
  04b65	0f af f0	 imul	 esi, eax
  04b68	85 f6		 test	 esi, esi
  04b6a	7e 09		 jle	 SHORT $L62062
  04b6c	8b 55 fc	 mov	 edx, DWORD PTR _interior$[ebp]
  04b6f	83 c2 01	 add	 edx, 1
  04b72	89 55 fc	 mov	 DWORD PTR _interior$[ebp], edx
$L62062:

; 3067 :             else

  04b75	eb 28		 jmp	 SHORT $L62066
$L62059:

; 3069 :                if ((int)(P2.y-P1.y)*(int)(P4.y-P3.y) > 0) ++interior;

  04b77	dd 45 e4	 fld	 QWORD PTR _P2$[ebp+8]
  04b7a	dc 65 f4	 fsub	 QWORD PTR _P1$[ebp+8]
  04b7d	e8 00 00 00 00	 call	 __ftol
  04b82	8b f0		 mov	 esi, eax
  04b84	dd 45 c4	 fld	 QWORD PTR _P4$[ebp+8]
  04b87	dc 65 d4	 fsub	 QWORD PTR _P3$[ebp+8]
  04b8a	e8 00 00 00 00	 call	 __ftol
  04b8f	0f af f0	 imul	 esi, eax
  04b92	85 f6		 test	 esi, esi
  04b94	7e 09		 jle	 SHORT $L62066
  04b96	8b 45 fc	 mov	 eax, DWORD PTR _interior$[ebp]
  04b99	83 c0 01	 add	 eax, 1
  04b9c	89 45 fc	 mov	 DWORD PTR _interior$[ebp], eax
$L62066:

; 3073 :       P1 = P2;

  04b9f	8d 4d dc	 lea	 ecx, DWORD PTR _P2$[ebp]
  04ba2	51		 push	 ecx
  04ba3	8d 4d ec	 lea	 ecx, DWORD PTR _P1$[ebp]
  04ba6	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 3074 :       P2 = P3;

  04bab	8d 55 cc	 lea	 edx, DWORD PTR _P3$[ebp]
  04bae	52		 push	 edx
  04baf	8d 4d dc	 lea	 ecx, DWORD PTR _P2$[ebp]
  04bb2	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 3075 :       P3 = P4;

  04bb7	8d 45 bc	 lea	 eax, DWORD PTR _P4$[ebp]
  04bba	50		 push	 eax
  04bbb	8d 4d cc	 lea	 ecx, DWORD PTR _P3$[ebp]
  04bbe	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 3076 : 
; 3077 :       // See if there are any more line segments
; 3078 :       // in the polygon to be tested.
; 3079 :       if (P3 == N3) break;

  04bc3	8d 4d 88	 lea	 ecx, DWORD PTR _N3$[ebp]
  04bc6	51		 push	 ecx
  04bc7	8d 4d cc	 lea	 ecx, DWORD PTR _P3$[ebp]
  04bca	e8 00 00 00 00	 call	 ??8FPoint@@QBEHABV0@@Z	; FPoint::operator==
  04bcf	85 c0		 test	 eax, eax
  04bd1	74 02		 je	 SHORT $L62067
  04bd3	eb 26		 jmp	 SHORT $L62040
$L62067:

; 3080 : 
; 3081 :       P4 = polygon[(++ nextnode) % n];

  04bd5	8b 55 98	 mov	 edx, DWORD PTR _nextnode$[ebp]
  04bd8	83 c2 01	 add	 edx, 1
  04bdb	89 55 98	 mov	 DWORD PTR _nextnode$[ebp], edx
  04bde	8b 45 98	 mov	 eax, DWORD PTR _nextnode$[ebp]
  04be1	99		 cdq
  04be2	f7 7d 10	 idiv	 DWORD PTR _n$[ebp]
  04be5	c1 e2 04	 shl	 edx, 4
  04be8	8b 45 0c	 mov	 eax, DWORD PTR _polygon$[ebp]
  04beb	03 c2		 add	 eax, edx
  04bed	50		 push	 eax
  04bee	8d 4d bc	 lea	 ecx, DWORD PTR _P4$[ebp]
  04bf1	e8 00 00 00 00	 call	 ??4FPoint@@QAEAAV0@ABV0@@Z ; FPoint::operator=

; 3082 :       }

  04bf6	e9 84 fd ff ff	 jmp	 $L62037
$L62040:

; 3083 : 
; 3084 :    if (interior & 1)

  04bfb	8b 4d fc	 mov	 ecx, DWORD PTR _interior$[ebp]
  04bfe	83 e1 01	 and	 ecx, 1
  04c01	85 c9		 test	 ecx, ecx
  04c03	74 07		 je	 SHORT $L62068

; 3085 :       return(True);

  04c05	b8 01 00 00 00	 mov	 eax, 1
  04c0a	eb 02		 jmp	 SHORT $L62069
$L62068:

; 3087 :       return(False);

  04c0c	33 c0		 xor	 eax, eax
$L62069:

; 3088 : }

  04c0e	5e		 pop	 esi
  04c0f	8b e5		 mov	 esp, ebp
  04c11	5d		 pop	 ebp
  04c12	c3		 ret	 0
?PointInteriorF@@YAHAAVFPoint@@PAV1@H@Z ENDP		; PointInteriorF
_TEXT	ENDS
;	COMDAT ??GFPoint@@QBE?AV0@XZ
_TEXT	SEGMENT
$T62583 = -16
___$ReturnUdt$ = 8
_this$ = -20
??GFPoint@@QBE?AV0@XZ PROC NEAR				; FPoint::operator-, COMDAT

; 342  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 343  :    return FPoint(-x,-y);

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	dd 40 08	 fld	 QWORD PTR [eax+8]
  0000f	d9 e0		 fchs
  00011	83 ec 08	 sub	 esp, 8
  00014	dd 1c 24	 fstp	 QWORD PTR [esp]
  00017	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	dd 01		 fld	 QWORD PTR [ecx]
  0001c	d9 e0		 fchs
  0001e	83 ec 08	 sub	 esp, 8
  00021	dd 1c 24	 fstp	 QWORD PTR [esp]
  00024	8d 4d f0	 lea	 ecx, DWORD PTR $T62583[ebp]
  00027	e8 00 00 00 00	 call	 ??0FPoint@@QAE@NN@Z	; FPoint::FPoint
  0002c	50		 push	 eax
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00030	e8 00 00 00 00	 call	 ??0FPoint@@QAE@ABV0@@Z	; FPoint::FPoint
  00035	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 344  : }

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
??GFPoint@@QBE?AV0@XZ ENDP				; FPoint::operator-
_TEXT	ENDS
;	COMDAT ??8FPoint@@QBEHABV0@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
??8FPoint@@QBEHABV0@@Z PROC NEAR			; FPoint::operator==, COMDAT

; 391  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 392  : 	return x == p.x  &&  y == p.y;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0000f	dd 00		 fld	 QWORD PTR [eax]
  00011	dc 19		 fcomp	 QWORD PTR [ecx]
  00013	df e0		 fnstsw	 ax
  00015	f6 c4 40	 test	 ah, 64			; 00000040H
  00018	74 1c		 je	 SHORT $L62585
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00020	dd 42 08	 fld	 QWORD PTR [edx+8]
  00023	dc 58 08	 fcomp	 QWORD PTR [eax+8]
  00026	df e0		 fnstsw	 ax
  00028	f6 c4 40	 test	 ah, 64			; 00000040H
  0002b	74 09		 je	 SHORT $L62585
  0002d	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR -8+[ebp], 1
  00034	eb 07		 jmp	 SHORT $L62586
$L62585:
  00036	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], 0
$L62586:
  0003d	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]

; 393  : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
??8FPoint@@QBEHABV0@@Z ENDP				; FPoint::operator==
_TEXT	ENDS
PUBLIC	??0SOL_ListID@@QAE@G@Z				; SOL_ListID::SOL_ListID
PUBLIC	??0SOL_ListID@@QAE@ABU0@@Z			; SOL_ListID::SOL_ListID
PUBLIC	?GetMemType@MemoryMgr@@QAE?AW4MemType@@G@Z	; MemoryMgr::GetMemType
PUBLIC	?Free@MemID@@QAEXXZ				; MemID::Free
PUBLIC	?SetProperty@ObjectID@@QBEXGF@Z			; ObjectID::SetProperty
PUBLIC	?KMergePoly@@YAXPAF@Z				; KMergePoly
PUBLIC	??DFakeSOL_ListID@@QBEPAVSOL_List@@XZ		; FakeSOL_ListID::operator*
PUBLIC	??0SOL_ListID@@QAE@XZ				; SOL_ListID::SOL_ListID
EXTRN	?MergePolygonsF@@YA?AVMemID@@PAUSCI_Point@@HPAVSOL_PolygonF@@@Z:NEAR ; MergePolygonsF
EXTRN	?pm@@3VPMachine@@A:BYTE				; pm
_DATA	SEGMENT
	ORG $+2
$SG62109 DB	'KMergePolygon has invalid MemID in polygonList (0x%x)', 00H
_DATA	ENDS
xdata$x	SEGMENT
$T62597	DD	019930520H
	DD	01H
	DD	FLAT:$T62599
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T62599	DD	0ffffffffH
	DD	FLAT:$L62595
xdata$x	ENDS
_TEXT	SEGMENT
$T62588 = -72
$T62589 = -76
$T62590 = -80
$T62591 = -84
$T62592 = -88
$T62593 = -92
$T62594 = -96
__$EHRec$ = -12
_args$ = 8
_theList$ = -60
_listSize$ = -24
_i$ = -40
_id$62077 = -64
_polygonListID$ = -32
_SCIPolygonID$ = -36
_size$ = -16
_pointsID$ = -56
_pointsArray$ = -52
_points$ = -44
_polygonList$ = -20
_list$ = -28
_index$ = -48
_id$62103 = -68
?KMergePoly@@YAXPAF@Z PROC NEAR				; KMergePoly

; 3092 : {

  04c13	55		 push	 ebp
  04c14	8b ec		 mov	 ebp, esp
  04c16	6a ff		 push	 -1
  04c18	68 00 00 00 00	 push	 $L62598
  04c1d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  04c23	50		 push	 eax
  04c24	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  04c2b	83 ec 54	 sub	 esp, 84			; 00000054H

; 3093 :    // Input
; 3094 :    // Arg1 = SCI polygon object
; 3095 :    // Arg2 = polygon list
; 3096 : 
; 3097 : 	SOL_ListID  theList;

  04c2e	8d 4d c4	 lea	 ecx, DWORD PTR _theList$[ebp]
  04c31	e8 00 00 00 00	 call	 ??0SOL_ListID@@QAE@XZ	; SOL_ListID::SOL_ListID

; 3098 :    int         listSize;
; 3099 :    int         i = 0;

  04c36	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 3100 : 
; 3101 : 	if (arg(2)) {

  04c3d	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  04c40	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  04c44	85 c9		 test	 ecx, ecx
  04c46	74 3b		 je	 SHORT $L62076

; 3102 :       ObjectID id = arg(2);

  04c48	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  04c4b	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  04c4f	50		 push	 eax
  04c50	8d 4d c0	 lea	 ecx, DWORD PTR _id$62077[ebp]
  04c53	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID

; 3103 : 		theList = id.GetProperty(s_elements);

  04c58	6a 24		 push	 36			; 00000024H
  04c5a	8d 4d c0	 lea	 ecx, DWORD PTR _id$62077[ebp]
  04c5d	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  04c62	50		 push	 eax
  04c63	8d 4d b8	 lea	 ecx, DWORD PTR $T62588[ebp]
  04c66	e8 00 00 00 00	 call	 ??0SOL_ListID@@QAE@G@Z	; SOL_ListID::SOL_ListID
  04c6b	66 8b 4d b8	 mov	 cx, WORD PTR $T62588[ebp]
  04c6f	66 89 4d c4	 mov	 WORD PTR _theList$[ebp], cx

; 3104 : 		// the number of polygons
; 3105 : 		listSize = id.GetProperty(s_size);

  04c73	6a 5a		 push	 90			; 0000005aH
  04c75	8d 4d c0	 lea	 ecx, DWORD PTR _id$62077[ebp]
  04c78	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  04c7d	0f bf d0	 movsx	 edx, ax
  04c80	89 55 e8	 mov	 DWORD PTR _listSize$[ebp], edx
$L62076:

; 3107 : 
; 3108 : 	// handle no polygons case... just return the given polygon
; 3109 : 	if (!arg(2) || !listSize) {

  04c83	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  04c86	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  04c8a	85 c9		 test	 ecx, ecx
  04c8c	74 06		 je	 SHORT $L62080
  04c8e	83 7d e8 00	 cmp	 DWORD PTR _listSize$[ebp], 0
  04c92	75 11		 jne	 SHORT $L62079
$L62080:

; 3110 : 		pm.acc = arg(1);

  04c94	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  04c97	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  04c9b	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 3111 : 		return;

  04ca0	e9 22 02 00 00	 jmp	 $L62072
$L62079:

; 3113 : 
; 3114 :    MemID polygonListID = BuildPolygonListF(theList,listSize);

  04ca5	8b 4d e8	 mov	 ecx, DWORD PTR _listSize$[ebp]
  04ca8	51		 push	 ecx
  04ca9	51		 push	 ecx
  04caa	8b cc		 mov	 ecx, esp
  04cac	89 65 b4	 mov	 DWORD PTR $T62589[ebp], esp
  04caf	8d 55 c4	 lea	 edx, DWORD PTR _theList$[ebp]
  04cb2	52		 push	 edx
  04cb3	e8 00 00 00 00	 call	 ??0SOL_ListID@@QAE@ABU0@@Z ; SOL_ListID::SOL_ListID
  04cb8	8d 45 b0	 lea	 eax, DWORD PTR $T62590[ebp]
  04cbb	50		 push	 eax
  04cbc	e8 00 00 00 00	 call	 ?BuildPolygonListF@@YA?AVMemID@@USOL_ListID@@H@Z ; BuildPolygonListF
  04cc1	83 c4 0c	 add	 esp, 12			; 0000000cH
  04cc4	50		 push	 eax
  04cc5	8d 4d e0	 lea	 ecx, DWORD PTR _polygonListID$[ebp]
  04cc8	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID

; 3115 : 
; 3116 :    ObjectID SCIPolygonID = arg(1);

  04ccd	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  04cd0	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  04cd4	52		 push	 edx
  04cd5	8d 4d dc	 lea	 ecx, DWORD PTR _SCIPolygonID$[ebp]
  04cd8	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID

; 3117 :    int size = SCIPolygonID.GetProperty(s_size);

  04cdd	6a 5a		 push	 90			; 0000005aH
  04cdf	8d 4d dc	 lea	 ecx, DWORD PTR _SCIPolygonID$[ebp]
  04ce2	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  04ce7	0f bf c0	 movsx	 eax, ax
  04cea	89 45 f0	 mov	 DWORD PTR _size$[ebp], eax

; 3118 :    MemID pointsID = ((ObjectID) SCIPolygonID.GetProperty(s_points)).GetProperty(s_data);

  04ced	6a 71		 push	 113			; 00000071H
  04cef	6a 5b		 push	 91			; 0000005bH
  04cf1	8d 4d dc	 lea	 ecx, DWORD PTR _SCIPolygonID$[ebp]
  04cf4	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  04cf9	50		 push	 eax
  04cfa	8d 4d ac	 lea	 ecx, DWORD PTR $T62591[ebp]
  04cfd	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  04d02	8b c8		 mov	 ecx, eax
  04d04	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  04d09	50		 push	 eax
  04d0a	8d 4d c8	 lea	 ecx, DWORD PTR _pointsID$[ebp]
  04d0d	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID

; 3119 : 
; 3120 : 	Array pointsArray ( pointsID );

  04d12	51		 push	 ecx
  04d13	8b cc		 mov	 ecx, esp
  04d15	89 65 a8	 mov	 DWORD PTR $T62592[ebp], esp
  04d18	8d 55 c8	 lea	 edx, DWORD PTR _pointsID$[ebp]
  04d1b	52		 push	 edx
  04d1c	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  04d21	8d 4d cc	 lea	 ecx, DWORD PTR _pointsArray$[ebp]
  04d24	e8 00 00 00 00	 call	 ??0Array@@QAE@VMemID@@@Z ; Array::Array
  04d29	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 3121 :    SCI_Point* points = (SCI_Point*) pointsArray.calcAddress ( 0 );

  04d30	6a 00		 push	 0
  04d32	8d 4d cc	 lea	 ecx, DWORD PTR _pointsArray$[ebp]
  04d35	e8 00 00 00 00	 call	 ?calcAddress@Array@@QAEPAXH@Z ; Array::calcAddress
  04d3a	89 45 d4	 mov	 DWORD PTR _points$[ebp], eax

; 3122 : 
; 3123 : 	SOL_PolygonF *polygonList = (SOL_PolygonF *)memMgr->GetAddr ( polygonListID );

  04d3d	8d 4d e0	 lea	 ecx, DWORD PTR _polygonListID$[ebp]
  04d40	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  04d45	50		 push	 eax
  04d46	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  04d4c	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr
  04d51	89 45 ec	 mov	 DWORD PTR _polygonList$[ebp], eax

; 3124 : 	pm.acc = MergePolygonsF ( points, size, polygonList );

  04d54	8b 45 ec	 mov	 eax, DWORD PTR _polygonList$[ebp]
  04d57	50		 push	 eax
  04d58	8b 4d f0	 mov	 ecx, DWORD PTR _size$[ebp]
  04d5b	51		 push	 ecx
  04d5c	8b 55 d4	 mov	 edx, DWORD PTR _points$[ebp]
  04d5f	52		 push	 edx
  04d60	8d 45 a4	 lea	 eax, DWORD PTR $T62593[ebp]
  04d63	50		 push	 eax
  04d64	e8 00 00 00 00	 call	 ?MergePolygonsF@@YA?AVMemID@@PAUSCI_Point@@HPAVSOL_PolygonF@@@Z ; MergePolygonsF
  04d69	83 c4 10	 add	 esp, 16			; 00000010H
  04d6c	8b c8		 mov	 ecx, eax
  04d6e	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  04d73	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  04d78	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 3125 : 
; 3126 :    // Identify the MERGED polygons
; 3127 : 	SOL_List* list = *theList;

  04d7d	8d 4d c4	 lea	 ecx, DWORD PTR _theList$[ebp]
  04d80	e8 00 00 00 00	 call	 ??DFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator*
  04d85	89 45 e4	 mov	 DWORD PTR _list$[ebp], eax

; 3128 : 	polygonList = (SOL_PolygonF *) memMgr->GetAddr(polygonListID);

  04d88	8d 4d e0	 lea	 ecx, DWORD PTR _polygonListID$[ebp]
  04d8b	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  04d90	50		 push	 eax
  04d91	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  04d97	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr
  04d9c	89 45 ec	 mov	 DWORD PTR _polygonList$[ebp], eax

; 3129 : 
; 3130 :  	for ( int index=0; index<theList->size(); index++ ) {

  04d9f	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _index$[ebp], 0
  04da6	eb 09		 jmp	 SHORT $L62099
$L62100:
  04da8	8b 4d d0	 mov	 ecx, DWORD PTR _index$[ebp]
  04dab	83 c1 01	 add	 ecx, 1
  04dae	89 4d d0	 mov	 DWORD PTR _index$[ebp], ecx
$L62099:
  04db1	8d 4d c4	 lea	 ecx, DWORD PTR _theList$[ebp]
  04db4	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  04db9	8b c8		 mov	 ecx, eax
  04dbb	e8 00 00 00 00	 call	 ?size@SOL_List@@QAEAAHXZ ; SOL_List::size
  04dc0	8b 55 d0	 mov	 edx, DWORD PTR _index$[ebp]
  04dc3	3b 10		 cmp	 edx, DWORD PTR [eax]
  04dc5	0f 8d e5 00 00
	00		 jge	 $L62101

; 3131 : 		if ( polygonList[index].polyPointsID ) {

  04dcb	8b 45 d0	 mov	 eax, DWORD PTR _index$[ebp]
  04dce	c1 e0 04	 shl	 eax, 4
  04dd1	8b 4d ec	 mov	 ecx, DWORD PTR _polygonList$[ebp]
  04dd4	8d 4c 01 0c	 lea	 ecx, DWORD PTR [ecx+eax+12]
  04dd8	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  04ddd	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  04de2	85 c0		 test	 eax, eax
  04de4	0f 84 c1 00 00
	00		 je	 $L62102

; 3132 : 			ObjectID id = (ObjectID)theList->at ( index );

  04dea	8b 55 d0	 mov	 edx, DWORD PTR _index$[ebp]
  04ded	52		 push	 edx
  04dee	8d 4d c4	 lea	 ecx, DWORD PTR _theList$[ebp]
  04df1	e8 00 00 00 00	 call	 ??CFakeSOL_ListID@@QBEPAVSOL_List@@XZ ; FakeSOL_ListID::operator->
  04df6	8b c8		 mov	 ecx, eax
  04df8	e8 00 00 00 00	 call	 ?at@SOL_List@@QAEGH@Z	; SOL_List::at
  04dfd	50		 push	 eax
  04dfe	8d 4d a0	 lea	 ecx, DWORD PTR $T62594[ebp]
  04e01	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  04e06	50		 push	 eax
  04e07	8d 4d bc	 lea	 ecx, DWORD PTR _id$62103[ebp]
  04e0a	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID

; 3133 : 
; 3134 : 			id.SetProperty ( s_type, polygonList[index].type );

  04e0f	8b 45 d0	 mov	 eax, DWORD PTR _index$[ebp]
  04e12	c1 e0 04	 shl	 eax, 4
  04e15	8b 4d ec	 mov	 ecx, DWORD PTR _polygonList$[ebp]
  04e18	66 0f b6 54 01
	04		 movzx	 dx, BYTE PTR [ecx+eax+4]
  04e1e	52		 push	 edx
  04e1f	6a 2b		 push	 43			; 0000002bH
  04e21	8d 4d bc	 lea	 ecx, DWORD PTR _id$62103[ebp]
  04e24	e8 00 00 00 00	 call	 ?SetProperty@ObjectID@@QBEXGF@Z ; ObjectID::SetProperty

; 3135 : 
; 3136 : 			if ( !memMgr->IsValid ( polygonList[index].polyPointsID ) || memMgr->GetMemType ( polygonList[index].polyPointsID ) != MemPointList ) {

  04e29	8b 45 d0	 mov	 eax, DWORD PTR _index$[ebp]
  04e2c	c1 e0 04	 shl	 eax, 4
  04e2f	8b 4d ec	 mov	 ecx, DWORD PTR _polygonList$[ebp]
  04e32	8d 4c 01 0c	 lea	 ecx, DWORD PTR [ecx+eax+12]
  04e36	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  04e3b	50		 push	 eax
  04e3c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  04e42	e8 00 00 00 00	 call	 ?IsValid@MemoryMgr@@QAEHG@Z ; MemoryMgr::IsValid
  04e47	85 c0		 test	 eax, eax
  04e49	74 23		 je	 SHORT $L62107
  04e4b	8b 55 d0	 mov	 edx, DWORD PTR _index$[ebp]
  04e4e	c1 e2 04	 shl	 edx, 4
  04e51	8b 45 ec	 mov	 eax, DWORD PTR _polygonList$[ebp]
  04e54	8d 4c 10 0c	 lea	 ecx, DWORD PTR [eax+edx+12]
  04e58	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  04e5d	50		 push	 eax
  04e5e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  04e64	e8 00 00 00 00	 call	 ?GetMemType@MemoryMgr@@QAE?AW4MemType@@G@Z ; MemoryMgr::GetMemType
  04e69	83 f8 46	 cmp	 eax, 70			; 00000046H
  04e6c	74 2b		 je	 SHORT $L62106
$L62107:

; 3137 : 				msgMgr->Fatal ( "KMergePolygon has invalid MemID in polygonList (0x%x)", (unsigned short)polygonList[index].polyPointsID );

  04e6e	8b 4d d0	 mov	 ecx, DWORD PTR _index$[ebp]
  04e71	c1 e1 04	 shl	 ecx, 4
  04e74	8b 55 ec	 mov	 edx, DWORD PTR _polygonList$[ebp]
  04e77	8d 4c 0a 0c	 lea	 ecx, DWORD PTR [edx+ecx+12]
  04e7b	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  04e80	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  04e85	50		 push	 eax
  04e86	68 00 00 00 00	 push	 OFFSET FLAT:$SG62109
  04e8b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  04e90	50		 push	 eax
  04e91	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  04e96	83 c4 0c	 add	 esp, 12			; 0000000cH
$L62106:

; 3139 : 
; 3140 : 			polygonList[index].polyPointsID.Free();

  04e99	8b 4d d0	 mov	 ecx, DWORD PTR _index$[ebp]
  04e9c	c1 e1 04	 shl	 ecx, 4
  04e9f	8b 55 ec	 mov	 edx, DWORD PTR _polygonList$[ebp]
  04ea2	8d 4c 0a 0c	 lea	 ecx, DWORD PTR [edx+ecx+12]
  04ea6	e8 00 00 00 00	 call	 ?Free@MemID@@QAEXXZ	; MemID::Free
$L62102:

; 3142 : 	}

  04eab	e9 f8 fe ff ff	 jmp	 $L62100
$L62101:

; 3143 : 
; 3144 : 	polygonListID.Free();

  04eb0	8d 4d e0	 lea	 ecx, DWORD PTR _polygonListID$[ebp]
  04eb3	e8 00 00 00 00	 call	 ?Free@MemID@@QAEXXZ	; MemID::Free

; 3145 : }

  04eb8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  04ebf	8d 4d cc	 lea	 ecx, DWORD PTR _pointsArray$[ebp]
  04ec2	e8 00 00 00 00	 call	 ??1Array@@QAE@XZ	; Array::~Array
$L62072:
  04ec7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  04eca	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  04ed1	8b e5		 mov	 esp, ebp
  04ed3	5d		 pop	 ebp
  04ed4	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L62595:
  0004e	8d 4d cc	 lea	 ecx, DWORD PTR _pointsArray$[ebp]
  00051	e8 00 00 00 00	 call	 ??1Array@@QAE@XZ	; Array::~Array
  00056	c3		 ret	 0
$L62598:
  00057	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T62597
  0005c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?KMergePoly@@YAXPAF@Z ENDP				; KMergePoly
;	COMDAT ?GetMemType@MemoryMgr@@QAE?AW4MemType@@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
?GetMemType@MemoryMgr@@QAE?AW4MemType@@G@Z PROC NEAR	; MemoryMgr::GetMemType, COMDAT

; 363  : 	MemType GetMemType(SOL_Handle h) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 364  : //		CheckValid(h);
; 365  : 		return (MemType) desc[h].memInfo.type;

  00007	8b 45 08	 mov	 eax, DWORD PTR _h$[ebp]
  0000a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0000f	c1 e0 04	 shl	 eax, 4
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00018	0f be 04 02	 movsx	 eax, BYTE PTR [edx+eax]

; 366  : 	}

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?GetMemType@MemoryMgr@@QAE?AW4MemType@@G@Z ENDP		; MemoryMgr::GetMemType
_TEXT	ENDS
EXTRN	?Free@MemoryMgr@@QAEXG@Z:NEAR			; MemoryMgr::Free
;	COMDAT ?Free@MemID@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Free@MemID@@QAEXXZ PROC NEAR				; MemID::Free, COMDAT

; 32   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 33   : 		if (handle) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000f	85 c9		 test	 ecx, ecx
  00011	74 1a		 je	 SHORT $L54529

; 34   : 			memMgr->Free(handle);

  00013	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00016	66 8b 02	 mov	 ax, WORD PTR [edx]
  00019	50		 push	 eax
  0001a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00020	e8 00 00 00 00	 call	 ?Free@MemoryMgr@@QAEXG@Z ; MemoryMgr::Free

; 35   : 			handle = 0;

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	66 c7 01 00 00	 mov	 WORD PTR [ecx], 0
$L54529:

; 37   : 	}

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?Free@MemID@@QAEXXZ ENDP				; MemID::Free
_TEXT	ENDS
;	COMDAT ??DFakeSOL_ListID@@QBEPAVSOL_List@@XZ
_TEXT	SEGMENT
_this$ = -4
??DFakeSOL_ListID@@QBEPAVSOL_List@@XZ PROC NEAR		; FakeSOL_ListID::operator*, COMDAT

; 84   : FakeTemplateID(FakeSOL_ListID, SOL_List, MemList)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??DFakeSOL_ListID@@QBEPAVSOL_List@@XZ ENDP		; FakeSOL_ListID::operator*
_TEXT	ENDS
PUBLIC	??0FakeSOL_ListID@@QAE@XZ			; FakeSOL_ListID::FakeSOL_ListID
;	COMDAT ??0SOL_ListID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0SOL_ListID@@QAE@XZ PROC NEAR				; SOL_ListID::SOL_ListID, COMDAT

; 86   : 	SOL_ListID() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0FakeSOL_ListID@@QAE@XZ ; FakeSOL_ListID::FakeSOL_ListID
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0SOL_ListID@@QAE@XZ ENDP				; SOL_ListID::SOL_ListID
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0FakeSOL_ListID@@QAE@XZ PROC NEAR			; FakeSOL_ListID::FakeSOL_ListID, COMDAT

; 84   : FakeTemplateID(FakeSOL_ListID, SOL_List, MemList)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0FakeSOL_ListID@@QAE@XZ ENDP				; FakeSOL_ListID::FakeSOL_ListID
_TEXT	ENDS
PUBLIC	??0FakeSOL_ListID@@QAE@G@Z			; FakeSOL_ListID::FakeSOL_ListID
;	COMDAT ??0SOL_ListID@@QAE@G@Z
_TEXT	SEGMENT
_this$ = -4
_h$ = 8
??0SOL_ListID@@QAE@G@Z PROC NEAR			; SOL_ListID::SOL_ListID, COMDAT

; 88   : 	SOL_ListID(SOL_Handle h) : FakeSOL_ListID(h) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	66 8b 45 08	 mov	 ax, WORD PTR _h$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0FakeSOL_ListID@@QAE@G@Z ; FakeSOL_ListID::FakeSOL_ListID
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0SOL_ListID@@QAE@G@Z ENDP				; SOL_ListID::SOL_ListID
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0FakeSOL_ListID@@QAE@G@Z PROC NEAR			; FakeSOL_ListID::FakeSOL_ListID, COMDAT

; 84   : FakeTemplateID(FakeSOL_ListID, SOL_List, MemList)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	66 8b 45 08	 mov	 ax, WORD PTR _h$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0FakeSOL_ListID@@QAE@G@Z ENDP				; FakeSOL_ListID::FakeSOL_ListID
_TEXT	ENDS
PUBLIC	?SetProperty@Object@@QAEXGF@Z			; Object::SetProperty
;	COMDAT ?SetProperty@ObjectID@@QBEXGF@Z
_TEXT	SEGMENT
_selector$ = 8
_value$ = 12
_this$ = -4
?SetProperty@ObjectID@@QBEXGF@Z PROC NEAR		; ObjectID::SetProperty, COMDAT

; 340  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 341  : 		//	set a property given a selector
; 342  : 		AssureValid();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?AssureValid@ObjectID@@QBEXXZ ; ObjectID::AssureValid

; 343  : 		(*this)->SetProperty(selector, value);

  0000f	66 8b 45 0c	 mov	 ax, WORD PTR _value$[ebp]
  00013	50		 push	 eax
  00014	66 8b 4d 08	 mov	 cx, WORD PTR _selector$[ebp]
  00018	51		 push	 ecx
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  00021	8b c8		 mov	 ecx, eax
  00023	e8 00 00 00 00	 call	 ?SetProperty@Object@@QAEXGF@Z ; Object::SetProperty

; 344  : 	}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?SetProperty@ObjectID@@QBEXGF@Z ENDP			; ObjectID::SetProperty
_TEXT	ENDS
PUBLIC	?SetGraphicsUpdate@Object@@QAEXXZ		; Object::SetGraphicsUpdate
;	COMDAT ?SetProperty@Object@@QAEXGF@Z
_TEXT	SEGMENT
_selector$ = 8
_value$ = 12
_this$ = -12
_property$ = -8
_index$ = -4
?SetProperty@Object@@QAEXGF@Z PROC NEAR			; Object::SetProperty, COMDAT

; 206  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		//	set a property given a selector
; 208  : 		Property* property = GetPropAddrCheck(selector);

  00009	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?GetPropAddrCheck@Object@@QAEPAFG@Z ; Object::GetPropAddrCheck
  00016	89 45 f8	 mov	 DWORD PTR _property$[ebp], eax

; 209  : 		int index = property - (Property*) this;

  00019	8b 4d f8	 mov	 ecx, DWORD PTR _property$[ebp]
  0001c	2b 4d f4	 sub	 ecx, DWORD PTR _this$[ebp]
  0001f	d1 f9		 sar	 ecx, 1
  00021	89 4d fc	 mov	 DWORD PTR _index$[ebp], ecx

; 210  : 		if (index <= MaxGraphUpdateIndex && index >= MinGraphUpdateIndex)

  00024	83 7d fc 2b	 cmp	 DWORD PTR _index$[ebp], 43 ; 0000002bH
  00028	7f 0e		 jg	 SHORT $L57820
  0002a	83 7d fc 18	 cmp	 DWORD PTR _index$[ebp], 24 ; 00000018H
  0002e	7c 08		 jl	 SHORT $L57820

; 211  : 			SetGraphicsUpdate();

  00030	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?SetGraphicsUpdate@Object@@QAEXXZ ; Object::SetGraphicsUpdate
$L57820:

; 212  : 		*property = value;

  00038	8b 55 f8	 mov	 edx, DWORD PTR _property$[ebp]
  0003b	66 8b 45 0c	 mov	 ax, WORD PTR _value$[ebp]
  0003f	66 89 02	 mov	 WORD PTR [edx], ax

; 213  : 	}

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 08 00	 ret	 8
?SetProperty@Object@@QAEXGF@Z ENDP			; Object::SetProperty
_TEXT	ENDS
;	COMDAT ?SetGraphicsUpdate@Object@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?SetGraphicsUpdate@Object@@QAEXXZ PROC NEAR		; Object::SetGraphicsUpdate, COMDAT

; 97   : 	void		SetGraphicsUpdate()		{ info |= GRAPH_UPD; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 48 0e	 mov	 cx, WORD PTR [eax+14]
  0000e	80 c9 08	 or	 cl, 8
  00011	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00014	66 89 4a 0e	 mov	 WORD PTR [edx+14], cx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?SetGraphicsUpdate@Object@@QAEXXZ ENDP			; Object::SetGraphicsUpdate
_TEXT	ENDS
PUBLIC	??0FakeSOL_ListID@@QAE@ABU0@@Z			; FakeSOL_ListID::FakeSOL_ListID
;	COMDAT ??0SOL_ListID@@QAE@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0SOL_ListID@@QAE@ABU0@@Z PROC NEAR			; SOL_ListID::SOL_ListID, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0FakeSOL_ListID@@QAE@ABU0@@Z ; FakeSOL_ListID::FakeSOL_ListID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0SOL_ListID@@QAE@ABU0@@Z ENDP				; SOL_ListID::SOL_ListID
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0FakeSOL_ListID@@QAE@ABU0@@Z PROC NEAR		; FakeSOL_ListID::FakeSOL_ListID, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0FakeSOL_ListID@@QAE@ABU0@@Z ENDP			; FakeSOL_ListID::FakeSOL_ListID
_TEXT	ENDS
PUBLIC	?KInPolygon@@YAXPAF@Z				; KInPolygon
_DATA	SEGMENT
	ORG $+2
$SG62128 DB	'\\vboxsrv\vagrant\DnGClientSource\clientwork\Interp\Poly'
	DB	'gon.cpp', 00H
_DATA	ENDS
xdata$x	SEGMENT
$T62616	DD	019930520H
	DD	01H
	DD	FLAT:$T62618
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T62618	DD	0ffffffffH
	DD	FLAT:$L62614
xdata$x	ENDS
_TEXT	SEGMENT
$T62613 = -40
__$EHRec$ = -12
_args$ = 8
_A$ = -20
_polygonID$ = -24
_arrayID$ = -36
_pointsArray$ = -32
_points$ = -28
_size$ = -16
?KInPolygon@@YAXPAF@Z PROC NEAR				; KInPolygon

; 3149 : {	

  04ed5	55		 push	 ebp
  04ed6	8b ec		 mov	 ebp, esp
  04ed8	6a ff		 push	 -1
  04eda	68 00 00 00 00	 push	 $L62617
  04edf	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  04ee5	50		 push	 eax
  04ee6	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  04eed	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 3150 :    // Input
; 3151 :    // Arg1 = A.x
; 3152 :    // Arg2 = A.y
; 3153 :    // Arg3 = polygon
; 3154 : 
; 3155 :    SCI_Point A(arg(1),arg(2));

  04ef0	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  04ef3	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  04ef7	51		 push	 ecx
  04ef8	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  04efb	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  04eff	50		 push	 eax
  04f00	8d 4d ec	 lea	 ecx, DWORD PTR _A$[ebp]
  04f03	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@HH@Z	; SCI_Point::SCI_Point

; 3156 : 
; 3157 :    ObjectID polygonID = arg(3);

  04f08	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  04f0b	66 8b 51 06	 mov	 dx, WORD PTR [ecx+6]
  04f0f	52		 push	 edx
  04f10	8d 4d e8	 lea	 ecx, DWORD PTR _polygonID$[ebp]
  04f13	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID

; 3158 : 
; 3159 : 	ObjectID arrayID = polygonID.GetProperty ( s_points );

  04f18	6a 5b		 push	 91			; 0000005bH
  04f1a	8d 4d e8	 lea	 ecx, DWORD PTR _polygonID$[ebp]
  04f1d	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  04f22	50		 push	 eax
  04f23	8d 4d dc	 lea	 ecx, DWORD PTR _arrayID$[ebp]
  04f26	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID

; 3160 : 	Array pointsArray ( arrayID.GetProperty ( s_data ) );

  04f2b	6a 71		 push	 113			; 00000071H
  04f2d	8d 4d dc	 lea	 ecx, DWORD PTR _arrayID$[ebp]
  04f30	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  04f35	51		 push	 ecx
  04f36	8b cc		 mov	 ecx, esp
  04f38	89 65 d8	 mov	 DWORD PTR $T62613[ebp], esp
  04f3b	50		 push	 eax
  04f3c	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  04f41	8d 4d e0	 lea	 ecx, DWORD PTR _pointsArray$[ebp]
  04f44	e8 00 00 00 00	 call	 ??0Array@@QAE@VMemID@@@Z ; Array::Array
  04f49	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 3161 :    SCI_Point* points = (SCI_Point*) pointsArray.calcAddress ( 0 );

  04f50	6a 00		 push	 0
  04f52	8d 4d e0	 lea	 ecx, DWORD PTR _pointsArray$[ebp]
  04f55	e8 00 00 00 00	 call	 ?calcAddress@Array@@QAEPAXH@Z ; Array::calcAddress
  04f5a	89 45 e4	 mov	 DWORD PTR _points$[ebp], eax

; 3162 : 	int size =  polygonID.GetProperty(s_size);

  04f5d	6a 5a		 push	 90			; 0000005aH
  04f5f	8d 4d e8	 lea	 ecx, DWORD PTR _polygonID$[ebp]
  04f62	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  04f67	0f bf c0	 movsx	 eax, ax
  04f6a	89 45 f0	 mov	 DWORD PTR _size$[ebp], eax

; 3163 : 	if (size < 3)

  04f6d	83 7d f0 03	 cmp	 DWORD PTR _size$[ebp], 3
  04f71	7d 1d		 jge	 SHORT $L62127

; 3164 : 	   msgMgr->Fatal(SrcLoc,Msg_NotAPolygon);

  04f73	6a 72		 push	 114			; 00000072H
  04f75	68 5c 0c 00 00	 push	 3164			; 00000c5cH
  04f7a	68 00 00 00 00	 push	 OFFSET FLAT:$SG62128
  04f7f	6a 61		 push	 97			; 00000061H
  04f81	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  04f87	51		 push	 ecx
  04f88	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXDPADHHZZ ; MsgMgr::Fatal
  04f8d	83 c4 14	 add	 esp, 20			; 00000014H
$L62127:

; 3165 : 
; 3166 : 	pm.acc = PointInterior(A,&points[0],size ); 

  04f90	8b 55 f0	 mov	 edx, DWORD PTR _size$[ebp]
  04f93	52		 push	 edx
  04f94	8b 45 e4	 mov	 eax, DWORD PTR _points$[ebp]
  04f97	50		 push	 eax
  04f98	8d 4d ec	 lea	 ecx, DWORD PTR _A$[ebp]
  04f9b	51		 push	 ecx
  04f9c	e8 00 00 00 00	 call	 ?PointInterior@@YAHAAUSCI_Point@@PAU1@H@Z ; PointInterior
  04fa1	83 c4 0c	 add	 esp, 12			; 0000000cH
  04fa4	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 3167 : }

  04fa9	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  04fb0	8d 4d e0	 lea	 ecx, DWORD PTR _pointsArray$[ebp]
  04fb3	e8 00 00 00 00	 call	 ??1Array@@QAE@XZ	; Array::~Array
  04fb8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  04fbb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  04fc2	8b e5		 mov	 esp, ebp
  04fc4	5d		 pop	 ebp
  04fc5	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L62614:
  00061	8d 4d e0	 lea	 ecx, DWORD PTR _pointsArray$[ebp]
  00064	e8 00 00 00 00	 call	 ??1Array@@QAE@XZ	; Array::~Array
  00069	c3		 ret	 0
$L62617:
  0006a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T62616
  0006f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?KInPolygon@@YAXPAF@Z ENDP				; KInPolygon
PUBLIC	?KAvoidPath@@YAXPAF@Z				; KAvoidPath
xdata$x	SEGMENT
$T62627	DD	019930520H
	DD	01H
	DD	FLAT:$T62629
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T62629	DD	0ffffffffH
	DD	FLAT:$L62625
xdata$x	ENDS
_TEXT	SEGMENT
$T62620 = -56
$T62621 = -60
$T62622 = -64
$T62623 = -68
$T62624 = -72
__$EHRec$ = -12
_args$ = 8
_theList$ = -40
_optimize$ = -36
_listSize$ = -24
_A$ = -16
_B$ = -20
_id$62138 = -44
_array$62142 = -52
_path$62143 = -48
_plane$ = -32
_polygonListID$ = -28
?KAvoidPath@@YAXPAF@Z PROC NEAR				; KAvoidPath

; 3171 : {	

  04fc6	55		 push	 ebp
  04fc7	8b ec		 mov	 ebp, esp
  04fc9	6a ff		 push	 -1
  04fcb	68 00 00 00 00	 push	 $L62628
  04fd0	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  04fd6	50		 push	 eax
  04fd7	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  04fde	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 3172 :    // Input
; 3173 :    // Arg1 = A.x
; 3174 :    // Arg2 = A.y
; 3175 :    // Arg3 = B.x
; 3176 :    // Arg4 = B.y
; 3177 :    // Arg5 = polygon list
; 3178 :    // Arg6 = SOL_Plane width
; 3179 :    // Arg7 = SOL_Plane height
; 3180 :    // Arg8 = optimize level (if no Arg8 then set to 1)
; 3181 :    // Arg9 = check plane edge (1 default)
; 3182 : 
; 3183 : 	SOL_ListID theList;

  04fe1	8d 4d d8	 lea	 ecx, DWORD PTR _theList$[ebp]
  04fe4	e8 00 00 00 00	 call	 ??0SOL_ListID@@QAE@XZ	; SOL_ListID::SOL_ListID

; 3184 :    int optimize = 1;

  04fe9	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _optimize$[ebp], 1

; 3185 : 	int listSize = 0;

  04ff0	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _listSize$[ebp], 0

; 3186 : 
; 3187 :    SCI_Point A(arg(1),arg(2));

  04ff7	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  04ffa	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  04ffe	51		 push	 ecx
  04fff	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  05002	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  05006	50		 push	 eax
  05007	8d 4d f0	 lea	 ecx, DWORD PTR _A$[ebp]
  0500a	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@HH@Z	; SCI_Point::SCI_Point

; 3188 :    SCI_Point B(arg(3),arg(4));

  0500f	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  05012	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  05016	52		 push	 edx
  05017	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  0501a	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0501e	51		 push	 ecx
  0501f	8d 4d ec	 lea	 ecx, DWORD PTR _B$[ebp]
  05022	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@HH@Z	; SCI_Point::SCI_Point

; 3189 : 
; 3190 : 	if (arg(5)) {

  05027	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  0502a	0f bf 42 0a	 movsx	 eax, WORD PTR [edx+10]
  0502e	85 c0		 test	 eax, eax
  05030	74 3b		 je	 SHORT $L62137

; 3191 :       ObjectID id = arg(5);

  05032	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  05035	66 8b 51 0a	 mov	 dx, WORD PTR [ecx+10]
  05039	52		 push	 edx
  0503a	8d 4d d4	 lea	 ecx, DWORD PTR _id$62138[ebp]
  0503d	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID

; 3192 : 		theList = id.GetProperty(s_elements);

  05042	6a 24		 push	 36			; 00000024H
  05044	8d 4d d4	 lea	 ecx, DWORD PTR _id$62138[ebp]
  05047	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  0504c	50		 push	 eax
  0504d	8d 4d c8	 lea	 ecx, DWORD PTR $T62620[ebp]
  05050	e8 00 00 00 00	 call	 ??0SOL_ListID@@QAE@G@Z	; SOL_ListID::SOL_ListID
  05055	66 8b 45 c8	 mov	 ax, WORD PTR $T62620[ebp]
  05059	66 89 45 d8	 mov	 WORD PTR _theList$[ebp], ax

; 3193 : 		// the number of polygons
; 3194 : 		listSize = id.GetProperty(s_size);

  0505d	6a 5a		 push	 90			; 0000005aH
  0505f	8d 4d d4	 lea	 ecx, DWORD PTR _id$62138[ebp]
  05062	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  05067	0f bf c8	 movsx	 ecx, ax
  0506a	89 4d e8	 mov	 DWORD PTR _listSize$[ebp], ecx
$L62137:

; 3196 : 
; 3197 : 	// handle no obstacle case... just act like a MoveTo
; 3198 : 	if (!arg(5) || !listSize) {

  0506d	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  05070	0f bf 42 0a	 movsx	 eax, WORD PTR [edx+10]
  05074	85 c0		 test	 eax, eax
  05076	74 06		 je	 SHORT $L62141
  05078	83 7d e8 00	 cmp	 DWORD PTR _listSize$[ebp], 0
  0507c	75 7e		 jne	 SHORT $L62140
$L62141:

; 3199 : 		Array array ( 6, INTARRAY );

  0507e	6a 00		 push	 0
  05080	6a 06		 push	 6
  05082	8d 4d cc	 lea	 ecx, DWORD PTR _array$62142[ebp]
  05085	e8 00 00 00 00	 call	 ??0Array@@QAE@HW4ArrayType@@@Z ; Array::Array
  0508a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 3200 : 
; 3201 :       SCI_Point* path = (SCI_Point*)array.calcAddress ( 0 );

  05091	6a 00		 push	 0
  05093	8d 4d cc	 lea	 ecx, DWORD PTR _array$62142[ebp]
  05096	e8 00 00 00 00	 call	 ?calcAddress@Array@@QAEPAXH@Z ; Array::calcAddress
  0509b	89 45 d0	 mov	 DWORD PTR _path$62143[ebp], eax

; 3202 : 
; 3203 : 		path[0] = A;

  0509e	8d 4d f0	 lea	 ecx, DWORD PTR _A$[ebp]
  050a1	51		 push	 ecx
  050a2	8b 4d d0	 mov	 ecx, DWORD PTR _path$62143[ebp]
  050a5	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 3204 : 		path[1] = B;

  050aa	8d 55 ec	 lea	 edx, DWORD PTR _B$[ebp]
  050ad	52		 push	 edx
  050ae	8b 4d d0	 mov	 ecx, DWORD PTR _path$62143[ebp]
  050b1	83 c1 04	 add	 ecx, 4
  050b4	e8 00 00 00 00	 call	 ??4SCI_Point@@QAEAAU0@ABU0@@Z ; SCI_Point::operator=

; 3205 : 		path[2].x = ENDOFPATH;

  050b9	8b 45 d0	 mov	 eax, DWORD PTR _path$62143[ebp]
  050bc	66 c7 40 08 77
	77		 mov	 WORD PTR [eax+8], 30583	; 00007777H

; 3206 : 		path[2].y = ENDOFPATH;

  050c2	8b 4d d0	 mov	 ecx, DWORD PTR _path$62143[ebp]
  050c5	66 c7 41 0a 77
	77		 mov	 WORD PTR [ecx+10], 30583 ; 00007777H

; 3207 : 
; 3208 : 		pm.acc = array.dataID();

  050cb	8d 55 c4	 lea	 edx, DWORD PTR $T62621[ebp]
  050ce	52		 push	 edx
  050cf	8d 4d cc	 lea	 ecx, DWORD PTR _array$62142[ebp]
  050d2	e8 00 00 00 00	 call	 ?dataID@Array@@QAE?AVMemID@@XZ ; Array::dataID
  050d7	8b c8		 mov	 ecx, eax
  050d9	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  050de	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  050e3	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 3209 : 
; 3210 : 		return;

  050e8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  050ef	8d 4d cc	 lea	 ecx, DWORD PTR _array$62142[ebp]
  050f2	e8 00 00 00 00	 call	 ??1Array@@QAE@XZ	; Array::~Array
  050f7	e9 c1 00 00 00	 jmp	 $L62131
$L62140:

; 3212 : 
; 3213 :    // SOL_Plane dimensions
; 3214 :    SCI_Point plane(arg(6),arg(7));

  050fc	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  050ff	0f bf 48 0e	 movsx	 ecx, WORD PTR [eax+14]
  05103	51		 push	 ecx
  05104	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  05107	0f bf 42 0c	 movsx	 eax, WORD PTR [edx+12]
  0510b	50		 push	 eax
  0510c	8d 4d e0	 lea	 ecx, DWORD PTR _plane$[ebp]
  0510f	e8 00 00 00 00	 call	 ??0SCI_Point@@QAE@HH@Z	; SCI_Point::SCI_Point

; 3215 : 
; 3216 : 	// optimize path or not?
; 3217 : 	if (argCount >= 8)

  05114	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  05117	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  0511a	83 fa 08	 cmp	 edx, 8
  0511d	7c 0a		 jl	 SHORT $L62147

; 3218 : 		optimize	= arg(8);

  0511f	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  05122	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  05126	89 4d dc	 mov	 DWORD PTR _optimize$[ebp], ecx
$L62147:

; 3219 : 
; 3220 : 	if (argCount >= 9)

  05129	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  0512c	0f bf 02	 movsx	 eax, WORD PTR [edx]
  0512f	83 f8 09	 cmp	 eax, 9
  05132	7c 0d		 jl	 SHORT $L62148

; 3221 : 		gCheckPlaneEdge = arg(9);

  05134	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  05137	0f bf 51 12	 movsx	 edx, WORD PTR [ecx+18]
  0513b	89 15 00 00 00
	00		 mov	 DWORD PTR ?gCheckPlaneEdge@@3HA, edx ; gCheckPlaneEdge
$L62148:

; 3222 : 
; 3223 :    MemID polygonListID = BuildPolygonList(theList,listSize);

  05141	8b 45 e8	 mov	 eax, DWORD PTR _listSize$[ebp]
  05144	50		 push	 eax
  05145	51		 push	 ecx
  05146	8b cc		 mov	 ecx, esp
  05148	89 65 c0	 mov	 DWORD PTR $T62622[ebp], esp
  0514b	8d 55 d8	 lea	 edx, DWORD PTR _theList$[ebp]
  0514e	52		 push	 edx
  0514f	e8 00 00 00 00	 call	 ??0SOL_ListID@@QAE@ABU0@@Z ; SOL_ListID::SOL_ListID
  05154	8d 45 bc	 lea	 eax, DWORD PTR $T62623[ebp]
  05157	50		 push	 eax
  05158	e8 00 00 00 00	 call	 ?BuildPolygonList@@YA?AVMemID@@USOL_ListID@@H@Z ; BuildPolygonList
  0515d	83 c4 0c	 add	 esp, 12			; 0000000cH
  05160	50		 push	 eax
  05161	8d 4d e4	 lea	 ecx, DWORD PTR _polygonListID$[ebp]
  05164	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID

; 3224 : 
; 3225 : 	pm.acc = (Acc) GetPath(A,B,(SOL_Polygon*) memMgr->GetAddr(polygonListID),optimize,plane);

  05169	8d 4d e0	 lea	 ecx, DWORD PTR _plane$[ebp]
  0516c	51		 push	 ecx
  0516d	8b 55 dc	 mov	 edx, DWORD PTR _optimize$[ebp]
  05170	52		 push	 edx
  05171	8d 4d e4	 lea	 ecx, DWORD PTR _polygonListID$[ebp]
  05174	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  05179	50		 push	 eax
  0517a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  05180	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr
  05185	50		 push	 eax
  05186	8d 45 ec	 lea	 eax, DWORD PTR _B$[ebp]
  05189	50		 push	 eax
  0518a	8d 4d f0	 lea	 ecx, DWORD PTR _A$[ebp]
  0518d	51		 push	 ecx
  0518e	8d 55 b8	 lea	 edx, DWORD PTR $T62624[ebp]
  05191	52		 push	 edx
  05192	e8 00 00 00 00	 call	 ?GetPath@@YA?AVMemID@@AAUSCI_Point@@0PAVSOL_Polygon@@H0@Z ; GetPath
  05197	83 c4 18	 add	 esp, 24			; 00000018H
  0519a	8b c8		 mov	 ecx, eax
  0519c	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  051a1	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  051a6	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 3226 :    polygonListID.Free();

  051ab	8d 4d e4	 lea	 ecx, DWORD PTR _polygonListID$[ebp]
  051ae	e8 00 00 00 00	 call	 ?Free@MemID@@QAEXXZ	; MemID::Free

; 3227 : 
; 3228 : 	gCheckPlaneEdge = _CHECK_VERT | _CHECK_HORIZ;

  051b3	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?gCheckPlaneEdge@@3HA, 3 ; gCheckPlaneEdge
$L62131:

; 3229 : }

  051bd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  051c0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  051c7	8b e5		 mov	 esp, ebp
  051c9	5d		 pop	 ebp
  051ca	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L62625:
  00074	8d 4d cc	 lea	 ecx, DWORD PTR _array$62142[ebp]
  00077	e8 00 00 00 00	 call	 ??1Array@@QAE@XZ	; Array::~Array
  0007c	c3		 ret	 0
$L62628:
  0007d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T62627
  00082	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?KAvoidPath@@YAXPAF@Z ENDP				; KAvoidPath
PUBLIC	?KTestPoly@@YAXPAF@Z				; KTestPoly
xdata$x	SEGMENT
$T62635	DD	019930520H
	DD	01H
	DD	FLAT:$T62637
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T62637	DD	0ffffffffH
	DD	FLAT:$L62633
xdata$x	ENDS
_TEXT	SEGMENT
$T62631 = -36
$T62632 = -40
__$EHRec$ = -12
_args$ = 8
_polygonID$ = -20
_arrayID$ = -32
_pointsArray$ = -28
_points$ = -24
_size$ = -16
?KTestPoly@@YAXPAF@Z PROC NEAR				; KTestPoly

; 3232 : {	

  051cb	55		 push	 ebp
  051cc	8b ec		 mov	 ebp, esp
  051ce	6a ff		 push	 -1
  051d0	68 00 00 00 00	 push	 $L62636
  051d5	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  051db	50		 push	 eax
  051dc	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  051e3	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 3233 :    // Input
; 3234 :    // Arg1 = polygon
; 3235 : 
; 3236 :    // Output
; 3237 :    // pm.acc = 1 for clockwise;
; 3238 :    //          -1 for counterclockwise;
; 3239 :    //          directions are screen directions
; 3240 : 
; 3241 :    ObjectID polygonID = (ObjectID) arg(1);

  051e6	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  051e9	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  051ed	51		 push	 ecx
  051ee	8d 4d dc	 lea	 ecx, DWORD PTR $T62631[ebp]
  051f1	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  051f6	50		 push	 eax
  051f7	8d 4d ec	 lea	 ecx, DWORD PTR _polygonID$[ebp]
  051fa	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID

; 3242 : 
; 3243 : 	ObjectID arrayID = polygonID.GetProperty ( s_points );

  051ff	6a 5b		 push	 91			; 0000005bH
  05201	8d 4d ec	 lea	 ecx, DWORD PTR _polygonID$[ebp]
  05204	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  05209	50		 push	 eax
  0520a	8d 4d e0	 lea	 ecx, DWORD PTR _arrayID$[ebp]
  0520d	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID

; 3244 : 	Array pointsArray ( arrayID.GetProperty ( s_data ) );

  05212	6a 71		 push	 113			; 00000071H
  05214	8d 4d e0	 lea	 ecx, DWORD PTR _arrayID$[ebp]
  05217	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  0521c	51		 push	 ecx
  0521d	8b cc		 mov	 ecx, esp
  0521f	89 65 d8	 mov	 DWORD PTR $T62632[ebp], esp
  05222	50		 push	 eax
  05223	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  05228	8d 4d e4	 lea	 ecx, DWORD PTR _pointsArray$[ebp]
  0522b	e8 00 00 00 00	 call	 ??0Array@@QAE@VMemID@@@Z ; Array::Array
  05230	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 3245 :    SCI_Point* points = (SCI_Point*) pointsArray.calcAddress ( 0 );

  05237	6a 00		 push	 0
  05239	8d 4d e4	 lea	 ecx, DWORD PTR _pointsArray$[ebp]
  0523c	e8 00 00 00 00	 call	 ?calcAddress@Array@@QAEPAXH@Z ; Array::calcAddress
  05241	89 45 e8	 mov	 DWORD PTR _points$[ebp], eax

; 3246 : 
; 3247 : 	int size = polygonID.GetProperty(s_size);

  05244	6a 5a		 push	 90			; 0000005aH
  05246	8d 4d ec	 lea	 ecx, DWORD PTR _polygonID$[ebp]
  05249	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  0524e	0f bf d0	 movsx	 edx, ax
  05251	89 55 f0	 mov	 DWORD PTR _size$[ebp], edx

; 3248 : 
; 3249 : 	if ( argCount == 1) {

  05254	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  05257	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0525a	83 f9 01	 cmp	 ecx, 1
  0525d	75 2c		 jne	 SHORT $L62167

; 3250 : 	   if (TestClockwise(points,size) < 0)

  0525f	8b 55 f0	 mov	 edx, DWORD PTR _size$[ebp]
  05262	52		 push	 edx
  05263	8b 45 e8	 mov	 eax, DWORD PTR _points$[ebp]
  05266	50		 push	 eax
  05267	e8 00 00 00 00	 call	 ?TestClockwise@@YAHPAUSCI_Point@@H@Z ; TestClockwise
  0526c	83 c4 08	 add	 esp, 8
  0526f	85 c0		 test	 eax, eax
  05271	7d 0c		 jge	 SHORT $L62168

; 3251 :    	   pm.acc = 1;

  05273	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, 1

; 3252 : 	   else

  0527d	eb 0a		 jmp	 SHORT $L62169
$L62168:

; 3253 :    	   pm.acc = -1;

  0527f	c7 05 04 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, -1
$L62169:

; 3254 : 	} else {

  05289	eb 10		 jmp	 SHORT $L62170
$L62167:

; 3255 : 		InvertPolygon ( points, size );

  0528b	8b 4d f0	 mov	 ecx, DWORD PTR _size$[ebp]
  0528e	51		 push	 ecx
  0528f	8b 55 e8	 mov	 edx, DWORD PTR _points$[ebp]
  05292	52		 push	 edx
  05293	e8 00 00 00 00	 call	 ?InvertPolygon@@YAXPAUSCI_Point@@H@Z ; InvertPolygon
  05298	83 c4 08	 add	 esp, 8
$L62170:

; 3257 : }

  0529b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  052a2	8d 4d e4	 lea	 ecx, DWORD PTR _pointsArray$[ebp]
  052a5	e8 00 00 00 00	 call	 ??1Array@@QAE@XZ	; Array::~Array
  052aa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  052ad	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  052b4	8b e5		 mov	 esp, ebp
  052b6	5d		 pop	 ebp
  052b7	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L62633:
  00087	8d 4d e4	 lea	 ecx, DWORD PTR _pointsArray$[ebp]
  0008a	e8 00 00 00 00	 call	 ??1Array@@QAE@XZ	; Array::~Array
  0008f	c3		 ret	 0
$L62636:
  00090	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T62635
  00095	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?KTestPoly@@YAXPAF@Z ENDP				; KTestPoly
END
