	TITLE	C:\Documents and Settings\don\Desktop\sciw\Interp\Rect.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??0SOL_Point@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@NN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SOL_Point@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeEmpty@SOL_Rect@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Xlen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ylen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8SOL_Rect@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SOL_Rect@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?Intersect@SOL_Rect@@QBEHABV1@PAV1@@Z		; SOL_Rect::Intersect
PUBLIC	??4SOL_Rect@@QAEAAV0@ABV0@@Z			; SOL_Rect::operator=
_TEXT	SEGMENT
_r$ = 8
_clip$ = 12
_this$ = -4
?Intersect@SOL_Rect@@QBEHABV1@PAV1@@Z PROC NEAR		; SOL_Rect::Intersect

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 11   : 	if ((B.x<r.A.x) || (B.y<r.A.y) || (A.x>r.B.x) || (A.y>r.B.y))

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  0000d	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00010	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00012	7c 29		 jl	 SHORT $L978
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  0001a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0001d	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00020	7c 1b		 jl	 SHORT $L978
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00028	8b 10		 mov	 edx, DWORD PTR [eax]
  0002a	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0002d	7f 0e		 jg	 SHORT $L978
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00035	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00038	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  0003b	7e 04		 jle	 SHORT $L977
$L978:

; 12   : 		return False;

  0003d	33 c0		 xor	 eax, eax
  0003f	eb 75		 jmp	 SHORT $L976
$L977:

; 13   : 	*clip = *this;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	50		 push	 eax
  00045	8b 4d 0c	 mov	 ecx, DWORD PTR _clip$[ebp]
  00048	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 14   : 	// Calculate overlap
; 15   : 	if (A.x < r.A.x)

  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00053	8b 01		 mov	 eax, DWORD PTR [ecx]
  00055	3b 02		 cmp	 eax, DWORD PTR [edx]
  00057	7d 0a		 jge	 SHORT $L979

; 16   : 		clip->A.x = r.A.x;

  00059	8b 4d 0c	 mov	 ecx, DWORD PTR _clip$[ebp]
  0005c	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  0005f	8b 02		 mov	 eax, DWORD PTR [edx]
  00061	89 01		 mov	 DWORD PTR [ecx], eax
$L979:

; 17   : 	if (A.y < r.A.y)

  00063	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00069	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0006c	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  0006f	7d 0c		 jge	 SHORT $L980

; 18   : 		clip->A.y = r.A.y;

  00071	8b 4d 0c	 mov	 ecx, DWORD PTR _clip$[ebp]
  00074	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00077	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0007a	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$L980:

; 19   : 	if (B.x > r.B.x)

  0007d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00083	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00086	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00089	7e 0c		 jle	 SHORT $L981

; 20   : 		clip->B.x = r.B.x;

  0008b	8b 4d 0c	 mov	 ecx, DWORD PTR _clip$[ebp]
  0008e	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00091	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00094	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L981:

; 21   : 	if (B.y > r.B.y)

  00097	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  0009d	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  000a0	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  000a3	7e 0c		 jle	 SHORT $L982

; 22   : 		clip->B.y = r.B.y;

  000a5	8b 4d 0c	 mov	 ecx, DWORD PTR _clip$[ebp]
  000a8	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  000ab	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000ae	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$L982:

; 23   : 	return True;

  000b1	b8 01 00 00 00	 mov	 eax, 1
$L976:

; 24   : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c2 08 00	 ret	 8
?Intersect@SOL_Rect@@QBEHABV1@PAV1@@Z ENDP		; SOL_Rect::Intersect
_TEXT	ENDS
PUBLIC	??4SOL_Point@@QAEAAV0@ABV0@@Z			; SOL_Point::operator=
;	COMDAT ??4SOL_Rect@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??4SOL_Rect@@QAEAAV0@ABV0@@Z PROC NEAR			; SOL_Rect::operator=, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??4SOL_Point@@QAEAAV0@ABV0@@Z ; SOL_Point::operator=
  00013	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00016	83 c1 08	 add	 ecx, 8
  00019	51		 push	 ecx
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 08	 add	 ecx, 8
  00020	e8 00 00 00 00	 call	 ??4SOL_Point@@QAEAAV0@ABV0@@Z ; SOL_Point::operator=
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??4SOL_Rect@@QAEAAV0@ABV0@@Z ENDP			; SOL_Rect::operator=
_TEXT	ENDS
;	COMDAT ??4SOL_Point@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
??4SOL_Point@@QAEAAV0@ABV0@@Z PROC NEAR			; SOL_Point::operator=, COMDAT

; 117  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 118  : 	x = p.x;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx

; 119  : 	y = p.y;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00017	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001a	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 120  : 	return *this;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 121  : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??4SOL_Point@@QAEAAV0@ABV0@@Z ENDP			; SOL_Point::operator=
_TEXT	ENDS
PUBLIC	?Intersect@SOL_Rect@@QBEHABV1@@Z		; SOL_Rect::Intersect
PUBLIC	?Split@SOL_Rect@@QAEHAAV1@PAV1@@Z		; SOL_Rect::Split
PUBLIC	??0SOL_Rect@@QAE@ABV0@@Z			; SOL_Rect::SOL_Rect
_TEXT	SEGMENT
_super$ = 8
_rectangles$ = 12
_this$ = -24
_i$ = -4
_r$993 = -20
?Split@SOL_Rect@@QAEHAAV1@PAV1@@Z PROC NEAR		; SOL_Rect::Split

; 30   : {

  000bc	55		 push	 ebp
  000bd	8b ec		 mov	 ebp, esp
  000bf	83 ec 18	 sub	 esp, 24			; 00000018H
  000c2	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 31   : 	/* This routine breaks apart this rectangle into multiple rectangles based
; 32   : 	 	upon the overlap of the super rectangle. Resulting rectangles are not
; 33   : 	 	overlaped by the super rectangle. 
; 34   : 	 	The return value is:
; 35   : 			-1 if no overlap.
; 36   : 		 	0 if this rectangle is completely overlaped.
; 37   : 		 	1,2,3 or 4 if this rectangle is partially overlaped.
; 38   : 	*/
; 39   : 
; 40   : 	int	i = -1;		

  000c5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _i$[ebp], -1

; 41   : 
; 42   : 	if (Intersect(super)) {

  000cc	8b 45 08	 mov	 eax, DWORD PTR _super$[ebp]
  000cf	50		 push	 eax
  000d0	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d3	e8 00 00 00 00	 call	 ?Intersect@SOL_Rect@@QBEHABV1@@Z ; SOL_Rect::Intersect
  000d8	85 c0		 test	 eax, eax
  000da	0f 84 99 01 00
	00		 je	 $L997

; 43   : 		SOL_Rect r = *this;

  000e0	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	51		 push	 ecx
  000e4	8d 4d ec	 lea	 ecx, DWORD PTR _r$993[ebp]
  000e7	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@ABV0@@Z ; SOL_Rect::SOL_Rect

; 44   : 		++i;

  000ec	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000ef	83 c2 01	 add	 edx, 1
  000f2	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx

; 45   : 
; 46   : 		// Check top and bottom first because the run length
; 47   : 		// encoding has row pointers
; 48   : 		if (r.A.y < super.A.y)	{

  000f5	8b 45 08	 mov	 eax, DWORD PTR _super$[ebp]
  000f8	8b 4d f0	 mov	 ecx, DWORD PTR _r$993[ebp+4]
  000fb	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  000fe	7d 5f		 jge	 SHORT $L994

; 49   : 			rectangles[i].A.y = A.y;

  00100	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00103	c1 e2 04	 shl	 edx, 4
  00106	8b 45 0c	 mov	 eax, DWORD PTR _rectangles$[ebp]
  00109	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0010c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0010f	89 4c 10 04	 mov	 DWORD PTR [eax+edx+4], ecx

; 50   : 			rectangles[i].A.x = A.x;

  00113	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00116	c1 e2 04	 shl	 edx, 4
  00119	8b 45 0c	 mov	 eax, DWORD PTR _rectangles$[ebp]
  0011c	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0011f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00121	89 0c 10	 mov	 DWORD PTR [eax+edx], ecx

; 51   : 			rectangles[i].B.y = super.A.y - 1;

  00124	8b 55 08	 mov	 edx, DWORD PTR _super$[ebp]
  00127	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0012a	83 e8 01	 sub	 eax, 1
  0012d	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00130	c1 e1 04	 shl	 ecx, 4
  00133	8b 55 0c	 mov	 edx, DWORD PTR _rectangles$[ebp]
  00136	89 44 0a 0c	 mov	 DWORD PTR [edx+ecx+12], eax

; 52   : 			rectangles[i++].B.x = B.x;

  0013a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0013d	c1 e0 04	 shl	 eax, 4
  00140	8b 4d 0c	 mov	 ecx, DWORD PTR _rectangles$[ebp]
  00143	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00146	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  00149	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx
  0014d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00150	83 c0 01	 add	 eax, 1
  00153	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 53   : 			r.A.y = super.A.y;

  00156	8b 4d 08	 mov	 ecx, DWORD PTR _super$[ebp]
  00159	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0015c	89 55 f0	 mov	 DWORD PTR _r$993[ebp+4], edx
$L994:

; 55   : 
; 56   : 		if (r.B.y > super.B.y)	{

  0015f	8b 45 08	 mov	 eax, DWORD PTR _super$[ebp]
  00162	8b 4d f8	 mov	 ecx, DWORD PTR _r$993[ebp+12]
  00165	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00168	7e 57		 jle	 SHORT $L995

; 57   : 			rectangles[i].A.y = super.B.y + 1;

  0016a	8b 55 08	 mov	 edx, DWORD PTR _super$[ebp]
  0016d	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00170	83 c0 01	 add	 eax, 1
  00173	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00176	c1 e1 04	 shl	 ecx, 4
  00179	8b 55 0c	 mov	 edx, DWORD PTR _rectangles$[ebp]
  0017c	89 44 0a 04	 mov	 DWORD PTR [edx+ecx+4], eax

; 58   : 			rectangles[i].A.x = r.A.x;

  00180	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00183	c1 e0 04	 shl	 eax, 4
  00186	8b 4d 0c	 mov	 ecx, DWORD PTR _rectangles$[ebp]
  00189	8b 55 ec	 mov	 edx, DWORD PTR _r$993[ebp]
  0018c	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 59   : 			rectangles[i].B.y = r.B.y;

  0018f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00192	c1 e0 04	 shl	 eax, 4
  00195	8b 4d 0c	 mov	 ecx, DWORD PTR _rectangles$[ebp]
  00198	8b 55 f8	 mov	 edx, DWORD PTR _r$993[ebp+12]
  0019b	89 54 01 0c	 mov	 DWORD PTR [ecx+eax+12], edx

; 60   : 			rectangles[i++].B.x = r.B.x;

  0019f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  001a2	c1 e0 04	 shl	 eax, 4
  001a5	8b 4d 0c	 mov	 ecx, DWORD PTR _rectangles$[ebp]
  001a8	8b 55 f4	 mov	 edx, DWORD PTR _r$993[ebp+8]
  001ab	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx
  001af	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  001b2	83 c0 01	 add	 eax, 1
  001b5	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 61   : 			r.B.y = super.B.y;

  001b8	8b 4d 08	 mov	 ecx, DWORD PTR _super$[ebp]
  001bb	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  001be	89 55 f8	 mov	 DWORD PTR _r$993[ebp+12], edx
$L995:

; 63   : 
; 64   : 		if (r.A.x < super.A.x)	{

  001c1	8b 45 08	 mov	 eax, DWORD PTR _super$[ebp]
  001c4	8b 4d ec	 mov	 ecx, DWORD PTR _r$993[ebp]
  001c7	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001c9	7d 55		 jge	 SHORT $L996

; 65   : 			rectangles[i].A.y = r.A.y;

  001cb	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  001ce	c1 e2 04	 shl	 edx, 4
  001d1	8b 45 0c	 mov	 eax, DWORD PTR _rectangles$[ebp]
  001d4	8b 4d f0	 mov	 ecx, DWORD PTR _r$993[ebp+4]
  001d7	89 4c 10 04	 mov	 DWORD PTR [eax+edx+4], ecx

; 66   : 			rectangles[i].A.x = r.A.x;

  001db	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  001de	c1 e2 04	 shl	 edx, 4
  001e1	8b 45 0c	 mov	 eax, DWORD PTR _rectangles$[ebp]
  001e4	8b 4d ec	 mov	 ecx, DWORD PTR _r$993[ebp]
  001e7	89 0c 10	 mov	 DWORD PTR [eax+edx], ecx

; 67   : 			rectangles[i].B.y = r.B.y;

  001ea	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  001ed	c1 e2 04	 shl	 edx, 4
  001f0	8b 45 0c	 mov	 eax, DWORD PTR _rectangles$[ebp]
  001f3	8b 4d f8	 mov	 ecx, DWORD PTR _r$993[ebp+12]
  001f6	89 4c 10 0c	 mov	 DWORD PTR [eax+edx+12], ecx

; 68   : 			rectangles[i++].B.x = super.A.x - 1;

  001fa	8b 55 08	 mov	 edx, DWORD PTR _super$[ebp]
  001fd	8b 02		 mov	 eax, DWORD PTR [edx]
  001ff	83 e8 01	 sub	 eax, 1
  00202	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00205	c1 e1 04	 shl	 ecx, 4
  00208	8b 55 0c	 mov	 edx, DWORD PTR _rectangles$[ebp]
  0020b	89 44 0a 08	 mov	 DWORD PTR [edx+ecx+8], eax
  0020f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00212	83 c0 01	 add	 eax, 1
  00215	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 69   : 			r.A.x = super.A.x;

  00218	8b 4d 08	 mov	 ecx, DWORD PTR _super$[ebp]
  0021b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0021d	89 55 ec	 mov	 DWORD PTR _r$993[ebp], edx
$L996:

; 71   : 
; 72   : 		if (r.B.x > super.B.x)	{

  00220	8b 45 08	 mov	 eax, DWORD PTR _super$[ebp]
  00223	8b 4d f4	 mov	 ecx, DWORD PTR _r$993[ebp+8]
  00226	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00229	7e 4e		 jle	 SHORT $L997

; 73   : 			rectangles[i].A.y = r.A.y;

  0022b	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0022e	c1 e2 04	 shl	 edx, 4
  00231	8b 45 0c	 mov	 eax, DWORD PTR _rectangles$[ebp]
  00234	8b 4d f0	 mov	 ecx, DWORD PTR _r$993[ebp+4]
  00237	89 4c 10 04	 mov	 DWORD PTR [eax+edx+4], ecx

; 74   : 			rectangles[i].A.x = super.B.x + 1;

  0023b	8b 55 08	 mov	 edx, DWORD PTR _super$[ebp]
  0023e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00241	83 c0 01	 add	 eax, 1
  00244	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00247	c1 e1 04	 shl	 ecx, 4
  0024a	8b 55 0c	 mov	 edx, DWORD PTR _rectangles$[ebp]
  0024d	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 75   : 			rectangles[i].B.y = r.B.y;

  00250	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00253	c1 e0 04	 shl	 eax, 4
  00256	8b 4d 0c	 mov	 ecx, DWORD PTR _rectangles$[ebp]
  00259	8b 55 f8	 mov	 edx, DWORD PTR _r$993[ebp+12]
  0025c	89 54 01 0c	 mov	 DWORD PTR [ecx+eax+12], edx

; 76   : 			rectangles[i++].B.x = r.B.x;

  00260	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00263	c1 e0 04	 shl	 eax, 4
  00266	8b 4d 0c	 mov	 ecx, DWORD PTR _rectangles$[ebp]
  00269	8b 55 f4	 mov	 edx, DWORD PTR _r$993[ebp+8]
  0026c	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx
  00270	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00273	83 c0 01	 add	 eax, 1
  00276	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L997:

; 80   : 	return (i);

  00279	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]

; 81   : }

  0027c	8b e5		 mov	 esp, ebp
  0027e	5d		 pop	 ebp
  0027f	c2 08 00	 ret	 8
?Split@SOL_Rect@@QAEHAAV1@PAV1@@Z ENDP			; SOL_Rect::Split
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHABV1@@Z
_TEXT	SEGMENT
_r$ = 8
_this$ = -4
?Intersect@SOL_Rect@@QBEHABV1@@Z PROC NEAR		; SOL_Rect::Intersect, COMDAT

; 189  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 190  : 	if (B.x < r.A.x)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  0000d	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00010	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00012	7d 04		 jge	 SHORT $L896

; 191  : 		return False;

  00014	33 c0		 xor	 eax, eax
  00016	eb 3a		 jmp	 SHORT $L895
$L896:

; 192  : 	if (B.y < r.A.y)

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  0001e	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00021	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00024	7d 04		 jge	 SHORT $L897

; 193  : 		return False;

  00026	33 c0		 xor	 eax, eax
  00028	eb 28		 jmp	 SHORT $L895
$L897:

; 194  : 	if (A.x > r.B.x)

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00030	8b 10		 mov	 edx, DWORD PTR [eax]
  00032	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00035	7e 04		 jle	 SHORT $L898

; 195  : 		return False;

  00037	33 c0		 xor	 eax, eax
  00039	eb 17		 jmp	 SHORT $L895
$L898:

; 196  : 	if (A.y > r.B.y)

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00041	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00044	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00047	7e 04		 jle	 SHORT $L899

; 197  : 		return False;

  00049	33 c0		 xor	 eax, eax
  0004b	eb 05		 jmp	 SHORT $L895
$L899:

; 198  : 	return True;

  0004d	b8 01 00 00 00	 mov	 eax, 1
$L895:

; 199  : }

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?Intersect@SOL_Rect@@QBEHABV1@@Z ENDP			; SOL_Rect::Intersect
_TEXT	ENDS
PUBLIC	??0SOL_Point@@QAE@ABV0@@Z			; SOL_Point::SOL_Point
;	COMDAT ??0SOL_Rect@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0SOL_Rect@@QAE@ABV0@@Z PROC NEAR			; SOL_Rect::SOL_Rect, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  00013	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00016	83 c1 08	 add	 ecx, 8
  00019	51		 push	 ecx
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 08	 add	 ecx, 8
  00020	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??0SOL_Rect@@QAE@ABV0@@Z ENDP				; SOL_Rect::SOL_Rect
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@ABV0@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
??0SOL_Point@@QAE@ABV0@@Z PROC NEAR			; SOL_Point::SOL_Point, COMDAT

; 22   : 	SOL_Point(const SOL_Point& p) : x(p.x), y(p.y) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00017	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001a	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??0SOL_Point@@QAE@ABV0@@Z ENDP				; SOL_Point::SOL_Point
_TEXT	ENDS
PUBLIC	?IsValid@SOL_Rect@@QBEHXZ			; SOL_Rect::IsValid
PUBLIC	?IsWithin@SOL_Rect@@QBEHHH@Z			; SOL_Rect::IsWithin
_TEXT	SEGMENT
_xdim$ = 8
_ydim$ = 12
_this$ = -4
?IsWithin@SOL_Rect@@QBEHHH@Z PROC NEAR			; SOL_Rect::IsWithin

; 88   : {

  00282	55		 push	 ebp
  00283	8b ec		 mov	 ebp, esp
  00285	51		 push	 ecx
  00286	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   : 	if (!IsValid())

  00289	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0028c	e8 00 00 00 00	 call	 ?IsValid@SOL_Rect@@QBEHXZ ; SOL_Rect::IsValid
  00291	85 c0		 test	 eax, eax
  00293	75 04		 jne	 SHORT $L1006

; 90   : 		return False;

  00295	33 c0		 xor	 eax, eax
  00297	eb 34		 jmp	 SHORT $L1005
$L1006:

; 91   : 
; 92   : 	if (A.x < 0  ||  A.y < 0)

  00299	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0029c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0029f	7c 09		 jl	 SHORT $L1008
  002a1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002a4	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  002a8	7d 04		 jge	 SHORT $L1007
$L1008:

; 93   : 		return False;

  002aa	33 c0		 xor	 eax, eax
  002ac	eb 1f		 jmp	 SHORT $L1005
$L1007:

; 94   : 
; 95   : //SNREMOVE	if (B.x >= xdim  ||  B.y >= ydim)
; 96   : 	if (B.x > xdim  ||  B.y > ydim)

  002ae	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  002b1	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  002b4	3b 45 08	 cmp	 eax, DWORD PTR _xdim$[ebp]
  002b7	7f 0b		 jg	 SHORT $L1010
  002b9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002bc	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  002bf	3b 55 0c	 cmp	 edx, DWORD PTR _ydim$[ebp]
  002c2	7e 04		 jle	 SHORT $L1009
$L1010:

; 97   : 		return False;

  002c4	33 c0		 xor	 eax, eax
  002c6	eb 05		 jmp	 SHORT $L1005
$L1009:

; 98   : 
; 99   : 	return True;

  002c8	b8 01 00 00 00	 mov	 eax, 1
$L1005:

; 100  : }

  002cd	8b e5		 mov	 esp, ebp
  002cf	5d		 pop	 ebp
  002d0	c2 08 00	 ret	 8
?IsWithin@SOL_Rect@@QBEHHH@Z ENDP			; SOL_Rect::IsWithin
_TEXT	ENDS
;	COMDAT ?IsValid@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsValid@SOL_Rect@@QBEHXZ PROC NEAR			; SOL_Rect::IsValid, COMDAT

; 124  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 125  : 	if (B.x < A.x  ||  B.y < A.y)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00010	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00012	7c 0e		 jl	 SHORT $L865
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0001d	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00020	7d 04		 jge	 SHORT $L864
$L865:

; 126  : 		return False;

  00022	33 c0		 xor	 eax, eax
  00024	eb 05		 jmp	 SHORT $L863
$L864:

; 127  : 	return True;

  00026	b8 01 00 00 00	 mov	 eax, 1
$L863:

; 128  : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?IsValid@SOL_Rect@@QBEHXZ ENDP				; SOL_Rect::IsValid
_TEXT	ENDS
END
