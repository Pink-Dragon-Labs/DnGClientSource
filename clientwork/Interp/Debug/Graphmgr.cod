	TITLE	C:\Documents and Settings\don\Desktop\sciw\Interp\Graphmgr.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BM@LHED@Instructed?5to?5scale?5to?5zero?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0SOL_Point@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@NN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SOL_Point@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@HHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@AAVSOL_Point@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Set@SOL_Rect@@QAEXHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeEmpty@SOL_Rect@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Xlen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ylen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Area@SOL_Rect@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8SOL_Rect@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clip@SOL_Rect@@QAEXABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Ratio@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Ratio@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??K@YAHHABVRatio@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D@YAHHABVRatio@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MemoryMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckValid@MemoryMgr@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GMemoryMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@V1@III@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AMemID@@QBEAADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8MemID@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??7MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Rgb24@@QAE@EEE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Rgb24@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Rgb24F@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??ASOLPalette@@QAEAAVRgb24F@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@HHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@VMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Type@Bitmap@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Handle@Bitmap@@QBE?AVMemID@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObj@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResX@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResY@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Skip@CelObj@@QBEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemapState@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Mirrored@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObj@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjView@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjView@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjView@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjView@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjMem@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjMem@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjMem@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjMem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjColor@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjColor@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjColor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjColor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Id@ScreenItem@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlaneId@ScreenItem@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?X1@ScreenItem@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Y1@ScreenItem@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCount@ScreenItem@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearDeleteCount@ScreenItem@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Draw@ScreenItem@@QAEXABVBuffer@@ABVSOL_Rect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSkip@ScreenItem@@QAEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCel@ScreenItem@@QAEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadPix@ScreenItem@@QAEEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCel@ScreenItem@@QAEXPAVCelObj@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetUpdateCount@ScreenItem@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetAddCount@ScreenItem@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetDeleteCount@ScreenItem@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SubmitPalette@ScreenItem@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SOL_Rect@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Draw@DrawItem@@QAEXAAVBuffer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnScreen@DrawItem@@QAEAAVSOL_Rect@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SI@DrawItem@@QAEAAVScreenItem@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@DrawList@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??ADrawList@@QAEAAVDrawItem@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCount@SOL_Plane@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Color@SOL_Plane@@QBEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DefRect@SOL_Plane@@QBEABVSOL_Rect@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Id@SOL_Plane@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsColored@SOL_Plane@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnScreen@SOL_Plane@@QAEAAVSOL_Rect@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PackSiArray@SOL_Plane@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetAddCount@SOL_Plane@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetDeleteCount@SOL_Plane@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetUpdateCount@SOL_Plane@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@PlaneList@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??APlaneList@@QAEAAVSOL_Plane@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??ARectList@@QBEABVSOL_Rect@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@RectList@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??ARectList@@QAEAAVSOL_Rect@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ScreenRect@Screen@@QBEABVSOL_Rect@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TopPlane@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TopSCIPlane@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Xdim@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ydim@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Planes@Screen@@QAEAAVPlaneList@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShowList@Screen@@QAEAAVRectList@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SortPlanes@Screen@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Screen@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?XDim@Buffer@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Xdim@GraphicsMgr@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ydim@GraphicsMgr@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPlaneNext@GraphicsMgr@@QAEPAVSOL_Plane@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NextScreen@GraphicsMgr@@QAEPAVScreen@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemapMarkRedraw@GraphicsMgr@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VisiblePlane@GraphicsMgr@@QAEPAVSOL_Plane@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1PaletteMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GPaletteMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeArrayID@@QBEPAUArrayHeader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ArrayID@@QAE@HW4ArrayType@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@ArrayID@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAE?AVMemID@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAEXVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_List@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@SOL_List@@QAEAAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeDispatchTblID@@QBEPAUDispatchTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeScriptEntryID@@QBEPAUScriptEntry@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntry@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeVariableID@@QBEPAUVariable@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Script@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Object@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGraphicsUpdate@Object@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?selectorDict@Object@@QAEPAVSelectorDict@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AObject@@QAEAAFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddr@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedPropAddr@Object@@QAEPBFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedProperty@Object@@QAEFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddrCheck@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@Object@@QAEFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropOffset@Object@@QAEIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetIndexedProperty@Object@@QAEXHF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetProperty@Object@@QAEXGF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssureValid@ObjectID@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsObject@ObjectID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeClassTblID@@QBEPAUClassTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1SOL_Cursor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GSOL_Cursor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GGraphicsMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Screen@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GRectList@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GDrawList@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Min@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Max@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7GraphicsMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7PaletteMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObj@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7Buffer@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjColor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7SOL_Cursor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjView@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7MemoryMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjMem@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?drawLists@@3PAPAVDrawList@@A			; drawLists
PUBLIC	?eraseLists@@3PAPAVRectList@@A			; eraseLists
PUBLIC	?graphMgr@@3PAVGraphicsMgr@@A			; graphMgr
_BSS	SEGMENT
?drawLists@@3PAPAVDrawList@@A DD 064H DUP (?)		; drawLists
?eraseLists@@3PAPAVRectList@@A DD 064H DUP (?)		; eraseLists
?graphMgr@@3PAVGraphicsMgr@@A DD 01H DUP (?)		; graphMgr
_BSS	ENDS
PUBLIC	??1Screen@@QAE@XZ				; Screen::~Screen
PUBLIC	??1GraphicsMgr@@UAE@XZ				; GraphicsMgr::~GraphicsMgr
PUBLIC	?FrameOut@GraphicsMgr@@UAEXHVSOL_Rect@@@Z	; GraphicsMgr::FrameOut
PUBLIC	?MovieFrameOut@GraphicsMgr@@UAEXVSOL_Rect@@@Z	; GraphicsMgr::MovieFrameOut
PUBLIC	?PalMorphFrameOut@GraphicsMgr@@UAEXPADPAVPlaneShowStyle@@@Z ; GraphicsMgr::PalMorphFrameOut
PUBLIC	??_7GraphicsMgr@@6B@				; GraphicsMgr::`vftable'
PUBLIC	??_GGraphicsMgr@@UAEPAXI@Z			; GraphicsMgr::`scalar deleting destructor'
PUBLIC	??_EGraphicsMgr@@UAEPAXI@Z			; GraphicsMgr::`vector deleting destructor'
EXTRN	__purecall:NEAR
EXTRN	??1Remap@@UAE@XZ:NEAR				; Remap::~Remap
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT ??_7GraphicsMgr@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\Graphmgr.cpp
CONST	SEGMENT
??_7GraphicsMgr@@6B@ DD FLAT:??_EGraphicsMgr@@UAEPAXI@Z	; GraphicsMgr::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?FrameOut@GraphicsMgr@@UAEXHVSOL_Rect@@@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?MovieFrameOut@GraphicsMgr@@UAEXVSOL_Rect@@@Z
	DD	FLAT:?PalMorphFrameOut@GraphicsMgr@@UAEXPADPAVPlaneShowStyle@@@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
xdata$x	SEGMENT
$T62306	DD	019930520H
	DD	01H
	DD	FLAT:$T62309
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T62309	DD	0ffffffffH
	DD	FLAT:$L62301
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1GraphicsMgr@@UAE@XZ PROC NEAR			; GraphicsMgr::~GraphicsMgr

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 $L62307
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7GraphicsMgr@@6B@ ; GraphicsMgr::`vftable'
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 30   : }

  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	81 c1 68 11 00
	00		 add	 ecx, 4456		; 00001168H
  00035	e8 00 00 00 00	 call	 ??1Remap@@UAE@XZ	; Remap::~Remap
  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	83 c1 14	 add	 ecx, 20			; 00000014H
  00047	e8 00 00 00 00	 call	 ??1Screen@@QAE@XZ	; Screen::~Screen
  0004c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L62301:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 14	 add	 ecx, 20			; 00000014H
  00006	e8 00 00 00 00	 call	 ??1Screen@@QAE@XZ	; Screen::~Screen
  0000b	c3		 ret	 0
$L62307:
  0000c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T62306
  00011	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1GraphicsMgr@@UAE@XZ ENDP				; GraphicsMgr::~GraphicsMgr
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
;	COMDAT ??_GGraphicsMgr@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GGraphicsMgr@@UAEPAXI@Z PROC NEAR			; GraphicsMgr::`scalar deleting destructor', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1GraphicsMgr@@UAE@XZ	; GraphicsMgr::~GraphicsMgr
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L61802
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L61802:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GGraphicsMgr@@UAEPAXI@Z ENDP				; GraphicsMgr::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??1PlaneList@@QAE@XZ:NEAR			; PlaneList::~PlaneList
EXTRN	??1RectList@@QAE@XZ:NEAR			; RectList::~RectList
;	COMDAT xdata$x
xdata$x	SEGMENT
$T62316	DD	019930520H
	DD	01H
	DD	FLAT:$T62318
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T62318	DD	0ffffffffH
	DD	FLAT:$L62313
xdata$x	ENDS
;	COMDAT ??1Screen@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1Screen@@QAE@XZ PROC NEAR				; Screen::~Screen, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 $L62317
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00023	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	81 c1 a4 01 00
	00		 add	 ecx, 420		; 000001a4H
  0002c	e8 00 00 00 00	 call	 ??1RectList@@QAE@XZ	; RectList::~RectList
  00031	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00038	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ??1PlaneList@@QAE@XZ	; PlaneList::~PlaneList
  00040	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00043	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L62313:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e8 00 00 00 00	 call	 ??1PlaneList@@QAE@XZ	; PlaneList::~PlaneList
  00008	c3		 ret	 0
$L62317:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T62316
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1Screen@@QAE@XZ ENDP					; Screen::~Screen
PUBLIC	??0Screen@@QAE@HH@Z				; Screen::Screen
PUBLIC	??0GraphicsMgr@@QAE@HH@Z			; GraphicsMgr::GraphicsMgr
EXTRN	??0Remap@@QAE@XZ:NEAR				; Remap::Remap
xdata$x	SEGMENT
$T62325	DD	019930520H
	DD	01H
	DD	FLAT:$T62327
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T62327	DD	0ffffffffH
	DD	FLAT:$L62322
xdata$x	ENDS
_TEXT	SEGMENT
_xdim$ = 8
_ydim$ = 12
_this$ = -16
__$EHRec$ = -12
??0GraphicsMgr@@QAE@HH@Z PROC NEAR			; GraphicsMgr::GraphicsMgr

; 33   : {

  0005a	55		 push	 ebp
  0005b	8b ec		 mov	 ebp, esp
  0005d	6a ff		 push	 -1
  0005f	68 00 00 00 00	 push	 $L62326
  00064	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0006a	50		 push	 eax
  0006b	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00072	51		 push	 ecx
  00073	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00076	8b 45 0c	 mov	 eax, DWORD PTR _ydim$[ebp]
  00079	50		 push	 eax
  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _xdim$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00081	83 c1 14	 add	 ecx, 20			; 00000014H
  00084	e8 00 00 00 00	 call	 ??0Screen@@QAE@HH@Z	; Screen::Screen
  00089	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00090	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	81 c1 68 11 00
	00		 add	 ecx, 4456		; 00001168H
  00099	e8 00 00 00 00	 call	 ??0Remap@@QAE@XZ	; Remap::Remap
  0009e	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000a1	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET FLAT:??_7GraphicsMgr@@6B@ ; GraphicsMgr::`vftable'

; 34   :    magHead = NULL;

  000a7	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000aa	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 35   : 	timingFlag = False;

  000b1	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	66 c7 81 94 11
	00 00 00 00	 mov	 WORD PTR [ecx+4500], 0

; 36   : 	pixelsPerCall = 0;

  000bd	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000c0	c7 82 64 11 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+4452], 0

; 37   : 	resizeFlag = False;

  000ca	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000cd	c7 80 90 11 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+4496], 0

; 38   : 	vmapValid = False;

  000d7	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 39   : 	morphOn = 0;

  000e1	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000e4	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 40   : }

  000eb	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000f2	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000f5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c2 08 00	 ret	 8
_TEXT	ENDS
text$x	SEGMENT
$L62322:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 14	 add	 ecx, 20			; 00000014H
  0001c	e8 00 00 00 00	 call	 ??1Screen@@QAE@XZ	; Screen::~Screen
  00021	c3		 ret	 0
$L62326:
  00022	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T62325
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0GraphicsMgr@@QAE@HH@Z ENDP				; GraphicsMgr::GraphicsMgr
PUBLIC	?Id@ScreenItem@@QBEJXZ				; ScreenItem::Id
PUBLIC	?PlaneId@ScreenItem@@QBEJXZ			; ScreenItem::PlaneId
PUBLIC	?AddCount@ScreenItem@@QBEHXZ			; ScreenItem::AddCount
PUBLIC	?ClearDeleteCount@ScreenItem@@QAEXXZ		; ScreenItem::ClearDeleteCount
PUBLIC	?SetCel@ScreenItem@@QAEXPAVCelObj@@@Z		; ScreenItem::SetCel
PUBLIC	?SetUpdateCount@ScreenItem@@QAEXH@Z		; ScreenItem::SetUpdateCount
PUBLIC	?NextScreen@GraphicsMgr@@QAEPAVScreen@@XZ	; GraphicsMgr::NextScreen
PUBLIC	?UpdateScreenItem@GraphicsMgr@@QAEXPAVScreenItem@@@Z ; GraphicsMgr::UpdateScreenItem
EXTRN	?GetScreenItem@Screen@@QAEPAVScreenItem@@HJ@Z:NEAR ; Screen::GetScreenItem
EXTRN	?Fatal@MsgMgr@@QAAXPADZZ:NEAR			; MsgMgr::Fatal
EXTRN	?msgMgr@@3PAVMsgMgr@@A:DWORD			; msgMgr
_DATA	SEGMENT
$SG61815 DB	'UpdateScreenItem has been passed a NULL pointer.', 00H
_DATA	ENDS
_TEXT	SEGMENT
_si$ = 8
_this$ = -4
?UpdateScreenItem@GraphicsMgr@@QAEXPAVScreenItem@@@Z PROC NEAR ; GraphicsMgr::UpdateScreenItem

; 44   : {

  00105	55		 push	 ebp
  00106	8b ec		 mov	 ebp, esp
  00108	51		 push	 ecx
  00109	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 45   : 	if ( !si )

  0010c	83 7d 08 00	 cmp	 DWORD PTR _si$[ebp], 0
  00110	75 13		 jne	 SHORT $L61814

; 46   : 		msgMgr->Fatal ( "UpdateScreenItem has been passed a NULL pointer." );

  00112	68 00 00 00 00	 push	 OFFSET FLAT:$SG61815
  00117	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00122	83 c4 08	 add	 esp, 8
$L61814:

; 47   : 
; 48   : 	// Make sure we have a valid screen item
; 49   : 	if (si != graphMgr->NextScreen()->GetScreenItem(si->PlaneId(),si->Id()))

  00125	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  00128	e8 00 00 00 00	 call	 ?Id@ScreenItem@@QBEJXZ	; ScreenItem::Id
  0012d	50		 push	 eax
  0012e	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  00131	e8 00 00 00 00	 call	 ?PlaneId@ScreenItem@@QBEJXZ ; ScreenItem::PlaneId
  00136	50		 push	 eax
  00137	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  0013d	e8 00 00 00 00	 call	 ?NextScreen@GraphicsMgr@@QAEPAVScreen@@XZ ; GraphicsMgr::NextScreen
  00142	8b c8		 mov	 ecx, eax
  00144	e8 00 00 00 00	 call	 ?GetScreenItem@Screen@@QAEPAVScreenItem@@HJ@Z ; Screen::GetScreenItem
  00149	39 45 08	 cmp	 DWORD PTR _si$[ebp], eax
  0014c	74 02		 je	 SHORT $L61816

; 50   : 		return;

  0014e	eb 38		 jmp	 SHORT $L61813
$L61816:

; 51   : //		msgMgr->Fatal(SrcLoc,Msg_ScreenItemNotExist);
; 52   : 
; 53   : 	if (!si->AddCount())

  00150	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  00153	e8 00 00 00 00	 call	 ?AddCount@ScreenItem@@QBEHXZ ; ScreenItem::AddCount
  00158	85 c0		 test	 eax, eax
  0015a	75 1a		 jne	 SHORT $L61817

; 54   : 		si->SetUpdateCount(graphMgr->ScreenCount());

  0015c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  00162	8b 11		 mov	 edx, DWORD PTR [ecx]
  00164	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  0016a	ff 52 04	 call	 DWORD PTR [edx+4]
  0016d	50		 push	 eax
  0016e	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  00171	e8 00 00 00 00	 call	 ?SetUpdateCount@ScreenItem@@QAEXH@Z ; ScreenItem::SetUpdateCount
$L61817:

; 55   : 
; 56   : 	// If deleted and added without an intermediate
; 57   : 	// FrameOut then the add will result in an update
; 58   : 	// and the deleteCount must be cleared
; 59   : 	si->ClearDeleteCount();

  00176	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  00179	e8 00 00 00 00	 call	 ?ClearDeleteCount@ScreenItem@@QAEXXZ ; ScreenItem::ClearDeleteCount

; 60   : 	si->SetCel(NULL);

  0017e	6a 00		 push	 0
  00180	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  00183	e8 00 00 00 00	 call	 ?SetCel@ScreenItem@@QAEXPAVCelObj@@@Z ; ScreenItem::SetCel
$L61813:

; 61   : }

  00188	8b e5		 mov	 esp, ebp
  0018a	5d		 pop	 ebp
  0018b	c2 04 00	 ret	 4
?UpdateScreenItem@GraphicsMgr@@QAEXPAVScreenItem@@@Z ENDP ; GraphicsMgr::UpdateScreenItem
_TEXT	ENDS
PUBLIC	?SetAddCount@ScreenItem@@QAEXH@Z		; ScreenItem::SetAddCount
PUBLIC	?SetDeleteCount@ScreenItem@@QAEXH@Z		; ScreenItem::SetDeleteCount
PUBLIC	?PackSiArray@SOL_Plane@@QAEXXZ			; SOL_Plane::PackSiArray
PUBLIC	?DeleteScreenItem@GraphicsMgr@@QAEXPAVScreenItem@@H@Z ; GraphicsMgr::DeleteScreenItem
PUBLIC	?GetPlaneNext@GraphicsMgr@@QAEPAVSOL_Plane@@H@Z	; GraphicsMgr::GetPlaneNext
EXTRN	?AbortScreenItem@SOL_Plane@@QAEXPBVScreenItem@@@Z:NEAR ; SOL_Plane::AbortScreenItem
_TEXT	SEGMENT
_si$ = 8
_planeId$ = 12
_this$ = -8
_plane$61824 = -4
?DeleteScreenItem@GraphicsMgr@@QAEXPAVScreenItem@@H@Z PROC NEAR ; GraphicsMgr::DeleteScreenItem

; 65   : {

  0018e	55		 push	 ebp
  0018f	8b ec		 mov	 ebp, esp
  00191	83 ec 08	 sub	 esp, 8
  00194	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 66   : 	// Assume we have a valid screen item
; 67   : 
; 68   : 	if (si->AddCount()) {

  00197	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  0019a	e8 00 00 00 00	 call	 ?AddCount@ScreenItem@@QBEHXZ ; ScreenItem::AddCount
  0019f	85 c0		 test	 eax, eax
  001a1	74 25		 je	 SHORT $L61823

; 69   : 		// This screen item has not be processed by a frameout
; 70   : 		// Just get rid of the screen item in the next screen
; 71   : 		SOL_Plane* plane = GetPlaneNext(planeId);

  001a3	8b 45 0c	 mov	 eax, DWORD PTR _planeId$[ebp]
  001a6	50		 push	 eax
  001a7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001aa	e8 00 00 00 00	 call	 ?GetPlaneNext@GraphicsMgr@@QAEPAVSOL_Plane@@H@Z ; GraphicsMgr::GetPlaneNext
  001af	89 45 fc	 mov	 DWORD PTR _plane$61824[ebp], eax

; 72   : 		plane->AbortScreenItem(si);

  001b2	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  001b5	51		 push	 ecx
  001b6	8b 4d fc	 mov	 ecx, DWORD PTR _plane$61824[ebp]
  001b9	e8 00 00 00 00	 call	 ?AbortScreenItem@SOL_Plane@@QAEXPBVScreenItem@@@Z ; SOL_Plane::AbortScreenItem

; 73   : 		plane->PackSiArray();

  001be	8b 4d fc	 mov	 ecx, DWORD PTR _plane$61824[ebp]
  001c1	e8 00 00 00 00	 call	 ?PackSiArray@SOL_Plane@@QAEXXZ ; SOL_Plane::PackSiArray

; 75   : 	else {

  001c6	eb 2e		 jmp	 SHORT $L61825
$L61823:

; 76   : 		si->SetDeleteCount(graphMgr->ScreenCount());

  001c8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  001ce	8b 02		 mov	 eax, DWORD PTR [edx]
  001d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  001d6	ff 50 04	 call	 DWORD PTR [eax+4]
  001d9	50		 push	 eax
  001da	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  001dd	e8 00 00 00 00	 call	 ?SetDeleteCount@ScreenItem@@QAEXH@Z ; ScreenItem::SetDeleteCount

; 77   : 		si->SetAddCount(0);

  001e2	6a 00		 push	 0
  001e4	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  001e7	e8 00 00 00 00	 call	 ?SetAddCount@ScreenItem@@QAEXH@Z ; ScreenItem::SetAddCount

; 78   : 		si->SetUpdateCount(0);

  001ec	6a 00		 push	 0
  001ee	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  001f1	e8 00 00 00 00	 call	 ?SetUpdateCount@ScreenItem@@QAEXH@Z ; ScreenItem::SetUpdateCount
$L61825:

; 80   : }

  001f6	8b e5		 mov	 esp, ebp
  001f8	5d		 pop	 ebp
  001f9	c2 08 00	 ret	 8
?DeleteScreenItem@GraphicsMgr@@QAEXPAVScreenItem@@H@Z ENDP ; GraphicsMgr::DeleteScreenItem
_TEXT	ENDS
PUBLIC	?DeleteScreenItem@GraphicsMgr@@QAEXPAVScreenItem@@@Z ; GraphicsMgr::DeleteScreenItem
_TEXT	SEGMENT
_si$ = 8
_this$ = -8
_planeId$ = -4
?DeleteScreenItem@GraphicsMgr@@QAEXPAVScreenItem@@@Z PROC NEAR ; GraphicsMgr::DeleteScreenItem

; 84   : {

  001fc	55		 push	 ebp
  001fd	8b ec		 mov	 ebp, esp
  001ff	83 ec 08	 sub	 esp, 8
  00202	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 85   : 	// Make sure we have a valid screen item
; 86   : 	int planeId = si->PlaneId();

  00205	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  00208	e8 00 00 00 00	 call	 ?PlaneId@ScreenItem@@QBEJXZ ; ScreenItem::PlaneId
  0020d	89 45 fc	 mov	 DWORD PTR _planeId$[ebp], eax

; 87   : 	if (si != graphMgr->NextScreen()->GetScreenItem(planeId, si->Id()))

  00210	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  00213	e8 00 00 00 00	 call	 ?Id@ScreenItem@@QBEJXZ	; ScreenItem::Id
  00218	50		 push	 eax
  00219	8b 45 fc	 mov	 eax, DWORD PTR _planeId$[ebp]
  0021c	50		 push	 eax
  0021d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  00223	e8 00 00 00 00	 call	 ?NextScreen@GraphicsMgr@@QAEPAVScreen@@XZ ; GraphicsMgr::NextScreen
  00228	8b c8		 mov	 ecx, eax
  0022a	e8 00 00 00 00	 call	 ?GetScreenItem@Screen@@QAEPAVScreenItem@@HJ@Z ; Screen::GetScreenItem
  0022f	39 45 08	 cmp	 DWORD PTR _si$[ebp], eax
  00232	74 02		 je	 SHORT $L61831

; 88   : 		return;

  00234	eb 10		 jmp	 SHORT $L61829
$L61831:

; 89   : //		msgMgr->Fatal(SrcLoc,Msg_ScreenItemNotExist);
; 90   : 
; 91   : 	DeleteScreenItem(si, planeId);

  00236	8b 4d fc	 mov	 ecx, DWORD PTR _planeId$[ebp]
  00239	51		 push	 ecx
  0023a	8b 55 08	 mov	 edx, DWORD PTR _si$[ebp]
  0023d	52		 push	 edx
  0023e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00241	e8 00 00 00 00	 call	 ?DeleteScreenItem@GraphicsMgr@@QAEXPAVScreenItem@@H@Z ; GraphicsMgr::DeleteScreenItem
$L61829:

; 92   : }

  00246	8b e5		 mov	 esp, ebp
  00248	5d		 pop	 ebp
  00249	c2 04 00	 ret	 4
?DeleteScreenItem@GraphicsMgr@@QAEXPAVScreenItem@@@Z ENDP ; GraphicsMgr::DeleteScreenItem
_TEXT	ENDS
PUBLIC	?ScreenRect@Screen@@QBEABVSOL_Rect@@XZ		; Screen::ScreenRect
PUBLIC	?SortPlanes@Screen@@QAEXXZ			; Screen::SortPlanes
PUBLIC	?Id@SOL_Plane@@QBEJXZ				; SOL_Plane::Id
PUBLIC	?OnScreen@SOL_Plane@@QAEAAVSOL_Rect@@XZ		; SOL_Plane::OnScreen
PUBLIC	?Clip@SOL_Rect@@QAEXABV1@@Z			; SOL_Rect::Clip
PUBLIC	?UpdatePlane@GraphicsMgr@@QAEXPAVSOL_Plane@@@Z	; GraphicsMgr::UpdatePlane
PUBLIC	?VisiblePlane@GraphicsMgr@@QAEPAVSOL_Plane@@H@Z	; GraphicsMgr::VisiblePlane
EXTRN	?UpdatePlane@SOL_Plane@@QAEXPAV1@@Z:NEAR	; SOL_Plane::UpdatePlane
_TEXT	SEGMENT
_plane$ = 8
_this$ = -8
_currentPlane$ = -4
?UpdatePlane@GraphicsMgr@@QAEXPAVSOL_Plane@@@Z PROC NEAR ; GraphicsMgr::UpdatePlane

; 96   : {

  0024c	55		 push	 ebp
  0024d	8b ec		 mov	 ebp, esp
  0024f	83 ec 08	 sub	 esp, 8
  00252	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 97   : 	if (plane != GetPlaneNext(plane->Id()))

  00255	8b 4d 08	 mov	 ecx, DWORD PTR _plane$[ebp]
  00258	e8 00 00 00 00	 call	 ?Id@SOL_Plane@@QBEJXZ	; SOL_Plane::Id
  0025d	50		 push	 eax
  0025e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00261	e8 00 00 00 00	 call	 ?GetPlaneNext@GraphicsMgr@@QAEPAVSOL_Plane@@H@Z ; GraphicsMgr::GetPlaneNext
  00266	39 45 08	 cmp	 DWORD PTR _plane$[ebp], eax
  00269	74 02		 je	 SHORT $L61836

; 98   : 		return;

  0026b	eb 46		 jmp	 SHORT $L61835
$L61836:

; 99   : //		msgMgr->Fatal(SrcLoc,Msg_PlaneNotFound,plane->Id());
; 100  : 		
; 101  : 	SOL_Plane* currentPlane = VisiblePlane(plane->Id());

  0026d	8b 4d 08	 mov	 ecx, DWORD PTR _plane$[ebp]
  00270	e8 00 00 00 00	 call	 ?Id@SOL_Plane@@QBEJXZ	; SOL_Plane::Id
  00275	50		 push	 eax
  00276	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00279	e8 00 00 00 00	 call	 ?VisiblePlane@GraphicsMgr@@QAEPAVSOL_Plane@@H@Z ; GraphicsMgr::VisiblePlane
  0027e	89 45 fc	 mov	 DWORD PTR _currentPlane$[ebp], eax

; 102  : 
; 103  : 	plane->UpdatePlane(currentPlane);

  00281	8b 45 fc	 mov	 eax, DWORD PTR _currentPlane$[ebp]
  00284	50		 push	 eax
  00285	8b 4d 08	 mov	 ecx, DWORD PTR _plane$[ebp]
  00288	e8 00 00 00 00	 call	 ?UpdatePlane@SOL_Plane@@QAEXPAV1@@Z ; SOL_Plane::UpdatePlane

; 104  : 	plane->OnScreen().Clip(next.ScreenRect());

  0028d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00290	83 c1 14	 add	 ecx, 20			; 00000014H
  00293	e8 00 00 00 00	 call	 ?ScreenRect@Screen@@QBEABVSOL_Rect@@XZ ; Screen::ScreenRect
  00298	50		 push	 eax
  00299	8b 4d 08	 mov	 ecx, DWORD PTR _plane$[ebp]
  0029c	e8 00 00 00 00	 call	 ?OnScreen@SOL_Plane@@QAEAAVSOL_Rect@@XZ ; SOL_Plane::OnScreen
  002a1	8b c8		 mov	 ecx, eax
  002a3	e8 00 00 00 00	 call	 ?Clip@SOL_Rect@@QAEXABV1@@Z ; SOL_Rect::Clip

; 105  : 
; 106  : 	next.SortPlanes();

  002a8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002ab	83 c1 14	 add	 ecx, 20			; 00000014H
  002ae	e8 00 00 00 00	 call	 ?SortPlanes@Screen@@QAEXXZ ; Screen::SortPlanes
$L61835:

; 107  : }

  002b3	8b e5		 mov	 esp, ebp
  002b5	5d		 pop	 ebp
  002b6	c2 04 00	 ret	 4
?UpdatePlane@GraphicsMgr@@QAEXPAVSOL_Plane@@@Z ENDP	; GraphicsMgr::UpdatePlane
_TEXT	ENDS
PUBLIC	?DeletePlane@GraphicsMgr@@QAEXH@Z		; GraphicsMgr::DeletePlane
PUBLIC	?DeletePlane@GraphicsMgr@@QAEXPAVSOL_Plane@@@Z	; GraphicsMgr::DeletePlane
_TEXT	SEGMENT
_planeId$ = 8
_this$ = -8
_plane$ = -4
?DeletePlane@GraphicsMgr@@QAEXH@Z PROC NEAR		; GraphicsMgr::DeletePlane

; 111  : {

  002b9	55		 push	 ebp
  002ba	8b ec		 mov	 ebp, esp
  002bc	83 ec 08	 sub	 esp, 8
  002bf	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 	SOL_Plane* plane = GetPlaneNext(planeId);

  002c2	8b 45 08	 mov	 eax, DWORD PTR _planeId$[ebp]
  002c5	50		 push	 eax
  002c6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002c9	e8 00 00 00 00	 call	 ?GetPlaneNext@GraphicsMgr@@QAEPAVSOL_Plane@@H@Z ; GraphicsMgr::GetPlaneNext
  002ce	89 45 fc	 mov	 DWORD PTR _plane$[ebp], eax

; 113  : 	if (plane == NULL)

  002d1	83 7d fc 00	 cmp	 DWORD PTR _plane$[ebp], 0
  002d5	75 02		 jne	 SHORT $L61843

; 114  : 		return;

  002d7	eb 0c		 jmp	 SHORT $L61841
$L61843:

; 115  : //		msgMgr->Fatal(SrcLoc,Msg_PlaneNotFound,plane->Id());
; 116  : 
; 117  : // FOR PQ4CD ONLY, COMMENT OUT THIS LINE:
; 118  : //		msgMgr->Fatal(SrcLoc,Msg_PlaneNotFound,plane->Id());
; 119  : // AND ADD THIS LINE:
; 120  : //		return;
; 121  : 	DeletePlane(plane);

  002d9	8b 4d fc	 mov	 ecx, DWORD PTR _plane$[ebp]
  002dc	51		 push	 ecx
  002dd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002e0	e8 00 00 00 00	 call	 ?DeletePlane@GraphicsMgr@@QAEXPAVSOL_Plane@@@Z ; GraphicsMgr::DeletePlane
$L61841:

; 122  : }

  002e5	8b e5		 mov	 esp, ebp
  002e7	5d		 pop	 ebp
  002e8	c2 04 00	 ret	 4
?DeletePlane@GraphicsMgr@@QAEXH@Z ENDP			; GraphicsMgr::DeletePlane
_TEXT	ENDS
PUBLIC	?AddCount@SOL_Plane@@QBEHXZ			; SOL_Plane::AddCount
PUBLIC	?SetAddCount@SOL_Plane@@QAEXH@Z			; SOL_Plane::SetAddCount
PUBLIC	?SetDeleteCount@SOL_Plane@@QAEXH@Z		; SOL_Plane::SetDeleteCount
PUBLIC	?SetUpdateCount@SOL_Plane@@QAEXH@Z		; SOL_Plane::SetUpdateCount
EXTRN	?AbortPlane@Screen@@QAEXPBVSOL_Plane@@@Z:NEAR	; Screen::AbortPlane
_TEXT	SEGMENT
_plane$ = 8
_this$ = -4
?DeletePlane@GraphicsMgr@@QAEXPAVSOL_Plane@@@Z PROC NEAR ; GraphicsMgr::DeletePlane

; 126  : {

  002eb	55		 push	 ebp
  002ec	8b ec		 mov	 ebp, esp
  002ee	51		 push	 ecx
  002ef	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 	if (plane != GetPlaneNext(plane->Id()))

  002f2	8b 4d 08	 mov	 ecx, DWORD PTR _plane$[ebp]
  002f5	e8 00 00 00 00	 call	 ?Id@SOL_Plane@@QBEJXZ	; SOL_Plane::Id
  002fa	50		 push	 eax
  002fb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002fe	e8 00 00 00 00	 call	 ?GetPlaneNext@GraphicsMgr@@QAEPAVSOL_Plane@@H@Z ; GraphicsMgr::GetPlaneNext
  00303	39 45 08	 cmp	 DWORD PTR _plane$[ebp], eax
  00306	74 02		 je	 SHORT $L61848

; 128  : 		return;

  00308	eb 45		 jmp	 SHORT $L61847
$L61848:

; 129  : //		msgMgr->Fatal(SrcLoc,Msg_PlaneNotFound,plane->Id());
; 130  : 		
; 131  : 	if (plane->AddCount())  {

  0030a	8b 4d 08	 mov	 ecx, DWORD PTR _plane$[ebp]
  0030d	e8 00 00 00 00	 call	 ?AddCount@SOL_Plane@@QBEHXZ ; SOL_Plane::AddCount
  00312	85 c0		 test	 eax, eax
  00314	74 11		 je	 SHORT $L61849

; 132  : 		next.AbortPlane(plane);

  00316	8b 45 08	 mov	 eax, DWORD PTR _plane$[ebp]
  00319	50		 push	 eax
  0031a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0031d	83 c1 14	 add	 ecx, 20			; 00000014H
  00320	e8 00 00 00 00	 call	 ?AbortPlane@Screen@@QAEXPBVSOL_Plane@@@Z ; Screen::AbortPlane

; 134  : 	else  {

  00325	eb 28		 jmp	 SHORT $L61850
$L61849:

; 135  : 		plane->SetDeleteCount(ScreenCount());

  00327	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0032a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0032c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0032f	ff 52 04	 call	 DWORD PTR [edx+4]
  00332	50		 push	 eax
  00333	8b 4d 08	 mov	 ecx, DWORD PTR _plane$[ebp]
  00336	e8 00 00 00 00	 call	 ?SetDeleteCount@SOL_Plane@@QAEXH@Z ; SOL_Plane::SetDeleteCount

; 136  : 		plane->SetAddCount(0);

  0033b	6a 00		 push	 0
  0033d	8b 4d 08	 mov	 ecx, DWORD PTR _plane$[ebp]
  00340	e8 00 00 00 00	 call	 ?SetAddCount@SOL_Plane@@QAEXH@Z ; SOL_Plane::SetAddCount

; 137  : 		plane->SetUpdateCount(0);

  00345	6a 00		 push	 0
  00347	8b 4d 08	 mov	 ecx, DWORD PTR _plane$[ebp]
  0034a	e8 00 00 00 00	 call	 ?SetUpdateCount@SOL_Plane@@QAEXH@Z ; SOL_Plane::SetUpdateCount
$L61850:
$L61847:

; 139  : }

  0034f	8b e5		 mov	 esp, ebp
  00351	5d		 pop	 ebp
  00352	c2 04 00	 ret	 4
?DeletePlane@GraphicsMgr@@QAEXPAVSOL_Plane@@@Z ENDP	; GraphicsMgr::DeletePlane
_TEXT	ENDS
PUBLIC	?Length@PlaneList@@QBEHXZ			; PlaneList::Length
PUBLIC	??APlaneList@@QAEAAVSOL_Plane@@H@Z		; PlaneList::operator[]
PUBLIC	?SubmitPalette@ScreenItem@@QAEXXZ		; ScreenItem::SubmitPalette
PUBLIC	??ASOLPalette@@QAEAAVRgb24F@@H@Z		; SOLPalette::operator[]
PUBLIC	??_GRectList@@QAEPAXI@Z				; RectList::`scalar deleting destructor'
PUBLIC	?Xdim@Screen@@QBEHXZ				; Screen::Xdim
PUBLIC	?Ydim@Screen@@QBEHXZ				; Screen::Ydim
PUBLIC	?Planes@Screen@@QAEAAVPlaneList@@XZ		; Screen::Planes
PUBLIC	?ShowList@Screen@@QAEAAVRectList@@XZ		; Screen::ShowList
PUBLIC	?SI@DrawItem@@QAEAAVScreenItem@@XZ		; DrawItem::SI
PUBLIC	?Length@DrawList@@QBEHXZ			; DrawList::Length
PUBLIC	??ADrawList@@QAEAAVDrawItem@@H@Z		; DrawList::operator[]
PUBLIC	??_GDrawList@@QAEPAXI@Z				; DrawList::`scalar deleting destructor'
PUBLIC	??0SOL_Rect@@QAE@HHHH@Z				; SOL_Rect::SOL_Rect
PUBLIC	?RemapMarkRedraw@GraphicsMgr@@QAEXXZ		; GraphicsMgr::RemapMarkRedraw
PUBLIC	?DrawEraseList@GraphicsMgr@@IAEXABVRectList@@ABVSOL_Plane@@@Z ; GraphicsMgr::DrawEraseList
PUBLIC	?DrawScreenItemList@GraphicsMgr@@IAEXAAVDrawList@@@Z ; GraphicsMgr::DrawScreenItemList
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??0SOLPalette@@QAE@XZ:NEAR			; SOLPalette::SOLPalette
EXTRN	??0RectList@@QAE@XZ:NEAR			; RectList::RectList
EXTRN	??4SOLPalette@@QAEAAV0@ABV0@@Z:NEAR		; SOLPalette::operator=
EXTRN	?Add@RectList@@QAEXABVSOL_Rect@@@Z:NEAR		; RectList::Add
EXTRN	?pm@@3VPMachine@@A:BYTE				; pm
EXTRN	?remapCount@Remap@@2IA:DWORD			; Remap::remapCount
EXTRN	??0DrawList@@QAE@XZ:NEAR			; DrawList::DrawList
EXTRN	?Sort@DrawList@@QAEXXZ:NEAR			; DrawList::Sort
EXTRN	?UpdateRedrawAllCount@SOL_Plane@@QAEXXZ:NEAR	; SOL_Plane::UpdateRedrawAllCount
EXTRN	?ProcessEffects@@YAXPAVPlaneShowStyle@@@Z:NEAR	; ProcessEffects
xdata$x	SEGMENT
$T62354	DD	019930520H
	DD	02H
	DD	FLAT:$T62356
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T62356	DD	0ffffffffH
	DD	FLAT:$L62351
	DD	0ffffffffH
	DD	FLAT:$L62352
xdata$x	ENDS
_TEXT	SEGMENT
_palArray$ = 8
_style$ = 12
_this$ = -2176
_palIndex$ = -1080
_myPal$ = -2108
_thisPal$ = -1056
_s$ = -1060
_i$ = -1084
_A$ = -28
_nplanes$ = -32
_dirtyRect$ = -1076
_count$61882 = -2112
_drawlist$61883 = -2116
_j$61884 = -2120
_k$61892 = -2124
_k$61899 = -2128
_count$61917 = -2132
_drawlist$61918 = -2136
_j$61919 = -2140
$T62335 = -2144
$T62336 = -2148
$T62339 = -2152
$T62340 = -2156
$T62343 = -2160
$T62344 = -2164
$T62347 = -2168
$T62348 = -2172
__$EHRec$ = -12
?PalMorphFrameOut@GraphicsMgr@@UAEXPADPAVPlaneShowStyle@@@Z PROC NEAR ; GraphicsMgr::PalMorphFrameOut

; 144  : {

  00355	55		 push	 ebp
  00356	8b ec		 mov	 ebp, esp
  00358	6a ff		 push	 -1
  0035a	68 00 00 00 00	 push	 $L62355
  0035f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00365	50		 push	 eax
  00366	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0036d	81 ec ac 08 00
	00		 sub	 esp, 2220		; 000008acH
  00373	56		 push	 esi
  00374	89 8d 80 f7 ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 145  : // First Decimate Original VMAP	and output to SCREEN
; 146  : 
; 147  : 	int palIndex = -1;

  0037a	c7 85 c8 fb ff
	ff ff ff ff ff	 mov	 DWORD PTR _palIndex$[ebp], -1

; 148  : 	SOLPalette  myPal;

  00384	8d 8d c4 f7 ff
	ff		 lea	 ecx, DWORD PTR _myPal$[ebp]
  0038a	e8 00 00 00 00	 call	 ??0SOLPalette@@QAE@XZ	; SOLPalette::SOLPalette

; 149  : 	SOLPalette  thisPal;

  0038f	8d 8d e0 fb ff
	ff		 lea	 ecx, DWORD PTR _thisPal$[ebp]
  00395	e8 00 00 00 00	 call	 ??0SOLPalette@@QAE@XZ	; SOLPalette::SOLPalette

; 150  : 	int s = pm.GlobalPtr[ gSCI_prevRoomNum ];

  0039a	a1 14 00 00 00	 mov	 eax, DWORD PTR ?pm@@3VPMachine@@A+20
  0039f	0f bf 48 6a	 movsx	 ecx, WORD PTR [eax+106]
  003a3	89 8d dc fb ff
	ff		 mov	 DWORD PTR _s$[ebp], ecx

; 151  : 	myPal = GPalette().Next();

  003a9	8b 95 80 f7 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  003af	8b 02		 mov	 eax, DWORD PTR [edx]
  003b1	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003b7	ff 50 1c	 call	 DWORD PTR [eax+28]
  003ba	89 85 7c f7 ff
	ff		 mov	 DWORD PTR -2180+[ebp], eax
  003c0	8b 8d 7c f7 ff
	ff		 mov	 ecx, DWORD PTR -2180+[ebp]
  003c6	8b 11		 mov	 edx, DWORD PTR [ecx]
  003c8	8b 8d 7c f7 ff
	ff		 mov	 ecx, DWORD PTR -2180+[ebp]
  003ce	ff 52 14	 call	 DWORD PTR [edx+20]
  003d1	50		 push	 eax
  003d2	8d 8d c4 f7 ff
	ff		 lea	 ecx, DWORD PTR _myPal$[ebp]
  003d8	e8 00 00 00 00	 call	 ??4SOLPalette@@QAEAAV0@ABV0@@Z ; SOLPalette::operator=

; 152  : 	int i;
; 153  : 	AlterVMAP(&myPal,&myPal,palIndex,palArray);	

  003dd	8b 45 08	 mov	 eax, DWORD PTR _palArray$[ebp]
  003e0	50		 push	 eax
  003e1	8b 8d c8 fb ff
	ff		 mov	 ecx, DWORD PTR _palIndex$[ebp]
  003e7	51		 push	 ecx
  003e8	8d 95 c4 f7 ff
	ff		 lea	 edx, DWORD PTR _myPal$[ebp]
  003ee	52		 push	 edx
  003ef	8d 85 c4 f7 ff
	ff		 lea	 eax, DWORD PTR _myPal$[ebp]
  003f5	50		 push	 eax
  003f6	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003fc	8b 11		 mov	 edx, DWORD PTR [ecx]
  003fe	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00404	ff 52 08	 call	 DWORD PTR [edx+8]

; 154  :  	SOL_Rect	A(0,0,next.Xdim()-1,next.Ydim()-1);

  00407	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0040d	83 c1 14	 add	 ecx, 20			; 00000014H
  00410	e8 00 00 00 00	 call	 ?Ydim@Screen@@QBEHXZ	; Screen::Ydim
  00415	83 e8 01	 sub	 eax, 1
  00418	50		 push	 eax
  00419	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0041f	83 c1 14	 add	 ecx, 20			; 00000014H
  00422	e8 00 00 00 00	 call	 ?Xdim@Screen@@QBEHXZ	; Screen::Xdim
  00427	83 e8 01	 sub	 eax, 1
  0042a	50		 push	 eax
  0042b	6a 00		 push	 0
  0042d	6a 00		 push	 0
  0042f	8d 4d e4	 lea	 ecx, DWORD PTR _A$[ebp]
  00432	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@HHHH@Z	; SOL_Rect::SOL_Rect

; 155  : 	next.ShowList().Add(A);

  00437	8d 45 e4	 lea	 eax, DWORD PTR _A$[ebp]
  0043a	50		 push	 eax
  0043b	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00441	83 c1 14	 add	 ecx, 20			; 00000014H
  00444	e8 00 00 00 00	 call	 ?ShowList@Screen@@QAEAAVRectList@@XZ ; Screen::ShowList
  00449	8b c8		 mov	 ecx, eax
  0044b	e8 00 00 00 00	 call	 ?Add@RectList@@QAEXABVSOL_Rect@@@Z ; RectList::Add

; 156  : 	ShowBits();

  00450	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00456	8b 11		 mov	 edx, DWORD PTR [ecx]
  00458	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0045e	ff 52 40	 call	 DWORD PTR [edx+64]

; 157  : 
; 158  : // Second draw next image to VMAP
; 159  : 
; 160  : 	int nplanes = next.Planes().Length();

  00461	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00467	83 c1 14	 add	 ecx, 20			; 00000014H
  0046a	e8 00 00 00 00	 call	 ?Planes@Screen@@QAEAAVPlaneList@@XZ ; Screen::Planes
  0046f	8b c8		 mov	 ecx, eax
  00471	e8 00 00 00 00	 call	 ?Length@PlaneList@@QBEHXZ ; PlaneList::Length
  00476	89 45 e0	 mov	 DWORD PTR _nplanes$[ebp], eax

; 161  : 
; 162  : 	for (i = 0;i < nplanes;i++)  {

  00479	c7 85 c4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00483	eb 0f		 jmp	 SHORT $L61863
$L61864:
  00485	8b 85 c4 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0048b	83 c0 01	 add	 eax, 1
  0048e	89 85 c4 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$L61863:
  00494	8b 8d c4 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  0049a	3b 4d e0	 cmp	 ecx, DWORD PTR _nplanes$[ebp]
  0049d	0f 8d d1 00 00
	00		 jge	 $L61865

; 163  : 		drawLists[i] = New DrawList;

  004a3	68 44 1f 00 00	 push	 8004			; 00001f44H
  004a8	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  004ad	83 c4 04	 add	 esp, 4
  004b0	89 85 9c f7 ff
	ff		 mov	 DWORD PTR $T62336[ebp], eax
  004b6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  004bd	83 bd 9c f7 ff
	ff 00		 cmp	 DWORD PTR $T62336[ebp], 0
  004c4	74 13		 je	 SHORT $L62337
  004c6	8b 8d 9c f7 ff
	ff		 mov	 ecx, DWORD PTR $T62336[ebp]
  004cc	e8 00 00 00 00	 call	 ??0DrawList@@QAE@XZ	; DrawList::DrawList
  004d1	89 85 78 f7 ff
	ff		 mov	 DWORD PTR -2184+[ebp], eax
  004d7	eb 0a		 jmp	 SHORT $L62338
$L62337:
  004d9	c7 85 78 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR -2184+[ebp], 0
$L62338:
  004e3	8b 95 78 f7 ff
	ff		 mov	 edx, DWORD PTR -2184+[ebp]
  004e9	89 95 a0 f7 ff
	ff		 mov	 DWORD PTR $T62335[ebp], edx
  004ef	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  004f6	8b 85 c4 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  004fc	8b 8d a0 f7 ff
	ff		 mov	 ecx, DWORD PTR $T62335[ebp]
  00502	89 0c 85 00 00
	00 00		 mov	 DWORD PTR ?drawLists@@3PAPAVDrawList@@A[eax*4], ecx

; 164  : 		eraseLists[i] = New RectList;

  00509	68 a4 0f 00 00	 push	 4004			; 00000fa4H
  0050e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00513	83 c4 04	 add	 esp, 4
  00516	89 85 94 f7 ff
	ff		 mov	 DWORD PTR $T62340[ebp], eax
  0051c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00523	83 bd 94 f7 ff
	ff 00		 cmp	 DWORD PTR $T62340[ebp], 0
  0052a	74 13		 je	 SHORT $L62341
  0052c	8b 8d 94 f7 ff
	ff		 mov	 ecx, DWORD PTR $T62340[ebp]
  00532	e8 00 00 00 00	 call	 ??0RectList@@QAE@XZ	; RectList::RectList
  00537	89 85 74 f7 ff
	ff		 mov	 DWORD PTR -2188+[ebp], eax
  0053d	eb 0a		 jmp	 SHORT $L62342
$L62341:
  0053f	c7 85 74 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR -2188+[ebp], 0
$L62342:
  00549	8b 95 74 f7 ff
	ff		 mov	 edx, DWORD PTR -2188+[ebp]
  0054f	89 95 98 f7 ff
	ff		 mov	 DWORD PTR $T62339[ebp], edx
  00555	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0055c	8b 85 c4 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00562	8b 8d 98 f7 ff
	ff		 mov	 ecx, DWORD PTR $T62339[ebp]
  00568	89 0c 85 00 00
	00 00		 mov	 DWORD PTR ?eraseLists@@3PAPAVRectList@@A[eax*4], ecx

; 165  : 	}

  0056f	e9 11 ff ff ff	 jmp	 $L61864
$L61865:

; 166  : 
; 167  : 	if (Remap::remapCount && lastRemapFlag)

  00574	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?remapCount@Remap@@2IA, 0 ; Remap::remapCount
  0057b	74 17		 je	 SHORT $L61874
  0057d	8b 95 80 f7 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00583	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  00587	74 0b		 je	 SHORT $L61874

; 168  : 		RemapMarkRedraw();

  00589	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0058f	e8 00 00 00 00	 call	 ?RemapMarkRedraw@GraphicsMgr@@QAEXXZ ; GraphicsMgr::RemapMarkRedraw
$L61874:

; 169  : 
; 170  : 	SOL_Rect dirtyRect(0,0,-1,-1);

  00594	6a ff		 push	 -1
  00596	6a ff		 push	 -1
  00598	6a 00		 push	 0
  0059a	6a 00		 push	 0
  0059c	8d 8d cc fb ff
	ff		 lea	 ecx, DWORD PTR _dirtyRect$[ebp]
  005a2	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@HHHH@Z	; SOL_Rect::SOL_Rect

; 171  : 	CalcLists(drawLists,eraseLists,dirtyRect);

  005a7	8d 85 cc fb ff
	ff		 lea	 eax, DWORD PTR _dirtyRect$[ebp]
  005ad	50		 push	 eax
  005ae	68 00 00 00 00	 push	 OFFSET FLAT:?eraseLists@@3PAPAVRectList@@A ; eraseLists
  005b3	68 00 00 00 00	 push	 OFFSET FLAT:?drawLists@@3PAPAVDrawList@@A ; drawLists
  005b8	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  005be	8b 11		 mov	 edx, DWORD PTR [ecx]
  005c0	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  005c6	ff 52 48	 call	 DWORD PTR [edx+72]

; 172  : 
; 173  : 	// The number of planes may have been reduced by CalcLists
; 174  : 	nplanes = next.Planes().Length();

  005c9	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  005cf	83 c1 14	 add	 ecx, 20			; 00000014H
  005d2	e8 00 00 00 00	 call	 ?Planes@Screen@@QAEAAVPlaneList@@XZ ; Screen::Planes
  005d7	8b c8		 mov	 ecx, eax
  005d9	e8 00 00 00 00	 call	 ?Length@PlaneList@@QBEHXZ ; PlaneList::Length
  005de	89 45 e0	 mov	 DWORD PTR _nplanes$[ebp], eax

; 175  : 
; 176  : 	// Sort the draw lists
; 177  : 	for (i = 0; i < nplanes; i++)

  005e1	c7 85 c4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  005eb	eb 0f		 jmp	 SHORT $L61876
$L61877:
  005ed	8b 85 c4 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  005f3	83 c0 01	 add	 eax, 1
  005f6	89 85 c4 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$L61876:
  005fc	8b 8d c4 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00602	3b 4d e0	 cmp	 ecx, DWORD PTR _nplanes$[ebp]
  00605	7d 14		 jge	 SHORT $L61878

; 178  : 		drawLists[i]->Sort();

  00607	8b 95 c4 fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  0060d	8b 0c 95 00 00
	00 00		 mov	 ecx, DWORD PTR ?drawLists@@3PAPAVDrawList@@A[edx*4]
  00614	e8 00 00 00 00	 call	 ?Sort@DrawList@@QAEXXZ	; DrawList::Sort
  00619	eb d2		 jmp	 SHORT $L61877
$L61878:

; 179  : 
; 180  : 	for (i = 0; i < nplanes; i++)  {

  0061b	c7 85 c4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00625	eb 0f		 jmp	 SHORT $L61879
$L61880:
  00627	8b 85 c4 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0062d	83 c0 01	 add	 eax, 1
  00630	89 85 c4 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$L61879:
  00636	8b 8d c4 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  0063c	3b 4d e0	 cmp	 ecx, DWORD PTR _nplanes$[ebp]
  0063f	7d 7b		 jge	 SHORT $L61881

; 181  : 		int count = drawLists[i]->Length();

  00641	8b 95 c4 fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00647	8b 0c 95 00 00
	00 00		 mov	 ecx, DWORD PTR ?drawLists@@3PAPAVDrawList@@A[edx*4]
  0064e	e8 00 00 00 00	 call	 ?Length@DrawList@@QBEHXZ ; DrawList::Length
  00653	89 85 c0 f7 ff
	ff		 mov	 DWORD PTR _count$61882[ebp], eax

; 182  : 		DrawList& drawlist = *drawLists[i];

  00659	8b 85 c4 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0065f	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?drawLists@@3PAPAVDrawList@@A[eax*4]
  00666	89 8d bc f7 ff
	ff		 mov	 DWORD PTR _drawlist$61883[ebp], ecx

; 183  : 		for (int j = 0; j < count; j++) {

  0066c	c7 85 b8 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$61884[ebp], 0
  00676	eb 0f		 jmp	 SHORT $L61885
$L61886:
  00678	8b 95 b8 f7 ff
	ff		 mov	 edx, DWORD PTR _j$61884[ebp]
  0067e	83 c2 01	 add	 edx, 1
  00681	89 95 b8 f7 ff
	ff		 mov	 DWORD PTR _j$61884[ebp], edx
$L61885:
  00687	8b 85 b8 f7 ff
	ff		 mov	 eax, DWORD PTR _j$61884[ebp]
  0068d	3b 85 c0 f7 ff
	ff		 cmp	 eax, DWORD PTR _count$61882[ebp]
  00693	7d 22		 jge	 SHORT $L61887

; 184  : 			drawlist[j].SI().SubmitPalette();

  00695	8b 8d b8 f7 ff
	ff		 mov	 ecx, DWORD PTR _j$61884[ebp]
  0069b	51		 push	 ecx
  0069c	8b 8d bc f7 ff
	ff		 mov	 ecx, DWORD PTR _drawlist$61883[ebp]
  006a2	e8 00 00 00 00	 call	 ??ADrawList@@QAEAAVDrawItem@@H@Z ; DrawList::operator[]
  006a7	8b c8		 mov	 ecx, eax
  006a9	e8 00 00 00 00	 call	 ?SI@DrawItem@@QAEAAVScreenItem@@XZ ; DrawItem::SI
  006ae	8b c8		 mov	 ecx, eax
  006b0	e8 00 00 00 00	 call	 ?SubmitPalette@ScreenItem@@QAEXXZ ; ScreenItem::SubmitPalette

; 185  : 		}

  006b5	eb c1		 jmp	 SHORT $L61886
$L61887:

; 186  : 	}

  006b7	e9 6b ff ff ff	 jmp	 $L61880
$L61881:

; 187  : 
; 188  : 	lastRemapFlag = GPalette().UpdateForFrame();

  006bc	8b 95 80 f7 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  006c2	8b 02		 mov	 eax, DWORD PTR [edx]
  006c4	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  006ca	ff 50 1c	 call	 DWORD PTR [eax+28]
  006cd	89 85 70 f7 ff
	ff		 mov	 DWORD PTR -2192+[ebp], eax
  006d3	8b 8d 70 f7 ff
	ff		 mov	 ecx, DWORD PTR -2192+[ebp]
  006d9	8b 11		 mov	 edx, DWORD PTR [ecx]
  006db	8b 8d 70 f7 ff
	ff		 mov	 ecx, DWORD PTR -2192+[ebp]
  006e1	ff 52 1c	 call	 DWORD PTR [edx+28]
  006e4	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  006ea	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 189  : 
; 190  : 	// draw to vmap
; 191  : 	vmapValid = False;

  006ed	8b 95 80 f7 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  006f3	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 192  : 	for (i = 0; i < nplanes; i++)  {

  006fa	c7 85 c4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00704	eb 0f		 jmp	 SHORT $L61888
$L61889:
  00706	8b 85 c4 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0070c	83 c0 01	 add	 eax, 1
  0070f	89 85 c4 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$L61888:
  00715	8b 8d c4 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  0071b	3b 4d e0	 cmp	 ecx, DWORD PTR _nplanes$[ebp]
  0071e	7d 51		 jge	 SHORT $L61890

; 193  : 		DrawEraseList(*eraseLists[i],next.Planes()[i]);

  00720	8b 95 c4 fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00726	52		 push	 edx
  00727	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0072d	83 c1 14	 add	 ecx, 20			; 00000014H
  00730	e8 00 00 00 00	 call	 ?Planes@Screen@@QAEAAVPlaneList@@XZ ; Screen::Planes
  00735	8b c8		 mov	 ecx, eax
  00737	e8 00 00 00 00	 call	 ??APlaneList@@QAEAAVSOL_Plane@@H@Z ; PlaneList::operator[]
  0073c	50		 push	 eax
  0073d	8b 85 c4 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00743	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?eraseLists@@3PAPAVRectList@@A[eax*4]
  0074a	51		 push	 ecx
  0074b	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00751	e8 00 00 00 00	 call	 ?DrawEraseList@GraphicsMgr@@IAEXABVRectList@@ABVSOL_Plane@@@Z ; GraphicsMgr::DrawEraseList

; 194  : 		DrawScreenItemList(*drawLists[i]);

  00756	8b 95 c4 fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  0075c	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?drawLists@@3PAPAVDrawList@@A[edx*4]
  00763	50		 push	 eax
  00764	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0076a	e8 00 00 00 00	 call	 ?DrawScreenItemList@GraphicsMgr@@IAEXAAVDrawList@@@Z ; GraphicsMgr::DrawScreenItemList

; 195  : 	}

  0076f	eb 95		 jmp	 SHORT $L61889
$L61890:

; 196  : 
; 197  : // Third rework palette to work for both palette reduced images
; 198  : 
; 199  : 	thisPal = GPalette().Next();

  00771	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00777	8b 11		 mov	 edx, DWORD PTR [ecx]
  00779	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0077f	ff 52 1c	 call	 DWORD PTR [edx+28]
  00782	89 85 6c f7 ff
	ff		 mov	 DWORD PTR -2196+[ebp], eax
  00788	8b 85 6c f7 ff
	ff		 mov	 eax, DWORD PTR -2196+[ebp]
  0078e	8b 10		 mov	 edx, DWORD PTR [eax]
  00790	8b 8d 6c f7 ff
	ff		 mov	 ecx, DWORD PTR -2196+[ebp]
  00796	ff 52 14	 call	 DWORD PTR [edx+20]
  00799	50		 push	 eax
  0079a	8d 8d e0 fb ff
	ff		 lea	 ecx, DWORD PTR _thisPal$[ebp]
  007a0	e8 00 00 00 00	 call	 ??4SOLPalette@@QAEAAV0@ABV0@@Z ; SOLPalette::operator=

; 200  : 
; 201  : 	if (s<1000) {

  007a5	81 bd dc fb ff
	ff e8 03 00 00	 cmp	 DWORD PTR _s$[ebp], 1000 ; 000003e8H
  007af	0f 8d f2 00 00
	00		 jge	 $L61891

; 202  : 	for(int k=0;k<256;k++){ 

  007b5	c7 85 b4 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _k$61892[ebp], 0
  007bf	eb 0f		 jmp	 SHORT $L61893
$L61894:
  007c1	8b 85 b4 f7 ff
	ff		 mov	 eax, DWORD PTR _k$61892[ebp]
  007c7	83 c0 01	 add	 eax, 1
  007ca	89 85 b4 f7 ff
	ff		 mov	 DWORD PTR _k$61892[ebp], eax
$L61893:
  007d0	81 bd b4 f7 ff
	ff 00 01 00 00	 cmp	 DWORD PTR _k$61892[ebp], 256 ; 00000100H
  007da	0f 8d c2 00 00
	00		 jge	 $L61895

; 203  : 			if ((palArray[k] == -1) || (palArray[k] == 0)) {

  007e0	8b 4d 08	 mov	 ecx, DWORD PTR _palArray$[ebp]
  007e3	03 8d b4 f7 ff
	ff		 add	 ecx, DWORD PTR _k$61892[ebp]
  007e9	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  007ec	83 fa ff	 cmp	 edx, -1
  007ef	74 14		 je	 SHORT $L61897
  007f1	8b 45 08	 mov	 eax, DWORD PTR _palArray$[ebp]
  007f4	03 85 b4 f7 ff
	ff		 add	 eax, DWORD PTR _k$61892[ebp]
  007fa	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  007fd	85 c9		 test	 ecx, ecx
  007ff	0f 85 98 00 00
	00		 jne	 $L61896
$L61897:

; 204  : //			if ((palArray[k] == -1) || ((palArray[k] == 0)&& ((k>71)&&(k<104)))) {
; 205  : // the above line is KQ7 specific
; 206  : 	  			(myPal)[k].red   = (thisPal)[k].red   ;

  00805	8b 95 b4 f7 ff
	ff		 mov	 edx, DWORD PTR _k$61892[ebp]
  0080b	52		 push	 edx
  0080c	8d 8d e0 fb ff
	ff		 lea	 ecx, DWORD PTR _thisPal$[ebp]
  00812	e8 00 00 00 00	 call	 ??ASOLPalette@@QAEAAVRgb24F@@H@Z ; SOLPalette::operator[]
  00817	8b f0		 mov	 esi, eax
  00819	8b 85 b4 f7 ff
	ff		 mov	 eax, DWORD PTR _k$61892[ebp]
  0081f	50		 push	 eax
  00820	8d 8d c4 f7 ff
	ff		 lea	 ecx, DWORD PTR _myPal$[ebp]
  00826	e8 00 00 00 00	 call	 ??ASOLPalette@@QAEAAVRgb24F@@H@Z ; SOLPalette::operator[]
  0082b	8a 0e		 mov	 cl, BYTE PTR [esi]
  0082d	88 08		 mov	 BYTE PTR [eax], cl

; 207  : 				(myPal)[k].green = (thisPal)[k].green  ;

  0082f	8b 95 b4 f7 ff
	ff		 mov	 edx, DWORD PTR _k$61892[ebp]
  00835	52		 push	 edx
  00836	8d 8d e0 fb ff
	ff		 lea	 ecx, DWORD PTR _thisPal$[ebp]
  0083c	e8 00 00 00 00	 call	 ??ASOLPalette@@QAEAAVRgb24F@@H@Z ; SOLPalette::operator[]
  00841	8b f0		 mov	 esi, eax
  00843	8b 85 b4 f7 ff
	ff		 mov	 eax, DWORD PTR _k$61892[ebp]
  00849	50		 push	 eax
  0084a	8d 8d c4 f7 ff
	ff		 lea	 ecx, DWORD PTR _myPal$[ebp]
  00850	e8 00 00 00 00	 call	 ??ASOLPalette@@QAEAAVRgb24F@@H@Z ; SOLPalette::operator[]
  00855	8a 4e 01	 mov	 cl, BYTE PTR [esi+1]
  00858	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 208  : 				(myPal)[k].blue  = (thisPal)[k].blue 	;

  0085b	8b 95 b4 f7 ff
	ff		 mov	 edx, DWORD PTR _k$61892[ebp]
  00861	52		 push	 edx
  00862	8d 8d e0 fb ff
	ff		 lea	 ecx, DWORD PTR _thisPal$[ebp]
  00868	e8 00 00 00 00	 call	 ??ASOLPalette@@QAEAAVRgb24F@@H@Z ; SOLPalette::operator[]
  0086d	8b f0		 mov	 esi, eax
  0086f	8b 85 b4 f7 ff
	ff		 mov	 eax, DWORD PTR _k$61892[ebp]
  00875	50		 push	 eax
  00876	8d 8d c4 f7 ff
	ff		 lea	 ecx, DWORD PTR _myPal$[ebp]
  0087c	e8 00 00 00 00	 call	 ??ASOLPalette@@QAEAAVRgb24F@@H@Z ; SOLPalette::operator[]
  00881	8a 4e 02	 mov	 cl, BYTE PTR [esi+2]
  00884	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 209  : 				(myPal)[k].flag  = 1 	;

  00887	8b 95 b4 f7 ff
	ff		 mov	 edx, DWORD PTR _k$61892[ebp]
  0088d	52		 push	 edx
  0088e	8d 8d c4 f7 ff
	ff		 lea	 ecx, DWORD PTR _myPal$[ebp]
  00894	e8 00 00 00 00	 call	 ??ASOLPalette@@QAEAAVRgb24F@@H@Z ; SOLPalette::operator[]
  00899	c6 40 03 01	 mov	 BYTE PTR [eax+3], 1
$L61896:

; 211  : 		}

  0089d	e9 1f ff ff ff	 jmp	 $L61894
$L61895:

; 213  : 	else

  008a2	e9 07 01 00 00	 jmp	 $L61902
$L61891:

; 214  : 	for(int k=0;k<256;k++){ 

  008a7	c7 85 b0 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _k$61899[ebp], 0
  008b1	eb 0f		 jmp	 SHORT $L61900
$L61901:
  008b3	8b 85 b0 f7 ff
	ff		 mov	 eax, DWORD PTR _k$61899[ebp]
  008b9	83 c0 01	 add	 eax, 1
  008bc	89 85 b0 f7 ff
	ff		 mov	 DWORD PTR _k$61899[ebp], eax
$L61900:
  008c2	81 bd b0 f7 ff
	ff 00 01 00 00	 cmp	 DWORD PTR _k$61899[ebp], 256 ; 00000100H
  008cc	0f 8d dc 00 00
	00		 jge	 $L61902

; 215  : //			if ((palArray[k] == -1) || (palArray[k] == 0)) {
; 216  : 			if ((palArray[k] == -1) || ((palArray[k] == 0)&& ((k>71)&&(k<104)))) {

  008d2	8b 4d 08	 mov	 ecx, DWORD PTR _palArray$[ebp]
  008d5	03 8d b0 f7 ff
	ff		 add	 ecx, DWORD PTR _k$61899[ebp]
  008db	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  008de	83 fa ff	 cmp	 edx, -1
  008e1	74 2e		 je	 SHORT $L61904
  008e3	8b 45 08	 mov	 eax, DWORD PTR _palArray$[ebp]
  008e6	03 85 b0 f7 ff
	ff		 add	 eax, DWORD PTR _k$61899[ebp]
  008ec	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  008ef	85 c9		 test	 ecx, ecx
  008f1	0f 85 b2 00 00
	00		 jne	 $L61903
  008f7	83 bd b0 f7 ff
	ff 47		 cmp	 DWORD PTR _k$61899[ebp], 71 ; 00000047H
  008fe	0f 8e a5 00 00
	00		 jle	 $L61903
  00904	83 bd b0 f7 ff
	ff 68		 cmp	 DWORD PTR _k$61899[ebp], 104 ; 00000068H
  0090b	0f 8d 98 00 00
	00		 jge	 $L61903
$L61904:

; 217  : // the above line is KQ7 specific
; 218  : 	  			(myPal)[k].red   = (thisPal)[k].red   ;

  00911	8b 95 b0 f7 ff
	ff		 mov	 edx, DWORD PTR _k$61899[ebp]
  00917	52		 push	 edx
  00918	8d 8d e0 fb ff
	ff		 lea	 ecx, DWORD PTR _thisPal$[ebp]
  0091e	e8 00 00 00 00	 call	 ??ASOLPalette@@QAEAAVRgb24F@@H@Z ; SOLPalette::operator[]
  00923	8b f0		 mov	 esi, eax
  00925	8b 85 b0 f7 ff
	ff		 mov	 eax, DWORD PTR _k$61899[ebp]
  0092b	50		 push	 eax
  0092c	8d 8d c4 f7 ff
	ff		 lea	 ecx, DWORD PTR _myPal$[ebp]
  00932	e8 00 00 00 00	 call	 ??ASOLPalette@@QAEAAVRgb24F@@H@Z ; SOLPalette::operator[]
  00937	8a 0e		 mov	 cl, BYTE PTR [esi]
  00939	88 08		 mov	 BYTE PTR [eax], cl

; 219  : 				(myPal)[k].green = (thisPal)[k].green  ;

  0093b	8b 95 b0 f7 ff
	ff		 mov	 edx, DWORD PTR _k$61899[ebp]
  00941	52		 push	 edx
  00942	8d 8d e0 fb ff
	ff		 lea	 ecx, DWORD PTR _thisPal$[ebp]
  00948	e8 00 00 00 00	 call	 ??ASOLPalette@@QAEAAVRgb24F@@H@Z ; SOLPalette::operator[]
  0094d	8b f0		 mov	 esi, eax
  0094f	8b 85 b0 f7 ff
	ff		 mov	 eax, DWORD PTR _k$61899[ebp]
  00955	50		 push	 eax
  00956	8d 8d c4 f7 ff
	ff		 lea	 ecx, DWORD PTR _myPal$[ebp]
  0095c	e8 00 00 00 00	 call	 ??ASOLPalette@@QAEAAVRgb24F@@H@Z ; SOLPalette::operator[]
  00961	8a 4e 01	 mov	 cl, BYTE PTR [esi+1]
  00964	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 220  : 				(myPal)[k].blue  = (thisPal)[k].blue 	;

  00967	8b 95 b0 f7 ff
	ff		 mov	 edx, DWORD PTR _k$61899[ebp]
  0096d	52		 push	 edx
  0096e	8d 8d e0 fb ff
	ff		 lea	 ecx, DWORD PTR _thisPal$[ebp]
  00974	e8 00 00 00 00	 call	 ??ASOLPalette@@QAEAAVRgb24F@@H@Z ; SOLPalette::operator[]
  00979	8b f0		 mov	 esi, eax
  0097b	8b 85 b0 f7 ff
	ff		 mov	 eax, DWORD PTR _k$61899[ebp]
  00981	50		 push	 eax
  00982	8d 8d c4 f7 ff
	ff		 lea	 ecx, DWORD PTR _myPal$[ebp]
  00988	e8 00 00 00 00	 call	 ??ASOLPalette@@QAEAAVRgb24F@@H@Z ; SOLPalette::operator[]
  0098d	8a 4e 02	 mov	 cl, BYTE PTR [esi+2]
  00990	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 221  : 				(myPal)[k].flag  = 1 	;

  00993	8b 95 b0 f7 ff
	ff		 mov	 edx, DWORD PTR _k$61899[ebp]
  00999	52		 push	 edx
  0099a	8d 8d c4 f7 ff
	ff		 lea	 ecx, DWORD PTR _myPal$[ebp]
  009a0	e8 00 00 00 00	 call	 ??ASOLPalette@@QAEAAVRgb24F@@H@Z ; SOLPalette::operator[]
  009a5	c6 40 03 01	 mov	 BYTE PTR [eax+3], 1
$L61903:

; 223  : 		}

  009a9	e9 05 ff ff ff	 jmp	 $L61901
$L61902:

; 224  : 
; 225  : 
; 226  : 	GPalette().Submit(myPal);

  009ae	8d 85 c4 f7 ff
	ff		 lea	 eax, DWORD PTR _myPal$[ebp]
  009b4	50		 push	 eax
  009b5	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  009bb	8b 11		 mov	 edx, DWORD PTR [ecx]
  009bd	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  009c3	ff 52 1c	 call	 DWORD PTR [edx+28]
  009c6	89 85 68 f7 ff
	ff		 mov	 DWORD PTR -2200+[ebp], eax
  009cc	8b 85 68 f7 ff
	ff		 mov	 eax, DWORD PTR -2200+[ebp]
  009d2	8b 10		 mov	 edx, DWORD PTR [eax]
  009d4	8b 8d 68 f7 ff
	ff		 mov	 ecx, DWORD PTR -2200+[ebp]
  009da	ff 52 04	 call	 DWORD PTR [edx+4]

; 227  : 	GPalette().UpdateFFrame();

  009dd	8b 85 80 f7 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  009e3	8b 10		 mov	 edx, DWORD PTR [eax]
  009e5	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  009eb	ff 52 1c	 call	 DWORD PTR [edx+28]
  009ee	89 85 64 f7 ff
	ff		 mov	 DWORD PTR -2204+[ebp], eax
  009f4	8b 85 64 f7 ff
	ff		 mov	 eax, DWORD PTR -2204+[ebp]
  009fa	8b 10		 mov	 edx, DWORD PTR [eax]
  009fc	8b 8d 64 f7 ff
	ff		 mov	 ecx, DWORD PTR -2204+[ebp]
  00a02	ff 52 20	 call	 DWORD PTR [edx+32]

; 228  : 	GPalette().UpdateHardware();

  00a05	8b 85 80 f7 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00a0b	8b 10		 mov	 edx, DWORD PTR [eax]
  00a0d	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00a13	ff 52 1c	 call	 DWORD PTR [edx+28]
  00a16	89 85 60 f7 ff
	ff		 mov	 DWORD PTR -2208+[ebp], eax
  00a1c	8b 85 60 f7 ff
	ff		 mov	 eax, DWORD PTR -2208+[ebp]
  00a22	8b 10		 mov	 edx, DWORD PTR [eax]
  00a24	8b 8d 60 f7 ff
	ff		 mov	 ecx, DWORD PTR -2208+[ebp]
  00a2a	ff 92 80 00 00
	00		 call	 DWORD PTR [edx+128]

; 229  : 
; 230  : // Fourth decimate new image in VMAP and output to screen
; 231  : 
; 232  : 	palIndex = 1;

  00a30	c7 85 c8 fb ff
	ff 01 00 00 00	 mov	 DWORD PTR _palIndex$[ebp], 1

; 233  : 	AlterVMAP(&thisPal,&myPal,palIndex,palArray);	

  00a3a	8b 45 08	 mov	 eax, DWORD PTR _palArray$[ebp]
  00a3d	50		 push	 eax
  00a3e	8b 8d c8 fb ff
	ff		 mov	 ecx, DWORD PTR _palIndex$[ebp]
  00a44	51		 push	 ecx
  00a45	8d 95 c4 f7 ff
	ff		 lea	 edx, DWORD PTR _myPal$[ebp]
  00a4b	52		 push	 edx
  00a4c	8d 85 e0 fb ff
	ff		 lea	 eax, DWORD PTR _thisPal$[ebp]
  00a52	50		 push	 eax
  00a53	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00a59	8b 11		 mov	 edx, DWORD PTR [ecx]
  00a5b	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00a61	ff 52 08	 call	 DWORD PTR [edx+8]

; 234  : 
; 235  : 	if ((style != NULL) && (style->style != PALETTEMORPH))

  00a64	83 7d 0c 00	 cmp	 DWORD PTR _style$[ebp], 0
  00a68	74 17		 je	 SHORT $L61905
  00a6a	8b 45 0c	 mov	 eax, DWORD PTR _style$[ebp]
  00a6d	83 78 04 0f	 cmp	 DWORD PTR [eax+4], 15	; 0000000fH
  00a71	74 0e		 je	 SHORT $L61905

; 236  : 		ProcessEffects(style);

  00a73	8b 4d 0c	 mov	 ecx, DWORD PTR _style$[ebp]
  00a76	51		 push	 ecx
  00a77	e8 00 00 00 00	 call	 ?ProcessEffects@@YAXPAVPlaneShowStyle@@@Z ; ProcessEffects
  00a7c	83 c4 04	 add	 esp, 4

; 237  : 	else {

  00a7f	eb 11		 jmp	 SHORT $L61906
$L61905:

; 238  : 		ShowBits();

  00a81	8b 95 80 f7 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00a87	8b 02		 mov	 eax, DWORD PTR [edx]
  00a89	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00a8f	ff 50 40	 call	 DWORD PTR [eax+64]
$L61906:

; 240  : 
; 241  : 	vmapValid = True;

  00a92	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00a98	c7 41 08 01 00
	00 00		 mov	 DWORD PTR [ecx+8], 1

; 242  : 
; 243  : // Finally let the graphics engine know everything should be redrawn
; 244  : // For palette cycling 
; 245  : 
; 246  : 	for (i = 0;i < nplanes;i++)	

  00a9f	c7 85 c4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00aa9	eb 0f		 jmp	 SHORT $L61907
$L61908:
  00aab	8b 95 c4 fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00ab1	83 c2 01	 add	 edx, 1
  00ab4	89 95 c4 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], edx
$L61907:
  00aba	8b 85 c4 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00ac0	3b 45 e0	 cmp	 eax, DWORD PTR _nplanes$[ebp]
  00ac3	7d 25		 jge	 SHORT $L61909

; 247  : 	next.Planes()[i].UpdateRedrawAllCount();

  00ac5	8b 8d c4 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00acb	51		 push	 ecx
  00acc	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00ad2	83 c1 14	 add	 ecx, 20			; 00000014H
  00ad5	e8 00 00 00 00	 call	 ?Planes@Screen@@QAEAAVPlaneList@@XZ ; Screen::Planes
  00ada	8b c8		 mov	 ecx, eax
  00adc	e8 00 00 00 00	 call	 ??APlaneList@@QAEAAVSOL_Plane@@H@Z ; PlaneList::operator[]
  00ae1	8b c8		 mov	 ecx, eax
  00ae3	e8 00 00 00 00	 call	 ?UpdateRedrawAllCount@SOL_Plane@@QAEXXZ ; SOL_Plane::UpdateRedrawAllCount
  00ae8	eb c1		 jmp	 SHORT $L61908
$L61909:

; 248  : 
; 249  : 	if (Remap::remapCount && lastRemapFlag)

  00aea	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?remapCount@Remap@@2IA, 0 ; Remap::remapCount
  00af1	74 17		 je	 SHORT $L61910
  00af3	8b 95 80 f7 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00af9	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  00afd	74 0b		 je	 SHORT $L61910

; 250  : 		RemapMarkRedraw();

  00aff	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b05	e8 00 00 00 00	 call	 ?RemapMarkRedraw@GraphicsMgr@@QAEXXZ ; GraphicsMgr::RemapMarkRedraw
$L61910:

; 251  : 
; 252  : 	CalcLists(drawLists,eraseLists,dirtyRect);

  00b0a	8d 85 cc fb ff
	ff		 lea	 eax, DWORD PTR _dirtyRect$[ebp]
  00b10	50		 push	 eax
  00b11	68 00 00 00 00	 push	 OFFSET FLAT:?eraseLists@@3PAPAVRectList@@A ; eraseLists
  00b16	68 00 00 00 00	 push	 OFFSET FLAT:?drawLists@@3PAPAVDrawList@@A ; drawLists
  00b1b	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b21	8b 11		 mov	 edx, DWORD PTR [ecx]
  00b23	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b29	ff 52 48	 call	 DWORD PTR [edx+72]

; 253  : 
; 254  : 	// The number of planes may have been reduced by CalcLists
; 255  : 	nplanes = next.Planes().Length();

  00b2c	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b32	83 c1 14	 add	 ecx, 20			; 00000014H
  00b35	e8 00 00 00 00	 call	 ?Planes@Screen@@QAEAAVPlaneList@@XZ ; Screen::Planes
  00b3a	8b c8		 mov	 ecx, eax
  00b3c	e8 00 00 00 00	 call	 ?Length@PlaneList@@QBEHXZ ; PlaneList::Length
  00b41	89 45 e0	 mov	 DWORD PTR _nplanes$[ebp], eax

; 256  : 
; 257  : 	// Sort the draw lists
; 258  : 	for (i = 0; i < nplanes; i++)

  00b44	c7 85 c4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00b4e	eb 0f		 jmp	 SHORT $L61911
$L61912:
  00b50	8b 85 c4 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00b56	83 c0 01	 add	 eax, 1
  00b59	89 85 c4 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$L61911:
  00b5f	8b 8d c4 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00b65	3b 4d e0	 cmp	 ecx, DWORD PTR _nplanes$[ebp]
  00b68	7d 14		 jge	 SHORT $L61913

; 259  : 		drawLists[i]->Sort();

  00b6a	8b 95 c4 fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00b70	8b 0c 95 00 00
	00 00		 mov	 ecx, DWORD PTR ?drawLists@@3PAPAVDrawList@@A[edx*4]
  00b77	e8 00 00 00 00	 call	 ?Sort@DrawList@@QAEXXZ	; DrawList::Sort
  00b7c	eb d2		 jmp	 SHORT $L61912
$L61913:

; 260  : 
; 261  : 	for (i = 0; i < nplanes; i++)  {

  00b7e	c7 85 c4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00b88	eb 0f		 jmp	 SHORT $L61914
$L61915:
  00b8a	8b 85 c4 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00b90	83 c0 01	 add	 eax, 1
  00b93	89 85 c4 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$L61914:
  00b99	8b 8d c4 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00b9f	3b 4d e0	 cmp	 ecx, DWORD PTR _nplanes$[ebp]
  00ba2	7d 7b		 jge	 SHORT $L61916

; 262  : 		int count = drawLists[i]->Length();

  00ba4	8b 95 c4 fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00baa	8b 0c 95 00 00
	00 00		 mov	 ecx, DWORD PTR ?drawLists@@3PAPAVDrawList@@A[edx*4]
  00bb1	e8 00 00 00 00	 call	 ?Length@DrawList@@QBEHXZ ; DrawList::Length
  00bb6	89 85 ac f7 ff
	ff		 mov	 DWORD PTR _count$61917[ebp], eax

; 263  : 		DrawList& drawlist = *drawLists[i];

  00bbc	8b 85 c4 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00bc2	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?drawLists@@3PAPAVDrawList@@A[eax*4]
  00bc9	89 8d a8 f7 ff
	ff		 mov	 DWORD PTR _drawlist$61918[ebp], ecx

; 264  : 		for (int j = 0; j < count; j++) {

  00bcf	c7 85 a4 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$61919[ebp], 0
  00bd9	eb 0f		 jmp	 SHORT $L61920
$L61921:
  00bdb	8b 95 a4 f7 ff
	ff		 mov	 edx, DWORD PTR _j$61919[ebp]
  00be1	83 c2 01	 add	 edx, 1
  00be4	89 95 a4 f7 ff
	ff		 mov	 DWORD PTR _j$61919[ebp], edx
$L61920:
  00bea	8b 85 a4 f7 ff
	ff		 mov	 eax, DWORD PTR _j$61919[ebp]
  00bf0	3b 85 ac f7 ff
	ff		 cmp	 eax, DWORD PTR _count$61917[ebp]
  00bf6	7d 22		 jge	 SHORT $L61922

; 265  : 			drawlist[j].SI().SubmitPalette();

  00bf8	8b 8d a4 f7 ff
	ff		 mov	 ecx, DWORD PTR _j$61919[ebp]
  00bfe	51		 push	 ecx
  00bff	8b 8d a8 f7 ff
	ff		 mov	 ecx, DWORD PTR _drawlist$61918[ebp]
  00c05	e8 00 00 00 00	 call	 ??ADrawList@@QAEAAVDrawItem@@H@Z ; DrawList::operator[]
  00c0a	8b c8		 mov	 ecx, eax
  00c0c	e8 00 00 00 00	 call	 ?SI@DrawItem@@QAEAAVScreenItem@@XZ ; DrawItem::SI
  00c11	8b c8		 mov	 ecx, eax
  00c13	e8 00 00 00 00	 call	 ?SubmitPalette@ScreenItem@@QAEXXZ ; ScreenItem::SubmitPalette

; 266  : 		}

  00c18	eb c1		 jmp	 SHORT $L61921
$L61922:

; 267  : 	}

  00c1a	e9 6b ff ff ff	 jmp	 $L61915
$L61916:

; 268  : 
; 269  : 	lastRemapFlag = GPalette().UpdateForFrame();

  00c1f	8b 95 80 f7 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00c25	8b 02		 mov	 eax, DWORD PTR [edx]
  00c27	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00c2d	ff 50 1c	 call	 DWORD PTR [eax+28]
  00c30	89 85 5c f7 ff
	ff		 mov	 DWORD PTR -2212+[ebp], eax
  00c36	8b 8d 5c f7 ff
	ff		 mov	 ecx, DWORD PTR -2212+[ebp]
  00c3c	8b 11		 mov	 edx, DWORD PTR [ecx]
  00c3e	8b 8d 5c f7 ff
	ff		 mov	 ecx, DWORD PTR -2212+[ebp]
  00c44	ff 52 1c	 call	 DWORD PTR [edx+28]
  00c47	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00c4d	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 270  : 
; 271  : 	// draw to vmap
; 272  : 	for (i = 0; i < nplanes; i++)  {

  00c50	c7 85 c4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00c5a	eb 0f		 jmp	 SHORT $L61923
$L61924:
  00c5c	8b 95 c4 fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00c62	83 c2 01	 add	 edx, 1
  00c65	89 95 c4 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], edx
$L61923:
  00c6b	8b 85 c4 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00c71	3b 45 e0	 cmp	 eax, DWORD PTR _nplanes$[ebp]
  00c74	7d 5e		 jge	 SHORT $L61925

; 273  : 		vmapValid = False;

  00c76	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00c7c	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 274  : 		DrawEraseList(*eraseLists[i],next.Planes()[i]);

  00c83	8b 95 c4 fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00c89	52		 push	 edx
  00c8a	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00c90	83 c1 14	 add	 ecx, 20			; 00000014H
  00c93	e8 00 00 00 00	 call	 ?Planes@Screen@@QAEAAVPlaneList@@XZ ; Screen::Planes
  00c98	8b c8		 mov	 ecx, eax
  00c9a	e8 00 00 00 00	 call	 ??APlaneList@@QAEAAVSOL_Plane@@H@Z ; PlaneList::operator[]
  00c9f	50		 push	 eax
  00ca0	8b 85 c4 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00ca6	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?eraseLists@@3PAPAVRectList@@A[eax*4]
  00cad	51		 push	 ecx
  00cae	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00cb4	e8 00 00 00 00	 call	 ?DrawEraseList@GraphicsMgr@@IAEXABVRectList@@ABVSOL_Plane@@@Z ; GraphicsMgr::DrawEraseList

; 275  : 		DrawScreenItemList(*drawLists[i]);

  00cb9	8b 95 c4 fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00cbf	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?drawLists@@3PAPAVDrawList@@A[edx*4]
  00cc6	50		 push	 eax
  00cc7	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00ccd	e8 00 00 00 00	 call	 ?DrawScreenItemList@GraphicsMgr@@IAEXAAVDrawList@@@Z ; GraphicsMgr::DrawScreenItemList

; 276  : 	}

  00cd2	eb 88		 jmp	 SHORT $L61924
$L61925:

; 277  : 
; 278  : 	GPalette().Submit(thisPal);

  00cd4	8d 8d e0 fb ff
	ff		 lea	 ecx, DWORD PTR _thisPal$[ebp]
  00cda	51		 push	 ecx
  00cdb	8b 95 80 f7 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00ce1	8b 02		 mov	 eax, DWORD PTR [edx]
  00ce3	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00ce9	ff 50 1c	 call	 DWORD PTR [eax+28]
  00cec	89 85 58 f7 ff
	ff		 mov	 DWORD PTR -2216+[ebp], eax
  00cf2	8b 8d 58 f7 ff
	ff		 mov	 ecx, DWORD PTR -2216+[ebp]
  00cf8	8b 11		 mov	 edx, DWORD PTR [ecx]
  00cfa	8b 8d 58 f7 ff
	ff		 mov	 ecx, DWORD PTR -2216+[ebp]
  00d00	ff 52 04	 call	 DWORD PTR [edx+4]

; 279  : 	GPalette().UpdateFFrame();

  00d03	8b 85 80 f7 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00d09	8b 10		 mov	 edx, DWORD PTR [eax]
  00d0b	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00d11	ff 52 1c	 call	 DWORD PTR [edx+28]
  00d14	89 85 54 f7 ff
	ff		 mov	 DWORD PTR -2220+[ebp], eax
  00d1a	8b 85 54 f7 ff
	ff		 mov	 eax, DWORD PTR -2220+[ebp]
  00d20	8b 10		 mov	 edx, DWORD PTR [eax]
  00d22	8b 8d 54 f7 ff
	ff		 mov	 ecx, DWORD PTR -2220+[ebp]
  00d28	ff 52 20	 call	 DWORD PTR [edx+32]

; 280  : 	GPalette().UpdateHardware();

  00d2b	8b 85 80 f7 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00d31	8b 10		 mov	 edx, DWORD PTR [eax]
  00d33	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00d39	ff 52 1c	 call	 DWORD PTR [edx+28]
  00d3c	89 85 50 f7 ff
	ff		 mov	 DWORD PTR -2224+[ebp], eax
  00d42	8b 85 50 f7 ff
	ff		 mov	 eax, DWORD PTR -2224+[ebp]
  00d48	8b 10		 mov	 edx, DWORD PTR [eax]
  00d4a	8b 8d 50 f7 ff
	ff		 mov	 ecx, DWORD PTR -2224+[ebp]
  00d50	ff 92 80 00 00
	00		 call	 DWORD PTR [edx+128]

; 281  : 
; 282  : 	ShowBits();

  00d56	8b 85 80 f7 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00d5c	8b 10		 mov	 edx, DWORD PTR [eax]
  00d5e	8b 8d 80 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00d64	ff 52 40	 call	 DWORD PTR [edx+64]

; 283  : 	vmapValid = True;

  00d67	8b 85 80 f7 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00d6d	c7 40 08 01 00
	00 00		 mov	 DWORD PTR [eax+8], 1

; 284  : 
; 285  : 	//  Clean up and return
; 286  : 	for (i = 0;i < nplanes;i++)  {

  00d74	c7 85 c4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00d7e	eb 0f		 jmp	 SHORT $L61926
$L61927:
  00d80	8b 8d c4 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00d86	83 c1 01	 add	 ecx, 1
  00d89	89 8d c4 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], ecx
$L61926:
  00d8f	8b 95 c4 fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00d95	3b 55 e0	 cmp	 edx, DWORD PTR _nplanes$[ebp]
  00d98	0f 8d 93 00 00
	00		 jge	 $L61928

; 287  : 		delete eraseLists[i];

  00d9e	8b 85 c4 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00da4	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?eraseLists@@3PAPAVRectList@@A[eax*4]
  00dab	89 8d 8c f7 ff
	ff		 mov	 DWORD PTR $T62344[ebp], ecx
  00db1	8b 95 8c f7 ff
	ff		 mov	 edx, DWORD PTR $T62344[ebp]
  00db7	89 95 90 f7 ff
	ff		 mov	 DWORD PTR $T62343[ebp], edx
  00dbd	83 bd 90 f7 ff
	ff 00		 cmp	 DWORD PTR $T62343[ebp], 0
  00dc4	74 15		 je	 SHORT $L62345
  00dc6	6a 01		 push	 1
  00dc8	8b 8d 90 f7 ff
	ff		 mov	 ecx, DWORD PTR $T62343[ebp]
  00dce	e8 00 00 00 00	 call	 ??_GRectList@@QAEPAXI@Z	; RectList::`scalar deleting destructor'
  00dd3	89 85 4c f7 ff
	ff		 mov	 DWORD PTR -2228+[ebp], eax
  00dd9	eb 0a		 jmp	 SHORT $L62346
$L62345:
  00ddb	c7 85 4c f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR -2228+[ebp], 0
$L62346:

; 288  : 		delete drawLists[i];

  00de5	8b 85 c4 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00deb	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?drawLists@@3PAPAVDrawList@@A[eax*4]
  00df2	89 8d 84 f7 ff
	ff		 mov	 DWORD PTR $T62348[ebp], ecx
  00df8	8b 95 84 f7 ff
	ff		 mov	 edx, DWORD PTR $T62348[ebp]
  00dfe	89 95 88 f7 ff
	ff		 mov	 DWORD PTR $T62347[ebp], edx
  00e04	83 bd 88 f7 ff
	ff 00		 cmp	 DWORD PTR $T62347[ebp], 0
  00e0b	74 15		 je	 SHORT $L62349
  00e0d	6a 01		 push	 1
  00e0f	8b 8d 88 f7 ff
	ff		 mov	 ecx, DWORD PTR $T62347[ebp]
  00e15	e8 00 00 00 00	 call	 ??_GDrawList@@QAEPAXI@Z	; DrawList::`scalar deleting destructor'
  00e1a	89 85 48 f7 ff
	ff		 mov	 DWORD PTR -2232+[ebp], eax
  00e20	eb 0a		 jmp	 SHORT $L62350
$L62349:
  00e22	c7 85 48 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR -2232+[ebp], 0
$L62350:

; 289  : 	}

  00e2c	e9 4f ff ff ff	 jmp	 $L61927
$L61928:

; 290  : }

  00e31	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00e34	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00e3b	5e		 pop	 esi
  00e3c	8b e5		 mov	 esp, ebp
  00e3e	5d		 pop	 ebp
  00e3f	c2 08 00	 ret	 8
_TEXT	ENDS
text$x	SEGMENT
$L62351:
  0002c	8b 85 9c f7 ff
	ff		 mov	 eax, DWORD PTR $T62336[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00038	59		 pop	 ecx
  00039	c3		 ret	 0
$L62352:
  0003a	8b 85 94 f7 ff
	ff		 mov	 eax, DWORD PTR $T62340[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00046	59		 pop	 ecx
  00047	c3		 ret	 0
$L62355:
  00048	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T62354
  0004d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?PalMorphFrameOut@GraphicsMgr@@UAEXPADPAVPlaneShowStyle@@@Z ENDP ; GraphicsMgr::PalMorphFrameOut
;	COMDAT ??_GRectList@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GRectList@@QAEPAXI@Z PROC NEAR			; RectList::`scalar deleting destructor', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1RectList@@QAE@XZ	; RectList::~RectList
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L61937
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L61937:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GRectList@@QAEPAXI@Z ENDP				; RectList::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??1DrawList@@QAE@XZ:NEAR			; DrawList::~DrawList
;	COMDAT ??_GDrawList@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GDrawList@@QAEPAXI@Z PROC NEAR			; DrawList::`scalar deleting destructor', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1DrawList@@QAE@XZ	; DrawList::~DrawList
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L61940
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L61940:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GDrawList@@QAEPAXI@Z ENDP				; DrawList::`scalar deleting destructor'
_TEXT	ENDS
xdata$x	SEGMENT
$T62379	DD	019930520H
	DD	02H
	DD	FLAT:$T62381
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T62381	DD	0ffffffffH
	DD	FLAT:$L62376
	DD	0ffffffffH
	DD	FLAT:$L62377
xdata$x	ENDS
_TEXT	SEGMENT
_showBits$ = 8
_dirtyRect$ = 12
_this$ = -68
_nplanes$ = -16
_i$ = -20
_j$ = -24
_count$61967 = -28
_drawlist$61968 = -32
$T62360 = -36
$T62361 = -40
$T62364 = -44
$T62365 = -48
$T62368 = -52
$T62369 = -56
$T62372 = -60
$T62373 = -64
__$EHRec$ = -12
?FrameOut@GraphicsMgr@@UAEXHVSOL_Rect@@@Z PROC NEAR	; GraphicsMgr::FrameOut

; 294  : {

  00e42	55		 push	 ebp
  00e43	8b ec		 mov	 ebp, esp
  00e45	6a ff		 push	 -1
  00e47	68 00 00 00 00	 push	 $L62380
  00e4c	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00e52	50		 push	 eax
  00e53	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00e5a	83 ec 50	 sub	 esp, 80			; 00000050H
  00e5d	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx

; 295  : 	#ifdef DEBUG
; 296  : 	static int reenter = 0;		//  BUGBUG - DF - Won't work if mult graphmgrs
; 297  : 	int i;
; 298  : 	reenter++;
; 299  : 	if (reenter == 2)
; 300  : 		msgMgr->Alert("Frameout reentered!");
; 301  : 
; 302  : 	#endif
; 303  : 
; 304  : 	int nplanes = next.Planes().Length();

  00e60	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e63	83 c1 14	 add	 ecx, 20			; 00000014H
  00e66	e8 00 00 00 00	 call	 ?Planes@Screen@@QAEAAVPlaneList@@XZ ; Screen::Planes
  00e6b	8b c8		 mov	 ecx, eax
  00e6d	e8 00 00 00 00	 call	 ?Length@PlaneList@@QBEHXZ ; PlaneList::Length
  00e72	89 45 f0	 mov	 DWORD PTR _nplanes$[ebp], eax

; 305  : 	int i,j;
; 306  : 	for (i = 0;i < nplanes;i++)  {

  00e75	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00e7c	eb 09		 jmp	 SHORT $L61949
$L61950:
  00e7e	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00e81	83 c0 01	 add	 eax, 1
  00e84	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$L61949:
  00e87	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  00e8a	3b 4d f0	 cmp	 ecx, DWORD PTR _nplanes$[ebp]
  00e8d	0f 8d 9b 00 00
	00		 jge	 $L61951

; 307  : 		drawLists[i] = New DrawList;

  00e93	68 44 1f 00 00	 push	 8004			; 00001f44H
  00e98	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00e9d	83 c4 04	 add	 esp, 4
  00ea0	89 45 d8	 mov	 DWORD PTR $T62361[ebp], eax
  00ea3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00eaa	83 7d d8 00	 cmp	 DWORD PTR $T62361[ebp], 0
  00eae	74 0d		 je	 SHORT $L62362
  00eb0	8b 4d d8	 mov	 ecx, DWORD PTR $T62361[ebp]
  00eb3	e8 00 00 00 00	 call	 ??0DrawList@@QAE@XZ	; DrawList::DrawList
  00eb8	89 45 b8	 mov	 DWORD PTR -72+[ebp], eax
  00ebb	eb 07		 jmp	 SHORT $L62363
$L62362:
  00ebd	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR -72+[ebp], 0
$L62363:
  00ec4	8b 55 b8	 mov	 edx, DWORD PTR -72+[ebp]
  00ec7	89 55 dc	 mov	 DWORD PTR $T62360[ebp], edx
  00eca	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00ed1	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00ed4	8b 4d dc	 mov	 ecx, DWORD PTR $T62360[ebp]
  00ed7	89 0c 85 00 00
	00 00		 mov	 DWORD PTR ?drawLists@@3PAPAVDrawList@@A[eax*4], ecx

; 308  : 		eraseLists[i] = New RectList;

  00ede	68 a4 0f 00 00	 push	 4004			; 00000fa4H
  00ee3	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00ee8	83 c4 04	 add	 esp, 4
  00eeb	89 45 d0	 mov	 DWORD PTR $T62365[ebp], eax
  00eee	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00ef5	83 7d d0 00	 cmp	 DWORD PTR $T62365[ebp], 0
  00ef9	74 0d		 je	 SHORT $L62366
  00efb	8b 4d d0	 mov	 ecx, DWORD PTR $T62365[ebp]
  00efe	e8 00 00 00 00	 call	 ??0RectList@@QAE@XZ	; RectList::RectList
  00f03	89 45 b4	 mov	 DWORD PTR -76+[ebp], eax
  00f06	eb 07		 jmp	 SHORT $L62367
$L62366:
  00f08	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR -76+[ebp], 0
$L62367:
  00f0f	8b 55 b4	 mov	 edx, DWORD PTR -76+[ebp]
  00f12	89 55 d4	 mov	 DWORD PTR $T62364[ebp], edx
  00f15	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00f1c	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00f1f	8b 4d d4	 mov	 ecx, DWORD PTR $T62364[ebp]
  00f22	89 0c 85 00 00
	00 00		 mov	 DWORD PTR ?eraseLists@@3PAPAVRectList@@A[eax*4], ecx

; 309  : 	}

  00f29	e9 50 ff ff ff	 jmp	 $L61950
$L61951:

; 310  : 
; 311  : 	if (Remap::remapCount && lastRemapFlag)

  00f2e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?remapCount@Remap@@2IA, 0 ; Remap::remapCount
  00f35	74 11		 je	 SHORT $L61960
  00f37	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  00f3a	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  00f3e	74 08		 je	 SHORT $L61960

; 312  : 		RemapMarkRedraw();

  00f40	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f43	e8 00 00 00 00	 call	 ?RemapMarkRedraw@GraphicsMgr@@QAEXXZ ; GraphicsMgr::RemapMarkRedraw
$L61960:

; 313  : 
; 314  : 	CalcLists(drawLists,eraseLists,dirtyRect);

  00f48	8d 45 0c	 lea	 eax, DWORD PTR _dirtyRect$[ebp]
  00f4b	50		 push	 eax
  00f4c	68 00 00 00 00	 push	 OFFSET FLAT:?eraseLists@@3PAPAVRectList@@A ; eraseLists
  00f51	68 00 00 00 00	 push	 OFFSET FLAT:?drawLists@@3PAPAVDrawList@@A ; drawLists
  00f56	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f59	8b 11		 mov	 edx, DWORD PTR [ecx]
  00f5b	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f5e	ff 52 48	 call	 DWORD PTR [edx+72]

; 315  : 
; 316  : 	// The number of planes may have been reduced by CalcLists
; 317  : 	nplanes = next.Planes().Length();

  00f61	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f64	83 c1 14	 add	 ecx, 20			; 00000014H
  00f67	e8 00 00 00 00	 call	 ?Planes@Screen@@QAEAAVPlaneList@@XZ ; Screen::Planes
  00f6c	8b c8		 mov	 ecx, eax
  00f6e	e8 00 00 00 00	 call	 ?Length@PlaneList@@QBEHXZ ; PlaneList::Length
  00f73	89 45 f0	 mov	 DWORD PTR _nplanes$[ebp], eax

; 318  : 
; 319  : 	// Sort the draw lists
; 320  : 	for (i = 0; i < nplanes; i++)

  00f76	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00f7d	eb 09		 jmp	 SHORT $L61961
$L61962:
  00f7f	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00f82	83 c0 01	 add	 eax, 1
  00f85	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$L61961:
  00f88	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  00f8b	3b 4d f0	 cmp	 ecx, DWORD PTR _nplanes$[ebp]
  00f8e	7d 11		 jge	 SHORT $L61963

; 321  : 		drawLists[i]->Sort();

  00f90	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  00f93	8b 0c 95 00 00
	00 00		 mov	 ecx, DWORD PTR ?drawLists@@3PAPAVDrawList@@A[edx*4]
  00f9a	e8 00 00 00 00	 call	 ?Sort@DrawList@@QAEXXZ	; DrawList::Sort
  00f9f	eb de		 jmp	 SHORT $L61962
$L61963:

; 322  : 
; 323  : 	for (i = 0; i < nplanes; i++)  {

  00fa1	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00fa8	eb 09		 jmp	 SHORT $L61964
$L61965:
  00faa	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00fad	83 c0 01	 add	 eax, 1
  00fb0	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$L61964:
  00fb3	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  00fb6	3b 4d f0	 cmp	 ecx, DWORD PTR _nplanes$[ebp]
  00fb9	7d 57		 jge	 SHORT $L61966

; 324  : 		int count = drawLists[i]->Length();

  00fbb	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  00fbe	8b 0c 95 00 00
	00 00		 mov	 ecx, DWORD PTR ?drawLists@@3PAPAVDrawList@@A[edx*4]
  00fc5	e8 00 00 00 00	 call	 ?Length@DrawList@@QBEHXZ ; DrawList::Length
  00fca	89 45 e4	 mov	 DWORD PTR _count$61967[ebp], eax

; 325  : 		DrawList& drawlist = *drawLists[i];

  00fcd	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00fd0	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?drawLists@@3PAPAVDrawList@@A[eax*4]
  00fd7	89 4d e0	 mov	 DWORD PTR _drawlist$61968[ebp], ecx

; 326  : 		for (j = 0; j < count; j++) {

  00fda	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00fe1	eb 09		 jmp	 SHORT $L61969
$L61970:
  00fe3	8b 55 e8	 mov	 edx, DWORD PTR _j$[ebp]
  00fe6	83 c2 01	 add	 edx, 1
  00fe9	89 55 e8	 mov	 DWORD PTR _j$[ebp], edx
$L61969:
  00fec	8b 45 e8	 mov	 eax, DWORD PTR _j$[ebp]
  00fef	3b 45 e4	 cmp	 eax, DWORD PTR _count$61967[ebp]
  00ff2	7d 1c		 jge	 SHORT $L61971

; 327  : 			drawlist[j].SI().SubmitPalette();

  00ff4	8b 4d e8	 mov	 ecx, DWORD PTR _j$[ebp]
  00ff7	51		 push	 ecx
  00ff8	8b 4d e0	 mov	 ecx, DWORD PTR _drawlist$61968[ebp]
  00ffb	e8 00 00 00 00	 call	 ??ADrawList@@QAEAAVDrawItem@@H@Z ; DrawList::operator[]
  01000	8b c8		 mov	 ecx, eax
  01002	e8 00 00 00 00	 call	 ?SI@DrawItem@@QAEAAVScreenItem@@XZ ; DrawItem::SI
  01007	8b c8		 mov	 ecx, eax
  01009	e8 00 00 00 00	 call	 ?SubmitPalette@ScreenItem@@QAEXXZ ; ScreenItem::SubmitPalette

; 328  : 		}

  0100e	eb d3		 jmp	 SHORT $L61970
$L61971:

; 329  : 	}

  01010	eb 98		 jmp	 SHORT $L61965
$L61966:

; 330  : 
; 331  : 	lastRemapFlag = GPalette().UpdateForFrame();

  01012	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  01015	8b 02		 mov	 eax, DWORD PTR [edx]
  01017	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0101a	ff 50 1c	 call	 DWORD PTR [eax+28]
  0101d	89 45 b0	 mov	 DWORD PTR -80+[ebp], eax
  01020	8b 4d b0	 mov	 ecx, DWORD PTR -80+[ebp]
  01023	8b 11		 mov	 edx, DWORD PTR [ecx]
  01025	8b 4d b0	 mov	 ecx, DWORD PTR -80+[ebp]
  01028	ff 52 1c	 call	 DWORD PTR [edx+28]
  0102b	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0102e	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 332  : 
; 333  : 	// draw to vmap
; 334  : 	for (i = 0; i < nplanes; i++)  {

  01031	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  01038	eb 09		 jmp	 SHORT $L61972
$L61973:
  0103a	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  0103d	83 c2 01	 add	 edx, 1
  01040	89 55 ec	 mov	 DWORD PTR _i$[ebp], edx
$L61972:
  01043	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  01046	3b 45 f0	 cmp	 eax, DWORD PTR _nplanes$[ebp]
  01049	7d 49		 jge	 SHORT $L61974

; 335  : 		vmapValid = False;

  0104b	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0104e	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 336  : 		DrawEraseList(*eraseLists[i],next.Planes()[i]);

  01055	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  01058	52		 push	 edx
  01059	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0105c	83 c1 14	 add	 ecx, 20			; 00000014H
  0105f	e8 00 00 00 00	 call	 ?Planes@Screen@@QAEAAVPlaneList@@XZ ; Screen::Planes
  01064	8b c8		 mov	 ecx, eax
  01066	e8 00 00 00 00	 call	 ??APlaneList@@QAEAAVSOL_Plane@@H@Z ; PlaneList::operator[]
  0106b	50		 push	 eax
  0106c	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  0106f	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?eraseLists@@3PAPAVRectList@@A[eax*4]
  01076	51		 push	 ecx
  01077	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0107a	e8 00 00 00 00	 call	 ?DrawEraseList@GraphicsMgr@@IAEXABVRectList@@ABVSOL_Plane@@@Z ; GraphicsMgr::DrawEraseList

; 337  : 		DrawScreenItemList(*drawLists[i]);

  0107f	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  01082	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?drawLists@@3PAPAVDrawList@@A[edx*4]
  01089	50		 push	 eax
  0108a	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0108d	e8 00 00 00 00	 call	 ?DrawScreenItemList@GraphicsMgr@@IAEXAAVDrawList@@@Z ; GraphicsMgr::DrawScreenItemList

; 338  : 	}

  01092	eb a6		 jmp	 SHORT $L61973
$L61974:

; 339  : 
; 340  : 	// move rectangles to video memory
; 341  : 	GPalette().UpdateHardware();

  01094	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  01097	8b 11		 mov	 edx, DWORD PTR [ecx]
  01099	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0109c	ff 52 1c	 call	 DWORD PTR [edx+28]
  0109f	89 45 ac	 mov	 DWORD PTR -84+[ebp], eax
  010a2	8b 45 ac	 mov	 eax, DWORD PTR -84+[ebp]
  010a5	8b 10		 mov	 edx, DWORD PTR [eax]
  010a7	8b 4d ac	 mov	 ecx, DWORD PTR -84+[ebp]
  010aa	ff 92 80 00 00
	00		 call	 DWORD PTR [edx+128]

; 342  : 
; 343  : 	// If not just a reference frame for a
; 344  : 	// show style output changes to hardware
; 345  : 	if (showBits)

  010b0	83 7d 08 00	 cmp	 DWORD PTR _showBits$[ebp], 0
  010b4	74 0b		 je	 SHORT $L61975

; 346  : 		ShowBits();

  010b6	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  010b9	8b 10		 mov	 edx, DWORD PTR [eax]
  010bb	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  010be	ff 52 40	 call	 DWORD PTR [edx+64]
$L61975:

; 347  : 	vmapValid = True;

  010c1	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  010c4	c7 40 08 01 00
	00 00		 mov	 DWORD PTR [eax+8], 1

; 348  : 
; 349  : 	//  Clean up and return
; 350  : 	for (i = 0;i < nplanes;i++)  {

  010cb	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  010d2	eb 09		 jmp	 SHORT $L61976
$L61977:
  010d4	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  010d7	83 c1 01	 add	 ecx, 1
  010da	89 4d ec	 mov	 DWORD PTR _i$[ebp], ecx
$L61976:
  010dd	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  010e0	3b 55 f0	 cmp	 edx, DWORD PTR _nplanes$[ebp]
  010e3	7d 60		 jge	 SHORT $L61978

; 351  : 		delete eraseLists[i];

  010e5	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  010e8	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?eraseLists@@3PAPAVRectList@@A[eax*4]
  010ef	89 4d c8	 mov	 DWORD PTR $T62369[ebp], ecx
  010f2	8b 55 c8	 mov	 edx, DWORD PTR $T62369[ebp]
  010f5	89 55 cc	 mov	 DWORD PTR $T62368[ebp], edx
  010f8	83 7d cc 00	 cmp	 DWORD PTR $T62368[ebp], 0
  010fc	74 0f		 je	 SHORT $L62370
  010fe	6a 01		 push	 1
  01100	8b 4d cc	 mov	 ecx, DWORD PTR $T62368[ebp]
  01103	e8 00 00 00 00	 call	 ??_GRectList@@QAEPAXI@Z	; RectList::`scalar deleting destructor'
  01108	89 45 a8	 mov	 DWORD PTR -88+[ebp], eax
  0110b	eb 07		 jmp	 SHORT $L62371
$L62370:
  0110d	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR -88+[ebp], 0
$L62371:

; 352  : 		delete drawLists[i];

  01114	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  01117	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?drawLists@@3PAPAVDrawList@@A[eax*4]
  0111e	89 4d c0	 mov	 DWORD PTR $T62373[ebp], ecx
  01121	8b 55 c0	 mov	 edx, DWORD PTR $T62373[ebp]
  01124	89 55 c4	 mov	 DWORD PTR $T62372[ebp], edx
  01127	83 7d c4 00	 cmp	 DWORD PTR $T62372[ebp], 0
  0112b	74 0f		 je	 SHORT $L62374
  0112d	6a 01		 push	 1
  0112f	8b 4d c4	 mov	 ecx, DWORD PTR $T62372[ebp]
  01132	e8 00 00 00 00	 call	 ??_GDrawList@@QAEPAXI@Z	; DrawList::`scalar deleting destructor'
  01137	89 45 a4	 mov	 DWORD PTR -92+[ebp], eax
  0113a	eb 07		 jmp	 SHORT $L62375
$L62374:
  0113c	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR -92+[ebp], 0
$L62375:

; 353  : 	}

  01143	eb 8f		 jmp	 SHORT $L61977
$L61978:

; 354  : 
; 355  : 	#ifdef DEBUG
; 356  : 	reenter--;
; 357  : 	#endif
; 358  : }

  01145	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01148	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0114f	8b e5		 mov	 esp, ebp
  01151	5d		 pop	 ebp
  01152	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
text$x	SEGMENT
$L62376:
  00052	8b 45 d8	 mov	 eax, DWORD PTR $T62361[ebp]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005b	59		 pop	 ecx
  0005c	c3		 ret	 0
$L62377:
  0005d	8b 45 d0	 mov	 eax, DWORD PTR $T62365[ebp]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00066	59		 pop	 ecx
  00067	c3		 ret	 0
$L62380:
  00068	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T62379
  0006d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?FrameOut@GraphicsMgr@@UAEXHVSOL_Rect@@@Z ENDP		; GraphicsMgr::FrameOut
PUBLIC	??0SOL_Point@@QAE@XZ				; SOL_Point::SOL_Point
;	COMDAT ??0SOL_Rect@@QAE@HHHH@Z
_TEXT	SEGMENT
_xa$ = 8
_ya$ = 12
_xb$ = 16
_yb$ = 20
_this$ = -4
??0SOL_Rect@@QAE@HHHH@Z PROC NEAR			; SOL_Rect::SOL_Rect, COMDAT

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 08	 add	 ecx, 8
  00015	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point

; 56   : 	A.x = xa;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _xa$[ebp]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 57   : 	A.y = ya;

  00022	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00025	8b 45 0c	 mov	 eax, DWORD PTR _ya$[ebp]
  00028	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 58   : 	B.x = xb;

  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8b 55 10	 mov	 edx, DWORD PTR _xb$[ebp]
  00031	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 59   : 	B.y = yb;

  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 4d 14	 mov	 ecx, DWORD PTR _yb$[ebp]
  0003a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 60   : }

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 10 00	 ret	 16			; 00000010H
??0SOL_Rect@@QAE@HHHH@Z ENDP				; SOL_Rect::SOL_Rect
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0SOL_Point@@QAE@XZ PROC NEAR				; SOL_Point::SOL_Point, COMDAT

; 20   : 	SOL_Point() : x(DefaultCoord), y(DefaultCoord) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 ef cd ab
	89		 mov	 DWORD PTR [eax], -1985229329 ; 89abcdefH
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 ef cd
	ab 89		 mov	 DWORD PTR [ecx+4], -1985229329 ; 89abcdefH
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0SOL_Point@@QAE@XZ ENDP				; SOL_Point::SOL_Point
_TEXT	ENDS
PUBLIC	??ARectList@@QBEABVSOL_Rect@@H@Z		; RectList::operator[]
PUBLIC	?Length@RectList@@QBEHXZ			; RectList::Length
PUBLIC	?Color@SOL_Plane@@QBEEXZ			; SOL_Plane::Color
PUBLIC	?IsColored@SOL_Plane@@QBEHXZ			; SOL_Plane::IsColored
PUBLIC	?XDim@Buffer@@QBEHXZ				; Buffer::XDim
PUBLIC	?Xlen@SOL_Rect@@QBEHXZ				; SOL_Rect::Xlen
PUBLIC	?Ylen@SOL_Rect@@QBEHXZ				; SOL_Rect::Ylen
PUBLIC	?Area@SOL_Rect@@QBEJXZ				; SOL_Rect::Area
PUBLIC	??0SOL_Rect@@QAE@ABV0@@Z			; SOL_Rect::SOL_Rect
PUBLIC	?MergeToShowList@GraphicsMgr@@IAEXABVSOL_Rect@@AAVRectList@@H@Z ; GraphicsMgr::MergeToShowList
EXTRN	_memset:NEAR
_TEXT	SEGMENT
_eraseList$ = 8
_plane$ = 12
_this$ = -56
_area$ = -4
_eraseListSize$61990 = -8
_i$61991 = -12
_rect$61995 = -28
_hRun$61996 = -40
_vRun$61997 = -32
_drawSkip$61998 = -48
_color$61999 = -36
_j$62000 = -44
_startDraw$62004 = -52
?DrawEraseList@GraphicsMgr@@IAEXABVRectList@@ABVSOL_Plane@@@Z PROC NEAR ; GraphicsMgr::DrawEraseList

; 362  : {

  01155	55		 push	 ebp
  01156	8b ec		 mov	 ebp, esp
  01158	83 ec 3c	 sub	 esp, 60			; 0000003cH
  0115b	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx

; 363  : 	//	Draws a monochrome rectangles and lines from a plane's
; 364  : 	//	erase list into the screen manager's screen.
; 365  : 	//	Adds to showList.
; 366  : 	int area = 0;

  0115e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _area$[ebp], 0

; 367  : 
; 368  : 	// Go through the entire list of erase items
; 369  : 	if (plane.IsColored())  {

  01165	8b 4d 0c	 mov	 ecx, DWORD PTR _plane$[ebp]
  01168	e8 00 00 00 00	 call	 ?IsColored@SOL_Plane@@QBEHXZ ; SOL_Plane::IsColored
  0116d	85 c0		 test	 eax, eax
  0116f	0f 84 06 01 00
	00		 je	 $L61994

; 370  : 		int eraseListSize = eraseList.Length();

  01175	8b 4d 08	 mov	 ecx, DWORD PTR _eraseList$[ebp]
  01178	e8 00 00 00 00	 call	 ?Length@RectList@@QBEHXZ ; RectList::Length
  0117d	89 45 f8	 mov	 DWORD PTR _eraseListSize$61990[ebp], eax

; 371  : 		for (int i = 0;i < eraseListSize;++i) {

  01180	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$61991[ebp], 0
  01187	eb 09		 jmp	 SHORT $L61992
$L61993:
  01189	8b 45 f4	 mov	 eax, DWORD PTR _i$61991[ebp]
  0118c	83 c0 01	 add	 eax, 1
  0118f	89 45 f4	 mov	 DWORD PTR _i$61991[ebp], eax
$L61992:
  01192	8b 4d f4	 mov	 ecx, DWORD PTR _i$61991[ebp]
  01195	3b 4d f8	 cmp	 ecx, DWORD PTR _eraseListSize$61990[ebp]
  01198	0f 8d dd 00 00
	00		 jge	 $L61994

; 372  : 			SOL_Rect rect = eraseList[i];

  0119e	8b 55 f4	 mov	 edx, DWORD PTR _i$61991[ebp]
  011a1	52		 push	 edx
  011a2	8b 4d 08	 mov	 ecx, DWORD PTR _eraseList$[ebp]
  011a5	e8 00 00 00 00	 call	 ??ARectList@@QBEABVSOL_Rect@@H@Z ; RectList::operator[]
  011aa	50		 push	 eax
  011ab	8d 4d e4	 lea	 ecx, DWORD PTR _rect$61995[ebp]
  011ae	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@ABV0@@Z ; SOL_Rect::SOL_Rect

; 373  : 
; 374  : 			// Add the rectangle to the showList
; 375  : 			MergeToShowList(rect,NextScreen()->ShowList(),pixelsPerCall);

  011b3	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  011b6	8b 88 64 11 00
	00		 mov	 ecx, DWORD PTR [eax+4452]
  011bc	51		 push	 ecx
  011bd	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  011c0	e8 00 00 00 00	 call	 ?NextScreen@GraphicsMgr@@QAEPAVScreen@@XZ ; GraphicsMgr::NextScreen
  011c5	8b c8		 mov	 ecx, eax
  011c7	e8 00 00 00 00	 call	 ?ShowList@Screen@@QAEAAVRectList@@XZ ; Screen::ShowList
  011cc	50		 push	 eax
  011cd	8d 55 e4	 lea	 edx, DWORD PTR _rect$61995[ebp]
  011d0	52		 push	 edx
  011d1	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  011d4	e8 00 00 00 00	 call	 ?MergeToShowList@GraphicsMgr@@IAEXABVSOL_Rect@@AAVRectList@@H@Z ; GraphicsMgr::MergeToShowList

; 376  : 			int hRun = rect.Xlen();

  011d9	8d 4d e4	 lea	 ecx, DWORD PTR _rect$61995[ebp]
  011dc	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  011e1	89 45 d8	 mov	 DWORD PTR _hRun$61996[ebp], eax

; 377  : 			int vRun = rect.Ylen();

  011e4	8d 4d e4	 lea	 ecx, DWORD PTR _rect$61995[ebp]
  011e7	e8 00 00 00 00	 call	 ?Ylen@SOL_Rect@@QBEHXZ	; SOL_Rect::Ylen
  011ec	89 45 e0	 mov	 DWORD PTR _vRun$61997[ebp], eax

; 378  : 			int drawSkip = CurrBuffer()->XDim();

  011ef	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  011f2	8b 10		 mov	 edx, DWORD PTR [eax]
  011f4	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  011f7	ff 52 10	 call	 DWORD PTR [edx+16]
  011fa	8b c8		 mov	 ecx, eax
  011fc	e8 00 00 00 00	 call	 ?XDim@Buffer@@QBEHXZ	; Buffer::XDim
  01201	89 45 d0	 mov	 DWORD PTR _drawSkip$61998[ebp], eax

; 379  : 			char color = plane.Color();

  01204	8b 4d 0c	 mov	 ecx, DWORD PTR _plane$[ebp]
  01207	e8 00 00 00 00	 call	 ?Color@SOL_Plane@@QBEEXZ ; SOL_Plane::Color
  0120c	88 45 dc	 mov	 BYTE PTR _color$61999[ebp], al

; 380  : 			for (int j = 0;j < vRun;++j) {

  0120f	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _j$62000[ebp], 0
  01216	eb 09		 jmp	 SHORT $L62001
$L62002:
  01218	8b 45 d4	 mov	 eax, DWORD PTR _j$62000[ebp]
  0121b	83 c0 01	 add	 eax, 1
  0121e	89 45 d4	 mov	 DWORD PTR _j$62000[ebp], eax
$L62001:
  01221	8b 4d d4	 mov	 ecx, DWORD PTR _j$62000[ebp]
  01224	3b 4d e0	 cmp	 ecx, DWORD PTR _vRun$61997[ebp]
  01227	7d 3d		 jge	 SHORT $L62003

; 381  : 				uchar* startDraw = CurrBuffer()->Addr(rect.A.x, rect.A.y + j);

  01229	8b 55 e8	 mov	 edx, DWORD PTR _rect$61995[ebp+4]
  0122c	03 55 d4	 add	 edx, DWORD PTR _j$62000[ebp]
  0122f	52		 push	 edx
  01230	8b 45 e4	 mov	 eax, DWORD PTR _rect$61995[ebp]
  01233	50		 push	 eax
  01234	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  01237	8b 11		 mov	 edx, DWORD PTR [ecx]
  01239	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0123c	ff 52 10	 call	 DWORD PTR [edx+16]
  0123f	89 45 c4	 mov	 DWORD PTR -60+[ebp], eax
  01242	8b 45 c4	 mov	 eax, DWORD PTR -60+[ebp]
  01245	8b 10		 mov	 edx, DWORD PTR [eax]
  01247	8b 4d c4	 mov	 ecx, DWORD PTR -60+[ebp]
  0124a	ff 12		 call	 DWORD PTR [edx]
  0124c	89 45 cc	 mov	 DWORD PTR _startDraw$62004[ebp], eax

; 382  : 				memset(startDraw,color,hRun);

  0124f	8b 45 d8	 mov	 eax, DWORD PTR _hRun$61996[ebp]
  01252	50		 push	 eax
  01253	0f be 4d dc	 movsx	 ecx, BYTE PTR _color$61999[ebp]
  01257	51		 push	 ecx
  01258	8b 55 cc	 mov	 edx, DWORD PTR _startDraw$62004[ebp]
  0125b	52		 push	 edx
  0125c	e8 00 00 00 00	 call	 _memset
  01261	83 c4 0c	 add	 esp, 12			; 0000000cH

; 383  : 			}

  01264	eb b2		 jmp	 SHORT $L62002
$L62003:

; 384  : 
; 385  : 			area += rect.Area();

  01266	8d 4d e4	 lea	 ecx, DWORD PTR _rect$61995[ebp]
  01269	e8 00 00 00 00	 call	 ?Area@SOL_Rect@@QBEJXZ	; SOL_Rect::Area
  0126e	8b 4d fc	 mov	 ecx, DWORD PTR _area$[ebp]
  01271	03 c8		 add	 ecx, eax
  01273	89 4d fc	 mov	 DWORD PTR _area$[ebp], ecx

; 386  : 		}

  01276	e9 0e ff ff ff	 jmp	 $L61993
$L61994:

; 388  : 
; 389  : //	if ( area )
; 390  : //		msgMgr->Mono ( "eraseList area = %d\n", area );
; 391  : }

  0127b	8b e5		 mov	 esp, ebp
  0127d	5d		 pop	 ebp
  0127e	c2 08 00	 ret	 8
?DrawEraseList@GraphicsMgr@@IAEXABVRectList@@ABVSOL_Plane@@@Z ENDP ; GraphicsMgr::DrawEraseList
_TEXT	ENDS
PUBLIC	?GetCel@ScreenItem@@QAEPAVCelObj@@XZ		; ScreenItem::GetCel
PUBLIC	?Draw@DrawItem@@QAEXAAVBuffer@@@Z		; DrawItem::Draw
PUBLIC	?OnScreen@DrawItem@@QAEAAVSOL_Rect@@XZ		; DrawItem::OnScreen
_TEXT	SEGMENT
_drawList$ = 8
_this$ = -20
_drawListSize$ = -4
_area$ = -8
_i$ = -12
_celObj$62015 = -16
?DrawScreenItemList@GraphicsMgr@@IAEXAAVDrawList@@@Z PROC NEAR ; GraphicsMgr::DrawScreenItemList

; 395  : {

  01281	55		 push	 ebp
  01282	8b ec		 mov	 ebp, esp
  01284	83 ec 14	 sub	 esp, 20			; 00000014H
  01287	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 396  : 	// Draws a rectangles and lines from cels
; 397  : 	//	into the screen manager's screen.
; 398  : 	//	Adds to showList
; 399  : 
; 400  : 	// Go through the entire list of screenItems
; 401  : 	int drawListSize = drawList.Length();

  0128a	8b 4d 08	 mov	 ecx, DWORD PTR _drawList$[ebp]
  0128d	e8 00 00 00 00	 call	 ?Length@DrawList@@QBEHXZ ; DrawList::Length
  01292	89 45 fc	 mov	 DWORD PTR _drawListSize$[ebp], eax

; 402  : 	int area = 0;

  01295	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _area$[ebp], 0

; 403  : 	for (int i = 0;i < drawListSize;++i) {

  0129c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  012a3	eb 09		 jmp	 SHORT $L62012
$L62013:
  012a5	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  012a8	83 c0 01	 add	 eax, 1
  012ab	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$L62012:
  012ae	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  012b1	3b 4d fc	 cmp	 ecx, DWORD PTR _drawListSize$[ebp]
  012b4	0f 8d a4 00 00
	00		 jge	 $L62014

; 404  : 		MergeToShowList(drawList[i].OnScreen(),NextScreen()->ShowList(),pixelsPerCall);

  012ba	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  012bd	8b 82 64 11 00
	00		 mov	 eax, DWORD PTR [edx+4452]
  012c3	50		 push	 eax
  012c4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  012c7	e8 00 00 00 00	 call	 ?NextScreen@GraphicsMgr@@QAEPAVScreen@@XZ ; GraphicsMgr::NextScreen
  012cc	8b c8		 mov	 ecx, eax
  012ce	e8 00 00 00 00	 call	 ?ShowList@Screen@@QAEAAVRectList@@XZ ; Screen::ShowList
  012d3	50		 push	 eax
  012d4	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  012d7	51		 push	 ecx
  012d8	8b 4d 08	 mov	 ecx, DWORD PTR _drawList$[ebp]
  012db	e8 00 00 00 00	 call	 ??ADrawList@@QAEAAVDrawItem@@H@Z ; DrawList::operator[]
  012e0	8b c8		 mov	 ecx, eax
  012e2	e8 00 00 00 00	 call	 ?OnScreen@DrawItem@@QAEAAVSOL_Rect@@XZ ; DrawItem::OnScreen
  012e7	50		 push	 eax
  012e8	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  012eb	e8 00 00 00 00	 call	 ?MergeToShowList@GraphicsMgr@@IAEXABVSOL_Rect@@AAVRectList@@H@Z ; GraphicsMgr::MergeToShowList

; 405  : 
; 406  : 		CelObj *celObj = drawList[i].SI().GetCel();

  012f0	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  012f3	52		 push	 edx
  012f4	8b 4d 08	 mov	 ecx, DWORD PTR _drawList$[ebp]
  012f7	e8 00 00 00 00	 call	 ??ADrawList@@QAEAAVDrawItem@@H@Z ; DrawList::operator[]
  012fc	8b c8		 mov	 ecx, eax
  012fe	e8 00 00 00 00	 call	 ?SI@DrawItem@@QAEAAVScreenItem@@XZ ; DrawItem::SI
  01303	8b c8		 mov	 ecx, eax
  01305	e8 00 00 00 00	 call	 ?GetCel@ScreenItem@@QAEPAVCelObj@@XZ ; ScreenItem::GetCel
  0130a	89 45 f0	 mov	 DWORD PTR _celObj$62015[ebp], eax

; 407  : 		celObj->ResPointer();

  0130d	8b 45 f0	 mov	 eax, DWORD PTR _celObj$62015[ebp]
  01310	8b 10		 mov	 edx, DWORD PTR [eax]
  01312	8b 4d f0	 mov	 ecx, DWORD PTR _celObj$62015[ebp]
  01315	ff 52 14	 call	 DWORD PTR [edx+20]

; 408  : 
; 409  : 		drawList[i].Draw(*CurrBuffer());

  01318	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0131b	8b 10		 mov	 edx, DWORD PTR [eax]
  0131d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01320	ff 52 10	 call	 DWORD PTR [edx+16]
  01323	50		 push	 eax
  01324	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  01327	50		 push	 eax
  01328	8b 4d 08	 mov	 ecx, DWORD PTR _drawList$[ebp]
  0132b	e8 00 00 00 00	 call	 ??ADrawList@@QAEAAVDrawItem@@H@Z ; DrawList::operator[]
  01330	8b c8		 mov	 ecx, eax
  01332	e8 00 00 00 00	 call	 ?Draw@DrawItem@@QAEXAAVBuffer@@@Z ; DrawItem::Draw

; 410  : 		area += drawList[i].OnScreen().Area();

  01337	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0133a	51		 push	 ecx
  0133b	8b 4d 08	 mov	 ecx, DWORD PTR _drawList$[ebp]
  0133e	e8 00 00 00 00	 call	 ??ADrawList@@QAEAAVDrawItem@@H@Z ; DrawList::operator[]
  01343	8b c8		 mov	 ecx, eax
  01345	e8 00 00 00 00	 call	 ?OnScreen@DrawItem@@QAEAAVSOL_Rect@@XZ ; DrawItem::OnScreen
  0134a	8b c8		 mov	 ecx, eax
  0134c	e8 00 00 00 00	 call	 ?Area@SOL_Rect@@QBEJXZ	; SOL_Rect::Area
  01351	8b 55 f8	 mov	 edx, DWORD PTR _area$[ebp]
  01354	03 d0		 add	 edx, eax
  01356	89 55 f8	 mov	 DWORD PTR _area$[ebp], edx

; 411  : 	}

  01359	e9 47 ff ff ff	 jmp	 $L62013
$L62014:

; 412  : 
; 413  : //	if ( area )
; 414  : //		msgMgr->Mono ( "drawList area = %d\n", area );
; 415  : }

  0135e	8b e5		 mov	 esp, ebp
  01360	5d		 pop	 ebp
  01361	c2 04 00	 ret	 4
?DrawScreenItemList@GraphicsMgr@@IAEXAAVDrawList@@@Z ENDP ; GraphicsMgr::DrawScreenItemList
_TEXT	ENDS
;	COMDAT ?Xlen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Xlen@SOL_Rect@@QBEHXZ PROC NEAR			; SOL_Rect::Xlen, COMDAT

; 153  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 154  : 	return B.x - A.x + 1;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00010	2b 01		 sub	 eax, DWORD PTR [ecx]
  00012	83 c0 01	 add	 eax, 1

; 155  : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?Xlen@SOL_Rect@@QBEHXZ ENDP				; SOL_Rect::Xlen
_TEXT	ENDS
;	COMDAT ?Ylen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Ylen@SOL_Rect@@QBEHXZ PROC NEAR			; SOL_Rect::Ylen, COMDAT

; 161  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 	return B.y - A.y + 1;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00010	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00013	83 c0 01	 add	 eax, 1

; 163  : }

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?Ylen@SOL_Rect@@QBEHXZ ENDP				; SOL_Rect::Ylen
_TEXT	ENDS
;	COMDAT ?Area@SOL_Rect@@QBEJXZ
_TEXT	SEGMENT
_this$ = -4
?Area@SOL_Rect@@QBEJXZ PROC NEAR			; SOL_Rect::Area, COMDAT

; 169  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 170  : 	return (long) Xlen() * Ylen();

  00008	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  00010	8b f0		 mov	 esi, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?Ylen@SOL_Rect@@QBEHXZ	; SOL_Rect::Ylen
  0001a	0f af c6	 imul	 eax, esi

; 171  : }

  0001d	5e		 pop	 esi
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?Area@SOL_Rect@@QBEJXZ ENDP				; SOL_Rect::Area
_TEXT	ENDS
PUBLIC	?NewScreenDim@GraphicsMgr@@QAEXHH@Z		; GraphicsMgr::NewScreenDim
EXTRN	?NewScreenDim@Screen@@QAEXHH@Z:NEAR		; Screen::NewScreenDim
_TEXT	SEGMENT
_xdim$ = 8
_ydim$ = 12
_this$ = -4
?NewScreenDim@GraphicsMgr@@QAEXHH@Z PROC NEAR		; GraphicsMgr::NewScreenDim

; 419  : {

  01364	55		 push	 ebp
  01365	8b ec		 mov	 ebp, esp
  01367	51		 push	 ecx
  01368	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 420  : 	next.NewScreenDim(xdim, ydim);

  0136b	8b 45 0c	 mov	 eax, DWORD PTR _ydim$[ebp]
  0136e	50		 push	 eax
  0136f	8b 4d 08	 mov	 ecx, DWORD PTR _xdim$[ebp]
  01372	51		 push	 ecx
  01373	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01376	83 c1 14	 add	 ecx, 20			; 00000014H
  01379	e8 00 00 00 00	 call	 ?NewScreenDim@Screen@@QAEXHH@Z ; Screen::NewScreenDim

; 421  : 	ClearLastScreen();

  0137e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01381	8b 02		 mov	 eax, DWORD PTR [edx]
  01383	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01386	ff 50 0c	 call	 DWORD PTR [eax+12]

; 422  : 	resizeFlag = True;

  01389	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0138c	c7 81 90 11 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+4496], 1

; 423  : }

  01396	8b e5		 mov	 esp, ebp
  01398	5d		 pop	 ebp
  01399	c2 08 00	 ret	 8
?NewScreenDim@GraphicsMgr@@QAEXHH@Z ENDP		; GraphicsMgr::NewScreenDim
_TEXT	ENDS
PUBLIC	?IsValid@MemID@@QBEHXZ				; MemID::IsValid
PUBLIC	?X1@ScreenItem@@QBEHXZ				; ScreenItem::X1
PUBLIC	?Y1@ScreenItem@@QBEHXZ				; ScreenItem::Y1
PUBLIC	??0SOL_Point@@QAE@ABV0@@Z			; SOL_Point::SOL_Point
PUBLIC	?GetSkip@ScreenItem@@QAEEXZ			; ScreenItem::GetSkip
PUBLIC	?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ	; ScreenItem::OnScreen
PUBLIC	?ReadPix@ScreenItem@@QAEEHH@Z			; ScreenItem::ReadPix
PUBLIC	?DefRect@SOL_Plane@@QBEABVSOL_Rect@@XZ		; SOL_Plane::DefRect
PUBLIC	?Type@Bitmap@@QBEHXZ				; Bitmap::Type
PUBLIC	?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z		; SOL_Rect::Intersect
PUBLIC	?Handle@Bitmap@@QBE?AVMemID@@XZ			; Bitmap::Handle
PUBLIC	?Xdim@GraphicsMgr@@QBEHXZ			; GraphicsMgr::Xdim
PUBLIC	?Ydim@GraphicsMgr@@QBEHXZ			; GraphicsMgr::Ydim
PUBLIC	?IsOnMe@GraphicsMgr@@QAEHAAVScreenItem@@ABVSOL_Plane@@ABVSOL_Point@@H@Z ; GraphicsMgr::IsOnMe
PUBLIC	?ResX@CelObj@@QBEHXZ				; CelObj::ResX
PUBLIC	?ResY@CelObj@@QBEHXZ				; CelObj::ResY
PUBLIC	??0Ratio@@QAE@HH@Z				; Ratio::Ratio
PUBLIC	??K@YAHHABVRatio@@@Z				; operator/
PUBLIC	??D@YAHHABVRatio@@@Z				; operator*
EXTRN	?GetCelObj@ScreenItem@@QAEXXZ:NEAR		; ScreenItem::GetCelObj
_TEXT	SEGMENT
_si$ = 8
_plane$ = 12
_p$ = 16
_checkSkip$ = 20
_this$ = -64
_scaleX$ = -20
_scaleY$ = -12
_pScreen$ = -36
_pCel$ = -28
_result$ = -4
$T62392 = -44
$T62393 = -52
$T62394 = -60
?IsOnMe@GraphicsMgr@@QAEHAAVScreenItem@@ABVSOL_Plane@@ABVSOL_Point@@H@Z PROC NEAR ; GraphicsMgr::IsOnMe

; 427  : {

  0139c	55		 push	 ebp
  0139d	8b ec		 mov	 ebp, esp
  0139f	83 ec 40	 sub	 esp, 64			; 00000040H
  013a2	53		 push	 ebx
  013a3	56		 push	 esi
  013a4	89 4d c0	 mov	 DWORD PTR _this$[ebp], ecx

; 428  : 	Ratio scaleX(graphMgr->Xdim(), SCIRESX);

  013a7	68 80 02 00 00	 push	 640			; 00000280H
  013ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  013b2	e8 00 00 00 00	 call	 ?Xdim@GraphicsMgr@@QBEHXZ ; GraphicsMgr::Xdim
  013b7	50		 push	 eax
  013b8	8d 4d ec	 lea	 ecx, DWORD PTR _scaleX$[ebp]
  013bb	e8 00 00 00 00	 call	 ??0Ratio@@QAE@HH@Z	; Ratio::Ratio

; 429  : 	Ratio scaleY(graphMgr->Ydim(), SCIRESY);

  013c0	68 e0 01 00 00	 push	 480			; 000001e0H
  013c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  013cb	e8 00 00 00 00	 call	 ?Ydim@GraphicsMgr@@QBEHXZ ; GraphicsMgr::Ydim
  013d0	50		 push	 eax
  013d1	8d 4d f4	 lea	 ecx, DWORD PTR _scaleY$[ebp]
  013d4	e8 00 00 00 00	 call	 ??0Ratio@@QAE@HH@Z	; Ratio::Ratio

; 430  : 
; 431  : 	SOL_Point pScreen;

  013d9	8d 4d dc	 lea	 ecx, DWORD PTR _pScreen$[ebp]
  013dc	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point

; 432  : 	pScreen.x = (p.x * scaleX) + plane.DefRect().A.x;

  013e1	8d 45 ec	 lea	 eax, DWORD PTR _scaleX$[ebp]
  013e4	50		 push	 eax
  013e5	8b 4d 10	 mov	 ecx, DWORD PTR _p$[ebp]
  013e8	8b 11		 mov	 edx, DWORD PTR [ecx]
  013ea	52		 push	 edx
  013eb	e8 00 00 00 00	 call	 ??D@YAHHABVRatio@@@Z	; operator*
  013f0	83 c4 08	 add	 esp, 8
  013f3	8b f0		 mov	 esi, eax
  013f5	8b 4d 0c	 mov	 ecx, DWORD PTR _plane$[ebp]
  013f8	e8 00 00 00 00	 call	 ?DefRect@SOL_Plane@@QBEABVSOL_Rect@@XZ ; SOL_Plane::DefRect
  013fd	03 30		 add	 esi, DWORD PTR [eax]
  013ff	89 75 dc	 mov	 DWORD PTR _pScreen$[ebp], esi

; 433  : 	pScreen.y = (p.y * scaleY) + plane.DefRect().A.y;

  01402	8d 45 f4	 lea	 eax, DWORD PTR _scaleY$[ebp]
  01405	50		 push	 eax
  01406	8b 4d 10	 mov	 ecx, DWORD PTR _p$[ebp]
  01409	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0140c	52		 push	 edx
  0140d	e8 00 00 00 00	 call	 ??D@YAHHABVRatio@@@Z	; operator*
  01412	83 c4 08	 add	 esp, 8
  01415	8b f0		 mov	 esi, eax
  01417	8b 4d 0c	 mov	 ecx, DWORD PTR _plane$[ebp]
  0141a	e8 00 00 00 00	 call	 ?DefRect@SOL_Plane@@QBEABVSOL_Rect@@XZ ; SOL_Plane::DefRect
  0141f	03 70 04	 add	 esi, DWORD PTR [eax+4]
  01422	89 75 e0	 mov	 DWORD PTR _pScreen$[ebp+4], esi

; 434  : 
; 435  : 	if (!si.OnScreen().Intersect(pScreen))

  01425	83 ec 08	 sub	 esp, 8
  01428	8b cc		 mov	 ecx, esp
  0142a	8d 45 dc	 lea	 eax, DWORD PTR _pScreen$[ebp]
  0142d	50		 push	 eax
  0142e	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  01433	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  01436	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  0143b	8b c8		 mov	 ecx, eax
  0143d	e8 00 00 00 00	 call	 ?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z ; SOL_Rect::Intersect
  01442	85 c0		 test	 eax, eax
  01444	75 07		 jne	 SHORT $L62032

; 436  : 		return False;

  01446	33 c0		 xor	 eax, eax
  01448	e9 60 01 00 00	 jmp	 $L62027
$L62032:

; 437  : 
; 438  : 	if (!checkSkip)

  0144d	83 7d 14 00	 cmp	 DWORD PTR _checkSkip$[ebp], 0
  01451	75 0a		 jne	 SHORT $L62033

; 439  : 		return True;

  01453	b8 01 00 00 00	 mov	 eax, 1
  01458	e9 50 01 00 00	 jmp	 $L62027
$L62033:

; 440  : 
; 441  : 	// check for an invalid CelObjMem bitmap handle... can't be on an invalid bitmap...
; 442  : 	if ( (si.bitmap.Type() == Bitmap::tMem) && !si.bitmap.Handle().IsValid() )

  0145d	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  01460	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01463	e8 00 00 00 00	 call	 ?Type@Bitmap@@QBEHXZ	; Bitmap::Type
  01468	83 f8 02	 cmp	 eax, 2
  0146b	75 21		 jne	 SHORT $L62035
  0146d	8d 4d d4	 lea	 ecx, DWORD PTR $T62392[ebp]
  01470	51		 push	 ecx
  01471	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  01474	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01477	e8 00 00 00 00	 call	 ?Handle@Bitmap@@QBE?AVMemID@@XZ ; Bitmap::Handle
  0147c	8b c8		 mov	 ecx, eax
  0147e	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  01483	85 c0		 test	 eax, eax
  01485	75 07		 jne	 SHORT $L62035

; 443  : 		return False;

  01487	33 c0		 xor	 eax, eax
  01489	e9 1f 01 00 00	 jmp	 $L62027
$L62035:

; 444  : 
; 445  : 	//  pCel = "Un User Scaled" offset 
; 446  : 	si.GetCelObj();

  0148e	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  01491	e8 00 00 00 00	 call	 ?GetCelObj@ScreenItem@@QAEXXZ ; ScreenItem::GetCelObj

; 447  : 
; 448  : 	SOL_Point pCel;

  01496	8d 4d e4	 lea	 ecx, DWORD PTR _pCel$[ebp]
  01499	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point

; 449  : 
; 450  : 	scaleX.numer =	si.GetCel()->ResX();

  0149e	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  014a1	e8 00 00 00 00	 call	 ?GetCel@ScreenItem@@QAEPAVCelObj@@XZ ; ScreenItem::GetCel
  014a6	8b c8		 mov	 ecx, eax
  014a8	e8 00 00 00 00	 call	 ?ResX@CelObj@@QBEHXZ	; CelObj::ResX
  014ad	89 45 ec	 mov	 DWORD PTR _scaleX$[ebp], eax

; 451  : 	scaleX.denom =	graphMgr->Xdim();

  014b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  014b6	e8 00 00 00 00	 call	 ?Xdim@GraphicsMgr@@QBEHXZ ; GraphicsMgr::Xdim
  014bb	89 45 f0	 mov	 DWORD PTR _scaleX$[ebp+4], eax

; 452  : 	scaleY.numer =	si.GetCel()->ResY();

  014be	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  014c1	e8 00 00 00 00	 call	 ?GetCel@ScreenItem@@QAEPAVCelObj@@XZ ; ScreenItem::GetCel
  014c6	8b c8		 mov	 ecx, eax
  014c8	e8 00 00 00 00	 call	 ?ResY@CelObj@@QBEHXZ	; CelObj::ResY
  014cd	89 45 f4	 mov	 DWORD PTR _scaleY$[ebp], eax

; 453  : 	scaleY.denom =	graphMgr->Ydim();

  014d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  014d6	e8 00 00 00 00	 call	 ?Ydim@GraphicsMgr@@QBEHXZ ; GraphicsMgr::Ydim
  014db	89 45 f8	 mov	 DWORD PTR _scaleY$[ebp+4], eax

; 454  : 
; 455  : 	pCel.x = (pScreen.x - si.X1())*scaleX;

  014de	8d 55 ec	 lea	 edx, DWORD PTR _scaleX$[ebp]
  014e1	52		 push	 edx
  014e2	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  014e5	e8 00 00 00 00	 call	 ?X1@ScreenItem@@QBEHXZ	; ScreenItem::X1
  014ea	8b 4d dc	 mov	 ecx, DWORD PTR _pScreen$[ebp]
  014ed	2b c8		 sub	 ecx, eax
  014ef	51		 push	 ecx
  014f0	e8 00 00 00 00	 call	 ??D@YAHHABVRatio@@@Z	; operator*
  014f5	83 c4 08	 add	 esp, 8
  014f8	89 45 e4	 mov	 DWORD PTR _pCel$[ebp], eax

; 456  : 	pCel.y = (pScreen.y - si.Y1())*scaleY;

  014fb	8d 55 f4	 lea	 edx, DWORD PTR _scaleY$[ebp]
  014fe	52		 push	 edx
  014ff	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  01502	e8 00 00 00 00	 call	 ?Y1@ScreenItem@@QBEHXZ	; ScreenItem::Y1
  01507	8b 4d e0	 mov	 ecx, DWORD PTR _pScreen$[ebp+4]
  0150a	2b c8		 sub	 ecx, eax
  0150c	51		 push	 ecx
  0150d	e8 00 00 00 00	 call	 ??D@YAHHABVRatio@@@Z	; operator*
  01512	83 c4 08	 add	 esp, 8
  01515	89 45 e8	 mov	 DWORD PTR _pCel$[ebp+4], eax

; 457  : 
; 458  : 	if (si.scale.scaleType != SCALE_OFF)  {

  01518	8b 55 08	 mov	 edx, DWORD PTR _si$[ebp]
  0151b	83 7a 2c 00	 cmp	 DWORD PTR [edx+44], 0
  0151f	74 5a		 je	 SHORT $L62038

; 459  : 		if (si.scale.scaleX  &&  si.scale.scaleY)  {

  01521	8b 45 08	 mov	 eax, DWORD PTR _si$[ebp]
  01524	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  01528	74 51		 je	 SHORT $L62038
  0152a	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  0152d	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  01531	74 48		 je	 SHORT $L62038

; 460  : 			pCel.x = pCel.x / Ratio(si.scale.scaleX, 128);

  01533	68 80 00 00 00	 push	 128			; 00000080H
  01538	8b 55 08	 mov	 edx, DWORD PTR _si$[ebp]
  0153b	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0153e	50		 push	 eax
  0153f	8d 4d cc	 lea	 ecx, DWORD PTR $T62393[ebp]
  01542	e8 00 00 00 00	 call	 ??0Ratio@@QAE@HH@Z	; Ratio::Ratio
  01547	50		 push	 eax
  01548	8b 4d e4	 mov	 ecx, DWORD PTR _pCel$[ebp]
  0154b	51		 push	 ecx
  0154c	e8 00 00 00 00	 call	 ??K@YAHHABVRatio@@@Z	; operator/
  01551	83 c4 08	 add	 esp, 8
  01554	89 45 e4	 mov	 DWORD PTR _pCel$[ebp], eax

; 461  : 			pCel.y = pCel.y / Ratio(si.scale.scaleY, 128);

  01557	68 80 00 00 00	 push	 128			; 00000080H
  0155c	8b 55 08	 mov	 edx, DWORD PTR _si$[ebp]
  0155f	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  01562	50		 push	 eax
  01563	8d 4d c4	 lea	 ecx, DWORD PTR $T62394[ebp]
  01566	e8 00 00 00 00	 call	 ??0Ratio@@QAE@HH@Z	; Ratio::Ratio
  0156b	50		 push	 eax
  0156c	8b 4d e8	 mov	 ecx, DWORD PTR _pCel$[ebp+4]
  0156f	51		 push	 ecx
  01570	e8 00 00 00 00	 call	 ??K@YAHHABVRatio@@@Z	; operator/
  01575	83 c4 08	 add	 esp, 8
  01578	89 45 e8	 mov	 DWORD PTR _pCel$[ebp+4], eax
$L62038:

; 464  : 
; 465  : 	Bool result = si.ReadPix(pCel.x,pCel.y) != si.GetSkip();

  0157b	8b 55 e8	 mov	 edx, DWORD PTR _pCel$[ebp+4]
  0157e	52		 push	 edx
  0157f	8b 45 e4	 mov	 eax, DWORD PTR _pCel$[ebp]
  01582	50		 push	 eax
  01583	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  01586	e8 00 00 00 00	 call	 ?ReadPix@ScreenItem@@QAEEHH@Z ; ScreenItem::ReadPix
  0158b	8a d8		 mov	 bl, al
  0158d	81 e3 ff 00 00
	00		 and	 ebx, 255		; 000000ffH
  01593	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  01596	e8 00 00 00 00	 call	 ?GetSkip@ScreenItem@@QAEEXZ ; ScreenItem::GetSkip
  0159b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  015a0	33 c9		 xor	 ecx, ecx
  015a2	3b d8		 cmp	 ebx, eax
  015a4	0f 95 c1	 setne	 cl
  015a7	89 4d fc	 mov	 DWORD PTR _result$[ebp], ecx

; 466  : 
; 467  : 	return result;

  015aa	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]
$L62027:

; 468  : }

  015ad	5e		 pop	 esi
  015ae	5b		 pop	 ebx
  015af	8b e5		 mov	 esp, ebp
  015b1	5d		 pop	 ebp
  015b2	c2 10 00	 ret	 16			; 00000010H
?IsOnMe@GraphicsMgr@@QAEHAAVScreenItem@@ABVSOL_Plane@@ABVSOL_Point@@H@Z ENDP ; GraphicsMgr::IsOnMe
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@ABV0@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
??0SOL_Point@@QAE@ABV0@@Z PROC NEAR			; SOL_Point::SOL_Point, COMDAT

; 22   : 	SOL_Point(const SOL_Point& p) : x(p.x), y(p.y) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00017	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001a	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??0SOL_Point@@QAE@ABV0@@Z ENDP				; SOL_Point::SOL_Point
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z
_TEXT	SEGMENT
_P$ = 8
_this$ = -4
?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z PROC NEAR	; SOL_Rect::Intersect, COMDAT

; 177  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 178  : 	if (P.x < A.x  ||  P.x > B.x)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _P$[ebp]
  0000d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000f	7c 0b		 jl	 SHORT $L1687
  00011	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00014	8b 45 08	 mov	 eax, DWORD PTR _P$[ebp]
  00017	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  0001a	7e 04		 jle	 SHORT $L1686
$L1687:

; 179  : 		return False;

  0001c	33 c0		 xor	 eax, eax
  0001e	eb 1f		 jmp	 SHORT $L1685
$L1686:

; 180  : 	if (P.y < A.y  ||  P.y > B.y)

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 55 0c	 mov	 edx, DWORD PTR _P$[ebp+4]
  00026	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00029	7c 0b		 jl	 SHORT $L1689
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _P$[ebp+4]
  00031	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00034	7e 04		 jle	 SHORT $L1688
$L1689:

; 181  : 		return False;

  00036	33 c0		 xor	 eax, eax
  00038	eb 05		 jmp	 SHORT $L1685
$L1688:

; 182  : 	return True;

  0003a	b8 01 00 00 00	 mov	 eax, 1
$L1685:

; 183  : }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z ENDP		; SOL_Rect::Intersect
_TEXT	ENDS
PUBLIC	?Intersect@SOL_Rect@@QBEHABV1@@Z		; SOL_Rect::Intersect
PUBLIC	?MakeEmpty@SOL_Rect@@QAEXXZ			; SOL_Rect::MakeEmpty
;	COMDAT ?Clip@SOL_Rect@@QAEXABV1@@Z
_TEXT	SEGMENT
_r$ = 8
_this$ = -4
?Clip@SOL_Rect@@QAEXABV1@@Z PROC NEAR			; SOL_Rect::Clip, COMDAT

; 224  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 225  : 	if (Intersect(r))  {

  00007	8b 45 08	 mov	 eax, DWORD PTR _r$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?Intersect@SOL_Rect@@QBEHABV1@@Z ; SOL_Rect::Intersect
  00013	85 c0		 test	 eax, eax
  00015	74 66		 je	 SHORT $L1711

; 226  : 		if (A.x < r.A.x)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  0001d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001f	3b 02		 cmp	 eax, DWORD PTR [edx]
  00021	7d 0a		 jge	 SHORT $L1712

; 227  : 			A.x = r.A.x;

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00029	8b 02		 mov	 eax, DWORD PTR [edx]
  0002b	89 01		 mov	 DWORD PTR [ecx], eax
$L1712:

; 228  : 		if (A.y < r.A.y)

  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00033	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00036	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00039	7d 0c		 jge	 SHORT $L1713

; 229  : 			A.y = r.A.y;

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00041	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00044	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$L1713:

; 230  : 		if (B.x > r.B.x)

  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  0004d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00050	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00053	7e 0c		 jle	 SHORT $L1714

; 231  : 			B.x = r.B.x;

  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  0005b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0005e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L1714:

; 232  : 		if (B.y > r.B.y)

  00061	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00067	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0006a	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  0006d	7e 0c		 jle	 SHORT $L1715

; 233  : 			B.y = r.B.y;

  0006f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00075	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00078	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$L1715:

; 235  : 	else

  0007b	eb 08		 jmp	 SHORT $L1716
$L1711:

; 236  : 		MakeEmpty();

  0007d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	e8 00 00 00 00	 call	 ?MakeEmpty@SOL_Rect@@QAEXXZ ; SOL_Rect::MakeEmpty
$L1716:

; 237  : }

  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
?Clip@SOL_Rect@@QAEXABV1@@Z ENDP			; SOL_Rect::Clip
_TEXT	ENDS
;	COMDAT ?MakeEmpty@SOL_Rect@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?MakeEmpty@SOL_Rect@@QAEXXZ PROC NEAR			; SOL_Rect::MakeEmpty, COMDAT

; 142  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 143  : 	B.x = -1;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 08 ff ff
	ff ff		 mov	 DWORD PTR [eax+8], -1

; 144  : 	B.y = -1;

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 0c ff ff
	ff ff		 mov	 DWORD PTR [ecx+12], -1

; 145  : 	A.x = 0;

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 146  : 	A.y = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 147  : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?MakeEmpty@SOL_Rect@@QAEXXZ ENDP			; SOL_Rect::MakeEmpty
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHABV1@@Z
_TEXT	SEGMENT
_r$ = 8
_this$ = -4
?Intersect@SOL_Rect@@QBEHABV1@@Z PROC NEAR		; SOL_Rect::Intersect, COMDAT

; 189  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 190  : 	if (B.x < r.A.x)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  0000d	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00010	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00012	7d 04		 jge	 SHORT $L1694

; 191  : 		return False;

  00014	33 c0		 xor	 eax, eax
  00016	eb 3a		 jmp	 SHORT $L1693
$L1694:

; 192  : 	if (B.y < r.A.y)

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  0001e	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00021	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00024	7d 04		 jge	 SHORT $L1695

; 193  : 		return False;

  00026	33 c0		 xor	 eax, eax
  00028	eb 28		 jmp	 SHORT $L1693
$L1695:

; 194  : 	if (A.x > r.B.x)

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00030	8b 10		 mov	 edx, DWORD PTR [eax]
  00032	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00035	7e 04		 jle	 SHORT $L1696

; 195  : 		return False;

  00037	33 c0		 xor	 eax, eax
  00039	eb 17		 jmp	 SHORT $L1693
$L1696:

; 196  : 	if (A.y > r.B.y)

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00041	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00044	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00047	7e 04		 jle	 SHORT $L1697

; 197  : 		return False;

  00049	33 c0		 xor	 eax, eax
  0004b	eb 05		 jmp	 SHORT $L1693
$L1697:

; 198  : 	return True;

  0004d	b8 01 00 00 00	 mov	 eax, 1
$L1693:

; 199  : }

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?Intersect@SOL_Rect@@QBEHABV1@@Z ENDP			; SOL_Rect::Intersect
_TEXT	ENDS
PUBLIC	??ARectList@@QAEAAVSOL_Rect@@H@Z		; RectList::operator[]
PUBLIC	??0SOL_Rect@@QAE@XZ				; SOL_Rect::SOL_Rect
PUBLIC	??4SOL_Rect@@QAEAAV0@ABV0@@Z			; SOL_Rect::operator=
PUBLIC	?Min@@YAHHH@Z					; Min
PUBLIC	?Max@@YAHHH@Z					; Max
EXTRN	?Delete@RectList@@QAEXH@Z:NEAR			; RectList::Delete
EXTRN	?Pack@RectList@@QAEHXZ:NEAR			; RectList::Pack
_TEXT	SEGMENT
_r$ = 8
_rectList$ = 12
_callOverhead$ = 16
_this$ = -68
_merged$ = -40
_rect1$ = -24
_doOver$ = -8
_listSize$ = -4
_i$62055 = -44
_rect2$62059 = -64
_pixelDif$62082 = -48
?MergeToShowList@GraphicsMgr@@IAEXABVSOL_Rect@@AAVRectList@@H@Z PROC NEAR ; GraphicsMgr::MergeToShowList

; 472  : {

  015b5	55		 push	 ebp
  015b6	8b ec		 mov	 ebp, esp
  015b8	83 ec 44	 sub	 esp, 68			; 00000044H
  015bb	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx

; 473  : /*
; 474  : 	Go through the rectangles merging the given rectangle when
; 475  : 	it is more efficient to draw one large rectangle rather than
; 476  : 	multiple small ones. i.e. which of the following examples
; 477  : 	is quicker to draw?
; 478  : 
; 479  : 
; 480  : 
; 481  : 	 ____________________				    	 ______________________________
; 482  : 	|                    |				    	|                     			 |
; 483  : 	|	                  |				    	|	                   			 |
; 484  : 	|							|				    	|							 			 |
; 485  : 	|							|				    	|							 			 |
; 486  : 	|			  ____________________	    	|			                      |
; 487  : 	|			 |         				 |	    	|			           				 |
; 488  : 	|			 |                    |	    	|			                      |
; 489  : 	|			 |							 |	    	|			  							 |
; 490  : 	|			 |							 |	    	|			  							 |
; 491  : 	|			 |							 |	    	|			  							 |
; 492  : 	|			 |							 |	    	|			  							 |
; 493  : 	|			 |							 |	    	|			  							 |
; 494  : 	|_________|							 |	    	|                   				 |
; 495  : 				 |							 |			|		  							  	 |
; 496  : 				 |							 |			|		  							  	 |
; 497  : 				 |							 |			|		  							  	 |
; 498  : 				 |							 |			|		   						  	 |
; 499  : 				 |____________________|			|______________________________|
; 500  : 
; 501  : */
; 502  : 	SOL_Rect merged;

  015be	8d 4d d8	 lea	 ecx, DWORD PTR _merged$[ebp]
  015c1	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@XZ	; SOL_Rect::SOL_Rect

; 503  : 	SOL_Rect rect1 = r;

  015c6	8b 45 08	 mov	 eax, DWORD PTR _r$[ebp]
  015c9	50		 push	 eax
  015ca	8d 4d e8	 lea	 ecx, DWORD PTR _rect1$[ebp]
  015cd	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@ABV0@@Z ; SOL_Rect::SOL_Rect

; 504  : 	Bool doOver = True;

  015d2	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _doOver$[ebp], 1

; 505  : 	int listSize = rectList.Length();

  015d9	8b 4d 0c	 mov	 ecx, DWORD PTR _rectList$[ebp]
  015dc	e8 00 00 00 00	 call	 ?Length@RectList@@QBEHXZ ; RectList::Length
  015e1	89 45 fc	 mov	 DWORD PTR _listSize$[ebp], eax
$L62053:

; 506  : 	while (doOver)  {

  015e4	83 7d f8 00	 cmp	 DWORD PTR _doOver$[ebp], 0
  015e8	0f 84 ed 00 00
	00		 je	 $L62054

; 507  : 		doOver = False;

  015ee	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _doOver$[ebp], 0

; 508  : 		for (int i = 0;i < listSize;++i) {

  015f5	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$62055[ebp], 0
  015fc	eb 09		 jmp	 SHORT $L62056
$L62057:
  015fe	8b 4d d4	 mov	 ecx, DWORD PTR _i$62055[ebp]
  01601	83 c1 01	 add	 ecx, 1
  01604	89 4d d4	 mov	 DWORD PTR _i$62055[ebp], ecx
$L62056:
  01607	8b 55 d4	 mov	 edx, DWORD PTR _i$62055[ebp]
  0160a	3b 55 fc	 cmp	 edx, DWORD PTR _listSize$[ebp]
  0160d	0f 8d b8 00 00
	00		 jge	 $L62058

; 509  : 			SOL_Rect rect2  = rectList[i];

  01613	8b 45 d4	 mov	 eax, DWORD PTR _i$62055[ebp]
  01616	50		 push	 eax
  01617	8b 4d 0c	 mov	 ecx, DWORD PTR _rectList$[ebp]
  0161a	e8 00 00 00 00	 call	 ??ARectList@@QAEAAVSOL_Rect@@H@Z ; RectList::operator[]
  0161f	50		 push	 eax
  01620	8d 4d c0	 lea	 ecx, DWORD PTR _rect2$62059[ebp]
  01623	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@ABV0@@Z ; SOL_Rect::SOL_Rect

; 510  : 			// If 
; 511  : 			// (area merged - (area rect1 + area rect2)) < pixelsPerCall 
; 512  : 			// then use merged rectangle
; 513  : 			// else use both rectangles
; 514  : 			merged.A.x = Min(rect1.A.x,rect2.A.x);

  01628	8b 4d c0	 mov	 ecx, DWORD PTR _rect2$62059[ebp]
  0162b	51		 push	 ecx
  0162c	8b 55 e8	 mov	 edx, DWORD PTR _rect1$[ebp]
  0162f	52		 push	 edx
  01630	e8 00 00 00 00	 call	 ?Min@@YAHHH@Z		; Min
  01635	83 c4 08	 add	 esp, 8
  01638	89 45 d8	 mov	 DWORD PTR _merged$[ebp], eax

; 515  : 			merged.B.x = Max(rect1.B.x,rect2.B.x);

  0163b	8b 45 c8	 mov	 eax, DWORD PTR _rect2$62059[ebp+8]
  0163e	50		 push	 eax
  0163f	8b 4d f0	 mov	 ecx, DWORD PTR _rect1$[ebp+8]
  01642	51		 push	 ecx
  01643	e8 00 00 00 00	 call	 ?Max@@YAHHH@Z		; Max
  01648	83 c4 08	 add	 esp, 8
  0164b	89 45 e0	 mov	 DWORD PTR _merged$[ebp+8], eax

; 516  : 			merged.A.y = Min(rect1.A.y,rect2.A.y);

  0164e	8b 55 c4	 mov	 edx, DWORD PTR _rect2$62059[ebp+4]
  01651	52		 push	 edx
  01652	8b 45 ec	 mov	 eax, DWORD PTR _rect1$[ebp+4]
  01655	50		 push	 eax
  01656	e8 00 00 00 00	 call	 ?Min@@YAHHH@Z		; Min
  0165b	83 c4 08	 add	 esp, 8
  0165e	89 45 dc	 mov	 DWORD PTR _merged$[ebp+4], eax

; 517  : 			merged.B.y = Max(rect1.B.y,rect2.B.y);

  01661	8b 4d cc	 mov	 ecx, DWORD PTR _rect2$62059[ebp+12]
  01664	51		 push	 ecx
  01665	8b 55 f4	 mov	 edx, DWORD PTR _rect1$[ebp+12]
  01668	52		 push	 edx
  01669	e8 00 00 00 00	 call	 ?Max@@YAHHH@Z		; Max
  0166e	83 c4 08	 add	 esp, 8
  01671	89 45 e4	 mov	 DWORD PTR _merged$[ebp+12], eax

; 518  : 
; 519  : 			// Overlap calculate the pixel difference
; 520  : 			int pixelDif =  merged.Area();

  01674	8d 4d d8	 lea	 ecx, DWORD PTR _merged$[ebp]
  01677	e8 00 00 00 00	 call	 ?Area@SOL_Rect@@QBEJXZ	; SOL_Rect::Area
  0167c	89 45 d0	 mov	 DWORD PTR _pixelDif$62082[ebp], eax

; 521  : 			pixelDif -= rect1.Area();

  0167f	8d 4d e8	 lea	 ecx, DWORD PTR _rect1$[ebp]
  01682	e8 00 00 00 00	 call	 ?Area@SOL_Rect@@QBEJXZ	; SOL_Rect::Area
  01687	8b 4d d0	 mov	 ecx, DWORD PTR _pixelDif$62082[ebp]
  0168a	2b c8		 sub	 ecx, eax
  0168c	89 4d d0	 mov	 DWORD PTR _pixelDif$62082[ebp], ecx

; 522  : 			pixelDif -= rect2.Area();

  0168f	8d 4d c0	 lea	 ecx, DWORD PTR _rect2$62059[ebp]
  01692	e8 00 00 00 00	 call	 ?Area@SOL_Rect@@QBEJXZ	; SOL_Rect::Area
  01697	8b 55 d0	 mov	 edx, DWORD PTR _pixelDif$62082[ebp]
  0169a	2b d0		 sub	 edx, eax
  0169c	89 55 d0	 mov	 DWORD PTR _pixelDif$62082[ebp], edx

; 523  : 
; 524  : 			if (pixelDif <= callOverhead) {

  0169f	8b 45 d0	 mov	 eax, DWORD PTR _pixelDif$62082[ebp]
  016a2	3b 45 10	 cmp	 eax, DWORD PTR _callOverhead$[ebp]
  016a5	7f 1f		 jg	 SHORT $L62083

; 525  : 				rect1 = merged;

  016a7	8d 4d d8	 lea	 ecx, DWORD PTR _merged$[ebp]
  016aa	51		 push	 ecx
  016ab	8d 4d e8	 lea	 ecx, DWORD PTR _rect1$[ebp]
  016ae	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 526  : 				rectList.Delete(i);     

  016b3	8b 55 d4	 mov	 edx, DWORD PTR _i$62055[ebp]
  016b6	52		 push	 edx
  016b7	8b 4d 0c	 mov	 ecx, DWORD PTR _rectList$[ebp]
  016ba	e8 00 00 00 00	 call	 ?Delete@RectList@@QAEXH@Z ; RectList::Delete

; 527  : 				// Start over again
; 528  : 				doOver = True;

  016bf	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _doOver$[ebp], 1
$L62083:

; 530  : 		}

  016c6	e9 33 ff ff ff	 jmp	 $L62057
$L62058:

; 531  : 		listSize = rectList.Pack();

  016cb	8b 4d 0c	 mov	 ecx, DWORD PTR _rectList$[ebp]
  016ce	e8 00 00 00 00	 call	 ?Pack@RectList@@QAEHXZ	; RectList::Pack
  016d3	89 45 fc	 mov	 DWORD PTR _listSize$[ebp], eax

; 532  : 	}

  016d6	e9 09 ff ff ff	 jmp	 $L62053
$L62054:

; 533  : 	rectList.Add(rect1);

  016db	8d 45 e8	 lea	 eax, DWORD PTR _rect1$[ebp]
  016de	50		 push	 eax
  016df	8b 4d 0c	 mov	 ecx, DWORD PTR _rectList$[ebp]
  016e2	e8 00 00 00 00	 call	 ?Add@RectList@@QAEXABVSOL_Rect@@@Z ; RectList::Add

; 534  : }

  016e7	8b e5		 mov	 esp, ebp
  016e9	5d		 pop	 ebp
  016ea	c2 0c 00	 ret	 12			; 0000000cH
?MergeToShowList@GraphicsMgr@@IAEXABVSOL_Rect@@AAVRectList@@H@Z ENDP ; GraphicsMgr::MergeToShowList
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0SOL_Rect@@QAE@XZ PROC NEAR				; SOL_Rect::SOL_Rect, COMDAT

; 13   : 	SOL_Rect()  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 08	 add	 ecx, 8
  00015	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0SOL_Rect@@QAE@XZ ENDP				; SOL_Rect::SOL_Rect
_TEXT	ENDS
_TEXT	SEGMENT
_dirtyRect$ = 8
_this$ = -4
?MovieFrameOut@GraphicsMgr@@UAEXVSOL_Rect@@@Z PROC NEAR	; GraphicsMgr::MovieFrameOut

; 538  : {

  016ed	55		 push	 ebp
  016ee	8b ec		 mov	 ebp, esp
  016f0	51		 push	 ecx
  016f1	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 539  : 	next.ShowList().Add(dirtyRect);

  016f4	8d 45 08	 lea	 eax, DWORD PTR _dirtyRect$[ebp]
  016f7	50		 push	 eax
  016f8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  016fb	83 c1 14	 add	 ecx, 20			; 00000014H
  016fe	e8 00 00 00 00	 call	 ?ShowList@Screen@@QAEAAVRectList@@XZ ; Screen::ShowList
  01703	8b c8		 mov	 ecx, eax
  01705	e8 00 00 00 00	 call	 ?Add@RectList@@QAEXABVSOL_Rect@@@Z ; RectList::Add

; 540  : 	graphMgr->ShowBits();

  0170a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  01710	8b 11		 mov	 edx, DWORD PTR [ecx]
  01712	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  01718	ff 52 40	 call	 DWORD PTR [edx+64]

; 541  :  	graphMgr->vmapValid = True;

  0171b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  01720	c7 40 08 01 00
	00 00		 mov	 DWORD PTR [eax+8], 1

; 542  : }

  01727	8b e5		 mov	 esp, ebp
  01729	5d		 pop	 ebp
  0172a	c2 10 00	 ret	 16			; 00000010H
?MovieFrameOut@GraphicsMgr@@UAEXVSOL_Rect@@@Z ENDP	; GraphicsMgr::MovieFrameOut
_TEXT	ENDS
PUBLIC	??0MemID@@QAE@G@Z				; MemID::MemID
PUBLIC	?NowSeen@GraphicsMgr@@QAEHHHAAVSOL_Rect@@@Z	; GraphicsMgr::NowSeen
EXTRN	?Search@PlaneList@@QBEHI@Z:NEAR			; PlaneList::Search
EXTRN	?NowSeen@SOL_Plane@@QAEHVMemID@@AAVSOL_Rect@@@Z:NEAR ; SOL_Plane::NowSeen
_TEXT	SEGMENT
_id$ = 8
_planeID$ = 12
_nowSeen$ = 16
_this$ = -12
_index$ = -4
?NowSeen@GraphicsMgr@@QAEHHHAAVSOL_Rect@@@Z PROC NEAR	; GraphicsMgr::NowSeen

; 546  : {

  0172d	55		 push	 ebp
  0172e	8b ec		 mov	 ebp, esp
  01730	83 ec 0c	 sub	 esp, 12			; 0000000cH
  01733	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 547  : 	// This is actually comming from the next screenItem.
; 548  : 	// There is not enough information kept in the last 
; 549  : 	// screenItem to properly calculate the now seen
; 550  : 	// rectangle. Since it works fine this way and to add
; 551  : 	// the information needed in the last screenItem would
; 552  : 	// be a slow down	in the graphics engine I'm not going
; 553  : 	// to change it. See the code below.
; 554  : 	int index = next.Planes().Search(planeID);

  01736	8b 45 0c	 mov	 eax, DWORD PTR _planeID$[ebp]
  01739	50		 push	 eax
  0173a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0173d	83 c1 14	 add	 ecx, 20			; 00000014H
  01740	e8 00 00 00 00	 call	 ?Planes@Screen@@QAEAAVPlaneList@@XZ ; Screen::Planes
  01745	8b c8		 mov	 ecx, eax
  01747	e8 00 00 00 00	 call	 ?Search@PlaneList@@QBEHI@Z ; PlaneList::Search
  0174c	89 45 fc	 mov	 DWORD PTR _index$[ebp], eax

; 555  : 	if (index == -1)

  0174f	83 7d fc ff	 cmp	 DWORD PTR _index$[ebp], -1
  01753	75 04		 jne	 SHORT $L62095

; 556  : 		return False;

  01755	33 c0		 xor	 eax, eax
  01757	eb 2e		 jmp	 SHORT $L62093
$L62095:

; 557  : //		msgMgr->Fatal(SrcLoc,Msg_PlaneNotFound,planeID);
; 558  : 	return next.Planes()[index].NowSeen(id,nowSeen);

  01759	8b 4d 10	 mov	 ecx, DWORD PTR _nowSeen$[ebp]
  0175c	51		 push	 ecx
  0175d	51		 push	 ecx
  0175e	8b cc		 mov	 ecx, esp
  01760	66 8b 55 08	 mov	 dx, WORD PTR _id$[ebp]
  01764	52		 push	 edx
  01765	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  0176a	8b 45 fc	 mov	 eax, DWORD PTR _index$[ebp]
  0176d	50		 push	 eax
  0176e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  01771	83 c1 14	 add	 ecx, 20			; 00000014H
  01774	e8 00 00 00 00	 call	 ?Planes@Screen@@QAEAAVPlaneList@@XZ ; Screen::Planes
  01779	8b c8		 mov	 ecx, eax
  0177b	e8 00 00 00 00	 call	 ??APlaneList@@QAEAAVSOL_Plane@@H@Z ; PlaneList::operator[]
  01780	8b c8		 mov	 ecx, eax
  01782	e8 00 00 00 00	 call	 ?NowSeen@SOL_Plane@@QAEHVMemID@@AAVSOL_Rect@@@Z ; SOL_Plane::NowSeen
$L62093:

; 559  : }

  01787	8b e5		 mov	 esp, ebp
  01789	5d		 pop	 ebp
  0178a	c2 0c 00	 ret	 12			; 0000000cH
?NowSeen@GraphicsMgr@@QAEHHHAAVSOL_Rect@@@Z ENDP	; GraphicsMgr::NowSeen
_TEXT	ENDS
;	COMDAT ?Min@@YAHHH@Z
_TEXT	SEGMENT
_a$ = 8
_b$ = 12
?Min@@YAHHH@Z PROC NEAR					; Min, COMDAT

; 102  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 103  : 	return a < b ? a : b;

  00004	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00007	3b 45 0c	 cmp	 eax, DWORD PTR _b$[ebp]
  0000a	7d 08		 jge	 SHORT $L62406
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0000f	89 4d fc	 mov	 DWORD PTR -4+[ebp], ecx
  00012	eb 06		 jmp	 SHORT $L62407
$L62406:
  00014	8b 55 0c	 mov	 edx, DWORD PTR _b$[ebp]
  00017	89 55 fc	 mov	 DWORD PTR -4+[ebp], edx
$L62407:
  0001a	8b 45 fc	 mov	 eax, DWORD PTR -4+[ebp]

; 104  : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?Min@@YAHHH@Z ENDP					; Min
_TEXT	ENDS
;	COMDAT ?Max@@YAHHH@Z
_TEXT	SEGMENT
_a$ = 8
_b$ = 12
?Max@@YAHHH@Z PROC NEAR					; Max, COMDAT

; 96   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 97   : 	return a > b ? a : b;

  00004	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00007	3b 45 0c	 cmp	 eax, DWORD PTR _b$[ebp]
  0000a	7e 08		 jle	 SHORT $L62409
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0000f	89 4d fc	 mov	 DWORD PTR -4+[ebp], ecx
  00012	eb 06		 jmp	 SHORT $L62410
$L62409:
  00014	8b 55 0c	 mov	 edx, DWORD PTR _b$[ebp]
  00017	89 55 fc	 mov	 DWORD PTR -4+[ebp], edx
$L62410:
  0001a	8b 45 fc	 mov	 eax, DWORD PTR -4+[ebp]

; 98   : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?Max@@YAHHH@Z ENDP					; Max
_TEXT	ENDS
;	COMDAT ??0Ratio@@QAE@HH@Z
_TEXT	SEGMENT
_num$ = 8
_denom$ = 12
_this$ = -4
??0Ratio@@QAE@HH@Z PROC NEAR				; Ratio::Ratio, COMDAT

; 9    : 	Ratio(int num, int denom)	:	numer(num), denom(denom) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _num$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _denom$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0Ratio@@QAE@HH@Z ENDP					; Ratio::Ratio
_TEXT	ENDS
;	COMDAT ??K@YAHHABVRatio@@@Z
_TEXT	SEGMENT
_i$ = 8
_r$ = 12
_val$ = -4
??K@YAHHABVRatio@@@Z PROC NEAR				; operator/, COMDAT

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 40   : 	int val = (i * r.denom) / r.numer;

  00005	8b 45 0c	 mov	 eax, DWORD PTR _r$[ebp]
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  0000b	0f af 48 04	 imul	 ecx, DWORD PTR [eax+4]
  0000f	8b 75 0c	 mov	 esi, DWORD PTR _r$[ebp]
  00012	8b c1		 mov	 eax, ecx
  00014	99		 cdq
  00015	f7 3e		 idiv	 DWORD PTR [esi]
  00017	89 45 fc	 mov	 DWORD PTR _val$[ebp], eax

; 41   : 	return val;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _val$[ebp]

; 42   : }

  0001d	5e		 pop	 esi
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??K@YAHHABVRatio@@@Z ENDP				; operator/
_TEXT	ENDS
;	COMDAT ??D@YAHHABVRatio@@@Z
_TEXT	SEGMENT
_i$ = 8
_ratio$ = 12
_total$ = -8
_val$ = -4
??D@YAHHABVRatio@@@Z PROC NEAR				; operator*, COMDAT

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 54   : 	int total = i * ratio.numer;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _ratio$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  0000c	0f af 08	 imul	 ecx, DWORD PTR [eax]
  0000f	89 4d f8	 mov	 DWORD PTR _total$[ebp], ecx

; 55   : 	int val = total / ratio.denom;

  00012	8b 4d 0c	 mov	 ecx, DWORD PTR _ratio$[ebp]
  00015	8b 45 f8	 mov	 eax, DWORD PTR _total$[ebp]
  00018	99		 cdq
  00019	f7 79 04	 idiv	 DWORD PTR [ecx+4]
  0001c	89 45 fc	 mov	 DWORD PTR _val$[ebp], eax

; 56   : 	if (total > ratio.denom  &&  total % ratio.denom)

  0001f	8b 55 0c	 mov	 edx, DWORD PTR _ratio$[ebp]
  00022	8b 45 f8	 mov	 eax, DWORD PTR _total$[ebp]
  00025	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00028	7e 17		 jle	 SHORT $L1833
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _ratio$[ebp]
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _total$[ebp]
  00030	99		 cdq
  00031	f7 79 04	 idiv	 DWORD PTR [ecx+4]
  00034	85 d2		 test	 edx, edx
  00036	74 09		 je	 SHORT $L1833

; 57   : 		val++;

  00038	8b 55 fc	 mov	 edx, DWORD PTR _val$[ebp]
  0003b	83 c2 01	 add	 edx, 1
  0003e	89 55 fc	 mov	 DWORD PTR _val$[ebp], edx
$L1833:

; 58   : 	return val;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _val$[ebp]

; 59   : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
??D@YAHHABVRatio@@@Z ENDP				; operator*
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0MemID@@QAE@G@Z PROC NEAR				; MemID::MemID, COMDAT

; 23   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 4d 08	 mov	 cx, WORD PTR _h$[ebp]
  0000e	66 89 08	 mov	 WORD PTR [eax], cx

; 24   : 	}

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??0MemID@@QAE@G@Z ENDP					; MemID::MemID
_TEXT	ENDS
PUBLIC	?IsValid@MemoryMgr@@QAEHG@Z			; MemoryMgr::IsValid
EXTRN	_memMgr:DWORD
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsValid@MemID@@QBEHXZ PROC NEAR			; MemID::IsValid, COMDAT

; 62   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 63   : 		return memMgr->IsValid(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?IsValid@MemoryMgr@@QAEHG@Z ; MemoryMgr::IsValid

; 64   : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?IsValid@MemID@@QBEHXZ ENDP				; MemID::IsValid
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT
_this$ = -8
_tempID$ = -4
_theID$ = 8
?IsValid@MemoryMgr@@QAEHG@Z PROC NEAR			; MemoryMgr::IsValid, COMDAT

; 475  : 	inline Bool MemoryMgr::IsValid(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 476  : 		unsigned short tempID = (unsigned short)theID;

  00009	66 8b 45 08	 mov	 ax, WORD PTR _theID$[ebp]
  0000d	66 89 45 fc	 mov	 WORD PTR _tempID$[ebp], ax

; 477  : 
; 478  : 		return(
; 479  : 				(tempID)															&&
; 480  : 				(tempID < maxDescriptors)									&&
; 481  : 				(desc[tempID].memInfo.bits.freeDescriptor == False)	&&
; 482  : 				(desc[tempID].memInfo.bits.freeMemory == False)
; 483  : 				);

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _tempID$[ebp]
  00014	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 58		 je	 SHORT $L62417
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _tempID$[ebp]
  00021	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  0002d	73 47		 jae	 SHORT $L62417
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _tempID$[ebp]
  00032	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00038	c1 e1 04	 shl	 ecx, 4
  0003b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00041	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00044	c1 e1 0e	 shl	 ecx, 14			; 0000000eH
  00047	c1 f9 1f	 sar	 ecx, 31			; 0000001fH
  0004a	85 c9		 test	 ecx, ecx
  0004c	75 28		 jne	 SHORT $L62417
  0004e	8b 55 fc	 mov	 edx, DWORD PTR _tempID$[ebp]
  00051	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00057	c1 e2 04	 shl	 edx, 4
  0005a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00060	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00063	c1 e2 14	 shl	 edx, 20			; 00000014H
  00066	c1 fa 1f	 sar	 edx, 31			; 0000001fH
  00069	85 d2		 test	 edx, edx
  0006b	75 09		 jne	 SHORT $L62417
  0006d	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR -12+[ebp], 1
  00074	eb 07		 jmp	 SHORT $L62418
$L62417:
  00076	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR -12+[ebp], 0
$L62418:
  0007d	8b 45 f4	 mov	 eax, DWORD PTR -12+[ebp]

; 484  : 	}

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 04 00	 ret	 4
?IsValid@MemoryMgr@@QAEHG@Z ENDP			; MemoryMgr::IsValid
_TEXT	ENDS
;	COMDAT ??ASOLPalette@@QAEAAVRgb24F@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??ASOLPalette@@QAEAAVRgb24F@@H@Z PROC NEAR		; SOLPalette::operator[], COMDAT

; 42   : 	Rgb24F&	operator[](int i)					{return colors[i];}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??ASOLPalette@@QAEAAVRgb24F@@H@Z ENDP			; SOLPalette::operator[]
_TEXT	ENDS
;	COMDAT ?Type@Bitmap@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Type@Bitmap@@QBEHXZ PROC NEAR				; Bitmap::Type, COMDAT

; 132  : 	int	Type() const			{return type;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?Type@Bitmap@@QBEHXZ ENDP				; Bitmap::Type
_TEXT	ENDS
PUBLIC	??0MemID@@QAE@ABV0@@Z				; MemID::MemID
;	COMDAT ?Handle@Bitmap@@QBE?AVMemID@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
?Handle@Bitmap@@QBE?AVMemID@@XZ PROC NEAR		; Bitmap::Handle, COMDAT

; 142  : 	MemID	Handle() const			{return memid;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 10	 add	 eax, 16			; 00000010H
  0000d	50		 push	 eax
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?Handle@Bitmap@@QBE?AVMemID@@XZ ENDP			; Bitmap::Handle
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0MemID@@QAE@ABV0@@Z PROC NEAR				; MemID::MemID, COMDAT

; 19   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  0000d	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00010	66 89 10	 mov	 WORD PTR [eax], dx

; 20   : 	}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0MemID@@QAE@ABV0@@Z ENDP				; MemID::MemID
_TEXT	ENDS
;	COMDAT ?ResX@CelObj@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?ResX@CelObj@@QBEHXZ PROC NEAR				; CelObj::ResX, COMDAT

; 181  : 	int	ResX() const			{return resx;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?ResX@CelObj@@QBEHXZ ENDP				; CelObj::ResX
_TEXT	ENDS
;	COMDAT ?ResY@CelObj@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?ResY@CelObj@@QBEHXZ PROC NEAR				; CelObj::ResY, COMDAT

; 182  : 	int	ResY() const			{return resy;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?ResY@CelObj@@QBEHXZ ENDP				; CelObj::ResY
_TEXT	ENDS
;	COMDAT ?Id@ScreenItem@@QBEJXZ
_TEXT	SEGMENT
_this$ = -4
?Id@ScreenItem@@QBEJXZ PROC NEAR			; ScreenItem::Id, COMDAT

; 61   : 	long			Id() const					{return id;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Id@ScreenItem@@QBEJXZ ENDP				; ScreenItem::Id
_TEXT	ENDS
;	COMDAT ?PlaneId@ScreenItem@@QBEJXZ
_TEXT	SEGMENT
_this$ = -4
?PlaneId@ScreenItem@@QBEJXZ PROC NEAR			; ScreenItem::PlaneId, COMDAT

; 63   : 	long			PlaneId() const			{return planeId;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?PlaneId@ScreenItem@@QBEJXZ ENDP			; ScreenItem::PlaneId
_TEXT	ENDS
;	COMDAT ?X1@ScreenItem@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?X1@ScreenItem@@QBEHXZ PROC NEAR			; ScreenItem::X1, COMDAT

; 68   : 	int			X1() const					{return x1;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?X1@ScreenItem@@QBEHXZ ENDP				; ScreenItem::X1
_TEXT	ENDS
;	COMDAT ?Y1@ScreenItem@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Y1@ScreenItem@@QBEHXZ PROC NEAR			; ScreenItem::Y1, COMDAT

; 69   : 	int			Y1() const					{return y1;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 64	 mov	 eax, DWORD PTR [eax+100]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Y1@ScreenItem@@QBEHXZ ENDP				; ScreenItem::Y1
_TEXT	ENDS
;	COMDAT ?AddCount@ScreenItem@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?AddCount@ScreenItem@@QBEHXZ PROC NEAR			; ScreenItem::AddCount, COMDAT

; 72   : 	int			AddCount() const			{return addCount;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?AddCount@ScreenItem@@QBEHXZ ENDP			; ScreenItem::AddCount
_TEXT	ENDS
;	COMDAT ?ClearDeleteCount@ScreenItem@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ClearDeleteCount@ScreenItem@@QAEXXZ PROC NEAR		; ScreenItem::ClearDeleteCount, COMDAT

; 78   : 	void			ClearDeleteCount()		{deleteCount = 0;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], 0
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?ClearDeleteCount@ScreenItem@@QAEXXZ ENDP		; ScreenItem::ClearDeleteCount
_TEXT	ENDS
PUBLIC	?Skip@CelObj@@QBEEXZ				; CelObj::Skip
;	COMDAT ?GetSkip@ScreenItem@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4
?GetSkip@ScreenItem@@QAEEXZ PROC NEAR			; ScreenItem::GetSkip, COMDAT

; 87   : 	uchar			GetSkip()					{GetCelObj();return cel->Skip();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetCelObj@ScreenItem@@QAEXXZ ; ScreenItem::GetCelObj
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00015	e8 00 00 00 00	 call	 ?Skip@CelObj@@QBEEXZ	; CelObj::Skip
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?GetSkip@ScreenItem@@QAEEXZ ENDP			; ScreenItem::GetSkip
_TEXT	ENDS
;	COMDAT ?Skip@CelObj@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4
?Skip@CelObj@@QBEEXZ PROC NEAR				; CelObj::Skip, COMDAT

; 184  : 	uchar	Skip() const			{return skip;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 38	 mov	 al, BYTE PTR [eax+56]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Skip@CelObj@@QBEEXZ ENDP				; CelObj::Skip
_TEXT	ENDS
;	COMDAT ?GetCel@ScreenItem@@QAEPAVCelObj@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetCel@ScreenItem@@QAEPAVCelObj@@XZ PROC NEAR		; ScreenItem::GetCel, COMDAT

; 88   : 	CelObj*		GetCel()						{return cel;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 54	 mov	 eax, DWORD PTR [eax+84]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetCel@ScreenItem@@QAEPAVCelObj@@XZ ENDP		; ScreenItem::GetCel
_TEXT	ENDS
;	COMDAT ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ
_TEXT	SEGMENT
_this$ = -4
?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ PROC NEAR	; ScreenItem::OnScreen, COMDAT

; 89   : 	SOL_Rect& 	OnScreen() 					{return onScreen;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 68	 add	 eax, 104		; 00000068H
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ENDP		; ScreenItem::OnScreen
_TEXT	ENDS
PUBLIC	?Mirrored@CelObj@@QBEHXZ			; CelObj::Mirrored
;	COMDAT ?ReadPix@ScreenItem@@QAEEHH@Z
_TEXT	SEGMENT
_x$ = 8
_y$ = 12
_this$ = -4
?ReadPix@ScreenItem@@QAEEHH@Z PROC NEAR			; ScreenItem::ReadPix, COMDAT

; 91   : 						{GetCelObj(); return cel->ReadPix(x, y, userMirror ^ cel->Mirrored());}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetCelObj@ScreenItem@@QAEXXZ ; ScreenItem::GetCelObj
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00015	e8 00 00 00 00	 call	 ?Mirrored@CelObj@@QBEHXZ ; CelObj::Mirrored
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  00020	33 d0		 xor	 edx, eax
  00022	52		 push	 edx
  00023	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002e	8b 4a 54	 mov	 ecx, DWORD PTR [edx+84]
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 50 54	 mov	 edx, DWORD PTR [eax+84]
  00037	8b 02		 mov	 eax, DWORD PTR [edx]
  00039	ff 50 10	 call	 DWORD PTR [eax+16]
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 08 00	 ret	 8
?ReadPix@ScreenItem@@QAEEHH@Z ENDP			; ScreenItem::ReadPix
_TEXT	ENDS
;	COMDAT ?Mirrored@CelObj@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Mirrored@CelObj@@QBEHXZ PROC NEAR			; CelObj::Mirrored, COMDAT

; 187  : 	Bool	Mirrored() const		{return mirrored;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 48	 mov	 eax, DWORD PTR [eax+72]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Mirrored@CelObj@@QBEHXZ ENDP				; CelObj::Mirrored
_TEXT	ENDS
;	COMDAT ?SetCel@ScreenItem@@QAEXPAVCelObj@@@Z
_TEXT	SEGMENT
_theCel$ = 8
_this$ = -12
$T62438 = -4
$T62439 = -8
?SetCel@ScreenItem@@QAEXPAVCelObj@@@Z PROC NEAR		; ScreenItem::SetCel, COMDAT

; 93   : 	void			SetCel(CelObj* theCel)  {delete cel; cel = theCel;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  0000f	89 4d f8	 mov	 DWORD PTR $T62439[ebp], ecx
  00012	8b 55 f8	 mov	 edx, DWORD PTR $T62439[ebp]
  00015	89 55 fc	 mov	 DWORD PTR $T62438[ebp], edx
  00018	83 7d fc 00	 cmp	 DWORD PTR $T62438[ebp], 0
  0001c	74 11		 je	 SHORT $L62440
  0001e	6a 01		 push	 1
  00020	8b 45 fc	 mov	 eax, DWORD PTR $T62438[ebp]
  00023	8b 10		 mov	 edx, DWORD PTR [eax]
  00025	8b 4d fc	 mov	 ecx, DWORD PTR $T62438[ebp]
  00028	ff 12		 call	 DWORD PTR [edx]
  0002a	89 45 f0	 mov	 DWORD PTR -16+[ebp], eax
  0002d	eb 07		 jmp	 SHORT $L62441
$L62440:
  0002f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR -16+[ebp], 0
$L62441:
  00036	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 4d 08	 mov	 ecx, DWORD PTR _theCel$[ebp]
  0003c	89 48 54	 mov	 DWORD PTR [eax+84], ecx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?SetCel@ScreenItem@@QAEXPAVCelObj@@@Z ENDP		; ScreenItem::SetCel
_TEXT	ENDS
;	COMDAT ?SetUpdateCount@ScreenItem@@QAEXH@Z
_TEXT	SEGMENT
_val$ = 8
_this$ = -4
?SetUpdateCount@ScreenItem@@QAEXH@Z PROC NEAR		; ScreenItem::SetUpdateCount, COMDAT

; 94   : 	void			SetUpdateCount(int val)	{updateCount = val;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _val$[ebp]
  0000d	89 48 48	 mov	 DWORD PTR [eax+72], ecx
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetUpdateCount@ScreenItem@@QAEXH@Z ENDP		; ScreenItem::SetUpdateCount
_TEXT	ENDS
;	COMDAT ?SetAddCount@ScreenItem@@QAEXH@Z
_TEXT	SEGMENT
_val$ = 8
_this$ = -4
?SetAddCount@ScreenItem@@QAEXH@Z PROC NEAR		; ScreenItem::SetAddCount, COMDAT

; 95   : 	void			SetAddCount(int val)		{addCount = val;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _val$[ebp]
  0000d	89 48 4c	 mov	 DWORD PTR [eax+76], ecx
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetAddCount@ScreenItem@@QAEXH@Z ENDP			; ScreenItem::SetAddCount
_TEXT	ENDS
;	COMDAT ?SetDeleteCount@ScreenItem@@QAEXH@Z
_TEXT	SEGMENT
_val$ = 8
_this$ = -4
?SetDeleteCount@ScreenItem@@QAEXH@Z PROC NEAR		; ScreenItem::SetDeleteCount, COMDAT

; 96   : 	void			SetDeleteCount(int val)	{deleteCount = val;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _val$[ebp]
  0000d	89 48 50	 mov	 DWORD PTR [eax+80], ecx
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetDeleteCount@ScreenItem@@QAEXH@Z ENDP		; ScreenItem::SetDeleteCount
_TEXT	ENDS
EXTRN	?SubmitPalette@CelObj@@QAEXXZ:NEAR		; CelObj::SubmitPalette
;	COMDAT ?SubmitPalette@ScreenItem@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?SubmitPalette@ScreenItem@@QAEXXZ PROC NEAR		; ScreenItem::SubmitPalette, COMDAT

; 103  : 	void			SubmitPalette()			{GetCelObj(); cel->SubmitPalette();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetCelObj@ScreenItem@@QAEXXZ ; ScreenItem::GetCelObj
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00015	e8 00 00 00 00	 call	 ?SubmitPalette@CelObj@@QAEXXZ ; CelObj::SubmitPalette
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?SubmitPalette@ScreenItem@@QAEXXZ ENDP			; ScreenItem::SubmitPalette
_TEXT	ENDS
PUBLIC	??4SOL_Point@@QAEAAV0@ABV0@@Z			; SOL_Point::operator=
;	COMDAT ??4SOL_Rect@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??4SOL_Rect@@QAEAAV0@ABV0@@Z PROC NEAR			; SOL_Rect::operator=, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??4SOL_Point@@QAEAAV0@ABV0@@Z ; SOL_Point::operator=
  00013	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00016	83 c1 08	 add	 ecx, 8
  00019	51		 push	 ecx
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 08	 add	 ecx, 8
  00020	e8 00 00 00 00	 call	 ??4SOL_Point@@QAEAAV0@ABV0@@Z ; SOL_Point::operator=
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??4SOL_Rect@@QAEAAV0@ABV0@@Z ENDP			; SOL_Rect::operator=
_TEXT	ENDS
;	COMDAT ??4SOL_Point@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
??4SOL_Point@@QAEAAV0@ABV0@@Z PROC NEAR			; SOL_Point::operator=, COMDAT

; 117  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 118  : 	x = p.x;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx

; 119  : 	y = p.y;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00017	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001a	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 120  : 	return *this;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 121  : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??4SOL_Point@@QAEAAV0@ABV0@@Z ENDP			; SOL_Point::operator=
_TEXT	ENDS
PUBLIC	?Draw@ScreenItem@@QAEXABVBuffer@@ABVSOL_Rect@@@Z ; ScreenItem::Draw
;	COMDAT ?Draw@DrawItem@@QAEXAAVBuffer@@@Z
_TEXT	SEGMENT
_dest$ = 8
_this$ = -4
?Draw@DrawItem@@QAEXAAVBuffer@@@Z PROC NEAR		; DrawItem::Draw, COMDAT

; 16   : 	void			Draw(Buffer& dest)	{si->Draw(dest,onScreen);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	50		 push	 eax
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00011	51		 push	 ecx
  00012	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00015	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00017	e8 00 00 00 00	 call	 ?Draw@ScreenItem@@QAEXABVBuffer@@ABVSOL_Rect@@@Z ; ScreenItem::Draw
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?Draw@DrawItem@@QAEXAAVBuffer@@@Z ENDP			; DrawItem::Draw
_TEXT	ENDS
;	COMDAT ?Draw@ScreenItem@@QAEXABVBuffer@@ABVSOL_Rect@@@Z
_TEXT	SEGMENT
_dest$ = 8
_drawRect$ = 12
_this$ = -4
?Draw@ScreenItem@@QAEXABVBuffer@@ABVSOL_Rect@@@Z PROC NEAR ; ScreenItem::Draw, COMDAT

; 84   : 						{cel->Draw(dest,*this,drawRect,userMirror^cel->Mirrored());}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  0000d	e8 00 00 00 00	 call	 ?Mirrored@CelObj@@QBEHXZ ; CelObj::Mirrored
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  00018	33 d0		 xor	 edx, eax
  0001a	52		 push	 edx
  0001b	8b 45 0c	 mov	 eax, DWORD PTR _drawRect$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  00026	52		 push	 edx
  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  0002d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00030	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  00033	8b 10		 mov	 edx, DWORD PTR [eax]
  00035	ff 52 0c	 call	 DWORD PTR [edx+12]
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
?Draw@ScreenItem@@QAEXABVBuffer@@ABVSOL_Rect@@@Z ENDP	; ScreenItem::Draw
_TEXT	ENDS
;	COMDAT ?OnScreen@DrawItem@@QAEAAVSOL_Rect@@XZ
_TEXT	SEGMENT
_this$ = -4
?OnScreen@DrawItem@@QAEAAVSOL_Rect@@XZ PROC NEAR	; DrawItem::OnScreen, COMDAT

; 17   : 	SOL_Rect&	OnScreen()				{return onScreen;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?OnScreen@DrawItem@@QAEAAVSOL_Rect@@XZ ENDP		; DrawItem::OnScreen
_TEXT	ENDS
;	COMDAT ?SI@DrawItem@@QAEAAVScreenItem@@XZ
_TEXT	SEGMENT
_this$ = -4
?SI@DrawItem@@QAEAAVScreenItem@@XZ PROC NEAR		; DrawItem::SI, COMDAT

; 18   : 	ScreenItem&	SI()						{return *si;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?SI@DrawItem@@QAEAAVScreenItem@@XZ ENDP			; DrawItem::SI
_TEXT	ENDS
;	COMDAT ?Length@DrawList@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Length@DrawList@@QBEHXZ PROC NEAR			; DrawList::Length, COMDAT

; 36   : 	int	Length() const							{return length;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?Length@DrawList@@QBEHXZ ENDP				; DrawList::Length
_TEXT	ENDS
;	COMDAT ??ADrawList@@QAEAAVDrawItem@@H@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
??ADrawList@@QAEAAVDrawItem@@H@Z PROC NEAR		; DrawList::operator[], COMDAT

; 40   : 	DrawItem& operator[](int index) 			{return *drawArray[index];}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 44 81 04	 mov	 eax, DWORD PTR [ecx+eax*4+4]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
??ADrawList@@QAEAAVDrawItem@@H@Z ENDP			; DrawList::operator[]
_TEXT	ENDS
;	COMDAT ?AddCount@SOL_Plane@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?AddCount@SOL_Plane@@QBEHXZ PROC NEAR			; SOL_Plane::AddCount, COMDAT

; 56   : 	int				AddCount() const			{return addCount;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?AddCount@SOL_Plane@@QBEHXZ ENDP			; SOL_Plane::AddCount
_TEXT	ENDS
;	COMDAT ?Color@SOL_Plane@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4
?Color@SOL_Plane@@QBEEXZ PROC NEAR			; SOL_Plane::Color, COMDAT

; 57   : 	uchar				Color() const				{return color;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 08	 mov	 al, BYTE PTR [eax+8]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Color@SOL_Plane@@QBEEXZ ENDP				; SOL_Plane::Color
_TEXT	ENDS
;	COMDAT ?DefRect@SOL_Plane@@QBEABVSOL_Rect@@XZ
_TEXT	SEGMENT
_this$ = -4
?DefRect@SOL_Plane@@QBEABVSOL_Rect@@XZ PROC NEAR	; SOL_Plane::DefRect, COMDAT

; 58   : 	const SOL_Rect& DefRect() const			{return plane;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 64	 add	 eax, 100		; 00000064H
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?DefRect@SOL_Plane@@QBEABVSOL_Rect@@XZ ENDP		; SOL_Plane::DefRect
_TEXT	ENDS
;	COMDAT ?Id@SOL_Plane@@QBEJXZ
_TEXT	SEGMENT
_this$ = -4
?Id@SOL_Plane@@QBEJXZ PROC NEAR				; SOL_Plane::Id, COMDAT

; 64   : 	long				Id() const					{return planeId;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?Id@SOL_Plane@@QBEJXZ ENDP				; SOL_Plane::Id
_TEXT	ENDS
;	COMDAT ?IsColored@SOL_Plane@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsColored@SOL_Plane@@QBEHXZ PROC NEAR			; SOL_Plane::IsColored, COMDAT

; 75   : 	Bool				IsColored() const			{return (type == coloredPlane);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	0f 94 c1	 sete	 cl
  00013	8b c1		 mov	 eax, ecx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?IsColored@SOL_Plane@@QBEHXZ ENDP			; SOL_Plane::IsColored
_TEXT	ENDS
;	COMDAT ?OnScreen@SOL_Plane@@QAEAAVSOL_Rect@@XZ
_TEXT	SEGMENT
_this$ = -4
?OnScreen@SOL_Plane@@QAEAAVSOL_Rect@@XZ PROC NEAR	; SOL_Plane::OnScreen, COMDAT

; 80   : 	SOL_Rect&		OnScreen()					{return onScreen;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 4c	 add	 eax, 76			; 0000004cH
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?OnScreen@SOL_Plane@@QAEAAVSOL_Rect@@XZ ENDP		; SOL_Plane::OnScreen
_TEXT	ENDS
EXTRN	?Pack@ScreenItemList@@QAEXXZ:NEAR		; ScreenItemList::Pack
;	COMDAT ?PackSiArray@SOL_Plane@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?PackSiArray@SOL_Plane@@QAEXXZ PROC NEAR		; SOL_Plane::PackSiArray, COMDAT

; 106  : 	void				PackSiArray()				{siArray.Pack();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0000d	e8 00 00 00 00	 call	 ?Pack@ScreenItemList@@QAEXXZ ; ScreenItemList::Pack
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?PackSiArray@SOL_Plane@@QAEXXZ ENDP			; SOL_Plane::PackSiArray
_TEXT	ENDS
;	COMDAT ?SetAddCount@SOL_Plane@@QAEXH@Z
_TEXT	SEGMENT
_val$ = 8
_this$ = -4
?SetAddCount@SOL_Plane@@QAEXH@Z PROC NEAR		; SOL_Plane::SetAddCount, COMDAT

; 114  : 	void				SetAddCount(int val)		{addCount = val;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _val$[ebp]
  0000d	89 48 30	 mov	 DWORD PTR [eax+48], ecx
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetAddCount@SOL_Plane@@QAEXH@Z ENDP			; SOL_Plane::SetAddCount
_TEXT	ENDS
;	COMDAT ?SetDeleteCount@SOL_Plane@@QAEXH@Z
_TEXT	SEGMENT
_val$ = 8
_this$ = -4
?SetDeleteCount@SOL_Plane@@QAEXH@Z PROC NEAR		; SOL_Plane::SetDeleteCount, COMDAT

; 116  : 	void				SetDeleteCount(int val)	{deleteCount = val;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _val$[ebp]
  0000d	89 48 44	 mov	 DWORD PTR [eax+68], ecx
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetDeleteCount@SOL_Plane@@QAEXH@Z ENDP			; SOL_Plane::SetDeleteCount
_TEXT	ENDS
;	COMDAT ?SetUpdateCount@SOL_Plane@@QAEXH@Z
_TEXT	SEGMENT
_val$ = 8
_this$ = -4
?SetUpdateCount@SOL_Plane@@QAEXH@Z PROC NEAR		; SOL_Plane::SetUpdateCount, COMDAT

; 122  : 	void				SetUpdateCount(int val)	{updateCount = val;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _val$[ebp]
  0000d	89 88 c0 9c 00
	00		 mov	 DWORD PTR [eax+40128], ecx
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?SetUpdateCount@SOL_Plane@@QAEXH@Z ENDP			; SOL_Plane::SetUpdateCount
_TEXT	ENDS
;	COMDAT ?Length@PlaneList@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Length@PlaneList@@QBEHXZ PROC NEAR			; PlaneList::Length, COMDAT

; 22   : 	int	Length() const								{return length;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 80 90 01 00
	00		 mov	 eax, DWORD PTR [eax+400]
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?Length@PlaneList@@QBEHXZ ENDP				; PlaneList::Length
_TEXT	ENDS
;	COMDAT ??APlaneList@@QAEAAVSOL_Plane@@H@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
??APlaneList@@QAEAAVSOL_Plane@@H@Z PROC NEAR		; PlaneList::operator[], COMDAT

; 29   : 	SOL_Plane& operator[](int index) 					{return *planeArray[index];}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??APlaneList@@QAEAAVSOL_Plane@@H@Z ENDP			; PlaneList::operator[]
_TEXT	ENDS
;	COMDAT ??ARectList@@QBEABVSOL_Rect@@H@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
??ARectList@@QBEABVSOL_Rect@@H@Z PROC NEAR		; RectList::operator[], COMDAT

; 44   : 	const SOL_Rect& operator[](int index) const	{return *rectArray[index];}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??ARectList@@QBEABVSOL_Rect@@H@Z ENDP			; RectList::operator[]
_TEXT	ENDS
;	COMDAT ?Length@RectList@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Length@RectList@@QBEHXZ PROC NEAR			; RectList::Length, COMDAT

; 45   : 	int	Length() const									{return length;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 80 a0 0f 00
	00		 mov	 eax, DWORD PTR [eax+4000]
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?Length@RectList@@QBEHXZ ENDP				; RectList::Length
_TEXT	ENDS
;	COMDAT ??ARectList@@QAEAAVSOL_Rect@@H@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
??ARectList@@QAEAAVSOL_Rect@@H@Z PROC NEAR		; RectList::operator[], COMDAT

; 48   : 	SOL_Rect&	operator[](int index)				{return *rectArray[index];}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??ARectList@@QAEAAVSOL_Rect@@H@Z ENDP			; RectList::operator[]
_TEXT	ENDS
;	COMDAT ?ScreenRect@Screen@@QBEABVSOL_Rect@@XZ
_TEXT	SEGMENT
_this$ = -4
?ScreenRect@Screen@@QBEABVSOL_Rect@@XZ PROC NEAR	; Screen::ScreenRect, COMDAT

; 29   : 	const	SOL_Rect& ScreenRect() const	{return screenRect;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	05 94 01 00 00	 add	 eax, 404		; 00000194H
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?ScreenRect@Screen@@QBEABVSOL_Rect@@XZ ENDP		; Screen::ScreenRect
_TEXT	ENDS
;	COMDAT ?Xdim@Screen@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Xdim@Screen@@QBEHXZ PROC NEAR				; Screen::Xdim, COMDAT

; 33   : 	int	Xdim() const						{return xDim;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 80 48 11 00
	00		 mov	 eax, DWORD PTR [eax+4424]
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?Xdim@Screen@@QBEHXZ ENDP				; Screen::Xdim
_TEXT	ENDS
;	COMDAT ?Ydim@Screen@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Ydim@Screen@@QBEHXZ PROC NEAR				; Screen::Ydim, COMDAT

; 34   : 	int	Ydim() const						{return yDim;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 80 4c 11 00
	00		 mov	 eax, DWORD PTR [eax+4428]
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?Ydim@Screen@@QBEHXZ ENDP				; Screen::Ydim
_TEXT	ENDS
;	COMDAT ?Planes@Screen@@QAEAAVPlaneList@@XZ
_TEXT	SEGMENT
_this$ = -4
?Planes@Screen@@QAEAAVPlaneList@@XZ PROC NEAR		; Screen::Planes, COMDAT

; 37   : 	PlaneList& Planes() 						{return planes;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Planes@Screen@@QAEAAVPlaneList@@XZ ENDP		; Screen::Planes
_TEXT	ENDS
;	COMDAT ?ShowList@Screen@@QAEAAVRectList@@XZ
_TEXT	SEGMENT
_this$ = -4
?ShowList@Screen@@QAEAAVRectList@@XZ PROC NEAR		; Screen::ShowList, COMDAT

; 60   : 			ShowList() 							{return showList;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	05 a4 01 00 00	 add	 eax, 420		; 000001a4H
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?ShowList@Screen@@QAEAAVRectList@@XZ ENDP		; Screen::ShowList
_TEXT	ENDS
EXTRN	?Sort@PlaneList@@QAEXXZ:NEAR			; PlaneList::Sort
;	COMDAT ?SortPlanes@Screen@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?SortPlanes@Screen@@QAEXXZ PROC NEAR			; Screen::SortPlanes, COMDAT

; 61   : 	void	SortPlanes()						{planes.Sort();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Sort@PlaneList@@QAEXXZ	; PlaneList::Sort
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?SortPlanes@Screen@@QAEXXZ ENDP				; Screen::SortPlanes
_TEXT	ENDS
PUBLIC	?Set@SOL_Rect@@QAEXHHHH@Z			; SOL_Rect::Set
EXTRN	??0PlaneList@@QAE@XZ:NEAR			; PlaneList::PlaneList
;	COMDAT xdata$x
; File C:\Documents and Settings\don\Desktop\sciw\Interp\screen.hpp
xdata$x	SEGMENT
$T62479	DD	019930520H
	DD	02H
	DD	FLAT:$T62481
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T62481	DD	0ffffffffH
	DD	FLAT:$L62476
	DD	00H
	DD	FLAT:$L62477
xdata$x	ENDS
;	COMDAT ??0Screen@@QAE@HH@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_newXdim$ = 8
_newYdim$ = 12
_this$ = -16
??0Screen@@QAE@HH@Z PROC NEAR				; Screen::Screen, COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 $L62480
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??0PlaneList@@QAE@XZ	; PlaneList::PlaneList
  00024	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	81 c1 94 01 00
	00		 add	 ecx, 404		; 00000194H
  00034	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@XZ	; SOL_Rect::SOL_Rect
  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	81 c1 a4 01 00
	00		 add	 ecx, 420		; 000001a4H
  00042	e8 00 00 00 00	 call	 ??0RectList@@QAE@XZ	; RectList::RectList
  00047	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 74   : 	xDim = newXdim;

  0004b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _newXdim$[ebp]
  00051	89 88 48 11 00
	00		 mov	 DWORD PTR [eax+4424], ecx

; 75   : 	yDim = newYdim;

  00057	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0005a	8b 45 0c	 mov	 eax, DWORD PTR _newYdim$[ebp]
  0005d	89 82 4c 11 00
	00		 mov	 DWORD PTR [edx+4428], eax

; 76   : 	screenRect.Set(0, 0, xDim - 1, yDim - 1);

  00063	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	8b 91 4c 11 00
	00		 mov	 edx, DWORD PTR [ecx+4428]
  0006c	83 ea 01	 sub	 edx, 1
  0006f	52		 push	 edx
  00070	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 88 48 11 00
	00		 mov	 ecx, DWORD PTR [eax+4424]
  00079	83 e9 01	 sub	 ecx, 1
  0007c	51		 push	 ecx
  0007d	6a 00		 push	 0
  0007f	6a 00		 push	 0
  00081	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	81 c1 94 01 00
	00		 add	 ecx, 404		; 00000194H
  0008a	e8 00 00 00 00	 call	 ?Set@SOL_Rect@@QAEXHHHH@Z ; SOL_Rect::Set

; 77   : }

  0008f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00096	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00099	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L62476:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e8 00 00 00 00	 call	 ??1PlaneList@@QAE@XZ	; PlaneList::~PlaneList
  00008	c3		 ret	 0
$L62477:
  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	81 c1 a4 01 00
	00		 add	 ecx, 420		; 000001a4H
  00012	e8 00 00 00 00	 call	 ??1RectList@@QAE@XZ	; RectList::~RectList
  00017	c3		 ret	 0
$L62480:
  00018	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T62479
  0001d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0Screen@@QAE@HH@Z ENDP				; Screen::Screen
;	COMDAT ?Set@SOL_Rect@@QAEXHHHH@Z
_TEXT	SEGMENT
_xa$ = 8
_ya$ = 12
_xb$ = 16
_yb$ = 20
_this$ = -4
?Set@SOL_Rect@@QAEXHHHH@Z PROC NEAR			; SOL_Rect::Set, COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 	A.x = xa;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _xa$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 75   : 	A.y = ya;

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _ya$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 76   : 	B.x = xb;

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 55 10	 mov	 edx, DWORD PTR _xb$[ebp]
  0001e	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 77   : 	B.y = yb;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 4d 14	 mov	 ecx, DWORD PTR _yb$[ebp]
  00027	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 78   : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 10 00	 ret	 16			; 00000010H
?Set@SOL_Rect@@QAEXHHHH@Z ENDP				; SOL_Rect::Set
_TEXT	ENDS
;	COMDAT ?XDim@Buffer@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?XDim@Buffer@@QBEHXZ PROC NEAR				; Buffer::XDim, COMDAT

; 12   : 	int		XDim() const							{return xDim;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?XDim@Buffer@@QBEHXZ ENDP				; Buffer::XDim
_TEXT	ENDS
;	COMDAT ?Xdim@GraphicsMgr@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Xdim@GraphicsMgr@@QBEHXZ PROC NEAR			; GraphicsMgr::Xdim, COMDAT

; 53   : 	int		Xdim() const							{return next.Xdim();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 14	 add	 ecx, 20			; 00000014H
  0000d	e8 00 00 00 00	 call	 ?Xdim@Screen@@QBEHXZ	; Screen::Xdim
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?Xdim@GraphicsMgr@@QBEHXZ ENDP				; GraphicsMgr::Xdim
_TEXT	ENDS
;	COMDAT ?Ydim@GraphicsMgr@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Ydim@GraphicsMgr@@QBEHXZ PROC NEAR			; GraphicsMgr::Ydim, COMDAT

; 54   : 	int		Ydim() const							{return next.Ydim();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 14	 add	 ecx, 20			; 00000014H
  0000d	e8 00 00 00 00	 call	 ?Ydim@Screen@@QBEHXZ	; Screen::Ydim
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?Ydim@GraphicsMgr@@QBEHXZ ENDP				; GraphicsMgr::Ydim
_TEXT	ENDS
EXTRN	?GetPlane@Screen@@QAEPAVSOL_Plane@@H@Z:NEAR	; Screen::GetPlane
;	COMDAT ?GetPlaneNext@GraphicsMgr@@QAEPAVSOL_Plane@@H@Z
_TEXT	SEGMENT
_planeId$ = 8
_this$ = -4
?GetPlaneNext@GraphicsMgr@@QAEPAVSOL_Plane@@H@Z PROC NEAR ; GraphicsMgr::GetPlaneNext, COMDAT

; 69   : 	SOL_Plane* 	GetPlaneNext(int planeId) 			{return next.GetPlane(planeId);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _planeId$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 14	 add	 ecx, 20			; 00000014H
  00011	e8 00 00 00 00	 call	 ?GetPlane@Screen@@QAEPAVSOL_Plane@@H@Z ; Screen::GetPlane
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?GetPlaneNext@GraphicsMgr@@QAEPAVSOL_Plane@@H@Z ENDP	; GraphicsMgr::GetPlaneNext
_TEXT	ENDS
;	COMDAT ?NextScreen@GraphicsMgr@@QAEPAVScreen@@XZ
_TEXT	SEGMENT
_this$ = -4
?NextScreen@GraphicsMgr@@QAEPAVScreen@@XZ PROC NEAR	; GraphicsMgr::NextScreen, COMDAT

; 72   : 	Screen*	NextScreen() 							{return &next;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 14	 add	 eax, 20			; 00000014H
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?NextScreen@GraphicsMgr@@QAEPAVScreen@@XZ ENDP		; GraphicsMgr::NextScreen
_TEXT	ENDS
EXTRN	?RemapMarkRedraw@Screen@@QAEXXZ:NEAR		; Screen::RemapMarkRedraw
;	COMDAT ?RemapMarkRedraw@GraphicsMgr@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?RemapMarkRedraw@GraphicsMgr@@QAEXXZ PROC NEAR		; GraphicsMgr::RemapMarkRedraw, COMDAT

; 77   : 	void		RemapMarkRedraw()						{next.RemapMarkRedraw();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 14	 add	 ecx, 20			; 00000014H
  0000d	e8 00 00 00 00	 call	 ?RemapMarkRedraw@Screen@@QAEXXZ ; Screen::RemapMarkRedraw
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?RemapMarkRedraw@GraphicsMgr@@QAEXXZ ENDP		; GraphicsMgr::RemapMarkRedraw
_TEXT	ENDS
;	COMDAT ?VisiblePlane@GraphicsMgr@@QAEPAVSOL_Plane@@H@Z
_TEXT	SEGMENT
_planeId$ = 8
_this$ = -4
?VisiblePlane@GraphicsMgr@@QAEPAVSOL_Plane@@H@Z PROC NEAR ; GraphicsMgr::VisiblePlane, COMDAT

; 84   : 					{return VisibleScreen().GetPlane(planeId);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _planeId$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	ff 52 44	 call	 DWORD PTR [edx+68]
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 ?GetPlane@Screen@@QAEPAVSOL_Plane@@H@Z ; Screen::GetPlane
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?VisiblePlane@GraphicsMgr@@QAEPAVSOL_Plane@@H@Z ENDP	; GraphicsMgr::VisiblePlane
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0SOL_Rect@@QAE@ABV0@@Z PROC NEAR			; SOL_Rect::SOL_Rect, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  00013	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00016	83 c1 08	 add	 ecx, 8
  00019	51		 push	 ecx
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 08	 add	 ecx, 8
  00020	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??0SOL_Rect@@QAE@ABV0@@Z ENDP				; SOL_Rect::SOL_Rect
_TEXT	ENDS
END
