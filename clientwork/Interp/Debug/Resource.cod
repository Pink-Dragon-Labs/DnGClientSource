	TITLE	C:\Documents and Settings\don\Desktop\sciw\Interp\Resource.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_07CCG@ResView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KCEF@?4v56?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06IAEF@ResPic?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04EODC@?4p56?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08OCKJ@ResChunk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PIPI@?4chk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07ICMB@ResHunk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GG@?4scr?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08BLBP@ResSound?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KPDA@?4snd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NNMB@ResVocab?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PGDD@?4voc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FLKK@ResPatch?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CEHK@?4pat?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07MKGC@ResFont?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04IDCK@?4fon?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06DEEM@ResPal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NJLC@?4pal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07HFNL@ResHeap?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GFFD@?4hep?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06HDCC@ResMsg?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JONM@?4msg?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NFDN@ResAudio?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MOHF@?4aud?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BKMJ@ResWave?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MPDF@?4wav?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@IMEI@ResAudio36?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BONB@ResSync?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KFFK@?4syn?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09CBJE@ResSync36?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06MIEL@ResMap?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CFLF@?4map?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@LIAH@ResMsgTranslation?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JFJA@?4trn?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08JLOL@ResRobot?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04LLKI@?4rbt?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06OEMP@ResVMD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04IOID@?4vmd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@LHED@Instructed?5to?5scale?5to?5zero?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07MAGC@?$CFs?3?5?$CFu?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04HPGM@?$CFs?3?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PIHH@?$CB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01KHHK@?$FO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01FDHG@?$CK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09BLDF@?$CFs?$CFs?$CFs?$CFu?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02PIMC@?$AN?6?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MemoryMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckValid@MemoryMgr@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GMemoryMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@MemID@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IW4ReservedHandle@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@V1@III@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AMemID@@QBEAADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8MemID@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??7MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetExtension@SOL_ResType@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSupported@SOL_ResType@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAttrs@SOL_ResType@@UBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ResView@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResView@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ResPic@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPic@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ResChunk@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResChunk@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ResScript@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResScript@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ResSound@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSound@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ResVocab@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResVocab@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ResPatch@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPatch@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ResFont@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResFont@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ResPal@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPal@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ResHeap@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResHeap@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ResMsg@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMsg@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ResAudio@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResAudio@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ResWave@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResWave@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ResAudio36@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResAudio36@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ResSync@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSync@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ResSync36@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSync36@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ResMap@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMap@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ResMsgTranslation@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMsgTranslation@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileType@ResMsgTranslation@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ResRobot@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResRobot@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ResVMD@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResVMD@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@NN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SOL_Point@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Rgb24@@QAE@EEE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Rgb24@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Rgb24F@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Ratio@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@HHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@VMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Type@Bitmap@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObj@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Skip@CelObj@@QBEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemapState@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Mirrored@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObj@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjView@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjView@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjView@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjView@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjMem@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjMem@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjMem@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjMem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjColor@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjColor@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjColor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjColor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1SOL_Cursor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GSOL_Cursor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@AAVSOL_Point@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Set@SOL_Rect@@QAEXHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeEmpty@SOL_Rect@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Xlen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ylen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8SOL_Rect@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Draw@ScreenItem@@QAEXABVBuffer@@ABVSOL_Rect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SOL_Rect@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TopPlane@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TopSCIPlane@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Xdim@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ydim@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeArrayID@@QBEPAUArrayHeader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ArrayID@@QAE@HW4ArrayType@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@ArrayID@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAE?AVMemID@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAEXVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_List@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@SOL_List@@QAEAAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeDispatchTblID@@QBEPAUDispatchTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeScriptEntryID@@QBEPAUScriptEntry@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntry@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeVariableID@@QBEPAUVariable@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Script@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Object@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGraphicsUpdate@Object@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?selectorDict@Object@@QAEPAVSelectorDict@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AObject@@QAEAAFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddr@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedPropAddr@Object@@QAEPBFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedProperty@Object@@QAEFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddrCheck@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@Object@@QAEFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropOffset@Object@@QAEIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetIndexedProperty@Object@@QAEXHF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetProperty@Object@@QAEXGF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssureValid@ObjectID@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsObject@ObjectID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeClassTblID@@QBEPAUClassTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Check@ResourceMgr@@MAEHPAVSOL_ResType@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Load@ResourceMgr@@MAEXPAVSOL_ResType@@AAUResTag@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DTextID@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeResTagID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeResTagID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@FakeResTagID@@QAEXIW4ReservedHandle@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeResTagID@@QBEPAUResTag@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ResTag@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ResTagID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AResTagID@@QAEAAUResTag@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@ResourceList@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeDebugSummaryStr@ResourceList@@QAEXAAVTextID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeDebugDetailStr@ResourceList@@QAEXAAVTextID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@ResourceList@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ResourceList@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ResTagID@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeResTagID@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SCI16ToSCI32ResType@@YAXAAW4MemType@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GResourceMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemClient@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ResTag@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TextID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ResMaps@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7ResPic@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResView@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResPal@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObj@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResHeap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResWave@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResRobot@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResPatch@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMsgTranslation@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7Buffer@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResScript@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjColor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSync36@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMsg@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7SOL_Cursor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjView@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResAudio36@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResAudio@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResFont@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7MemoryMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResVMD@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResChunk@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSync@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjMem@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResourceMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResVocab@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7MemClient@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?resMgr@@3PAVResourceMgr@@A			; resMgr
PUBLIC	?maxVolumes@@3HA				; maxVolumes
PUBLIC	?resPatches@@3VMemID@@A				; resPatches
PUBLIC	?resPatches36@@3VMemID@@A			; resPatches36
PUBLIC	?langPath@@3PADA				; langPath
PUBLIC	?maxOpenVolumes@@3HA				; maxOpenVolumes
PUBLIC	?resMaps@@3PAUResMaps@@A			; resMaps
PUBLIC	?volPath@@3PADA					; volPath
_BSS	SEGMENT
$SG63553 DB	01H DUP (?)
	ALIGN	4

$SG63565 DB	01H DUP (?)
	ALIGN	4

$SG63582 DB	01H DUP (?)
	ALIGN	4

$SG63594 DB	01H DUP (?)
	ALIGN	4

?resMgr@@3PAVResourceMgr@@A DD 01H DUP (?)		; resMgr
?maxVolumes@@3HA DD 01H DUP (?)				; maxVolumes
?resPatches@@3VMemID@@A DW 01H DUP (?)			; resPatches
	ALIGN	4

?resPatches36@@3VMemID@@A DW 01H DUP (?)		; resPatches36
	ALIGN	4

?langPath@@3PADA DB 0105H DUP (?)			; langPath
	ALIGN	4

?resMaps@@3PAUResMaps@@A DD 01H DUP (?)			; resMaps
?volPath@@3PADA DB 0105H DUP (?)			; volPath
_BSS	ENDS
CRT$XCU	SEGMENT
_$S24	DD	FLAT:_$E23
_$S27	DD	FLAT:_$E26
_$S30	DD	FLAT:_$E29
CRT$XCU	ENDS
_DATA	SEGMENT
?maxOpenVolumes@@3HA DD 0aH				; maxOpenVolumes
_?saveFD@?1??SetLanguage@ResourceMgr@@QAEXPAD@Z@4HA DD 0ffffffffH
$SG63552 DB	'ResType', 00H
$SG63564 DB	'ResType', 00H
$SG63581 DB	'ResType', 00H
$SG63593 DB	'ResType', 00H
_DATA	ENDS
_TEXT	SEGMENT
_$E23	PROC NEAR
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	e8 00 00 00 00	 call	 _$E22
  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
_$E23	ENDP
_TEXT	ENDS
PUBLIC	??0MemID@@QAE@XZ				; MemID::MemID
_TEXT	SEGMENT
_$E22	PROC NEAR

; 46   : MemID				resPatches;

  0000a	55		 push	 ebp
  0000b	8b ec		 mov	 ebp, esp
  0000d	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?resPatches@@3VMemID@@A ; resPatches
  00012	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
_$E22	ENDP
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0MemID@@QAE@XZ PROC NEAR				; MemID::MemID, COMDAT

; 15   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 16   : 	}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0MemID@@QAE@XZ ENDP					; MemID::MemID
_TEXT	ENDS
_TEXT	SEGMENT
_$E26	PROC NEAR
  00019	55		 push	 ebp
  0001a	8b ec		 mov	 ebp, esp
  0001c	e8 00 00 00 00	 call	 _$E25
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_$E26	ENDP
_$E25	PROC NEAR

; 47   : MemID				resPatches36;

  00023	55		 push	 ebp
  00024	8b ec		 mov	 ebp, esp
  00026	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?resPatches36@@3VMemID@@A ; resPatches36
  0002b	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_$E25	ENDP
_$E29	PROC NEAR
  00032	55		 push	 ebp
  00033	8b ec		 mov	 ebp, esp
  00035	e8 00 00 00 00	 call	 _$E28
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
_$E29	ENDP
_TEXT	ENDS
PUBLIC	??0ResourceList@@QAE@ABU0@@Z			; ResourceList::ResourceList
PUBLIC	??0ResSync@@QAE@XZ				; ResSync::ResSync
PUBLIC	??0ResSync36@@QAE@XZ				; ResSync36::ResSync36
PUBLIC	??0ResMap@@QAE@XZ				; ResMap::ResMap
PUBLIC	??0ResMsgTranslation@@QAE@XZ			; ResMsgTranslation::ResMsgTranslation
PUBLIC	??0ResRobot@@QAE@XZ				; ResRobot::ResRobot
PUBLIC	??0ResVMD@@QAE@XZ				; ResVMD::ResVMD
PUBLIC	??0ResView@@QAE@XZ				; ResView::ResView
PUBLIC	??0ResPic@@QAE@XZ				; ResPic::ResPic
PUBLIC	??0ResChunk@@QAE@XZ				; ResChunk::ResChunk
PUBLIC	??0ResScript@@QAE@XZ				; ResScript::ResScript
PUBLIC	??0ResSound@@QAE@XZ				; ResSound::ResSound
PUBLIC	??0ResVocab@@QAE@XZ				; ResVocab::ResVocab
PUBLIC	??0ResPatch@@QAE@XZ				; ResPatch::ResPatch
PUBLIC	??0ResFont@@QAE@XZ				; ResFont::ResFont
PUBLIC	??0ResPal@@QAE@XZ				; ResPal::ResPal
PUBLIC	??0ResHeap@@QAE@XZ				; ResHeap::ResHeap
PUBLIC	??0ResMsg@@QAE@XZ				; ResMsg::ResMsg
PUBLIC	??0ResAudio@@QAE@XZ				; ResAudio::ResAudio
PUBLIC	??0ResWave@@QAE@XZ				; ResWave::ResWave
PUBLIC	??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z ; ResourceList::ResourceList
PUBLIC	??0ResAudio36@@QAE@XZ				; ResAudio36::ResAudio36
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	??0SOL_ResType@@QAE@PAD0@Z:NEAR			; SOL_ResType::SOL_ResType
_BSS	SEGMENT
	ALIGN	4

_resources DB	0240H DUP (?)
_BSS	ENDS
xdata$x	SEGMENT
$T64656	DD	019930520H
	DD	018H
	DD	FLAT:$T64659
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T64659	DD	0ffffffffH
	DD	FLAT:$L64629
	DD	0ffffffffH
	DD	FLAT:$L64630
	DD	0ffffffffH
	DD	FLAT:$L64631
	DD	0ffffffffH
	DD	FLAT:$L64632
	DD	0ffffffffH
	DD	FLAT:$L64633
	DD	0ffffffffH
	DD	FLAT:$L64634
	DD	0ffffffffH
	DD	FLAT:$L64635
	DD	0ffffffffH
	DD	FLAT:$L64636
	DD	0ffffffffH
	DD	FLAT:$L64637
	DD	0ffffffffH
	DD	FLAT:$L64638
	DD	0ffffffffH
	DD	FLAT:$L64639
	DD	0ffffffffH
	DD	FLAT:$L64640
	DD	0ffffffffH
	DD	FLAT:$L64641
	DD	0ffffffffH
	DD	FLAT:$L64642
	DD	0ffffffffH
	DD	FLAT:$L64643
	DD	0ffffffffH
	DD	FLAT:$L64644
	DD	0ffffffffH
	DD	FLAT:$L64645
	DD	0ffffffffH
	DD	FLAT:$L64646
	DD	0ffffffffH
	DD	FLAT:$L64647
	DD	0ffffffffH
	DD	FLAT:$L64648
	DD	0ffffffffH
	DD	FLAT:$L64649
	DD	0ffffffffH
	DD	FLAT:$L64650
	DD	0ffffffffH
	DD	FLAT:$L64651
	DD	0ffffffffH
	DD	FLAT:$L64652
xdata$x	ENDS
_TEXT	SEGMENT
$T64514 = -68
$T64515 = -72
$T64516 = -76
$T64519 = -100
$T64520 = -104
$T64521 = -108
$T64524 = -132
$T64525 = -136
$T64526 = -140
$T64529 = -164
$T64530 = -168
$T64531 = -172
$T64534 = -196
$T64535 = -200
$T64536 = -204
$T64539 = -228
$T64540 = -232
$T64541 = -236
$T64544 = -260
$T64545 = -264
$T64546 = -268
$T64549 = -292
$T64550 = -296
$T64551 = -300
$T64554 = -324
$T64555 = -328
$T64556 = -332
$T64559 = -356
$T64560 = -360
$T64561 = -364
$T64564 = -388
$T64565 = -392
$T64566 = -396
$T64569 = -420
$T64570 = -424
$T64571 = -428
$T64574 = -452
$T64575 = -456
$T64576 = -460
$T64579 = -484
$T64580 = -488
$T64581 = -492
$T64584 = -516
$T64585 = -520
$T64586 = -524
$T64589 = -548
$T64590 = -552
$T64591 = -556
$T64594 = -580
$T64595 = -584
$T64596 = -588
$T64599 = -612
$T64600 = -616
$T64601 = -620
$T64604 = -644
$T64605 = -648
$T64606 = -652
$T64609 = -676
$T64610 = -680
$T64611 = -684
$T64614 = -708
$T64615 = -712
$T64616 = -716
$T64619 = -740
$T64620 = -744
$T64621 = -748
$T64624 = -772
$T64625 = -776
$T64626 = -780
__$EHRec$ = -12
$T64509 = -36
$T64510 = -40
$T64511 = -44
_$E28	PROC NEAR

; 112  : static ResourceList resources[] = {

  0003c	55		 push	 ebp
  0003d	8b ec		 mov	 ebp, esp
  0003f	6a ff		 push	 -1
  00041	68 00 00 00 00	 push	 $L64657
  00046	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0004c	50		 push	 eax
  0004d	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00054	81 ec 60 03 00
	00		 sub	 esp, 864		; 00000360H

; 113  : 
; 114  : 	ResourceList(New ResView, ViewResListHandle, 5000),

  0005a	68 0c 01 00 00	 push	 268			; 0000010cH
  0005f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00064	83 c4 04	 add	 esp, 4
  00067	89 45 d4	 mov	 DWORD PTR $T64511[ebp], eax
  0006a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00071	83 7d d4 00	 cmp	 DWORD PTR $T64511[ebp], 0
  00075	74 10		 je	 SHORT $L64512
  00077	8b 4d d4	 mov	 ecx, DWORD PTR $T64511[ebp]
  0007a	e8 00 00 00 00	 call	 ??0ResView@@QAE@XZ	; ResView::ResView
  0007f	89 85 f0 fc ff
	ff		 mov	 DWORD PTR -784+[ebp], eax
  00085	eb 0a		 jmp	 SHORT $L64513
$L64512:
  00087	c7 85 f0 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR -784+[ebp], 0
$L64513:
  00091	8b 85 f0 fc ff
	ff		 mov	 eax, DWORD PTR -784+[ebp]
  00097	89 45 d8	 mov	 DWORD PTR $T64510[ebp], eax
  0009a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000a1	68 88 13 00 00	 push	 5000			; 00001388H
  000a6	6a 02		 push	 2
  000a8	8b 4d d8	 mov	 ecx, DWORD PTR $T64510[ebp]
  000ab	51		 push	 ecx
  000ac	8d 4d dc	 lea	 ecx, DWORD PTR $T64509[ebp]
  000af	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z ; ResourceList::ResourceList
  000b4	50		 push	 eax
  000b5	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_resources
  000ba	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@ABU0@@Z ; ResourceList::ResourceList

; 115  : 	ResourceList(New ResPic, PicResListHandle, 100),

  000bf	68 0c 01 00 00	 push	 268			; 0000010cH
  000c4	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000c9	83 c4 04	 add	 esp, 4
  000cc	89 45 b4	 mov	 DWORD PTR $T64516[ebp], eax
  000cf	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000d6	83 7d b4 00	 cmp	 DWORD PTR $T64516[ebp], 0
  000da	74 10		 je	 SHORT $L64517
  000dc	8b 4d b4	 mov	 ecx, DWORD PTR $T64516[ebp]
  000df	e8 00 00 00 00	 call	 ??0ResPic@@QAE@XZ	; ResPic::ResPic
  000e4	89 85 ec fc ff
	ff		 mov	 DWORD PTR -788+[ebp], eax
  000ea	eb 0a		 jmp	 SHORT $L64518
$L64517:
  000ec	c7 85 ec fc ff
	ff 00 00 00 00	 mov	 DWORD PTR -788+[ebp], 0
$L64518:
  000f6	8b 95 ec fc ff
	ff		 mov	 edx, DWORD PTR -788+[ebp]
  000fc	89 55 b8	 mov	 DWORD PTR $T64515[ebp], edx
  000ff	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00106	6a 64		 push	 100			; 00000064H
  00108	6a 03		 push	 3
  0010a	8b 45 b8	 mov	 eax, DWORD PTR $T64515[ebp]
  0010d	50		 push	 eax
  0010e	8d 4d bc	 lea	 ecx, DWORD PTR $T64514[ebp]
  00111	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z ; ResourceList::ResourceList
  00116	50		 push	 eax
  00117	b9 18 00 00 00	 mov	 ecx, OFFSET FLAT:_resources+24
  0011c	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@ABU0@@Z ; ResourceList::ResourceList

; 116  : 	ResourceList(New ResScript, ScriptResListHandle, 2500),

  00121	68 0c 01 00 00	 push	 268			; 0000010cH
  00126	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0012b	83 c4 04	 add	 esp, 4
  0012e	89 45 94	 mov	 DWORD PTR $T64521[ebp], eax
  00131	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00138	83 7d 94 00	 cmp	 DWORD PTR $T64521[ebp], 0
  0013c	74 10		 je	 SHORT $L64522
  0013e	8b 4d 94	 mov	 ecx, DWORD PTR $T64521[ebp]
  00141	e8 00 00 00 00	 call	 ??0ResScript@@QAE@XZ	; ResScript::ResScript
  00146	89 85 e8 fc ff
	ff		 mov	 DWORD PTR -792+[ebp], eax
  0014c	eb 0a		 jmp	 SHORT $L64523
$L64522:
  0014e	c7 85 e8 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR -792+[ebp], 0
$L64523:
  00158	8b 8d e8 fc ff
	ff		 mov	 ecx, DWORD PTR -792+[ebp]
  0015e	89 4d 98	 mov	 DWORD PTR $T64520[ebp], ecx
  00161	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00168	68 c4 09 00 00	 push	 2500			; 000009c4H
  0016d	6a 04		 push	 4
  0016f	8b 55 98	 mov	 edx, DWORD PTR $T64520[ebp]
  00172	52		 push	 edx
  00173	8d 4d 9c	 lea	 ecx, DWORD PTR $T64519[ebp]
  00176	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z ; ResourceList::ResourceList
  0017b	50		 push	 eax
  0017c	b9 30 00 00 00	 mov	 ecx, OFFSET FLAT:_resources+48
  00181	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@ABU0@@Z ; ResourceList::ResourceList

; 117  : 	ResourceList(New SOL_ResType),				// OBJECT

  00186	68 0c 01 00 00	 push	 268			; 0000010cH
  0018b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00190	83 c4 04	 add	 esp, 4
  00193	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T64526[ebp], eax
  00199	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  001a0	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR $T64526[ebp], 0
  001a7	74 1d		 je	 SHORT $L64527
  001a9	68 00 00 00 00	 push	 OFFSET FLAT:$SG63552
  001ae	68 00 00 00 00	 push	 OFFSET FLAT:$SG63553
  001b3	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T64526[ebp]
  001b9	e8 00 00 00 00	 call	 ??0SOL_ResType@@QAE@PAD0@Z ; SOL_ResType::SOL_ResType
  001be	89 85 e4 fc ff
	ff		 mov	 DWORD PTR -796+[ebp], eax
  001c4	eb 0a		 jmp	 SHORT $L64528
$L64527:
  001c6	c7 85 e4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR -796+[ebp], 0
$L64528:
  001d0	8b 85 e4 fc ff
	ff		 mov	 eax, DWORD PTR -796+[ebp]
  001d6	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T64525[ebp], eax
  001dc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001e3	6a 01		 push	 1
  001e5	6a 00		 push	 0
  001e7	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR $T64525[ebp]
  001ed	51		 push	 ecx
  001ee	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T64524[ebp]
  001f4	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z ; ResourceList::ResourceList
  001f9	50		 push	 eax
  001fa	b9 48 00 00 00	 mov	 ecx, OFFSET FLAT:_resources+72
  001ff	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@ABU0@@Z ; ResourceList::ResourceList

; 118  : 	ResourceList(New ResSound, SoundResListHandle, 10),

  00204	68 0c 01 00 00	 push	 268			; 0000010cH
  00209	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0020e	83 c4 04	 add	 esp, 4
  00211	89 85 54 ff ff
	ff		 mov	 DWORD PTR $T64531[ebp], eax
  00217	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4
  0021e	83 bd 54 ff ff
	ff 00		 cmp	 DWORD PTR $T64531[ebp], 0
  00225	74 13		 je	 SHORT $L64532
  00227	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR $T64531[ebp]
  0022d	e8 00 00 00 00	 call	 ??0ResSound@@QAE@XZ	; ResSound::ResSound
  00232	89 85 e0 fc ff
	ff		 mov	 DWORD PTR -800+[ebp], eax
  00238	eb 0a		 jmp	 SHORT $L64533
$L64532:
  0023a	c7 85 e0 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR -800+[ebp], 0
$L64533:
  00244	8b 95 e0 fc ff
	ff		 mov	 edx, DWORD PTR -800+[ebp]
  0024a	89 95 58 ff ff
	ff		 mov	 DWORD PTR $T64530[ebp], edx
  00250	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00257	6a 0a		 push	 10			; 0000000aH
  00259	6a 05		 push	 5
  0025b	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR $T64530[ebp]
  00261	50		 push	 eax
  00262	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR $T64529[ebp]
  00268	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z ; ResourceList::ResourceList
  0026d	50		 push	 eax
  0026e	b9 60 00 00 00	 mov	 ecx, OFFSET FLAT:_resources+96
  00273	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@ABU0@@Z ; ResourceList::ResourceList

; 119  : 	ResourceList(New SOL_ResType),				// MEM (obsolete)

  00278	68 0c 01 00 00	 push	 268			; 0000010cH
  0027d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00282	83 c4 04	 add	 esp, 4
  00285	89 85 34 ff ff
	ff		 mov	 DWORD PTR $T64536[ebp], eax
  0028b	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5
  00292	83 bd 34 ff ff
	ff 00		 cmp	 DWORD PTR $T64536[ebp], 0
  00299	74 1d		 je	 SHORT $L64537
  0029b	68 00 00 00 00	 push	 OFFSET FLAT:$SG63564
  002a0	68 00 00 00 00	 push	 OFFSET FLAT:$SG63565
  002a5	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR $T64536[ebp]
  002ab	e8 00 00 00 00	 call	 ??0SOL_ResType@@QAE@PAD0@Z ; SOL_ResType::SOL_ResType
  002b0	89 85 dc fc ff
	ff		 mov	 DWORD PTR -804+[ebp], eax
  002b6	eb 0a		 jmp	 SHORT $L64538
$L64537:
  002b8	c7 85 dc fc ff
	ff 00 00 00 00	 mov	 DWORD PTR -804+[ebp], 0
$L64538:
  002c2	8b 8d dc fc ff
	ff		 mov	 ecx, DWORD PTR -804+[ebp]
  002c8	89 8d 38 ff ff
	ff		 mov	 DWORD PTR $T64535[ebp], ecx
  002ce	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  002d5	6a 01		 push	 1
  002d7	6a 00		 push	 0
  002d9	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR $T64535[ebp]
  002df	52		 push	 edx
  002e0	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR $T64534[ebp]
  002e6	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z ; ResourceList::ResourceList
  002eb	50		 push	 eax
  002ec	b9 78 00 00 00	 mov	 ecx, OFFSET FLAT:_resources+120
  002f1	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@ABU0@@Z ; ResourceList::ResourceList

; 120  : 	ResourceList(New ResVocab, VocabResListHandle, 50),

  002f6	68 0c 01 00 00	 push	 268			; 0000010cH
  002fb	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00300	83 c4 04	 add	 esp, 4
  00303	89 85 14 ff ff
	ff		 mov	 DWORD PTR $T64541[ebp], eax
  00309	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 6
  00310	83 bd 14 ff ff
	ff 00		 cmp	 DWORD PTR $T64541[ebp], 0
  00317	74 13		 je	 SHORT $L64542
  00319	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR $T64541[ebp]
  0031f	e8 00 00 00 00	 call	 ??0ResVocab@@QAE@XZ	; ResVocab::ResVocab
  00324	89 85 d8 fc ff
	ff		 mov	 DWORD PTR -808+[ebp], eax
  0032a	eb 0a		 jmp	 SHORT $L64543
$L64542:
  0032c	c7 85 d8 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR -808+[ebp], 0
$L64543:
  00336	8b 85 d8 fc ff
	ff		 mov	 eax, DWORD PTR -808+[ebp]
  0033c	89 85 18 ff ff
	ff		 mov	 DWORD PTR $T64540[ebp], eax
  00342	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00349	6a 32		 push	 50			; 00000032H
  0034b	6a 06		 push	 6
  0034d	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR $T64540[ebp]
  00353	51		 push	 ecx
  00354	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR $T64539[ebp]
  0035a	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z ; ResourceList::ResourceList
  0035f	50		 push	 eax
  00360	b9 90 00 00 00	 mov	 ecx, OFFSET FLAT:_resources+144
  00365	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@ABU0@@Z ; ResourceList::ResourceList

; 121  : 	ResourceList(New ResFont, FontResListHandle, 50),

  0036a	68 0c 01 00 00	 push	 268			; 0000010cH
  0036f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00374	83 c4 04	 add	 esp, 4
  00377	89 85 f4 fe ff
	ff		 mov	 DWORD PTR $T64546[ebp], eax
  0037d	c7 45 fc 07 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 7
  00384	83 bd f4 fe ff
	ff 00		 cmp	 DWORD PTR $T64546[ebp], 0
  0038b	74 13		 je	 SHORT $L64547
  0038d	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR $T64546[ebp]
  00393	e8 00 00 00 00	 call	 ??0ResFont@@QAE@XZ	; ResFont::ResFont
  00398	89 85 d4 fc ff
	ff		 mov	 DWORD PTR -812+[ebp], eax
  0039e	eb 0a		 jmp	 SHORT $L64548
$L64547:
  003a0	c7 85 d4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR -812+[ebp], 0
$L64548:
  003aa	8b 95 d4 fc ff
	ff		 mov	 edx, DWORD PTR -812+[ebp]
  003b0	89 95 f8 fe ff
	ff		 mov	 DWORD PTR $T64545[ebp], edx
  003b6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003bd	6a 32		 push	 50			; 00000032H
  003bf	6a 07		 push	 7
  003c1	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR $T64545[ebp]
  003c7	50		 push	 eax
  003c8	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR $T64544[ebp]
  003ce	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z ; ResourceList::ResourceList
  003d3	50		 push	 eax
  003d4	b9 a8 00 00 00	 mov	 ecx, OFFSET FLAT:_resources+168
  003d9	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@ABU0@@Z ; ResourceList::ResourceList

; 122  : 	ResourceList(New SOL_ResType),				// CURSOR

  003de	68 0c 01 00 00	 push	 268			; 0000010cH
  003e3	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  003e8	83 c4 04	 add	 esp, 4
  003eb	89 85 d4 fe ff
	ff		 mov	 DWORD PTR $T64551[ebp], eax
  003f1	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 8
  003f8	83 bd d4 fe ff
	ff 00		 cmp	 DWORD PTR $T64551[ebp], 0
  003ff	74 1d		 je	 SHORT $L64552
  00401	68 00 00 00 00	 push	 OFFSET FLAT:$SG63581
  00406	68 00 00 00 00	 push	 OFFSET FLAT:$SG63582
  0040b	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR $T64551[ebp]
  00411	e8 00 00 00 00	 call	 ??0SOL_ResType@@QAE@PAD0@Z ; SOL_ResType::SOL_ResType
  00416	89 85 d0 fc ff
	ff		 mov	 DWORD PTR -816+[ebp], eax
  0041c	eb 0a		 jmp	 SHORT $L64553
$L64552:
  0041e	c7 85 d0 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR -816+[ebp], 0
$L64553:
  00428	8b 8d d0 fc ff
	ff		 mov	 ecx, DWORD PTR -816+[ebp]
  0042e	89 8d d8 fe ff
	ff		 mov	 DWORD PTR $T64550[ebp], ecx
  00434	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0043b	6a 01		 push	 1
  0043d	6a 00		 push	 0
  0043f	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR $T64550[ebp]
  00445	52		 push	 edx
  00446	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR $T64549[ebp]
  0044c	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z ; ResourceList::ResourceList
  00451	50		 push	 eax
  00452	b9 c0 00 00 00	 mov	 ecx, OFFSET FLAT:_resources+192
  00457	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@ABU0@@Z ; ResourceList::ResourceList

; 123  : 	ResourceList(New ResPatch, PatchResListHandle, 50),

  0045c	68 0c 01 00 00	 push	 268			; 0000010cH
  00461	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00466	83 c4 04	 add	 esp, 4
  00469	89 85 b4 fe ff
	ff		 mov	 DWORD PTR $T64556[ebp], eax
  0046f	c7 45 fc 09 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 9
  00476	83 bd b4 fe ff
	ff 00		 cmp	 DWORD PTR $T64556[ebp], 0
  0047d	74 13		 je	 SHORT $L64557
  0047f	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR $T64556[ebp]
  00485	e8 00 00 00 00	 call	 ??0ResPatch@@QAE@XZ	; ResPatch::ResPatch
  0048a	89 85 cc fc ff
	ff		 mov	 DWORD PTR -820+[ebp], eax
  00490	eb 0a		 jmp	 SHORT $L64558
$L64557:
  00492	c7 85 cc fc ff
	ff 00 00 00 00	 mov	 DWORD PTR -820+[ebp], 0
$L64558:
  0049c	8b 85 cc fc ff
	ff		 mov	 eax, DWORD PTR -820+[ebp]
  004a2	89 85 b8 fe ff
	ff		 mov	 DWORD PTR $T64555[ebp], eax
  004a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  004af	6a 32		 push	 50			; 00000032H
  004b1	6a 08		 push	 8
  004b3	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR $T64555[ebp]
  004b9	51		 push	 ecx
  004ba	8d 8d bc fe ff
	ff		 lea	 ecx, DWORD PTR $T64554[ebp]
  004c0	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z ; ResourceList::ResourceList
  004c5	50		 push	 eax
  004c6	b9 d8 00 00 00	 mov	 ecx, OFFSET FLAT:_resources+216
  004cb	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@ABU0@@Z ; ResourceList::ResourceList

; 124  : 	ResourceList(New SOL_ResType),				// BITMAP

  004d0	68 0c 01 00 00	 push	 268			; 0000010cH
  004d5	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  004da	83 c4 04	 add	 esp, 4
  004dd	89 85 94 fe ff
	ff		 mov	 DWORD PTR $T64561[ebp], eax
  004e3	c7 45 fc 0a 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  004ea	83 bd 94 fe ff
	ff 00		 cmp	 DWORD PTR $T64561[ebp], 0
  004f1	74 1d		 je	 SHORT $L64562
  004f3	68 00 00 00 00	 push	 OFFSET FLAT:$SG63593
  004f8	68 00 00 00 00	 push	 OFFSET FLAT:$SG63594
  004fd	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR $T64561[ebp]
  00503	e8 00 00 00 00	 call	 ??0SOL_ResType@@QAE@PAD0@Z ; SOL_ResType::SOL_ResType
  00508	89 85 c8 fc ff
	ff		 mov	 DWORD PTR -824+[ebp], eax
  0050e	eb 0a		 jmp	 SHORT $L64563
$L64562:
  00510	c7 85 c8 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR -824+[ebp], 0
$L64563:
  0051a	8b 95 c8 fc ff
	ff		 mov	 edx, DWORD PTR -824+[ebp]
  00520	89 95 98 fe ff
	ff		 mov	 DWORD PTR $T64560[ebp], edx
  00526	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0052d	6a 01		 push	 1
  0052f	6a 00		 push	 0
  00531	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR $T64560[ebp]
  00537	50		 push	 eax
  00538	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T64559[ebp]
  0053e	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z ; ResourceList::ResourceList
  00543	50		 push	 eax
  00544	b9 f0 00 00 00	 mov	 ecx, OFFSET FLAT:_resources+240
  00549	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@ABU0@@Z ; ResourceList::ResourceList

; 125  : 	ResourceList(New ResPal, PalResListHandle, 50),

  0054e	68 0c 01 00 00	 push	 268			; 0000010cH
  00553	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00558	83 c4 04	 add	 esp, 4
  0055b	89 85 74 fe ff
	ff		 mov	 DWORD PTR $T64566[ebp], eax
  00561	c7 45 fc 0b 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  00568	83 bd 74 fe ff
	ff 00		 cmp	 DWORD PTR $T64566[ebp], 0
  0056f	74 13		 je	 SHORT $L64567
  00571	8b 8d 74 fe ff
	ff		 mov	 ecx, DWORD PTR $T64566[ebp]
  00577	e8 00 00 00 00	 call	 ??0ResPal@@QAE@XZ	; ResPal::ResPal
  0057c	89 85 c4 fc ff
	ff		 mov	 DWORD PTR -828+[ebp], eax
  00582	eb 0a		 jmp	 SHORT $L64568
$L64567:
  00584	c7 85 c4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR -828+[ebp], 0
$L64568:
  0058e	8b 8d c4 fc ff
	ff		 mov	 ecx, DWORD PTR -828+[ebp]
  00594	89 8d 78 fe ff
	ff		 mov	 DWORD PTR $T64565[ebp], ecx
  0059a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  005a1	6a 32		 push	 50			; 00000032H
  005a3	6a 09		 push	 9
  005a5	8b 95 78 fe ff
	ff		 mov	 edx, DWORD PTR $T64565[ebp]
  005ab	52		 push	 edx
  005ac	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T64564[ebp]
  005b2	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z ; ResourceList::ResourceList
  005b7	50		 push	 eax
  005b8	b9 08 01 00 00	 mov	 ecx, OFFSET FLAT:_resources+264
  005bd	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@ABU0@@Z ; ResourceList::ResourceList

; 126  : 	ResourceList(New ResWave, WaveResListHandle, 10),

  005c2	68 0c 01 00 00	 push	 268			; 0000010cH
  005c7	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  005cc	83 c4 04	 add	 esp, 4
  005cf	89 85 54 fe ff
	ff		 mov	 DWORD PTR $T64571[ebp], eax
  005d5	c7 45 fc 0c 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  005dc	83 bd 54 fe ff
	ff 00		 cmp	 DWORD PTR $T64571[ebp], 0
  005e3	74 13		 je	 SHORT $L64572
  005e5	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR $T64571[ebp]
  005eb	e8 00 00 00 00	 call	 ??0ResWave@@QAE@XZ	; ResWave::ResWave
  005f0	89 85 c0 fc ff
	ff		 mov	 DWORD PTR -832+[ebp], eax
  005f6	eb 0a		 jmp	 SHORT $L64573
$L64572:
  005f8	c7 85 c0 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR -832+[ebp], 0
$L64573:
  00602	8b 85 c0 fc ff
	ff		 mov	 eax, DWORD PTR -832+[ebp]
  00608	89 85 58 fe ff
	ff		 mov	 DWORD PTR $T64570[ebp], eax
  0060e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00615	6a 0a		 push	 10			; 0000000aH
  00617	6a 0a		 push	 10			; 0000000aH
  00619	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR $T64570[ebp]
  0061f	51		 push	 ecx
  00620	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR $T64569[ebp]
  00626	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z ; ResourceList::ResourceList
  0062b	50		 push	 eax
  0062c	b9 20 01 00 00	 mov	 ecx, OFFSET FLAT:_resources+288
  00631	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@ABU0@@Z ; ResourceList::ResourceList

; 127  : 	ResourceList(New ResAudio, AudioResListHandle, 10),

  00636	68 0c 01 00 00	 push	 268			; 0000010cH
  0063b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00640	83 c4 04	 add	 esp, 4
  00643	89 85 34 fe ff
	ff		 mov	 DWORD PTR $T64576[ebp], eax
  00649	c7 45 fc 0d 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  00650	83 bd 34 fe ff
	ff 00		 cmp	 DWORD PTR $T64576[ebp], 0
  00657	74 13		 je	 SHORT $L64577
  00659	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR $T64576[ebp]
  0065f	e8 00 00 00 00	 call	 ??0ResAudio@@QAE@XZ	; ResAudio::ResAudio
  00664	89 85 bc fc ff
	ff		 mov	 DWORD PTR -836+[ebp], eax
  0066a	eb 0a		 jmp	 SHORT $L64578
$L64577:
  0066c	c7 85 bc fc ff
	ff 00 00 00 00	 mov	 DWORD PTR -836+[ebp], 0
$L64578:
  00676	8b 95 bc fc ff
	ff		 mov	 edx, DWORD PTR -836+[ebp]
  0067c	89 95 38 fe ff
	ff		 mov	 DWORD PTR $T64575[ebp], edx
  00682	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00689	6a 0a		 push	 10			; 0000000aH
  0068b	6a 0b		 push	 11			; 0000000bH
  0068d	8b 85 38 fe ff
	ff		 mov	 eax, DWORD PTR $T64575[ebp]
  00693	50		 push	 eax
  00694	8d 8d 3c fe ff
	ff		 lea	 ecx, DWORD PTR $T64574[ebp]
  0069a	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z ; ResourceList::ResourceList
  0069f	50		 push	 eax
  006a0	b9 38 01 00 00	 mov	 ecx, OFFSET FLAT:_resources+312
  006a5	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@ABU0@@Z ; ResourceList::ResourceList

; 128  : 	ResourceList(New ResSync, SyncResListHandle, 10),

  006aa	68 0c 01 00 00	 push	 268			; 0000010cH
  006af	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  006b4	83 c4 04	 add	 esp, 4
  006b7	89 85 14 fe ff
	ff		 mov	 DWORD PTR $T64581[ebp], eax
  006bd	c7 45 fc 0e 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  006c4	83 bd 14 fe ff
	ff 00		 cmp	 DWORD PTR $T64581[ebp], 0
  006cb	74 13		 je	 SHORT $L64582
  006cd	8b 8d 14 fe ff
	ff		 mov	 ecx, DWORD PTR $T64581[ebp]
  006d3	e8 00 00 00 00	 call	 ??0ResSync@@QAE@XZ	; ResSync::ResSync
  006d8	89 85 b8 fc ff
	ff		 mov	 DWORD PTR -840+[ebp], eax
  006de	eb 0a		 jmp	 SHORT $L64583
$L64582:
  006e0	c7 85 b8 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR -840+[ebp], 0
$L64583:
  006ea	8b 8d b8 fc ff
	ff		 mov	 ecx, DWORD PTR -840+[ebp]
  006f0	89 8d 18 fe ff
	ff		 mov	 DWORD PTR $T64580[ebp], ecx
  006f6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  006fd	6a 0a		 push	 10			; 0000000aH
  006ff	6a 0c		 push	 12			; 0000000cH
  00701	8b 95 18 fe ff
	ff		 mov	 edx, DWORD PTR $T64580[ebp]
  00707	52		 push	 edx
  00708	8d 8d 1c fe ff
	ff		 lea	 ecx, DWORD PTR $T64579[ebp]
  0070e	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z ; ResourceList::ResourceList
  00713	50		 push	 eax
  00714	b9 50 01 00 00	 mov	 ecx, OFFSET FLAT:_resources+336
  00719	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@ABU0@@Z ; ResourceList::ResourceList

; 129  : 	ResourceList(New ResMsg, MsgResListHandle, 500),

  0071e	68 0c 01 00 00	 push	 268			; 0000010cH
  00723	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00728	83 c4 04	 add	 esp, 4
  0072b	89 85 f4 fd ff
	ff		 mov	 DWORD PTR $T64586[ebp], eax
  00731	c7 45 fc 0f 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  00738	83 bd f4 fd ff
	ff 00		 cmp	 DWORD PTR $T64586[ebp], 0
  0073f	74 13		 je	 SHORT $L64587
  00741	8b 8d f4 fd ff
	ff		 mov	 ecx, DWORD PTR $T64586[ebp]
  00747	e8 00 00 00 00	 call	 ??0ResMsg@@QAE@XZ	; ResMsg::ResMsg
  0074c	89 85 b4 fc ff
	ff		 mov	 DWORD PTR -844+[ebp], eax
  00752	eb 0a		 jmp	 SHORT $L64588
$L64587:
  00754	c7 85 b4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR -844+[ebp], 0
$L64588:
  0075e	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR -844+[ebp]
  00764	89 85 f8 fd ff
	ff		 mov	 DWORD PTR $T64585[ebp], eax
  0076a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00771	68 f4 01 00 00	 push	 500			; 000001f4H
  00776	6a 0d		 push	 13			; 0000000dH
  00778	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR $T64585[ebp]
  0077e	51		 push	 ecx
  0077f	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR $T64584[ebp]
  00785	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z ; ResourceList::ResourceList
  0078a	50		 push	 eax
  0078b	b9 68 01 00 00	 mov	 ecx, OFFSET FLAT:_resources+360
  00790	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@ABU0@@Z ; ResourceList::ResourceList

; 130  : 	ResourceList(New ResMap, MapResListHandle, 500),

  00795	68 0c 01 00 00	 push	 268			; 0000010cH
  0079a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0079f	83 c4 04	 add	 esp, 4
  007a2	89 85 d4 fd ff
	ff		 mov	 DWORD PTR $T64591[ebp], eax
  007a8	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 16 ; 00000010H
  007af	83 bd d4 fd ff
	ff 00		 cmp	 DWORD PTR $T64591[ebp], 0
  007b6	74 13		 je	 SHORT $L64592
  007b8	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR $T64591[ebp]
  007be	e8 00 00 00 00	 call	 ??0ResMap@@QAE@XZ	; ResMap::ResMap
  007c3	89 85 b0 fc ff
	ff		 mov	 DWORD PTR -848+[ebp], eax
  007c9	eb 0a		 jmp	 SHORT $L64593
$L64592:
  007cb	c7 85 b0 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR -848+[ebp], 0
$L64593:
  007d5	8b 95 b0 fc ff
	ff		 mov	 edx, DWORD PTR -848+[ebp]
  007db	89 95 d8 fd ff
	ff		 mov	 DWORD PTR $T64590[ebp], edx
  007e1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  007e8	68 f4 01 00 00	 push	 500			; 000001f4H
  007ed	6a 0e		 push	 14			; 0000000eH
  007ef	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR $T64590[ebp]
  007f5	50		 push	 eax
  007f6	8d 8d dc fd ff
	ff		 lea	 ecx, DWORD PTR $T64589[ebp]
  007fc	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z ; ResourceList::ResourceList
  00801	50		 push	 eax
  00802	b9 80 01 00 00	 mov	 ecx, OFFSET FLAT:_resources+384
  00807	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@ABU0@@Z ; ResourceList::ResourceList

; 131  : 	ResourceList(New ResHeap, HeapResListHandle, 2500),

  0080c	68 0c 01 00 00	 push	 268			; 0000010cH
  00811	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00816	83 c4 04	 add	 esp, 4
  00819	89 85 b4 fd ff
	ff		 mov	 DWORD PTR $T64596[ebp], eax
  0081f	c7 45 fc 11 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 17 ; 00000011H
  00826	83 bd b4 fd ff
	ff 00		 cmp	 DWORD PTR $T64596[ebp], 0
  0082d	74 13		 je	 SHORT $L64597
  0082f	8b 8d b4 fd ff
	ff		 mov	 ecx, DWORD PTR $T64596[ebp]
  00835	e8 00 00 00 00	 call	 ??0ResHeap@@QAE@XZ	; ResHeap::ResHeap
  0083a	89 85 ac fc ff
	ff		 mov	 DWORD PTR -852+[ebp], eax
  00840	eb 0a		 jmp	 SHORT $L64598
$L64597:
  00842	c7 85 ac fc ff
	ff 00 00 00 00	 mov	 DWORD PTR -852+[ebp], 0
$L64598:
  0084c	8b 8d ac fc ff
	ff		 mov	 ecx, DWORD PTR -852+[ebp]
  00852	89 8d b8 fd ff
	ff		 mov	 DWORD PTR $T64595[ebp], ecx
  00858	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0085f	68 c4 09 00 00	 push	 2500			; 000009c4H
  00864	6a 0f		 push	 15			; 0000000fH
  00866	8b 95 b8 fd ff
	ff		 mov	 edx, DWORD PTR $T64595[ebp]
  0086c	52		 push	 edx
  0086d	8d 8d bc fd ff
	ff		 lea	 ecx, DWORD PTR $T64594[ebp]
  00873	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z ; ResourceList::ResourceList
  00878	50		 push	 eax
  00879	b9 98 01 00 00	 mov	 ecx, OFFSET FLAT:_resources+408
  0087e	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@ABU0@@Z ; ResourceList::ResourceList

; 132  :    ResourceList(New ResChunk, ChunkResListHandle, 10),

  00883	68 0c 01 00 00	 push	 268			; 0000010cH
  00888	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0088d	83 c4 04	 add	 esp, 4
  00890	89 85 94 fd ff
	ff		 mov	 DWORD PTR $T64601[ebp], eax
  00896	c7 45 fc 12 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 18 ; 00000012H
  0089d	83 bd 94 fd ff
	ff 00		 cmp	 DWORD PTR $T64601[ebp], 0
  008a4	74 13		 je	 SHORT $L64602
  008a6	8b 8d 94 fd ff
	ff		 mov	 ecx, DWORD PTR $T64601[ebp]
  008ac	e8 00 00 00 00	 call	 ??0ResChunk@@QAE@XZ	; ResChunk::ResChunk
  008b1	89 85 a8 fc ff
	ff		 mov	 DWORD PTR -856+[ebp], eax
  008b7	eb 0a		 jmp	 SHORT $L64603
$L64602:
  008b9	c7 85 a8 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR -856+[ebp], 0
$L64603:
  008c3	8b 85 a8 fc ff
	ff		 mov	 eax, DWORD PTR -856+[ebp]
  008c9	89 85 98 fd ff
	ff		 mov	 DWORD PTR $T64600[ebp], eax
  008cf	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  008d6	6a 0a		 push	 10			; 0000000aH
  008d8	6a 10		 push	 16			; 00000010H
  008da	8b 8d 98 fd ff
	ff		 mov	 ecx, DWORD PTR $T64600[ebp]
  008e0	51		 push	 ecx
  008e1	8d 8d 9c fd ff
	ff		 lea	 ecx, DWORD PTR $T64599[ebp]
  008e7	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z ; ResourceList::ResourceList
  008ec	50		 push	 eax
  008ed	b9 b0 01 00 00	 mov	 ecx, OFFSET FLAT:_resources+432
  008f2	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@ABU0@@Z ; ResourceList::ResourceList

; 133  : 	ResourceList(New ResAudio36, Audio36ResListHandle, 10),

  008f7	68 0c 01 00 00	 push	 268			; 0000010cH
  008fc	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00901	83 c4 04	 add	 esp, 4
  00904	89 85 74 fd ff
	ff		 mov	 DWORD PTR $T64606[ebp], eax
  0090a	c7 45 fc 13 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 19 ; 00000013H
  00911	83 bd 74 fd ff
	ff 00		 cmp	 DWORD PTR $T64606[ebp], 0
  00918	74 13		 je	 SHORT $L64607
  0091a	8b 8d 74 fd ff
	ff		 mov	 ecx, DWORD PTR $T64606[ebp]
  00920	e8 00 00 00 00	 call	 ??0ResAudio36@@QAE@XZ	; ResAudio36::ResAudio36
  00925	89 85 a4 fc ff
	ff		 mov	 DWORD PTR -860+[ebp], eax
  0092b	eb 0a		 jmp	 SHORT $L64608
$L64607:
  0092d	c7 85 a4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR -860+[ebp], 0
$L64608:
  00937	8b 95 a4 fc ff
	ff		 mov	 edx, DWORD PTR -860+[ebp]
  0093d	89 95 78 fd ff
	ff		 mov	 DWORD PTR $T64605[ebp], edx
  00943	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0094a	6a 0a		 push	 10			; 0000000aH
  0094c	6a 11		 push	 17			; 00000011H
  0094e	8b 85 78 fd ff
	ff		 mov	 eax, DWORD PTR $T64605[ebp]
  00954	50		 push	 eax
  00955	8d 8d 7c fd ff
	ff		 lea	 ecx, DWORD PTR $T64604[ebp]
  0095b	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z ; ResourceList::ResourceList
  00960	50		 push	 eax
  00961	b9 c8 01 00 00	 mov	 ecx, OFFSET FLAT:_resources+456
  00966	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@ABU0@@Z ; ResourceList::ResourceList

; 134  : 	ResourceList(New ResSync36, Sync36ResListHandle, 10),

  0096b	68 0c 01 00 00	 push	 268			; 0000010cH
  00970	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00975	83 c4 04	 add	 esp, 4
  00978	89 85 54 fd ff
	ff		 mov	 DWORD PTR $T64611[ebp], eax
  0097e	c7 45 fc 14 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 20 ; 00000014H
  00985	83 bd 54 fd ff
	ff 00		 cmp	 DWORD PTR $T64611[ebp], 0
  0098c	74 13		 je	 SHORT $L64612
  0098e	8b 8d 54 fd ff
	ff		 mov	 ecx, DWORD PTR $T64611[ebp]
  00994	e8 00 00 00 00	 call	 ??0ResSync36@@QAE@XZ	; ResSync36::ResSync36
  00999	89 85 a0 fc ff
	ff		 mov	 DWORD PTR -864+[ebp], eax
  0099f	eb 0a		 jmp	 SHORT $L64613
$L64612:
  009a1	c7 85 a0 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR -864+[ebp], 0
$L64613:
  009ab	8b 8d a0 fc ff
	ff		 mov	 ecx, DWORD PTR -864+[ebp]
  009b1	89 8d 58 fd ff
	ff		 mov	 DWORD PTR $T64610[ebp], ecx
  009b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  009be	6a 0a		 push	 10			; 0000000aH
  009c0	6a 12		 push	 18			; 00000012H
  009c2	8b 95 58 fd ff
	ff		 mov	 edx, DWORD PTR $T64610[ebp]
  009c8	52		 push	 edx
  009c9	8d 8d 5c fd ff
	ff		 lea	 ecx, DWORD PTR $T64609[ebp]
  009cf	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z ; ResourceList::ResourceList
  009d4	50		 push	 eax
  009d5	b9 e0 01 00 00	 mov	 ecx, OFFSET FLAT:_resources+480
  009da	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@ABU0@@Z ; ResourceList::ResourceList

; 135  : 	ResourceList(New ResMsgTranslation, MsgTranslationResListHandle, 10),

  009df	68 0c 01 00 00	 push	 268			; 0000010cH
  009e4	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  009e9	83 c4 04	 add	 esp, 4
  009ec	89 85 34 fd ff
	ff		 mov	 DWORD PTR $T64616[ebp], eax
  009f2	c7 45 fc 15 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 21 ; 00000015H
  009f9	83 bd 34 fd ff
	ff 00		 cmp	 DWORD PTR $T64616[ebp], 0
  00a00	74 13		 je	 SHORT $L64617
  00a02	8b 8d 34 fd ff
	ff		 mov	 ecx, DWORD PTR $T64616[ebp]
  00a08	e8 00 00 00 00	 call	 ??0ResMsgTranslation@@QAE@XZ ; ResMsgTranslation::ResMsgTranslation
  00a0d	89 85 9c fc ff
	ff		 mov	 DWORD PTR -868+[ebp], eax
  00a13	eb 0a		 jmp	 SHORT $L64618
$L64617:
  00a15	c7 85 9c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR -868+[ebp], 0
$L64618:
  00a1f	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR -868+[ebp]
  00a25	89 85 38 fd ff
	ff		 mov	 DWORD PTR $T64615[ebp], eax
  00a2b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00a32	6a 0a		 push	 10			; 0000000aH
  00a34	6a 13		 push	 19			; 00000013H
  00a36	8b 8d 38 fd ff
	ff		 mov	 ecx, DWORD PTR $T64615[ebp]
  00a3c	51		 push	 ecx
  00a3d	8d 8d 3c fd ff
	ff		 lea	 ecx, DWORD PTR $T64614[ebp]
  00a43	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z ; ResourceList::ResourceList
  00a48	50		 push	 eax
  00a49	b9 f8 01 00 00	 mov	 ecx, OFFSET FLAT:_resources+504
  00a4e	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@ABU0@@Z ; ResourceList::ResourceList

; 136  : 	ResourceList(New ResRobot, RobotResListHandle, 10),

  00a53	68 0c 01 00 00	 push	 268			; 0000010cH
  00a58	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00a5d	83 c4 04	 add	 esp, 4
  00a60	89 85 14 fd ff
	ff		 mov	 DWORD PTR $T64621[ebp], eax
  00a66	c7 45 fc 16 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 22 ; 00000016H
  00a6d	83 bd 14 fd ff
	ff 00		 cmp	 DWORD PTR $T64621[ebp], 0
  00a74	74 13		 je	 SHORT $L64622
  00a76	8b 8d 14 fd ff
	ff		 mov	 ecx, DWORD PTR $T64621[ebp]
  00a7c	e8 00 00 00 00	 call	 ??0ResRobot@@QAE@XZ	; ResRobot::ResRobot
  00a81	89 85 98 fc ff
	ff		 mov	 DWORD PTR -872+[ebp], eax
  00a87	eb 0a		 jmp	 SHORT $L64623
$L64622:
  00a89	c7 85 98 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR -872+[ebp], 0
$L64623:
  00a93	8b 95 98 fc ff
	ff		 mov	 edx, DWORD PTR -872+[ebp]
  00a99	89 95 18 fd ff
	ff		 mov	 DWORD PTR $T64620[ebp], edx
  00a9f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00aa6	6a 0a		 push	 10			; 0000000aH
  00aa8	6a 14		 push	 20			; 00000014H
  00aaa	8b 85 18 fd ff
	ff		 mov	 eax, DWORD PTR $T64620[ebp]
  00ab0	50		 push	 eax
  00ab1	8d 8d 1c fd ff
	ff		 lea	 ecx, DWORD PTR $T64619[ebp]
  00ab7	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z ; ResourceList::ResourceList
  00abc	50		 push	 eax
  00abd	b9 10 02 00 00	 mov	 ecx, OFFSET FLAT:_resources+528
  00ac2	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@ABU0@@Z ; ResourceList::ResourceList

; 137  : 	ResourceList(New ResVMD, VMDResListHandle, 10)
; 138  : };

  00ac7	68 0c 01 00 00	 push	 268			; 0000010cH
  00acc	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00ad1	83 c4 04	 add	 esp, 4
  00ad4	89 85 f4 fc ff
	ff		 mov	 DWORD PTR $T64626[ebp], eax
  00ada	c7 45 fc 17 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 23 ; 00000017H
  00ae1	83 bd f4 fc ff
	ff 00		 cmp	 DWORD PTR $T64626[ebp], 0
  00ae8	74 13		 je	 SHORT $L64627
  00aea	8b 8d f4 fc ff
	ff		 mov	 ecx, DWORD PTR $T64626[ebp]
  00af0	e8 00 00 00 00	 call	 ??0ResVMD@@QAE@XZ	; ResVMD::ResVMD
  00af5	89 85 94 fc ff
	ff		 mov	 DWORD PTR -876+[ebp], eax
  00afb	eb 0a		 jmp	 SHORT $L64628
$L64627:
  00afd	c7 85 94 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR -876+[ebp], 0
$L64628:
  00b07	8b 8d 94 fc ff
	ff		 mov	 ecx, DWORD PTR -876+[ebp]
  00b0d	89 8d f8 fc ff
	ff		 mov	 DWORD PTR $T64625[ebp], ecx
  00b13	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00b1a	6a 0a		 push	 10			; 0000000aH
  00b1c	6a 15		 push	 21			; 00000015H
  00b1e	8b 95 f8 fc ff
	ff		 mov	 edx, DWORD PTR $T64625[ebp]
  00b24	52		 push	 edx
  00b25	8d 8d fc fc ff
	ff		 lea	 ecx, DWORD PTR $T64624[ebp]
  00b2b	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z ; ResourceList::ResourceList
  00b30	50		 push	 eax
  00b31	b9 28 02 00 00	 mov	 ecx, OFFSET FLAT:_resources+552
  00b36	e8 00 00 00 00	 call	 ??0ResourceList@@QAE@ABU0@@Z ; ResourceList::ResourceList
  00b3b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00b3e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00b45	8b e5		 mov	 esp, ebp
  00b47	5d		 pop	 ebp
  00b48	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L64629:
  00000	8b 45 d4	 mov	 eax, DWORD PTR $T64511[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
$L64630:
  0000b	8b 45 b4	 mov	 eax, DWORD PTR $T64516[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
$L64631:
  00016	8b 45 94	 mov	 eax, DWORD PTR $T64521[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001f	59		 pop	 ecx
  00020	c3		 ret	 0
$L64632:
  00021	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR $T64526[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002d	59		 pop	 ecx
  0002e	c3		 ret	 0
$L64633:
  0002f	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR $T64531[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003b	59		 pop	 ecx
  0003c	c3		 ret	 0
$L64634:
  0003d	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR $T64536[ebp]
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00049	59		 pop	 ecx
  0004a	c3		 ret	 0
$L64635:
  0004b	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR $T64541[ebp]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00057	59		 pop	 ecx
  00058	c3		 ret	 0
$L64636:
  00059	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR $T64546[ebp]
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00065	59		 pop	 ecx
  00066	c3		 ret	 0
$L64637:
  00067	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR $T64551[ebp]
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00073	59		 pop	 ecx
  00074	c3		 ret	 0
$L64638:
  00075	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR $T64556[ebp]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00081	59		 pop	 ecx
  00082	c3		 ret	 0
$L64639:
  00083	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR $T64561[ebp]
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008f	59		 pop	 ecx
  00090	c3		 ret	 0
$L64640:
  00091	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR $T64566[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0009d	59		 pop	 ecx
  0009e	c3		 ret	 0
$L64641:
  0009f	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR $T64571[ebp]
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000ab	59		 pop	 ecx
  000ac	c3		 ret	 0
$L64642:
  000ad	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR $T64576[ebp]
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000b9	59		 pop	 ecx
  000ba	c3		 ret	 0
$L64643:
  000bb	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR $T64581[ebp]
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000c7	59		 pop	 ecx
  000c8	c3		 ret	 0
$L64644:
  000c9	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR $T64586[ebp]
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000d5	59		 pop	 ecx
  000d6	c3		 ret	 0
$L64645:
  000d7	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR $T64591[ebp]
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000e3	59		 pop	 ecx
  000e4	c3		 ret	 0
$L64646:
  000e5	8b 85 b4 fd ff
	ff		 mov	 eax, DWORD PTR $T64596[ebp]
  000eb	50		 push	 eax
  000ec	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000f1	59		 pop	 ecx
  000f2	c3		 ret	 0
$L64647:
  000f3	8b 85 94 fd ff
	ff		 mov	 eax, DWORD PTR $T64601[ebp]
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000ff	59		 pop	 ecx
  00100	c3		 ret	 0
$L64648:
  00101	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR $T64606[ebp]
  00107	50		 push	 eax
  00108	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0010d	59		 pop	 ecx
  0010e	c3		 ret	 0
$L64649:
  0010f	8b 85 54 fd ff
	ff		 mov	 eax, DWORD PTR $T64611[ebp]
  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0011b	59		 pop	 ecx
  0011c	c3		 ret	 0
$L64650:
  0011d	8b 85 34 fd ff
	ff		 mov	 eax, DWORD PTR $T64616[ebp]
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00129	59		 pop	 ecx
  0012a	c3		 ret	 0
$L64651:
  0012b	8b 85 14 fd ff
	ff		 mov	 eax, DWORD PTR $T64621[ebp]
  00131	50		 push	 eax
  00132	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00137	59		 pop	 ecx
  00138	c3		 ret	 0
$L64652:
  00139	8b 85 f4 fc ff
	ff		 mov	 eax, DWORD PTR $T64626[ebp]
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00145	59		 pop	 ecx
  00146	c3		 ret	 0
$L64657:
  00147	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T64656
  0014c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
_$E28	ENDP
PUBLIC	?GetExtension@SOL_ResType@@UBEPBDXZ		; SOL_ResType::GetExtension
PUBLIC	?IsSupported@SOL_ResType@@UBEHXZ		; SOL_ResType::IsSupported
PUBLIC	?GetAttrs@SOL_ResType@@UBEIXZ			; SOL_ResType::GetAttrs
PUBLIC	?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ	; SOL_ResType::GetFileType
PUBLIC	?GetType@ResView@@UBE?AW4MemType@@XZ		; ResView::GetType
PUBLIC	??_7ResView@@6B@				; ResView::`vftable'
PUBLIC	??_C@_07CCG@ResView?$AA@			; `string'
PUBLIC	??_C@_04KCEF@?4v56?$AA@				; `string'
EXTRN	?Check@SOL_ResType@@UAEHG@Z:NEAR		; SOL_ResType::Check
EXTRN	?Close@SOL_ResType@@UBEHH@Z:NEAR		; SOL_ResType::Close
EXTRN	?Load@SOL_ResType@@UAEXAAUResTag@@H@Z:NEAR	; SOL_ResType::Load
EXTRN	?MakeName@SOL_ResType@@UBEXPAD0G@Z:NEAR		; SOL_ResType::MakeName
EXTRN	?MakeWildName@SOL_ResType@@UBEXPAD0@Z:NEAR	; SOL_ResType::MakeWildName
EXTRN	?Open@SOL_ResType@@UAEHGPAD@Z:NEAR		; SOL_ResType::Open
EXTRN	?FindDirEntry@SOL_ResType@@UBEHGPAH@Z:NEAR	; SOL_ResType::FindDirEntry
EXTRN	?FindPatchEntry@SOL_ResType@@UBEHG@Z:NEAR	; SOL_ResType::FindPatchEntry
EXTRN	?CheckPatches@SOL_ResType@@UBEHG@Z:NEAR		; SOL_ResType::CheckPatches
EXTRN	?ConfirmType@SOL_ResType@@MBEXW4MemType@@@Z:NEAR ; SOL_ResType::ConfirmType
EXTRN	?Decompress@SOL_ResType@@MBEXAAUResTag@@@Z:NEAR	; SOL_ResType::Decompress
EXTRN	?FindPatch36Entry@SOL_ResType@@MBEHPAD@Z:NEAR	; SOL_ResType::FindPatch36Entry
EXTRN	?GetFileSize@SOL_ResType@@MBEJXZ:NEAR		; SOL_ResType::GetFileSize
EXTRN	?MakeName@SOL_ResType@@MBEXPAD00@Z:NEAR		; SOL_ResType::MakeName
EXTRN	?Read@SOL_ResType@@MBEHPAXH@Z:NEAR		; SOL_ResType::Read
EXTRN	?SeekToData@ResView@@MBEHXZ:NEAR		; ResView::SeekToData
;	COMDAT ??_7ResView@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\restype.hpp
CONST	SEGMENT
??_7ResView@@6B@ DD FLAT:?Check@SOL_ResType@@UAEHG@Z	; ResView::`vftable'
	DD	FLAT:?Close@SOL_ResType@@UBEHH@Z
	DD	FLAT:?GetExtension@SOL_ResType@@UBEPBDXZ
	DD	FLAT:?IsSupported@SOL_ResType@@UBEHXZ
	DD	FLAT:?Load@SOL_ResType@@UAEXAAUResTag@@H@Z
	DD	FLAT:?MakeName@SOL_ResType@@MBEXPAD00@Z
	DD	FLAT:?MakeName@SOL_ResType@@UBEXPAD0G@Z
	DD	FLAT:?MakeWildName@SOL_ResType@@UBEXPAD0@Z
	DD	FLAT:?Open@SOL_ResType@@UAEHGPAD@Z
	DD	FLAT:?FindDirEntry@SOL_ResType@@UBEHGPAH@Z
	DD	FLAT:?FindPatchEntry@SOL_ResType@@UBEHG@Z
	DD	FLAT:?CheckPatches@SOL_ResType@@UBEHG@Z
	DD	FLAT:?GetType@ResView@@UBE?AW4MemType@@XZ
	DD	FLAT:?GetAttrs@SOL_ResType@@UBEIXZ
	DD	FLAT:?ConfirmType@SOL_ResType@@MBEXW4MemType@@@Z
	DD	FLAT:?Decompress@SOL_ResType@@MBEXAAUResTag@@@Z
	DD	FLAT:?FindPatch36Entry@SOL_ResType@@MBEHPAD@Z
	DD	FLAT:?GetFileSize@SOL_ResType@@MBEJXZ
	DD	FLAT:?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
	DD	FLAT:?Read@SOL_ResType@@MBEHPAXH@Z
	DD	FLAT:?SeekToData@ResView@@MBEHXZ
CONST	ENDS
;	COMDAT ??_C@_07CCG@ResView?$AA@
_DATA	SEGMENT
??_C@_07CCG@ResView?$AA@ DB 'ResView', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04KCEF@?4v56?$AA@
_DATA	SEGMENT
??_C@_04KCEF@?4v56?$AA@ DB '.v56', 00H			; `string'
_DATA	ENDS
;	COMDAT ??0ResView@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0ResView@@QAE@XZ PROC NEAR				; ResView::ResView, COMDAT

; 69   : 	ResView() : SOL_ResType(".v56", "ResView")  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CCG@ResView?$AA@ ; `string'
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04KCEF@?4v56?$AA@ ; `string'
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0SOL_ResType@@QAE@PAD0@Z ; SOL_ResType::SOL_ResType
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ResView@@6B@ ; ResView::`vftable'
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0ResView@@QAE@XZ ENDP					; ResView::ResView
_TEXT	ENDS
;	COMDAT ?GetExtension@SOL_ResType@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetExtension@SOL_ResType@@UBEPBDXZ PROC NEAR		; SOL_ResType::GetExtension, COMDAT

; 34   : 	virtual const char*	GetExtension() const 	{ return ext; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetExtension@SOL_ResType@@UBEPBDXZ ENDP		; SOL_ResType::GetExtension
_TEXT	ENDS
;	COMDAT ?IsSupported@SOL_ResType@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsSupported@SOL_ResType@@UBEHXZ PROC NEAR		; SOL_ResType::IsSupported, COMDAT

; 35   : 	virtual Bool			IsSupported() const		{ return *ext != 0; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f be 40 04	 movsx	 eax, BYTE PTR [eax+4]
  0000e	f7 d8		 neg	 eax
  00010	1b c0		 sbb	 eax, eax
  00012	f7 d8		 neg	 eax
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?IsSupported@SOL_ResType@@UBEHXZ ENDP			; SOL_ResType::IsSupported
_TEXT	ENDS
;	COMDAT ?GetAttrs@SOL_ResType@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetAttrs@SOL_ResType@@UBEIXZ PROC NEAR			; SOL_ResType::GetAttrs, COMDAT

; 46   : 								{ return DISCARDABLE | MOVEABLE | CHECKSUMMABLE; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b8 00 86 00 00	 mov	 eax, 34304		; 00008600H
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetAttrs@SOL_ResType@@UBEIXZ ENDP			; SOL_ResType::GetAttrs
_TEXT	ENDS
;	COMDAT ?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ PROC NEAR	; SOL_ResType::GetFileType, COMDAT

; 53   : 	virtual MemType		GetFileType() const 		{ return GetType(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 10		 mov	 edx, DWORD PTR [eax]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	ff 52 30	 call	 DWORD PTR [edx+48]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ ENDP	; SOL_ResType::GetFileType
_TEXT	ENDS
;	COMDAT ?GetType@ResView@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetType@ResView@@UBE?AW4MemType@@XZ PROC NEAR		; ResView::GetType, COMDAT

; 70   : 	MemType	GetType() const {return MemResView;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	33 c0		 xor	 eax, eax
  00009	8b e5		 mov	 esp, ebp
  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?GetType@ResView@@UBE?AW4MemType@@XZ ENDP		; ResView::GetType
_TEXT	ENDS
PUBLIC	?GetType@ResPic@@UBE?AW4MemType@@XZ		; ResPic::GetType
PUBLIC	??_7ResPic@@6B@					; ResPic::`vftable'
PUBLIC	??_C@_06IAEF@ResPic?$AA@			; `string'
PUBLIC	??_C@_04EODC@?4p56?$AA@				; `string'
EXTRN	?SeekToData@ResPic@@MBEHXZ:NEAR			; ResPic::SeekToData
;	COMDAT ??_7ResPic@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\restype.hpp
CONST	SEGMENT
??_7ResPic@@6B@ DD FLAT:?Check@SOL_ResType@@UAEHG@Z	; ResPic::`vftable'
	DD	FLAT:?Close@SOL_ResType@@UBEHH@Z
	DD	FLAT:?GetExtension@SOL_ResType@@UBEPBDXZ
	DD	FLAT:?IsSupported@SOL_ResType@@UBEHXZ
	DD	FLAT:?Load@SOL_ResType@@UAEXAAUResTag@@H@Z
	DD	FLAT:?MakeName@SOL_ResType@@MBEXPAD00@Z
	DD	FLAT:?MakeName@SOL_ResType@@UBEXPAD0G@Z
	DD	FLAT:?MakeWildName@SOL_ResType@@UBEXPAD0@Z
	DD	FLAT:?Open@SOL_ResType@@UAEHGPAD@Z
	DD	FLAT:?FindDirEntry@SOL_ResType@@UBEHGPAH@Z
	DD	FLAT:?FindPatchEntry@SOL_ResType@@UBEHG@Z
	DD	FLAT:?CheckPatches@SOL_ResType@@UBEHG@Z
	DD	FLAT:?GetType@ResPic@@UBE?AW4MemType@@XZ
	DD	FLAT:?GetAttrs@SOL_ResType@@UBEIXZ
	DD	FLAT:?ConfirmType@SOL_ResType@@MBEXW4MemType@@@Z
	DD	FLAT:?Decompress@SOL_ResType@@MBEXAAUResTag@@@Z
	DD	FLAT:?FindPatch36Entry@SOL_ResType@@MBEHPAD@Z
	DD	FLAT:?GetFileSize@SOL_ResType@@MBEJXZ
	DD	FLAT:?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
	DD	FLAT:?Read@SOL_ResType@@MBEHPAXH@Z
	DD	FLAT:?SeekToData@ResPic@@MBEHXZ
CONST	ENDS
;	COMDAT ??_C@_06IAEF@ResPic?$AA@
_DATA	SEGMENT
??_C@_06IAEF@ResPic?$AA@ DB 'ResPic', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04EODC@?4p56?$AA@
_DATA	SEGMENT
??_C@_04EODC@?4p56?$AA@ DB '.p56', 00H			; `string'
_DATA	ENDS
;	COMDAT ??0ResPic@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0ResPic@@QAE@XZ PROC NEAR				; ResPic::ResPic, COMDAT

; 77   : 	ResPic() : SOL_ResType(".p56", "ResPic")  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06IAEF@ResPic?$AA@ ; `string'
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04EODC@?4p56?$AA@ ; `string'
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0SOL_ResType@@QAE@PAD0@Z ; SOL_ResType::SOL_ResType
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ResPic@@6B@ ; ResPic::`vftable'
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0ResPic@@QAE@XZ ENDP					; ResPic::ResPic
_TEXT	ENDS
;	COMDAT ?GetType@ResPic@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetType@ResPic@@UBE?AW4MemType@@XZ PROC NEAR		; ResPic::GetType, COMDAT

; 78   : 	MemType GetType() const {return MemResPic;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b8 01 00 00 00	 mov	 eax, 1
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetType@ResPic@@UBE?AW4MemType@@XZ ENDP		; ResPic::GetType
_TEXT	ENDS
PUBLIC	?GetType@ResChunk@@UBE?AW4MemType@@XZ		; ResChunk::GetType
PUBLIC	??_7ResChunk@@6B@				; ResChunk::`vftable'
PUBLIC	??_C@_08OCKJ@ResChunk?$AA@			; `string'
PUBLIC	??_C@_04PIPI@?4chk?$AA@				; `string'
EXTRN	?SeekToData@SOL_ResType@@MBEHXZ:NEAR		; SOL_ResType::SeekToData
;	COMDAT ??_7ResChunk@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\restype.hpp
CONST	SEGMENT
??_7ResChunk@@6B@ DD FLAT:?Check@SOL_ResType@@UAEHG@Z	; ResChunk::`vftable'
	DD	FLAT:?Close@SOL_ResType@@UBEHH@Z
	DD	FLAT:?GetExtension@SOL_ResType@@UBEPBDXZ
	DD	FLAT:?IsSupported@SOL_ResType@@UBEHXZ
	DD	FLAT:?Load@SOL_ResType@@UAEXAAUResTag@@H@Z
	DD	FLAT:?MakeName@SOL_ResType@@MBEXPAD00@Z
	DD	FLAT:?MakeName@SOL_ResType@@UBEXPAD0G@Z
	DD	FLAT:?MakeWildName@SOL_ResType@@UBEXPAD0@Z
	DD	FLAT:?Open@SOL_ResType@@UAEHGPAD@Z
	DD	FLAT:?FindDirEntry@SOL_ResType@@UBEHGPAH@Z
	DD	FLAT:?FindPatchEntry@SOL_ResType@@UBEHG@Z
	DD	FLAT:?CheckPatches@SOL_ResType@@UBEHG@Z
	DD	FLAT:?GetType@ResChunk@@UBE?AW4MemType@@XZ
	DD	FLAT:?GetAttrs@SOL_ResType@@UBEIXZ
	DD	FLAT:?ConfirmType@SOL_ResType@@MBEXW4MemType@@@Z
	DD	FLAT:?Decompress@SOL_ResType@@MBEXAAUResTag@@@Z
	DD	FLAT:?FindPatch36Entry@SOL_ResType@@MBEHPAD@Z
	DD	FLAT:?GetFileSize@SOL_ResType@@MBEJXZ
	DD	FLAT:?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
	DD	FLAT:?Read@SOL_ResType@@MBEHPAXH@Z
	DD	FLAT:?SeekToData@SOL_ResType@@MBEHXZ
CONST	ENDS
;	COMDAT ??_C@_08OCKJ@ResChunk?$AA@
_DATA	SEGMENT
??_C@_08OCKJ@ResChunk?$AA@ DB 'ResChunk', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04PIPI@?4chk?$AA@
_DATA	SEGMENT
??_C@_04PIPI@?4chk?$AA@ DB '.chk', 00H			; `string'
_DATA	ENDS
;	COMDAT ??0ResChunk@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0ResChunk@@QAE@XZ PROC NEAR				; ResChunk::ResChunk, COMDAT

; 84   : 	ResChunk() : SOL_ResType(".chk", "ResChunk")  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08OCKJ@ResChunk?$AA@ ; `string'
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04PIPI@?4chk?$AA@ ; `string'
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0SOL_ResType@@QAE@PAD0@Z ; SOL_ResType::SOL_ResType
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ResChunk@@6B@ ; ResChunk::`vftable'
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0ResChunk@@QAE@XZ ENDP				; ResChunk::ResChunk
_TEXT	ENDS
;	COMDAT ?GetType@ResChunk@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetType@ResChunk@@UBE?AW4MemType@@XZ PROC NEAR		; ResChunk::GetType, COMDAT

; 88   : 	MemType GetType() const			{return MemResChunk;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b8 12 00 00 00	 mov	 eax, 18			; 00000012H
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetType@ResChunk@@UBE?AW4MemType@@XZ ENDP		; ResChunk::GetType
_TEXT	ENDS
PUBLIC	?GetType@ResScript@@UBE?AW4MemType@@XZ		; ResScript::GetType
PUBLIC	??_7ResScript@@6B@				; ResScript::`vftable'
PUBLIC	??_C@_07ICMB@ResHunk?$AA@			; `string'
PUBLIC	??_C@_04GG@?4scr?$AA@				; `string'
;	COMDAT ??_7ResScript@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\restype.hpp
CONST	SEGMENT
??_7ResScript@@6B@ DD FLAT:?Check@SOL_ResType@@UAEHG@Z	; ResScript::`vftable'
	DD	FLAT:?Close@SOL_ResType@@UBEHH@Z
	DD	FLAT:?GetExtension@SOL_ResType@@UBEPBDXZ
	DD	FLAT:?IsSupported@SOL_ResType@@UBEHXZ
	DD	FLAT:?Load@SOL_ResType@@UAEXAAUResTag@@H@Z
	DD	FLAT:?MakeName@SOL_ResType@@MBEXPAD00@Z
	DD	FLAT:?MakeName@SOL_ResType@@UBEXPAD0G@Z
	DD	FLAT:?MakeWildName@SOL_ResType@@UBEXPAD0@Z
	DD	FLAT:?Open@SOL_ResType@@UAEHGPAD@Z
	DD	FLAT:?FindDirEntry@SOL_ResType@@UBEHGPAH@Z
	DD	FLAT:?FindPatchEntry@SOL_ResType@@UBEHG@Z
	DD	FLAT:?CheckPatches@SOL_ResType@@UBEHG@Z
	DD	FLAT:?GetType@ResScript@@UBE?AW4MemType@@XZ
	DD	FLAT:?GetAttrs@SOL_ResType@@UBEIXZ
	DD	FLAT:?ConfirmType@SOL_ResType@@MBEXW4MemType@@@Z
	DD	FLAT:?Decompress@SOL_ResType@@MBEXAAUResTag@@@Z
	DD	FLAT:?FindPatch36Entry@SOL_ResType@@MBEHPAD@Z
	DD	FLAT:?GetFileSize@SOL_ResType@@MBEJXZ
	DD	FLAT:?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
	DD	FLAT:?Read@SOL_ResType@@MBEHPAXH@Z
	DD	FLAT:?SeekToData@SOL_ResType@@MBEHXZ
CONST	ENDS
;	COMDAT ??_C@_07ICMB@ResHunk?$AA@
_DATA	SEGMENT
??_C@_07ICMB@ResHunk?$AA@ DB 'ResHunk', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04GG@?4scr?$AA@
_DATA	SEGMENT
??_C@_04GG@?4scr?$AA@ DB '.scr', 00H			; `string'
_DATA	ENDS
;	COMDAT ??0ResScript@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0ResScript@@QAE@XZ PROC NEAR				; ResScript::ResScript, COMDAT

; 93   : 	ResScript() : SOL_ResType(".scr", "ResHunk")  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07ICMB@ResHunk?$AA@ ; `string'
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04GG@?4scr?$AA@ ; `string'
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0SOL_ResType@@QAE@PAD0@Z ; SOL_ResType::SOL_ResType
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ResScript@@6B@ ; ResScript::`vftable'
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0ResScript@@QAE@XZ ENDP				; ResScript::ResScript
_TEXT	ENDS
;	COMDAT ?GetType@ResScript@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetType@ResScript@@UBE?AW4MemType@@XZ PROC NEAR	; ResScript::GetType, COMDAT

; 94   : 	MemType GetType() const			{return MemResHunk;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b8 02 00 00 00	 mov	 eax, 2
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetType@ResScript@@UBE?AW4MemType@@XZ ENDP		; ResScript::GetType
_TEXT	ENDS
PUBLIC	?GetType@ResSound@@UBE?AW4MemType@@XZ		; ResSound::GetType
PUBLIC	??_7ResSound@@6B@				; ResSound::`vftable'
PUBLIC	??_C@_08BLBP@ResSound?$AA@			; `string'
PUBLIC	??_C@_04KPDA@?4snd?$AA@				; `string'
;	COMDAT ??_7ResSound@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\restype.hpp
CONST	SEGMENT
??_7ResSound@@6B@ DD FLAT:?Check@SOL_ResType@@UAEHG@Z	; ResSound::`vftable'
	DD	FLAT:?Close@SOL_ResType@@UBEHH@Z
	DD	FLAT:?GetExtension@SOL_ResType@@UBEPBDXZ
	DD	FLAT:?IsSupported@SOL_ResType@@UBEHXZ
	DD	FLAT:?Load@SOL_ResType@@UAEXAAUResTag@@H@Z
	DD	FLAT:?MakeName@SOL_ResType@@MBEXPAD00@Z
	DD	FLAT:?MakeName@SOL_ResType@@UBEXPAD0G@Z
	DD	FLAT:?MakeWildName@SOL_ResType@@UBEXPAD0@Z
	DD	FLAT:?Open@SOL_ResType@@UAEHGPAD@Z
	DD	FLAT:?FindDirEntry@SOL_ResType@@UBEHGPAH@Z
	DD	FLAT:?FindPatchEntry@SOL_ResType@@UBEHG@Z
	DD	FLAT:?CheckPatches@SOL_ResType@@UBEHG@Z
	DD	FLAT:?GetType@ResSound@@UBE?AW4MemType@@XZ
	DD	FLAT:?GetAttrs@SOL_ResType@@UBEIXZ
	DD	FLAT:?ConfirmType@SOL_ResType@@MBEXW4MemType@@@Z
	DD	FLAT:?Decompress@SOL_ResType@@MBEXAAUResTag@@@Z
	DD	FLAT:?FindPatch36Entry@SOL_ResType@@MBEHPAD@Z
	DD	FLAT:?GetFileSize@SOL_ResType@@MBEJXZ
	DD	FLAT:?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
	DD	FLAT:?Read@SOL_ResType@@MBEHPAXH@Z
	DD	FLAT:?SeekToData@SOL_ResType@@MBEHXZ
CONST	ENDS
;	COMDAT ??_C@_08BLBP@ResSound?$AA@
_DATA	SEGMENT
??_C@_08BLBP@ResSound?$AA@ DB 'ResSound', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04KPDA@?4snd?$AA@
_DATA	SEGMENT
??_C@_04KPDA@?4snd?$AA@ DB '.snd', 00H			; `string'
_DATA	ENDS
;	COMDAT ??0ResSound@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0ResSound@@QAE@XZ PROC NEAR				; ResSound::ResSound, COMDAT

; 98   : 	ResSound() : SOL_ResType(".snd", "ResSound")  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08BLBP@ResSound?$AA@ ; `string'
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04KPDA@?4snd?$AA@ ; `string'
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0SOL_ResType@@QAE@PAD0@Z ; SOL_ResType::SOL_ResType
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ResSound@@6B@ ; ResSound::`vftable'
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0ResSound@@QAE@XZ ENDP				; ResSound::ResSound
_TEXT	ENDS
;	COMDAT ?GetType@ResSound@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetType@ResSound@@UBE?AW4MemType@@XZ PROC NEAR		; ResSound::GetType, COMDAT

; 99   : 	MemType GetType() const 	{return MemResSound;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b8 04 00 00 00	 mov	 eax, 4
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetType@ResSound@@UBE?AW4MemType@@XZ ENDP		; ResSound::GetType
_TEXT	ENDS
PUBLIC	?GetType@ResVocab@@UBE?AW4MemType@@XZ		; ResVocab::GetType
PUBLIC	??_7ResVocab@@6B@				; ResVocab::`vftable'
PUBLIC	??_C@_08NNMB@ResVocab?$AA@			; `string'
PUBLIC	??_C@_04PGDD@?4voc?$AA@				; `string'
;	COMDAT ??_7ResVocab@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\restype.hpp
CONST	SEGMENT
??_7ResVocab@@6B@ DD FLAT:?Check@SOL_ResType@@UAEHG@Z	; ResVocab::`vftable'
	DD	FLAT:?Close@SOL_ResType@@UBEHH@Z
	DD	FLAT:?GetExtension@SOL_ResType@@UBEPBDXZ
	DD	FLAT:?IsSupported@SOL_ResType@@UBEHXZ
	DD	FLAT:?Load@SOL_ResType@@UAEXAAUResTag@@H@Z
	DD	FLAT:?MakeName@SOL_ResType@@MBEXPAD00@Z
	DD	FLAT:?MakeName@SOL_ResType@@UBEXPAD0G@Z
	DD	FLAT:?MakeWildName@SOL_ResType@@UBEXPAD0@Z
	DD	FLAT:?Open@SOL_ResType@@UAEHGPAD@Z
	DD	FLAT:?FindDirEntry@SOL_ResType@@UBEHGPAH@Z
	DD	FLAT:?FindPatchEntry@SOL_ResType@@UBEHG@Z
	DD	FLAT:?CheckPatches@SOL_ResType@@UBEHG@Z
	DD	FLAT:?GetType@ResVocab@@UBE?AW4MemType@@XZ
	DD	FLAT:?GetAttrs@SOL_ResType@@UBEIXZ
	DD	FLAT:?ConfirmType@SOL_ResType@@MBEXW4MemType@@@Z
	DD	FLAT:?Decompress@SOL_ResType@@MBEXAAUResTag@@@Z
	DD	FLAT:?FindPatch36Entry@SOL_ResType@@MBEHPAD@Z
	DD	FLAT:?GetFileSize@SOL_ResType@@MBEJXZ
	DD	FLAT:?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
	DD	FLAT:?Read@SOL_ResType@@MBEHPAXH@Z
	DD	FLAT:?SeekToData@SOL_ResType@@MBEHXZ
CONST	ENDS
;	COMDAT ??_C@_08NNMB@ResVocab?$AA@
_DATA	SEGMENT
??_C@_08NNMB@ResVocab?$AA@ DB 'ResVocab', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04PGDD@?4voc?$AA@
_DATA	SEGMENT
??_C@_04PGDD@?4voc?$AA@ DB '.voc', 00H			; `string'
_DATA	ENDS
;	COMDAT ??0ResVocab@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0ResVocab@@QAE@XZ PROC NEAR				; ResVocab::ResVocab, COMDAT

; 103  : 	ResVocab() : SOL_ResType(".voc", "ResVocab")  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08NNMB@ResVocab?$AA@ ; `string'
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04PGDD@?4voc?$AA@ ; `string'
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0SOL_ResType@@QAE@PAD0@Z ; SOL_ResType::SOL_ResType
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ResVocab@@6B@ ; ResVocab::`vftable'
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0ResVocab@@QAE@XZ ENDP				; ResVocab::ResVocab
_TEXT	ENDS
;	COMDAT ?GetType@ResVocab@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetType@ResVocab@@UBE?AW4MemType@@XZ PROC NEAR		; ResVocab::GetType, COMDAT

; 104  : 	MemType GetType() const		{ return MemResVocab; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b8 06 00 00 00	 mov	 eax, 6
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetType@ResVocab@@UBE?AW4MemType@@XZ ENDP		; ResVocab::GetType
_TEXT	ENDS
PUBLIC	?GetType@ResPatch@@UBE?AW4MemType@@XZ		; ResPatch::GetType
PUBLIC	??_7ResPatch@@6B@				; ResPatch::`vftable'
PUBLIC	??_C@_08FLKK@ResPatch?$AA@			; `string'
PUBLIC	??_C@_04CEHK@?4pat?$AA@				; `string'
;	COMDAT ??_7ResPatch@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\restype.hpp
CONST	SEGMENT
??_7ResPatch@@6B@ DD FLAT:?Check@SOL_ResType@@UAEHG@Z	; ResPatch::`vftable'
	DD	FLAT:?Close@SOL_ResType@@UBEHH@Z
	DD	FLAT:?GetExtension@SOL_ResType@@UBEPBDXZ
	DD	FLAT:?IsSupported@SOL_ResType@@UBEHXZ
	DD	FLAT:?Load@SOL_ResType@@UAEXAAUResTag@@H@Z
	DD	FLAT:?MakeName@SOL_ResType@@MBEXPAD00@Z
	DD	FLAT:?MakeName@SOL_ResType@@UBEXPAD0G@Z
	DD	FLAT:?MakeWildName@SOL_ResType@@UBEXPAD0@Z
	DD	FLAT:?Open@SOL_ResType@@UAEHGPAD@Z
	DD	FLAT:?FindDirEntry@SOL_ResType@@UBEHGPAH@Z
	DD	FLAT:?FindPatchEntry@SOL_ResType@@UBEHG@Z
	DD	FLAT:?CheckPatches@SOL_ResType@@UBEHG@Z
	DD	FLAT:?GetType@ResPatch@@UBE?AW4MemType@@XZ
	DD	FLAT:?GetAttrs@SOL_ResType@@UBEIXZ
	DD	FLAT:?ConfirmType@SOL_ResType@@MBEXW4MemType@@@Z
	DD	FLAT:?Decompress@SOL_ResType@@MBEXAAUResTag@@@Z
	DD	FLAT:?FindPatch36Entry@SOL_ResType@@MBEHPAD@Z
	DD	FLAT:?GetFileSize@SOL_ResType@@MBEJXZ
	DD	FLAT:?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
	DD	FLAT:?Read@SOL_ResType@@MBEHPAXH@Z
	DD	FLAT:?SeekToData@SOL_ResType@@MBEHXZ
CONST	ENDS
;	COMDAT ??_C@_08FLKK@ResPatch?$AA@
_DATA	SEGMENT
??_C@_08FLKK@ResPatch?$AA@ DB 'ResPatch', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04CEHK@?4pat?$AA@
_DATA	SEGMENT
??_C@_04CEHK@?4pat?$AA@ DB '.pat', 00H			; `string'
_DATA	ENDS
;	COMDAT ??0ResPatch@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0ResPatch@@QAE@XZ PROC NEAR				; ResPatch::ResPatch, COMDAT

; 108  : 	ResPatch() : SOL_ResType(".pat", "ResPatch")  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08FLKK@ResPatch?$AA@ ; `string'
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04CEHK@?4pat?$AA@ ; `string'
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0SOL_ResType@@QAE@PAD0@Z ; SOL_ResType::SOL_ResType
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ResPatch@@6B@ ; ResPatch::`vftable'
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0ResPatch@@QAE@XZ ENDP				; ResPatch::ResPatch
_TEXT	ENDS
;	COMDAT ?GetType@ResPatch@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetType@ResPatch@@UBE?AW4MemType@@XZ PROC NEAR		; ResPatch::GetType, COMDAT

; 109  : 	MemType GetType() const		{ return MemResPatch; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b8 09 00 00 00	 mov	 eax, 9
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetType@ResPatch@@UBE?AW4MemType@@XZ ENDP		; ResPatch::GetType
_TEXT	ENDS
PUBLIC	?GetType@ResFont@@UBE?AW4MemType@@XZ		; ResFont::GetType
PUBLIC	??_7ResFont@@6B@				; ResFont::`vftable'
PUBLIC	??_C@_07MKGC@ResFont?$AA@			; `string'
PUBLIC	??_C@_04IDCK@?4fon?$AA@				; `string'
;	COMDAT ??_7ResFont@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\restype.hpp
CONST	SEGMENT
??_7ResFont@@6B@ DD FLAT:?Check@SOL_ResType@@UAEHG@Z	; ResFont::`vftable'
	DD	FLAT:?Close@SOL_ResType@@UBEHH@Z
	DD	FLAT:?GetExtension@SOL_ResType@@UBEPBDXZ
	DD	FLAT:?IsSupported@SOL_ResType@@UBEHXZ
	DD	FLAT:?Load@SOL_ResType@@UAEXAAUResTag@@H@Z
	DD	FLAT:?MakeName@SOL_ResType@@MBEXPAD00@Z
	DD	FLAT:?MakeName@SOL_ResType@@UBEXPAD0G@Z
	DD	FLAT:?MakeWildName@SOL_ResType@@UBEXPAD0@Z
	DD	FLAT:?Open@SOL_ResType@@UAEHGPAD@Z
	DD	FLAT:?FindDirEntry@SOL_ResType@@UBEHGPAH@Z
	DD	FLAT:?FindPatchEntry@SOL_ResType@@UBEHG@Z
	DD	FLAT:?CheckPatches@SOL_ResType@@UBEHG@Z
	DD	FLAT:?GetType@ResFont@@UBE?AW4MemType@@XZ
	DD	FLAT:?GetAttrs@SOL_ResType@@UBEIXZ
	DD	FLAT:?ConfirmType@SOL_ResType@@MBEXW4MemType@@@Z
	DD	FLAT:?Decompress@SOL_ResType@@MBEXAAUResTag@@@Z
	DD	FLAT:?FindPatch36Entry@SOL_ResType@@MBEHPAD@Z
	DD	FLAT:?GetFileSize@SOL_ResType@@MBEJXZ
	DD	FLAT:?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
	DD	FLAT:?Read@SOL_ResType@@MBEHPAXH@Z
	DD	FLAT:?SeekToData@SOL_ResType@@MBEHXZ
CONST	ENDS
;	COMDAT ??_C@_07MKGC@ResFont?$AA@
_DATA	SEGMENT
??_C@_07MKGC@ResFont?$AA@ DB 'ResFont', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04IDCK@?4fon?$AA@
_DATA	SEGMENT
??_C@_04IDCK@?4fon?$AA@ DB '.fon', 00H			; `string'
_DATA	ENDS
;	COMDAT ??0ResFont@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0ResFont@@QAE@XZ PROC NEAR				; ResFont::ResFont, COMDAT

; 113  : 	ResFont() : SOL_ResType(".fon", "ResFont")  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07MKGC@ResFont?$AA@ ; `string'
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04IDCK@?4fon?$AA@ ; `string'
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0SOL_ResType@@QAE@PAD0@Z ; SOL_ResType::SOL_ResType
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ResFont@@6B@ ; ResFont::`vftable'
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0ResFont@@QAE@XZ ENDP					; ResFont::ResFont
_TEXT	ENDS
;	COMDAT ?GetType@ResFont@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetType@ResFont@@UBE?AW4MemType@@XZ PROC NEAR		; ResFont::GetType, COMDAT

; 114  : 	MemType GetType() const		{ return MemResFont; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b8 07 00 00 00	 mov	 eax, 7
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetType@ResFont@@UBE?AW4MemType@@XZ ENDP		; ResFont::GetType
_TEXT	ENDS
PUBLIC	?GetType@ResPal@@UBE?AW4MemType@@XZ		; ResPal::GetType
PUBLIC	??_7ResPal@@6B@					; ResPal::`vftable'
PUBLIC	??_C@_06DEEM@ResPal?$AA@			; `string'
PUBLIC	??_C@_04NJLC@?4pal?$AA@				; `string'
EXTRN	?SeekToData@ResPal@@MBEHXZ:NEAR			; ResPal::SeekToData
;	COMDAT ??_7ResPal@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\restype.hpp
CONST	SEGMENT
??_7ResPal@@6B@ DD FLAT:?Check@SOL_ResType@@UAEHG@Z	; ResPal::`vftable'
	DD	FLAT:?Close@SOL_ResType@@UBEHH@Z
	DD	FLAT:?GetExtension@SOL_ResType@@UBEPBDXZ
	DD	FLAT:?IsSupported@SOL_ResType@@UBEHXZ
	DD	FLAT:?Load@SOL_ResType@@UAEXAAUResTag@@H@Z
	DD	FLAT:?MakeName@SOL_ResType@@MBEXPAD00@Z
	DD	FLAT:?MakeName@SOL_ResType@@UBEXPAD0G@Z
	DD	FLAT:?MakeWildName@SOL_ResType@@UBEXPAD0@Z
	DD	FLAT:?Open@SOL_ResType@@UAEHGPAD@Z
	DD	FLAT:?FindDirEntry@SOL_ResType@@UBEHGPAH@Z
	DD	FLAT:?FindPatchEntry@SOL_ResType@@UBEHG@Z
	DD	FLAT:?CheckPatches@SOL_ResType@@UBEHG@Z
	DD	FLAT:?GetType@ResPal@@UBE?AW4MemType@@XZ
	DD	FLAT:?GetAttrs@SOL_ResType@@UBEIXZ
	DD	FLAT:?ConfirmType@SOL_ResType@@MBEXW4MemType@@@Z
	DD	FLAT:?Decompress@SOL_ResType@@MBEXAAUResTag@@@Z
	DD	FLAT:?FindPatch36Entry@SOL_ResType@@MBEHPAD@Z
	DD	FLAT:?GetFileSize@SOL_ResType@@MBEJXZ
	DD	FLAT:?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
	DD	FLAT:?Read@SOL_ResType@@MBEHPAXH@Z
	DD	FLAT:?SeekToData@ResPal@@MBEHXZ
CONST	ENDS
;	COMDAT ??_C@_06DEEM@ResPal?$AA@
_DATA	SEGMENT
??_C@_06DEEM@ResPal?$AA@ DB 'ResPal', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04NJLC@?4pal?$AA@
_DATA	SEGMENT
??_C@_04NJLC@?4pal?$AA@ DB '.pal', 00H			; `string'
_DATA	ENDS
;	COMDAT ??0ResPal@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0ResPal@@QAE@XZ PROC NEAR				; ResPal::ResPal, COMDAT

; 119  : 	ResPal() : SOL_ResType(".pal", "ResPal")  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06DEEM@ResPal?$AA@ ; `string'
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04NJLC@?4pal?$AA@ ; `string'
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0SOL_ResType@@QAE@PAD0@Z ; SOL_ResType::SOL_ResType
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ResPal@@6B@ ; ResPal::`vftable'
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0ResPal@@QAE@XZ ENDP					; ResPal::ResPal
_TEXT	ENDS
;	COMDAT ?GetType@ResPal@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetType@ResPal@@UBE?AW4MemType@@XZ PROC NEAR		; ResPal::GetType, COMDAT

; 120  : 	MemType	GetType() const		{ return MemResPalette; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetType@ResPal@@UBE?AW4MemType@@XZ ENDP		; ResPal::GetType
_TEXT	ENDS
PUBLIC	?GetType@ResHeap@@UBE?AW4MemType@@XZ		; ResHeap::GetType
PUBLIC	??_7ResHeap@@6B@				; ResHeap::`vftable'
PUBLIC	??_C@_07HFNL@ResHeap?$AA@			; `string'
PUBLIC	??_C@_04GFFD@?4hep?$AA@				; `string'
;	COMDAT ??_7ResHeap@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\restype.hpp
CONST	SEGMENT
??_7ResHeap@@6B@ DD FLAT:?Check@SOL_ResType@@UAEHG@Z	; ResHeap::`vftable'
	DD	FLAT:?Close@SOL_ResType@@UBEHH@Z
	DD	FLAT:?GetExtension@SOL_ResType@@UBEPBDXZ
	DD	FLAT:?IsSupported@SOL_ResType@@UBEHXZ
	DD	FLAT:?Load@SOL_ResType@@UAEXAAUResTag@@H@Z
	DD	FLAT:?MakeName@SOL_ResType@@MBEXPAD00@Z
	DD	FLAT:?MakeName@SOL_ResType@@UBEXPAD0G@Z
	DD	FLAT:?MakeWildName@SOL_ResType@@UBEXPAD0@Z
	DD	FLAT:?Open@SOL_ResType@@UAEHGPAD@Z
	DD	FLAT:?FindDirEntry@SOL_ResType@@UBEHGPAH@Z
	DD	FLAT:?FindPatchEntry@SOL_ResType@@UBEHG@Z
	DD	FLAT:?CheckPatches@SOL_ResType@@UBEHG@Z
	DD	FLAT:?GetType@ResHeap@@UBE?AW4MemType@@XZ
	DD	FLAT:?GetAttrs@SOL_ResType@@UBEIXZ
	DD	FLAT:?ConfirmType@SOL_ResType@@MBEXW4MemType@@@Z
	DD	FLAT:?Decompress@SOL_ResType@@MBEXAAUResTag@@@Z
	DD	FLAT:?FindPatch36Entry@SOL_ResType@@MBEHPAD@Z
	DD	FLAT:?GetFileSize@SOL_ResType@@MBEJXZ
	DD	FLAT:?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
	DD	FLAT:?Read@SOL_ResType@@MBEHPAXH@Z
	DD	FLAT:?SeekToData@SOL_ResType@@MBEHXZ
CONST	ENDS
;	COMDAT ??_C@_07HFNL@ResHeap?$AA@
_DATA	SEGMENT
??_C@_07HFNL@ResHeap?$AA@ DB 'ResHeap', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04GFFD@?4hep?$AA@
_DATA	SEGMENT
??_C@_04GFFD@?4hep?$AA@ DB '.hep', 00H			; `string'
_DATA	ENDS
;	COMDAT ??0ResHeap@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0ResHeap@@QAE@XZ PROC NEAR				; ResHeap::ResHeap, COMDAT

; 126  : 	ResHeap() : SOL_ResType(".hep", "ResHeap")  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07HFNL@ResHeap?$AA@ ; `string'
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04GFFD@?4hep?$AA@ ; `string'
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0SOL_ResType@@QAE@PAD0@Z ; SOL_ResType::SOL_ResType
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ResHeap@@6B@ ; ResHeap::`vftable'
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0ResHeap@@QAE@XZ ENDP					; ResHeap::ResHeap
_TEXT	ENDS
;	COMDAT ?GetType@ResHeap@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetType@ResHeap@@UBE?AW4MemType@@XZ PROC NEAR		; ResHeap::GetType, COMDAT

; 127  : 	MemType GetType() const 		{ return MemResHeap; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetType@ResHeap@@UBE?AW4MemType@@XZ ENDP		; ResHeap::GetType
_TEXT	ENDS
PUBLIC	?GetType@ResMsg@@UBE?AW4MemType@@XZ		; ResMsg::GetType
PUBLIC	??_7ResMsg@@6B@					; ResMsg::`vftable'
PUBLIC	??_C@_06HDCC@ResMsg?$AA@			; `string'
PUBLIC	??_C@_04JONM@?4msg?$AA@				; `string'
;	COMDAT ??_7ResMsg@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\restype.hpp
CONST	SEGMENT
??_7ResMsg@@6B@ DD FLAT:?Check@SOL_ResType@@UAEHG@Z	; ResMsg::`vftable'
	DD	FLAT:?Close@SOL_ResType@@UBEHH@Z
	DD	FLAT:?GetExtension@SOL_ResType@@UBEPBDXZ
	DD	FLAT:?IsSupported@SOL_ResType@@UBEHXZ
	DD	FLAT:?Load@SOL_ResType@@UAEXAAUResTag@@H@Z
	DD	FLAT:?MakeName@SOL_ResType@@MBEXPAD00@Z
	DD	FLAT:?MakeName@SOL_ResType@@UBEXPAD0G@Z
	DD	FLAT:?MakeWildName@SOL_ResType@@UBEXPAD0@Z
	DD	FLAT:?Open@SOL_ResType@@UAEHGPAD@Z
	DD	FLAT:?FindDirEntry@SOL_ResType@@UBEHGPAH@Z
	DD	FLAT:?FindPatchEntry@SOL_ResType@@UBEHG@Z
	DD	FLAT:?CheckPatches@SOL_ResType@@UBEHG@Z
	DD	FLAT:?GetType@ResMsg@@UBE?AW4MemType@@XZ
	DD	FLAT:?GetAttrs@SOL_ResType@@UBEIXZ
	DD	FLAT:?ConfirmType@SOL_ResType@@MBEXW4MemType@@@Z
	DD	FLAT:?Decompress@SOL_ResType@@MBEXAAUResTag@@@Z
	DD	FLAT:?FindPatch36Entry@SOL_ResType@@MBEHPAD@Z
	DD	FLAT:?GetFileSize@SOL_ResType@@MBEJXZ
	DD	FLAT:?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
	DD	FLAT:?Read@SOL_ResType@@MBEHPAXH@Z
	DD	FLAT:?SeekToData@SOL_ResType@@MBEHXZ
CONST	ENDS
;	COMDAT ??_C@_06HDCC@ResMsg?$AA@
_DATA	SEGMENT
??_C@_06HDCC@ResMsg?$AA@ DB 'ResMsg', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04JONM@?4msg?$AA@
_DATA	SEGMENT
??_C@_04JONM@?4msg?$AA@ DB '.msg', 00H			; `string'
_DATA	ENDS
;	COMDAT ??0ResMsg@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0ResMsg@@QAE@XZ PROC NEAR				; ResMsg::ResMsg, COMDAT

; 131  : 	ResMsg() : SOL_ResType(".msg", "ResMsg")  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06HDCC@ResMsg?$AA@ ; `string'
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04JONM@?4msg?$AA@ ; `string'
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0SOL_ResType@@QAE@PAD0@Z ; SOL_ResType::SOL_ResType
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ResMsg@@6B@ ; ResMsg::`vftable'
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0ResMsg@@QAE@XZ ENDP					; ResMsg::ResMsg
_TEXT	ENDS
;	COMDAT ?GetType@ResMsg@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetType@ResMsg@@UBE?AW4MemType@@XZ PROC NEAR		; ResMsg::GetType, COMDAT

; 132  : 	MemType GetType() const 		{ return MemResMsg; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetType@ResMsg@@UBE?AW4MemType@@XZ ENDP		; ResMsg::GetType
_TEXT	ENDS
PUBLIC	?GetType@ResAudio@@UBE?AW4MemType@@XZ		; ResAudio::GetType
PUBLIC	??_7ResAudio@@6B@				; ResAudio::`vftable'
PUBLIC	??_C@_08NFDN@ResAudio?$AA@			; `string'
PUBLIC	??_C@_04MOHF@?4aud?$AA@				; `string'
EXTRN	?SeekToData@ResAudio@@MBEHXZ:NEAR		; ResAudio::SeekToData
;	COMDAT ??_7ResAudio@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\restype.hpp
CONST	SEGMENT
??_7ResAudio@@6B@ DD FLAT:?Check@SOL_ResType@@UAEHG@Z	; ResAudio::`vftable'
	DD	FLAT:?Close@SOL_ResType@@UBEHH@Z
	DD	FLAT:?GetExtension@SOL_ResType@@UBEPBDXZ
	DD	FLAT:?IsSupported@SOL_ResType@@UBEHXZ
	DD	FLAT:?Load@SOL_ResType@@UAEXAAUResTag@@H@Z
	DD	FLAT:?MakeName@SOL_ResType@@MBEXPAD00@Z
	DD	FLAT:?MakeName@SOL_ResType@@UBEXPAD0G@Z
	DD	FLAT:?MakeWildName@SOL_ResType@@UBEXPAD0@Z
	DD	FLAT:?Open@SOL_ResType@@UAEHGPAD@Z
	DD	FLAT:?FindDirEntry@SOL_ResType@@UBEHGPAH@Z
	DD	FLAT:?FindPatchEntry@SOL_ResType@@UBEHG@Z
	DD	FLAT:?CheckPatches@SOL_ResType@@UBEHG@Z
	DD	FLAT:?GetType@ResAudio@@UBE?AW4MemType@@XZ
	DD	FLAT:?GetAttrs@SOL_ResType@@UBEIXZ
	DD	FLAT:?ConfirmType@SOL_ResType@@MBEXW4MemType@@@Z
	DD	FLAT:?Decompress@SOL_ResType@@MBEXAAUResTag@@@Z
	DD	FLAT:?FindPatch36Entry@SOL_ResType@@MBEHPAD@Z
	DD	FLAT:?GetFileSize@SOL_ResType@@MBEJXZ
	DD	FLAT:?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
	DD	FLAT:?Read@SOL_ResType@@MBEHPAXH@Z
	DD	FLAT:?SeekToData@ResAudio@@MBEHXZ
CONST	ENDS
;	COMDAT ??_C@_08NFDN@ResAudio?$AA@
_DATA	SEGMENT
??_C@_08NFDN@ResAudio?$AA@ DB 'ResAudio', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04MOHF@?4aud?$AA@
_DATA	SEGMENT
??_C@_04MOHF@?4aud?$AA@ DB '.aud', 00H			; `string'
_DATA	ENDS
;	COMDAT ??0ResAudio@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0ResAudio@@QAE@XZ PROC NEAR				; ResAudio::ResAudio, COMDAT

; 136  : 	ResAudio() : SOL_ResType(".aud", "ResAudio")  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08NFDN@ResAudio?$AA@ ; `string'
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04MOHF@?4aud?$AA@ ; `string'
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0SOL_ResType@@QAE@PAD0@Z ; SOL_ResType::SOL_ResType
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ResAudio@@6B@ ; ResAudio::`vftable'
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0ResAudio@@QAE@XZ ENDP				; ResAudio::ResAudio
_TEXT	ENDS
;	COMDAT ?GetType@ResAudio@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetType@ResAudio@@UBE?AW4MemType@@XZ PROC NEAR		; ResAudio::GetType, COMDAT

; 137  : 	MemType GetType() const 		{ return MemResAudio; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b8 0d 00 00 00	 mov	 eax, 13			; 0000000dH
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetType@ResAudio@@UBE?AW4MemType@@XZ ENDP		; ResAudio::GetType
_TEXT	ENDS
PUBLIC	?GetType@ResWave@@UBE?AW4MemType@@XZ		; ResWave::GetType
PUBLIC	??_7ResWave@@6B@				; ResWave::`vftable'
PUBLIC	??_C@_07BKMJ@ResWave?$AA@			; `string'
PUBLIC	??_C@_04MPDF@?4wav?$AA@				; `string'
EXTRN	?SeekToData@ResWave@@MBEHXZ:NEAR		; ResWave::SeekToData
;	COMDAT ??_7ResWave@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\restype.hpp
CONST	SEGMENT
??_7ResWave@@6B@ DD FLAT:?Check@SOL_ResType@@UAEHG@Z	; ResWave::`vftable'
	DD	FLAT:?Close@SOL_ResType@@UBEHH@Z
	DD	FLAT:?GetExtension@SOL_ResType@@UBEPBDXZ
	DD	FLAT:?IsSupported@SOL_ResType@@UBEHXZ
	DD	FLAT:?Load@SOL_ResType@@UAEXAAUResTag@@H@Z
	DD	FLAT:?MakeName@SOL_ResType@@MBEXPAD00@Z
	DD	FLAT:?MakeName@SOL_ResType@@UBEXPAD0G@Z
	DD	FLAT:?MakeWildName@SOL_ResType@@UBEXPAD0@Z
	DD	FLAT:?Open@SOL_ResType@@UAEHGPAD@Z
	DD	FLAT:?FindDirEntry@SOL_ResType@@UBEHGPAH@Z
	DD	FLAT:?FindPatchEntry@SOL_ResType@@UBEHG@Z
	DD	FLAT:?CheckPatches@SOL_ResType@@UBEHG@Z
	DD	FLAT:?GetType@ResWave@@UBE?AW4MemType@@XZ
	DD	FLAT:?GetAttrs@SOL_ResType@@UBEIXZ
	DD	FLAT:?ConfirmType@SOL_ResType@@MBEXW4MemType@@@Z
	DD	FLAT:?Decompress@SOL_ResType@@MBEXAAUResTag@@@Z
	DD	FLAT:?FindPatch36Entry@SOL_ResType@@MBEHPAD@Z
	DD	FLAT:?GetFileSize@SOL_ResType@@MBEJXZ
	DD	FLAT:?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
	DD	FLAT:?Read@SOL_ResType@@MBEHPAXH@Z
	DD	FLAT:?SeekToData@ResWave@@MBEHXZ
CONST	ENDS
;	COMDAT ??_C@_07BKMJ@ResWave?$AA@
_DATA	SEGMENT
??_C@_07BKMJ@ResWave?$AA@ DB 'ResWave', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04MPDF@?4wav?$AA@
_DATA	SEGMENT
??_C@_04MPDF@?4wav?$AA@ DB '.wav', 00H			; `string'
_DATA	ENDS
;	COMDAT ??0ResWave@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0ResWave@@QAE@XZ PROC NEAR				; ResWave::ResWave, COMDAT

; 143  : 	ResWave() : SOL_ResType(".wav", "ResWave")  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07BKMJ@ResWave?$AA@ ; `string'
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04MPDF@?4wav?$AA@ ; `string'
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0SOL_ResType@@QAE@PAD0@Z ; SOL_ResType::SOL_ResType
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ResWave@@6B@ ; ResWave::`vftable'
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0ResWave@@QAE@XZ ENDP					; ResWave::ResWave
_TEXT	ENDS
;	COMDAT ?GetType@ResWave@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetType@ResWave@@UBE?AW4MemType@@XZ PROC NEAR		; ResWave::GetType, COMDAT

; 144  : 	MemType GetType() const 		{ return MemResWAVE; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetType@ResWave@@UBE?AW4MemType@@XZ ENDP		; ResWave::GetType
_TEXT	ENDS
PUBLIC	??_C@_0L@IMEI@ResAudio36?$AA@			; `string'
PUBLIC	??_C@_00A@?$AA@					; `string'
PUBLIC	?GetType@ResAudio36@@UBE?AW4MemType@@XZ		; ResAudio36::GetType
PUBLIC	??_7ResAudio36@@6B@				; ResAudio36::`vftable'
EXTRN	?SeekToData@ResAudio36@@MBEHXZ:NEAR		; ResAudio36::SeekToData
;	COMDAT ??_C@_00A@?$AA@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\restype.hpp
_BSS	SEGMENT
??_C@_00A@?$AA@ DB 01H DUP (?)				; `string'
_BSS	ENDS
;	COMDAT ??_7ResAudio36@@6B@
CONST	SEGMENT
??_7ResAudio36@@6B@ DD FLAT:?Check@SOL_ResType@@UAEHG@Z	; ResAudio36::`vftable'
	DD	FLAT:?Close@SOL_ResType@@UBEHH@Z
	DD	FLAT:?GetExtension@SOL_ResType@@UBEPBDXZ
	DD	FLAT:?IsSupported@SOL_ResType@@UBEHXZ
	DD	FLAT:?Load@SOL_ResType@@UAEXAAUResTag@@H@Z
	DD	FLAT:?MakeName@SOL_ResType@@MBEXPAD00@Z
	DD	FLAT:?MakeName@SOL_ResType@@UBEXPAD0G@Z
	DD	FLAT:?MakeWildName@SOL_ResType@@UBEXPAD0@Z
	DD	FLAT:?Open@SOL_ResType@@UAEHGPAD@Z
	DD	FLAT:?FindDirEntry@SOL_ResType@@UBEHGPAH@Z
	DD	FLAT:?FindPatchEntry@SOL_ResType@@UBEHG@Z
	DD	FLAT:?CheckPatches@SOL_ResType@@UBEHG@Z
	DD	FLAT:?GetType@ResAudio36@@UBE?AW4MemType@@XZ
	DD	FLAT:?GetAttrs@SOL_ResType@@UBEIXZ
	DD	FLAT:?ConfirmType@SOL_ResType@@MBEXW4MemType@@@Z
	DD	FLAT:?Decompress@SOL_ResType@@MBEXAAUResTag@@@Z
	DD	FLAT:?FindPatch36Entry@SOL_ResType@@MBEHPAD@Z
	DD	FLAT:?GetFileSize@SOL_ResType@@MBEJXZ
	DD	FLAT:?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
	DD	FLAT:?Read@SOL_ResType@@MBEHPAXH@Z
	DD	FLAT:?SeekToData@ResAudio36@@MBEHXZ
CONST	ENDS
;	COMDAT ??_C@_0L@IMEI@ResAudio36?$AA@
_DATA	SEGMENT
??_C@_0L@IMEI@ResAudio36?$AA@ DB 'ResAudio36', 00H	; `string'
_DATA	ENDS
;	COMDAT ??0ResAudio36@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0ResAudio36@@QAE@XZ PROC NEAR				; ResAudio36::ResAudio36, COMDAT

; 150  : 	ResAudio36() : SOL_ResType("", "ResAudio36")  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@IMEI@ResAudio36?$AA@ ; `string'
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0SOL_ResType@@QAE@PAD0@Z ; SOL_ResType::SOL_ResType
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ResAudio36@@6B@ ; ResAudio36::`vftable'
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0ResAudio36@@QAE@XZ ENDP				; ResAudio36::ResAudio36
_TEXT	ENDS
;	COMDAT ?GetType@ResAudio36@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetType@ResAudio36@@UBE?AW4MemType@@XZ PROC NEAR	; ResAudio36::GetType, COMDAT

; 151  : 	MemType GetType() const 		{ return MemResAudio; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b8 0d 00 00 00	 mov	 eax, 13			; 0000000dH
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetType@ResAudio36@@UBE?AW4MemType@@XZ ENDP		; ResAudio36::GetType
_TEXT	ENDS
PUBLIC	?GetType@ResSync@@UBE?AW4MemType@@XZ		; ResSync::GetType
PUBLIC	??_7ResSync@@6B@				; ResSync::`vftable'
PUBLIC	??_C@_07BONB@ResSync?$AA@			; `string'
PUBLIC	??_C@_04KFFK@?4syn?$AA@				; `string'
;	COMDAT ??_7ResSync@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\restype.hpp
CONST	SEGMENT
??_7ResSync@@6B@ DD FLAT:?Check@SOL_ResType@@UAEHG@Z	; ResSync::`vftable'
	DD	FLAT:?Close@SOL_ResType@@UBEHH@Z
	DD	FLAT:?GetExtension@SOL_ResType@@UBEPBDXZ
	DD	FLAT:?IsSupported@SOL_ResType@@UBEHXZ
	DD	FLAT:?Load@SOL_ResType@@UAEXAAUResTag@@H@Z
	DD	FLAT:?MakeName@SOL_ResType@@MBEXPAD00@Z
	DD	FLAT:?MakeName@SOL_ResType@@UBEXPAD0G@Z
	DD	FLAT:?MakeWildName@SOL_ResType@@UBEXPAD0@Z
	DD	FLAT:?Open@SOL_ResType@@UAEHGPAD@Z
	DD	FLAT:?FindDirEntry@SOL_ResType@@UBEHGPAH@Z
	DD	FLAT:?FindPatchEntry@SOL_ResType@@UBEHG@Z
	DD	FLAT:?CheckPatches@SOL_ResType@@UBEHG@Z
	DD	FLAT:?GetType@ResSync@@UBE?AW4MemType@@XZ
	DD	FLAT:?GetAttrs@SOL_ResType@@UBEIXZ
	DD	FLAT:?ConfirmType@SOL_ResType@@MBEXW4MemType@@@Z
	DD	FLAT:?Decompress@SOL_ResType@@MBEXAAUResTag@@@Z
	DD	FLAT:?FindPatch36Entry@SOL_ResType@@MBEHPAD@Z
	DD	FLAT:?GetFileSize@SOL_ResType@@MBEJXZ
	DD	FLAT:?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
	DD	FLAT:?Read@SOL_ResType@@MBEHPAXH@Z
	DD	FLAT:?SeekToData@SOL_ResType@@MBEHXZ
CONST	ENDS
;	COMDAT ??_C@_07BONB@ResSync?$AA@
_DATA	SEGMENT
??_C@_07BONB@ResSync?$AA@ DB 'ResSync', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04KFFK@?4syn?$AA@
_DATA	SEGMENT
??_C@_04KFFK@?4syn?$AA@ DB '.syn', 00H			; `string'
_DATA	ENDS
;	COMDAT ??0ResSync@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0ResSync@@QAE@XZ PROC NEAR				; ResSync::ResSync, COMDAT

; 157  : 	ResSync() : SOL_ResType(".syn", "ResSync")  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07BONB@ResSync?$AA@ ; `string'
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04KFFK@?4syn?$AA@ ; `string'
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0SOL_ResType@@QAE@PAD0@Z ; SOL_ResType::SOL_ResType
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ResSync@@6B@ ; ResSync::`vftable'
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0ResSync@@QAE@XZ ENDP					; ResSync::ResSync
_TEXT	ENDS
;	COMDAT ?GetType@ResSync@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetType@ResSync@@UBE?AW4MemType@@XZ PROC NEAR		; ResSync::GetType, COMDAT

; 158  : 	MemType GetType() const 		{ return MemResSync; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetType@ResSync@@UBE?AW4MemType@@XZ ENDP		; ResSync::GetType
_TEXT	ENDS
PUBLIC	?GetType@ResSync36@@UBE?AW4MemType@@XZ		; ResSync36::GetType
PUBLIC	??_7ResSync36@@6B@				; ResSync36::`vftable'
PUBLIC	??_C@_09CBJE@ResSync36?$AA@			; `string'
;	COMDAT ??_7ResSync36@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\restype.hpp
CONST	SEGMENT
??_7ResSync36@@6B@ DD FLAT:?Check@SOL_ResType@@UAEHG@Z	; ResSync36::`vftable'
	DD	FLAT:?Close@SOL_ResType@@UBEHH@Z
	DD	FLAT:?GetExtension@SOL_ResType@@UBEPBDXZ
	DD	FLAT:?IsSupported@SOL_ResType@@UBEHXZ
	DD	FLAT:?Load@SOL_ResType@@UAEXAAUResTag@@H@Z
	DD	FLAT:?MakeName@SOL_ResType@@MBEXPAD00@Z
	DD	FLAT:?MakeName@SOL_ResType@@UBEXPAD0G@Z
	DD	FLAT:?MakeWildName@SOL_ResType@@UBEXPAD0@Z
	DD	FLAT:?Open@SOL_ResType@@UAEHGPAD@Z
	DD	FLAT:?FindDirEntry@SOL_ResType@@UBEHGPAH@Z
	DD	FLAT:?FindPatchEntry@SOL_ResType@@UBEHG@Z
	DD	FLAT:?CheckPatches@SOL_ResType@@UBEHG@Z
	DD	FLAT:?GetType@ResSync36@@UBE?AW4MemType@@XZ
	DD	FLAT:?GetAttrs@SOL_ResType@@UBEIXZ
	DD	FLAT:?ConfirmType@SOL_ResType@@MBEXW4MemType@@@Z
	DD	FLAT:?Decompress@SOL_ResType@@MBEXAAUResTag@@@Z
	DD	FLAT:?FindPatch36Entry@SOL_ResType@@MBEHPAD@Z
	DD	FLAT:?GetFileSize@SOL_ResType@@MBEJXZ
	DD	FLAT:?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
	DD	FLAT:?Read@SOL_ResType@@MBEHPAXH@Z
	DD	FLAT:?SeekToData@SOL_ResType@@MBEHXZ
CONST	ENDS
;	COMDAT ??_C@_09CBJE@ResSync36?$AA@
_DATA	SEGMENT
??_C@_09CBJE@ResSync36?$AA@ DB 'ResSync36', 00H		; `string'
_DATA	ENDS
;	COMDAT ??0ResSync36@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0ResSync36@@QAE@XZ PROC NEAR				; ResSync36::ResSync36, COMDAT

; 162  : 	ResSync36() : SOL_ResType("", "ResSync36")  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09CBJE@ResSync36?$AA@ ; `string'
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0SOL_ResType@@QAE@PAD0@Z ; SOL_ResType::SOL_ResType
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ResSync36@@6B@ ; ResSync36::`vftable'
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0ResSync36@@QAE@XZ ENDP				; ResSync36::ResSync36
_TEXT	ENDS
;	COMDAT ?GetType@ResSync36@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetType@ResSync36@@UBE?AW4MemType@@XZ PROC NEAR	; ResSync36::GetType, COMDAT

; 163  : 	MemType GetType() const 		{ return MemResSync; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetType@ResSync36@@UBE?AW4MemType@@XZ ENDP		; ResSync36::GetType
_TEXT	ENDS
PUBLIC	?GetType@ResMap@@UBE?AW4MemType@@XZ		; ResMap::GetType
PUBLIC	??_7ResMap@@6B@					; ResMap::`vftable'
PUBLIC	??_C@_06MIEL@ResMap?$AA@			; `string'
PUBLIC	??_C@_04CFLF@?4map?$AA@				; `string'
;	COMDAT ??_7ResMap@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\restype.hpp
CONST	SEGMENT
??_7ResMap@@6B@ DD FLAT:?Check@SOL_ResType@@UAEHG@Z	; ResMap::`vftable'
	DD	FLAT:?Close@SOL_ResType@@UBEHH@Z
	DD	FLAT:?GetExtension@SOL_ResType@@UBEPBDXZ
	DD	FLAT:?IsSupported@SOL_ResType@@UBEHXZ
	DD	FLAT:?Load@SOL_ResType@@UAEXAAUResTag@@H@Z
	DD	FLAT:?MakeName@SOL_ResType@@MBEXPAD00@Z
	DD	FLAT:?MakeName@SOL_ResType@@UBEXPAD0G@Z
	DD	FLAT:?MakeWildName@SOL_ResType@@UBEXPAD0@Z
	DD	FLAT:?Open@SOL_ResType@@UAEHGPAD@Z
	DD	FLAT:?FindDirEntry@SOL_ResType@@UBEHGPAH@Z
	DD	FLAT:?FindPatchEntry@SOL_ResType@@UBEHG@Z
	DD	FLAT:?CheckPatches@SOL_ResType@@UBEHG@Z
	DD	FLAT:?GetType@ResMap@@UBE?AW4MemType@@XZ
	DD	FLAT:?GetAttrs@SOL_ResType@@UBEIXZ
	DD	FLAT:?ConfirmType@SOL_ResType@@MBEXW4MemType@@@Z
	DD	FLAT:?Decompress@SOL_ResType@@MBEXAAUResTag@@@Z
	DD	FLAT:?FindPatch36Entry@SOL_ResType@@MBEHPAD@Z
	DD	FLAT:?GetFileSize@SOL_ResType@@MBEJXZ
	DD	FLAT:?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
	DD	FLAT:?Read@SOL_ResType@@MBEHPAXH@Z
	DD	FLAT:?SeekToData@SOL_ResType@@MBEHXZ
CONST	ENDS
;	COMDAT ??_C@_06MIEL@ResMap?$AA@
_DATA	SEGMENT
??_C@_06MIEL@ResMap?$AA@ DB 'ResMap', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04CFLF@?4map?$AA@
_DATA	SEGMENT
??_C@_04CFLF@?4map?$AA@ DB '.map', 00H			; `string'
_DATA	ENDS
;	COMDAT ??0ResMap@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0ResMap@@QAE@XZ PROC NEAR				; ResMap::ResMap, COMDAT

; 167  : 	ResMap() : SOL_ResType(".map", "ResMap")  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06MIEL@ResMap?$AA@ ; `string'
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04CFLF@?4map?$AA@ ; `string'
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0SOL_ResType@@QAE@PAD0@Z ; SOL_ResType::SOL_ResType
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ResMap@@6B@ ; ResMap::`vftable'
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0ResMap@@QAE@XZ ENDP					; ResMap::ResMap
_TEXT	ENDS
;	COMDAT ?GetType@ResMap@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetType@ResMap@@UBE?AW4MemType@@XZ PROC NEAR		; ResMap::GetType, COMDAT

; 168  : 	MemType GetType() const 		{ return MemResMap; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetType@ResMap@@UBE?AW4MemType@@XZ ENDP		; ResMap::GetType
_TEXT	ENDS
PUBLIC	?GetType@ResMsgTranslation@@UBE?AW4MemType@@XZ	; ResMsgTranslation::GetType
PUBLIC	?GetFileType@ResMsgTranslation@@UBE?AW4MemType@@XZ ; ResMsgTranslation::GetFileType
PUBLIC	??_7ResMsgTranslation@@6B@			; ResMsgTranslation::`vftable'
PUBLIC	??_C@_0BC@LIAH@ResMsgTranslation?$AA@		; `string'
PUBLIC	??_C@_04JFJA@?4trn?$AA@				; `string'
;	COMDAT ??_7ResMsgTranslation@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\restype.hpp
CONST	SEGMENT
??_7ResMsgTranslation@@6B@ DD FLAT:?Check@SOL_ResType@@UAEHG@Z ; ResMsgTranslation::`vftable'
	DD	FLAT:?Close@SOL_ResType@@UBEHH@Z
	DD	FLAT:?GetExtension@SOL_ResType@@UBEPBDXZ
	DD	FLAT:?IsSupported@SOL_ResType@@UBEHXZ
	DD	FLAT:?Load@SOL_ResType@@UAEXAAUResTag@@H@Z
	DD	FLAT:?MakeName@SOL_ResType@@MBEXPAD00@Z
	DD	FLAT:?MakeName@SOL_ResType@@UBEXPAD0G@Z
	DD	FLAT:?MakeWildName@SOL_ResType@@UBEXPAD0@Z
	DD	FLAT:?Open@SOL_ResType@@UAEHGPAD@Z
	DD	FLAT:?FindDirEntry@SOL_ResType@@UBEHGPAH@Z
	DD	FLAT:?FindPatchEntry@SOL_ResType@@UBEHG@Z
	DD	FLAT:?CheckPatches@SOL_ResType@@UBEHG@Z
	DD	FLAT:?GetType@ResMsgTranslation@@UBE?AW4MemType@@XZ
	DD	FLAT:?GetAttrs@SOL_ResType@@UBEIXZ
	DD	FLAT:?ConfirmType@SOL_ResType@@MBEXW4MemType@@@Z
	DD	FLAT:?Decompress@SOL_ResType@@MBEXAAUResTag@@@Z
	DD	FLAT:?FindPatch36Entry@SOL_ResType@@MBEHPAD@Z
	DD	FLAT:?GetFileSize@SOL_ResType@@MBEJXZ
	DD	FLAT:?GetFileType@ResMsgTranslation@@UBE?AW4MemType@@XZ
	DD	FLAT:?Read@SOL_ResType@@MBEHPAXH@Z
	DD	FLAT:?SeekToData@SOL_ResType@@MBEHXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@LIAH@ResMsgTranslation?$AA@
_DATA	SEGMENT
??_C@_0BC@LIAH@ResMsgTranslation?$AA@ DB 'ResMsgTranslation', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_04JFJA@?4trn?$AA@
_DATA	SEGMENT
??_C@_04JFJA@?4trn?$AA@ DB '.trn', 00H			; `string'
_DATA	ENDS
;	COMDAT ??0ResMsgTranslation@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0ResMsgTranslation@@QAE@XZ PROC NEAR			; ResMsgTranslation::ResMsgTranslation, COMDAT

; 172  : 	ResMsgTranslation() : SOL_ResType(".trn", "ResMsgTranslation")  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@LIAH@ResMsgTranslation?$AA@ ; `string'
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04JFJA@?4trn?$AA@ ; `string'
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0SOL_ResType@@QAE@PAD0@Z ; SOL_ResType::SOL_ResType
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ResMsgTranslation@@6B@ ; ResMsgTranslation::`vftable'
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0ResMsgTranslation@@QAE@XZ ENDP			; ResMsgTranslation::ResMsgTranslation
_TEXT	ENDS
;	COMDAT ?GetType@ResMsgTranslation@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetType@ResMsgTranslation@@UBE?AW4MemType@@XZ PROC NEAR ; ResMsgTranslation::GetType, COMDAT

; 176  : 	MemType GetType() const 			{ return MemResMsgTranslation; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b8 15 00 00 00	 mov	 eax, 21			; 00000015H
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetType@ResMsgTranslation@@UBE?AW4MemType@@XZ ENDP	; ResMsgTranslation::GetType
_TEXT	ENDS
;	COMDAT ?GetFileType@ResMsgTranslation@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetFileType@ResMsgTranslation@@UBE?AW4MemType@@XZ PROC NEAR ; ResMsgTranslation::GetFileType, COMDAT

; 177  : 	MemType GetFileType() const 		{ return MemResMsg; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetFileType@ResMsgTranslation@@UBE?AW4MemType@@XZ ENDP	; ResMsgTranslation::GetFileType
_TEXT	ENDS
PUBLIC	?GetType@ResRobot@@UBE?AW4MemType@@XZ		; ResRobot::GetType
PUBLIC	??_7ResRobot@@6B@				; ResRobot::`vftable'
PUBLIC	??_C@_08JLOL@ResRobot?$AA@			; `string'
PUBLIC	??_C@_04LLKI@?4rbt?$AA@				; `string'
;	COMDAT ??_7ResRobot@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\restype.hpp
CONST	SEGMENT
??_7ResRobot@@6B@ DD FLAT:?Check@SOL_ResType@@UAEHG@Z	; ResRobot::`vftable'
	DD	FLAT:?Close@SOL_ResType@@UBEHH@Z
	DD	FLAT:?GetExtension@SOL_ResType@@UBEPBDXZ
	DD	FLAT:?IsSupported@SOL_ResType@@UBEHXZ
	DD	FLAT:?Load@SOL_ResType@@UAEXAAUResTag@@H@Z
	DD	FLAT:?MakeName@SOL_ResType@@MBEXPAD00@Z
	DD	FLAT:?MakeName@SOL_ResType@@UBEXPAD0G@Z
	DD	FLAT:?MakeWildName@SOL_ResType@@UBEXPAD0@Z
	DD	FLAT:?Open@SOL_ResType@@UAEHGPAD@Z
	DD	FLAT:?FindDirEntry@SOL_ResType@@UBEHGPAH@Z
	DD	FLAT:?FindPatchEntry@SOL_ResType@@UBEHG@Z
	DD	FLAT:?CheckPatches@SOL_ResType@@UBEHG@Z
	DD	FLAT:?GetType@ResRobot@@UBE?AW4MemType@@XZ
	DD	FLAT:?GetAttrs@SOL_ResType@@UBEIXZ
	DD	FLAT:?ConfirmType@SOL_ResType@@MBEXW4MemType@@@Z
	DD	FLAT:?Decompress@SOL_ResType@@MBEXAAUResTag@@@Z
	DD	FLAT:?FindPatch36Entry@SOL_ResType@@MBEHPAD@Z
	DD	FLAT:?GetFileSize@SOL_ResType@@MBEJXZ
	DD	FLAT:?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
	DD	FLAT:?Read@SOL_ResType@@MBEHPAXH@Z
	DD	FLAT:?SeekToData@SOL_ResType@@MBEHXZ
CONST	ENDS
;	COMDAT ??_C@_08JLOL@ResRobot?$AA@
_DATA	SEGMENT
??_C@_08JLOL@ResRobot?$AA@ DB 'ResRobot', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04LLKI@?4rbt?$AA@
_DATA	SEGMENT
??_C@_04LLKI@?4rbt?$AA@ DB '.rbt', 00H			; `string'
_DATA	ENDS
;	COMDAT ??0ResRobot@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0ResRobot@@QAE@XZ PROC NEAR				; ResRobot::ResRobot, COMDAT

; 181  : 	ResRobot() : SOL_ResType(".rbt", "ResRobot")  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08JLOL@ResRobot?$AA@ ; `string'
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04LLKI@?4rbt?$AA@ ; `string'
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0SOL_ResType@@QAE@PAD0@Z ; SOL_ResType::SOL_ResType
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ResRobot@@6B@ ; ResRobot::`vftable'
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0ResRobot@@QAE@XZ ENDP				; ResRobot::ResRobot
_TEXT	ENDS
;	COMDAT ?GetType@ResRobot@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetType@ResRobot@@UBE?AW4MemType@@XZ PROC NEAR		; ResRobot::GetType, COMDAT

; 182  : 	MemType GetType() const 			{ return MemResRobot; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetType@ResRobot@@UBE?AW4MemType@@XZ ENDP		; ResRobot::GetType
_TEXT	ENDS
PUBLIC	?GetType@ResVMD@@UBE?AW4MemType@@XZ		; ResVMD::GetType
PUBLIC	??_7ResVMD@@6B@					; ResVMD::`vftable'
PUBLIC	??_C@_06OEMP@ResVMD?$AA@			; `string'
PUBLIC	??_C@_04IOID@?4vmd?$AA@				; `string'
EXTRN	?SeekToData@ResVMD@@MBEHXZ:NEAR			; ResVMD::SeekToData
;	COMDAT ??_7ResVMD@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\restype.hpp
CONST	SEGMENT
??_7ResVMD@@6B@ DD FLAT:?Check@SOL_ResType@@UAEHG@Z	; ResVMD::`vftable'
	DD	FLAT:?Close@SOL_ResType@@UBEHH@Z
	DD	FLAT:?GetExtension@SOL_ResType@@UBEPBDXZ
	DD	FLAT:?IsSupported@SOL_ResType@@UBEHXZ
	DD	FLAT:?Load@SOL_ResType@@UAEXAAUResTag@@H@Z
	DD	FLAT:?MakeName@SOL_ResType@@MBEXPAD00@Z
	DD	FLAT:?MakeName@SOL_ResType@@UBEXPAD0G@Z
	DD	FLAT:?MakeWildName@SOL_ResType@@UBEXPAD0@Z
	DD	FLAT:?Open@SOL_ResType@@UAEHGPAD@Z
	DD	FLAT:?FindDirEntry@SOL_ResType@@UBEHGPAH@Z
	DD	FLAT:?FindPatchEntry@SOL_ResType@@UBEHG@Z
	DD	FLAT:?CheckPatches@SOL_ResType@@UBEHG@Z
	DD	FLAT:?GetType@ResVMD@@UBE?AW4MemType@@XZ
	DD	FLAT:?GetAttrs@SOL_ResType@@UBEIXZ
	DD	FLAT:?ConfirmType@SOL_ResType@@MBEXW4MemType@@@Z
	DD	FLAT:?Decompress@SOL_ResType@@MBEXAAUResTag@@@Z
	DD	FLAT:?FindPatch36Entry@SOL_ResType@@MBEHPAD@Z
	DD	FLAT:?GetFileSize@SOL_ResType@@MBEJXZ
	DD	FLAT:?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
	DD	FLAT:?Read@SOL_ResType@@MBEHPAXH@Z
	DD	FLAT:?SeekToData@ResVMD@@MBEHXZ
CONST	ENDS
;	COMDAT ??_C@_06OEMP@ResVMD?$AA@
_DATA	SEGMENT
??_C@_06OEMP@ResVMD?$AA@ DB 'ResVMD', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04IOID@?4vmd?$AA@
_DATA	SEGMENT
??_C@_04IOID@?4vmd?$AA@ DB '.vmd', 00H			; `string'
_DATA	ENDS
;	COMDAT ??0ResVMD@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0ResVMD@@QAE@XZ PROC NEAR				; ResVMD::ResVMD, COMDAT

; 187  : 	ResVMD() : SOL_ResType(".vmd", "ResVMD")  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06OEMP@ResVMD?$AA@ ; `string'
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04IOID@?4vmd?$AA@ ; `string'
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0SOL_ResType@@QAE@PAD0@Z ; SOL_ResType::SOL_ResType
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ResVMD@@6B@ ; ResVMD::`vftable'
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0ResVMD@@QAE@XZ ENDP					; ResVMD::ResVMD
_TEXT	ENDS
;	COMDAT ?GetType@ResVMD@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetType@ResVMD@@UBE?AW4MemType@@XZ PROC NEAR		; ResVMD::GetType, COMDAT

; 188  : 	MemType	GetType() const		{ return MemResVMD; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b8 17 00 00 00	 mov	 eax, 23			; 00000017H
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetType@ResVMD@@UBE?AW4MemType@@XZ ENDP		; ResVMD::GetType
_TEXT	ENDS
PUBLIC	??0ResTagID@@QAE@XZ				; ResTagID::ResTagID
;	COMDAT ??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z
_TEXT	SEGMENT
_this$ = -4
_obj$ = 8
_handle$ = 12
_chunkSize$ = 16
??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z PROC NEAR ; ResourceList::ResourceList, COMDAT

; 64   : 		obj(obj), chunkSize(chunkSize), curSize(0), maxSize(chunkSize), handle(handle) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _obj$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 04	 add	 ecx, 4
  00015	e8 00 00 00 00	 call	 ??0ResTagID@@QAE@XZ	; ResTagID::ResTagID
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 4d 10	 mov	 ecx, DWORD PTR _chunkSize$[ebp]
  0002a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0002d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00030	8b 45 10	 mov	 eax, DWORD PTR _chunkSize$[ebp]
  00033	89 42 10	 mov	 DWORD PTR [edx+16], eax
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 55 0c	 mov	 edx, DWORD PTR _handle$[ebp]
  0003c	89 51 14	 mov	 DWORD PTR [ecx+20], edx
  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 0c 00	 ret	 12			; 0000000cH
??0ResourceList@@QAE@PAVSOL_ResType@@W4ReservedHandle@@H@Z ENDP ; ResourceList::ResourceList
_TEXT	ENDS
PUBLIC	??0FakeResTagID@@QAE@XZ				; FakeResTagID::FakeResTagID
;	COMDAT ??0ResTagID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0ResTagID@@QAE@XZ PROC NEAR				; ResTagID::ResTagID, COMDAT

; 57   : 	ResTagID() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0FakeResTagID@@QAE@XZ	; FakeResTagID::FakeResTagID
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0ResTagID@@QAE@XZ ENDP				; ResTagID::ResTagID
_TEXT	ENDS
;	COMDAT ??0FakeResTagID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0FakeResTagID@@QAE@XZ PROC NEAR			; FakeResTagID::FakeResTagID, COMDAT

; 54   : FakeTemplateID(FakeResTagID, ResTag, MemResourceList)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0FakeResTagID@@QAE@XZ ENDP				; FakeResTagID::FakeResTagID
_TEXT	ENDS
PUBLIC	??0ResTagID@@QAE@ABU0@@Z			; ResTagID::ResTagID
;	COMDAT ??0ResourceList@@QAE@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0ResourceList@@QAE@ABU0@@Z PROC NEAR			; ResourceList::ResourceList, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00014	83 c0 04	 add	 eax, 4
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 c1 04	 add	 ecx, 4
  0001e	e8 00 00 00 00	 call	 ??0ResTagID@@QAE@ABU0@@Z ; ResTagID::ResTagID
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00029	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0002c	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00035	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00038	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00041	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00044	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0004d	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00050	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00053	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
??0ResourceList@@QAE@ABU0@@Z ENDP			; ResourceList::ResourceList
_TEXT	ENDS
PUBLIC	??0FakeResTagID@@QAE@ABU0@@Z			; FakeResTagID::FakeResTagID
;	COMDAT ??0ResTagID@@QAE@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0ResTagID@@QAE@ABU0@@Z PROC NEAR			; ResTagID::ResTagID, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0FakeResTagID@@QAE@ABU0@@Z ; FakeResTagID::FakeResTagID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0ResTagID@@QAE@ABU0@@Z ENDP				; ResTagID::ResTagID
_TEXT	ENDS
PUBLIC	??0MemID@@QAE@ABV0@@Z				; MemID::MemID
;	COMDAT ??0FakeResTagID@@QAE@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0FakeResTagID@@QAE@ABU0@@Z PROC NEAR			; FakeResTagID::FakeResTagID, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0FakeResTagID@@QAE@ABU0@@Z ENDP			; FakeResTagID::FakeResTagID
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0MemID@@QAE@ABV0@@Z PROC NEAR				; MemID::MemID, COMDAT

; 19   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  0000d	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00010	66 89 10	 mov	 WORD PTR [eax], dx

; 20   : 	}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0MemID@@QAE@ABV0@@Z ENDP				; MemID::MemID
_TEXT	ENDS
PUBLIC	??0ResourceMgr@@QAE@XZ				; ResourceMgr::ResourceMgr
PUBLIC	?Free@ResourceMgr@@UAEXW4MemType@@G@Z		; ResourceMgr::Free
PUBLIC	?BuildPatchTables@ResourceMgr@@UAEXXZ		; ResourceMgr::BuildPatchTables
PUBLIC	?Check@ResourceMgr@@UAEHW4MemType@@G@Z		; ResourceMgr::Check
PUBLIC	?Close@ResourceMgr@@UAEHH@Z			; ResourceMgr::Close
PUBLIC	?Find@ResourceMgr@@UAE?AVMemID@@W4MemType@@G@Z	; ResourceMgr::Find
PUBLIC	?FindType@ResourceMgr@@UAEGW4MemType@@@Z	; ResourceMgr::FindType
PUBLIC	?Get@ResourceMgr@@UAE?AVMemID@@W4MemType@@GH@Z	; ResourceMgr::Get
PUBLIC	?GetResMapID@ResourceMgr@@UAE?AVMemID@@H@Z	; ResourceMgr::GetResMapID
PUBLIC	?LoadResMaps@ResourceMgr@@UAEXXZ		; ResourceMgr::LoadResMaps
PUBLIC	?Lock@ResourceMgr@@UAEXW4MemType@@G@Z		; ResourceMgr::Lock
PUBLIC	?MakeDebugDisplayStr@ResourceMgr@@UAE?AVTextID@@XZ ; ResourceMgr::MakeDebugDisplayStr
PUBLIC	?MakeName@ResourceMgr@@UAEPADW4MemType@@G@Z	; ResourceMgr::MakeName
PUBLIC	?Open@ResourceMgr@@UAEHW4MemType@@GPAD@Z	; ResourceMgr::Open
PUBLIC	?OpenVolume@ResourceMgr@@UAEHH@Z		; ResourceMgr::OpenVolume
PUBLIC	?Release@ResourceMgr@@UAEXW4MemType@@G@Z	; ResourceMgr::Release
PUBLIC	?SetDiscardable@ResourceMgr@@UAEXW4MemType@@G@Z	; ResourceMgr::SetDiscardable
PUBLIC	?SetNotDiscardable@ResourceMgr@@UAEXW4MemType@@G@Z ; ResourceMgr::SetNotDiscardable
PUBLIC	?Unlock@ResourceMgr@@UAEXW4MemType@@G@Z		; ResourceMgr::Unlock
PUBLIC	?VolumeOpen@ResourceMgr@@UAEHH@Z		; ResourceMgr::VolumeOpen
PUBLIC	?AddIndex@ResourceMgr@@MAEHW4MemType@@G@Z	; ResourceMgr::AddIndex
PUBLIC	?Check@ResourceMgr@@MAEHPAVSOL_ResType@@G@Z	; ResourceMgr::Check
PUBLIC	?DeleteIndex@ResourceMgr@@MAEXW4MemType@@G@Z	; ResourceMgr::DeleteIndex
PUBLIC	?GetIndex@ResourceMgr@@MAEHW4MemType@@G@Z	; ResourceMgr::GetIndex
PUBLIC	?InitResourceMgr@ResourceMgr@@MAEXXZ		; ResourceMgr::InitResourceMgr
PUBLIC	?Load@ResourceMgr@@MAEXPAVSOL_ResType@@AAUResTag@@H@Z ; ResourceMgr::Load
PUBLIC	??_7ResourceMgr@@6B@				; ResourceMgr::`vftable'
PUBLIC	??_GResourceMgr@@UAEPAXI@Z			; ResourceMgr::`scalar deleting destructor'
PUBLIC	??_EResourceMgr@@UAEPAXI@Z			; ResourceMgr::`vector deleting destructor'
PUBLIC	??0MemClient@@QAE@XZ				; MemClient::MemClient
PUBLIC	?Get@ResourceList@@QAEXXZ			; ResourceList::Get
;	COMDAT ??_7ResourceMgr@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\Resource.cpp
CONST	SEGMENT
??_7ResourceMgr@@6B@ DD FLAT:?Free@ResourceMgr@@UAEXW4MemType@@G@Z ; ResourceMgr::`vftable'
	DD	FLAT:??_EResourceMgr@@UAEPAXI@Z
	DD	FLAT:?BuildPatchTables@ResourceMgr@@UAEXXZ
	DD	FLAT:?Check@ResourceMgr@@MAEHPAVSOL_ResType@@G@Z
	DD	FLAT:?Check@ResourceMgr@@UAEHW4MemType@@G@Z
	DD	FLAT:?Close@ResourceMgr@@UAEHH@Z
	DD	FLAT:?Find@ResourceMgr@@UAE?AVMemID@@W4MemType@@G@Z
	DD	FLAT:?FindType@ResourceMgr@@UAEGW4MemType@@@Z
	DD	FLAT:?Get@ResourceMgr@@UAE?AVMemID@@W4MemType@@GH@Z
	DD	FLAT:?GetResMapID@ResourceMgr@@UAE?AVMemID@@H@Z
	DD	FLAT:?LoadResMaps@ResourceMgr@@UAEXXZ
	DD	FLAT:?Lock@ResourceMgr@@UAEXW4MemType@@G@Z
	DD	FLAT:?MakeDebugDisplayStr@ResourceMgr@@UAE?AVTextID@@XZ
	DD	FLAT:?MakeName@ResourceMgr@@UAEPADW4MemType@@G@Z
	DD	FLAT:?Open@ResourceMgr@@UAEHW4MemType@@GPAD@Z
	DD	FLAT:?OpenVolume@ResourceMgr@@UAEHH@Z
	DD	FLAT:?Release@ResourceMgr@@UAEXW4MemType@@G@Z
	DD	FLAT:?SetDiscardable@ResourceMgr@@UAEXW4MemType@@G@Z
	DD	FLAT:?SetNotDiscardable@ResourceMgr@@UAEXW4MemType@@G@Z
	DD	FLAT:?Unlock@ResourceMgr@@UAEXW4MemType@@G@Z
	DD	FLAT:?VolumeOpen@ResourceMgr@@UAEHH@Z
	DD	FLAT:?AddIndex@ResourceMgr@@MAEHW4MemType@@G@Z
	DD	FLAT:?DeleteIndex@ResourceMgr@@MAEXW4MemType@@G@Z
	DD	FLAT:?GetIndex@ResourceMgr@@MAEHW4MemType@@G@Z
	DD	FLAT:?InitResourceMgr@ResourceMgr@@MAEXXZ
	DD	FLAT:?Load@ResourceMgr@@MAEXPAVSOL_ResType@@AAUResTag@@H@Z
CONST	ENDS
_TEXT	SEGMENT
_this$ = -8
_i$ = -4
??0ResourceMgr@@QAE@XZ PROC NEAR			; ResourceMgr::ResourceMgr

; 164  : {

  00b49	55		 push	 ebp
  00b4a	8b ec		 mov	 ebp, esp
  00b4c	83 ec 08	 sub	 esp, 8
  00b4f	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00b52	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b55	e8 00 00 00 00	 call	 ??0MemClient@@QAE@XZ	; MemClient::MemClient
  00b5a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b5d	83 c1 04	 add	 ecx, 4
  00b60	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  00b65	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b68	81 c1 ec 00 00
	00		 add	 ecx, 236		; 000000ecH
  00b6e	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  00b73	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00b76	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ResourceMgr@@6B@ ; ResourceMgr::`vftable'

; 165  : 	for (int i = 0; i < nResourceTypes; ++i) {

  00b7c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00b83	eb 09		 jmp	 SHORT $L63695
$L63696:
  00b85	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00b88	83 c1 01	 add	 ecx, 1
  00b8b	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L63695:
  00b8e	83 7d fc 18	 cmp	 DWORD PTR _i$[ebp], 24	; 00000018H
  00b92	7d 13		 jge	 SHORT $L63697

; 166  : 		resources[i].Get();

  00b94	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00b97	6b c9 18	 imul	 ecx, 24			; 00000018H
  00b9a	81 c1 00 00 00
	00		 add	 ecx, OFFSET FLAT:_resources
  00ba0	e8 00 00 00 00	 call	 ?Get@ResourceList@@QAEXXZ ; ResourceList::Get

; 167  : 	}

  00ba5	eb de		 jmp	 SHORT $L63696
$L63697:

; 168  : 	InitResourceMgr();

  00ba7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00baa	e8 00 00 00 00	 call	 ?InitResourceMgr@ResourceMgr@@MAEXXZ ; ResourceMgr::InitResourceMgr

; 169  : }

  00baf	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00bb2	8b e5		 mov	 esp, ebp
  00bb4	5d		 pop	 ebp
  00bb5	c3		 ret	 0
??0ResourceMgr@@QAE@XZ ENDP				; ResourceMgr::ResourceMgr
_TEXT	ENDS
;	COMDAT ?Check@ResourceMgr@@MAEHPAVSOL_ResType@@G@Z
_TEXT	SEGMENT
_obj$ = 8
_num$ = 12
_this$ = -4
?Check@ResourceMgr@@MAEHPAVSOL_ResType@@G@Z PROC NEAR	; ResourceMgr::Check, COMDAT

; 86   : 	virtual Bool	Check(SOL_ResType* obj, ResNum num)	{ return obj->Check(num); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	66 8b 45 0c	 mov	 ax, WORD PTR _num$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _obj$[ebp]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _obj$[ebp]
  00014	ff 12		 call	 DWORD PTR [edx]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
?Check@ResourceMgr@@MAEHPAVSOL_ResType@@G@Z ENDP	; ResourceMgr::Check
_TEXT	ENDS
;	COMDAT ?Load@ResourceMgr@@MAEXPAVSOL_ResType@@AAUResTag@@H@Z
_TEXT	SEGMENT
_obj$ = 8
_tag$ = 12
_lock$ = 16
_this$ = -4
?Load@ResourceMgr@@MAEXPAVSOL_ResType@@AAUResTag@@H@Z PROC NEAR ; ResourceMgr::Load, COMDAT

; 91   : 	 	{ obj->Load(tag,lock); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 10	 mov	 eax, DWORD PTR _lock$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR _tag$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR _obj$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _obj$[ebp]
  00017	ff 50 10	 call	 DWORD PTR [eax+16]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 0c 00	 ret	 12			; 0000000cH
?Load@ResourceMgr@@MAEXPAVSOL_ResType@@AAUResTag@@H@Z ENDP ; ResourceMgr::Load
_TEXT	ENDS
PUBLIC	?Get@FakeResTagID@@QAEXIW4ReservedHandle@@I@Z	; FakeResTagID::Get
;	COMDAT ?Get@ResourceList@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Get@ResourceList@@QAEXXZ PROC NEAR			; ResourceList::Get, COMDAT

; 67   : 	Get() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 68   : 		if (handle)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0000e	74 21		 je	 SHORT $L63498

; 69   : 			id.Get(sizeof(ResTag) * chunkSize, handle, INITMEMORY | MOVEABLE);

  00010	68 00 02 01 00	 push	 66048			; 00010200H
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0001b	52		 push	 edx
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00022	c1 e1 02	 shl	 ecx, 2
  00025	51		 push	 ecx
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	83 c1 04	 add	 ecx, 4
  0002c	e8 00 00 00 00	 call	 ?Get@FakeResTagID@@QAEXIW4ReservedHandle@@I@Z ; FakeResTagID::Get
$L63498:

; 70   : 	}

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?Get@ResourceList@@QAEXXZ ENDP				; ResourceList::Get
_TEXT	ENDS
PUBLIC	?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get
;	COMDAT ?Get@FakeResTagID@@QAEXIW4ReservedHandle@@I@Z
_TEXT	SEGMENT
_size$ = 8
_h$ = 12
_attrs$ = 16
_this$ = -4
?Get@FakeResTagID@@QAEXIW4ReservedHandle@@I@Z PROC NEAR	; FakeResTagID::Get, COMDAT

; 54   : FakeTemplateID(FakeResTagID, ResTag, MemResourceList)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR _h$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	6a 00		 push	 0
  0000f	6a 00		 push	 0
  00011	8b 4d 10	 mov	 ecx, DWORD PTR _attrs$[ebp]
  00014	81 c9 00 00 08
	00		 or	 ecx, 524288		; 00080000H
  0001a	51		 push	 ecx
  0001b	8b 55 08	 mov	 edx, DWORD PTR _size$[ebp]
  0001e	52		 push	 edx
  0001f	6a 31		 push	 49			; 00000031H
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 0c 00	 ret	 12			; 0000000cH
?Get@FakeResTagID@@QAEXIW4ReservedHandle@@I@Z ENDP	; FakeResTagID::Get
_TEXT	ENDS
EXTRN	?Alloc@MemoryMgr@@QAEGIIIPAUMemClient@@DW4ReservedHandle@@@Z:NEAR ; MemoryMgr::Alloc
EXTRN	_memMgr:DWORD
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT
_type$ = 8
_size$ = 12
_a$ = 16
_num$ = 20
_client$ = 24
_initChar$ = 28
_h$ = 32
_this$ = -4
?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z PROC NEAR ; MemID::Get, COMDAT

; 42   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 43   : 		handle = memMgr->Alloc(type | a, size, num, client, initChar, h);

  00007	8b 45 20	 mov	 eax, DWORD PTR _h$[ebp]
  0000a	50		 push	 eax
  0000b	8a 4d 1c	 mov	 cl, BYTE PTR _initChar$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 18	 mov	 edx, DWORD PTR _client$[ebp]
  00012	52		 push	 edx
  00013	8b 45 14	 mov	 eax, DWORD PTR _num$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 55 08	 mov	 edx, DWORD PTR _type$[ebp]
  0001e	0b 55 10	 or	 edx, DWORD PTR _a$[ebp]
  00021	52		 push	 edx
  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00028	e8 00 00 00 00	 call	 ?Alloc@MemoryMgr@@QAEGIIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemoryMgr::Alloc
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	66 89 01	 mov	 WORD PTR [ecx], ax

; 44   : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 1c 00	 ret	 28			; 0000001cH
?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ENDP ; MemID::Get
_TEXT	ENDS
PUBLIC	??1ResourceMgr@@UAE@XZ				; ResourceMgr::~ResourceMgr
;	COMDAT ??_GResourceMgr@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GResourceMgr@@UAEPAXI@Z PROC NEAR			; ResourceMgr::`scalar deleting destructor', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1ResourceMgr@@UAE@XZ	; ResourceMgr::~ResourceMgr
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L63701
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L63701:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GResourceMgr@@UAEPAXI@Z ENDP				; ResourceMgr::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7MemClient@@6B@				; MemClient::`vftable'
EXTRN	__purecall:NEAR
;	COMDAT ??_7MemClient@@6B@
CONST	SEGMENT
??_7MemClient@@6B@ DD FLAT:__purecall			; MemClient::`vftable'
CONST	ENDS
;	COMDAT ??0MemClient@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0MemClient@@QAE@XZ PROC NEAR				; MemClient::MemClient, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7MemClient@@6B@ ; MemClient::`vftable'
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0MemClient@@QAE@XZ ENDP				; MemClient::MemClient
_TEXT	ENDS
PUBLIC	?Free@ResourceList@@QAEXXZ			; ResourceList::Free
_TEXT	SEGMENT
$T64723 = -8
_this$ = -12
_i$ = -4
??1ResourceMgr@@UAE@XZ PROC NEAR			; ResourceMgr::~ResourceMgr

; 172  : {

  00bb6	55		 push	 ebp
  00bb7	8b ec		 mov	 ebp, esp
  00bb9	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00bbc	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00bbf	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00bc2	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ResourceMgr@@6B@ ; ResourceMgr::`vftable'

; 173  : 	delete [] resMaps;

  00bc8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMaps@@3PAUResMaps@@A ; resMaps
  00bce	89 4d f8	 mov	 DWORD PTR $T64723[ebp], ecx
  00bd1	8b 55 f8	 mov	 edx, DWORD PTR $T64723[ebp]
  00bd4	52		 push	 edx
  00bd5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00bda	83 c4 04	 add	 esp, 4

; 174  : 	for (int i = 0; i < nResourceTypes; ++i)

  00bdd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00be4	eb 09		 jmp	 SHORT $L63709
$L63710:
  00be6	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00be9	83 c0 01	 add	 eax, 1
  00bec	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L63709:
  00bef	83 7d fc 18	 cmp	 DWORD PTR _i$[ebp], 24	; 00000018H
  00bf3	7d 13		 jge	 SHORT $L63711

; 175  : 		resources[i].Free();

  00bf5	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00bf8	6b c9 18	 imul	 ecx, 24			; 00000018H
  00bfb	81 c1 00 00 00
	00		 add	 ecx, OFFSET FLAT:_resources
  00c01	e8 00 00 00 00	 call	 ?Free@ResourceList@@QAEXXZ ; ResourceList::Free
  00c06	eb de		 jmp	 SHORT $L63710
$L63711:

; 176  : 
; 177  : #ifdef DEBUG
; 178  : 	rmResList->Print();
; 179  : 	delete rmResList;
; 180  : #endif
; 181  : }

  00c08	8b e5		 mov	 esp, ebp
  00c0a	5d		 pop	 ebp
  00c0b	c3		 ret	 0
??1ResourceMgr@@UAE@XZ ENDP				; ResourceMgr::~ResourceMgr
_TEXT	ENDS
PUBLIC	?Free@MemID@@QAEXXZ				; MemID::Free
;	COMDAT ?Free@ResourceList@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8
$T64725 = -4
?Free@ResourceList@@QAEXXZ PROC NEAR			; ResourceList::Free, COMDAT

; 99   : 	void Free() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 100  : 		delete obj;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR $T64725[ebp], ecx
  00011	8b 55 fc	 mov	 edx, DWORD PTR $T64725[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001a	83 c4 04	 add	 esp, 4

; 101  : 		id.Free();

  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	83 c1 04	 add	 ecx, 4
  00023	e8 00 00 00 00	 call	 ?Free@MemID@@QAEXXZ	; MemID::Free

; 102  : 	}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?Free@ResourceList@@QAEXXZ ENDP				; ResourceList::Free
_TEXT	ENDS
EXTRN	?Free@MemoryMgr@@QAEXG@Z:NEAR			; MemoryMgr::Free
;	COMDAT ?Free@MemID@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Free@MemID@@QAEXXZ PROC NEAR				; MemID::Free, COMDAT

; 32   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 33   : 		if (handle) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000f	85 c9		 test	 ecx, ecx
  00011	74 1a		 je	 SHORT $L52883

; 34   : 			memMgr->Free(handle);

  00013	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00016	66 8b 02	 mov	 ax, WORD PTR [edx]
  00019	50		 push	 eax
  0001a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00020	e8 00 00 00 00	 call	 ?Free@MemoryMgr@@QAEXG@Z ; MemoryMgr::Free

; 35   : 			handle = 0;

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	66 c7 01 00 00	 mov	 WORD PTR [ecx], 0
$L52883:

; 37   : 	}

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?Free@MemID@@QAEXXZ ENDP				; MemID::Free
_TEXT	ENDS
_TEXT	SEGMENT
_type$ = 8
_num$ = 12
_path$ = 16
_this$ = -4
?Open@ResourceMgr@@UAEHW4MemType@@GPAD@Z PROC NEAR	; ResourceMgr::Open

; 185  : {

  00c0c	55		 push	 ebp
  00c0d	8b ec		 mov	 ebp, esp
  00c0f	51		 push	 ecx
  00c10	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 186  : 	return resources[type].obj->Open(num, path);

  00c13	8b 45 10	 mov	 eax, DWORD PTR _path$[ebp]
  00c16	50		 push	 eax
  00c17	66 8b 4d 0c	 mov	 cx, WORD PTR _num$[ebp]
  00c1b	51		 push	 ecx
  00c1c	8b 55 08	 mov	 edx, DWORD PTR _type$[ebp]
  00c1f	6b d2 18	 imul	 edx, 24			; 00000018H
  00c22	8b 8a 00 00 00
	00		 mov	 ecx, DWORD PTR _resources[edx]
  00c28	8b 45 08	 mov	 eax, DWORD PTR _type$[ebp]
  00c2b	6b c0 18	 imul	 eax, 24			; 00000018H
  00c2e	8b 90 00 00 00
	00		 mov	 edx, DWORD PTR _resources[eax]
  00c34	8b 02		 mov	 eax, DWORD PTR [edx]
  00c36	ff 50 20	 call	 DWORD PTR [eax+32]

; 187  : }

  00c39	8b e5		 mov	 esp, ebp
  00c3b	5d		 pop	 ebp
  00c3c	c2 0c 00	 ret	 12			; 0000000cH
?Open@ResourceMgr@@UAEHW4MemType@@GPAD@Z ENDP		; ResourceMgr::Open
_TEXT	ENDS
EXTRN	?Close@@YAHH@Z:NEAR				; Close
_TEXT	SEGMENT
_fd$ = 8
_this$ = -4
?Close@ResourceMgr@@UAEHH@Z PROC NEAR			; ResourceMgr::Close

; 191  : {

  00c3f	55		 push	 ebp
  00c40	8b ec		 mov	 ebp, esp
  00c42	51		 push	 ecx
  00c43	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 192  : 	if (fd != -1 && !VolumeOpen(fd))

  00c46	83 7d 08 ff	 cmp	 DWORD PTR _fd$[ebp], -1
  00c4a	74 21		 je	 SHORT $L63722
  00c4c	8b 45 08	 mov	 eax, DWORD PTR _fd$[ebp]
  00c4f	50		 push	 eax
  00c50	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c53	8b 11		 mov	 edx, DWORD PTR [ecx]
  00c55	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c58	ff 52 50	 call	 DWORD PTR [edx+80]
  00c5b	85 c0		 test	 eax, eax
  00c5d	75 0e		 jne	 SHORT $L63722

; 193  : 		return ::Close(fd);

  00c5f	8b 45 08	 mov	 eax, DWORD PTR _fd$[ebp]
  00c62	50		 push	 eax
  00c63	e8 00 00 00 00	 call	 ?Close@@YAHH@Z		; Close
  00c68	83 c4 04	 add	 esp, 4
  00c6b	eb 03		 jmp	 SHORT $L63721
$L63722:

; 194  : 	return -1;

  00c6d	83 c8 ff	 or	 eax, -1
$L63721:

; 195  : }

  00c70	8b e5		 mov	 esp, ebp
  00c72	5d		 pop	 ebp
  00c73	c2 04 00	 ret	 4
?Close@ResourceMgr@@UAEHH@Z ENDP			; ResourceMgr::Close
_TEXT	ENDS
PUBLIC	?SCI16ToSCI32ResType@@YAXAAW4MemType@@@Z	; SCI16ToSCI32ResType
PUBLIC	?IsValid@MemID@@QBEHXZ				; MemID::IsValid
PUBLIC	??BMemID@@QBEGXZ				; MemID::operator unsigned short
PUBLIC	??DMemID@@QBEPAXXZ				; MemID::operator*
PUBLIC	??0ResTag@@QAE@ABU0@@Z				; ResTag::ResTag
PUBLIC	??DFakeResTagID@@QBEPAUResTag@@XZ		; FakeResTagID::operator*
EXTRN	?Fatal@MsgMgr@@QAAXPADZZ:NEAR			; MsgMgr::Fatal
EXTRN	?Fatal@MsgMgr@@QAAXDPADHHZZ:NEAR		; MsgMgr::Fatal
EXTRN	?WING@@3HA:DWORD				; WING
EXTRN	?ShiftPaletteView@@YAXPAE@Z:NEAR		; ShiftPaletteView
EXTRN	?ShiftPalettePic@@YAXPAE@Z:NEAR			; ShiftPalettePic
EXTRN	?msgMgr@@3PAVMsgMgr@@A:DWORD			; msgMgr
EXTRN	?Attrs@MemID@@QBEIXZ:NEAR			; MemID::Attrs
EXTRN	?Lock@MemID@@QBEPAXXZ:NEAR			; MemID::Lock
_DATA	SEGMENT
$SG63735 DB	'C:\Documents and Settings\don\Desktop\sciw\Interp\Resour'
	DB	'ce.cpp', 00H
	ORG $+1
$SG63740 DB	'Resource handle is invalid after Find. ResType = %d, Res'
	DB	'Num = %d', 00H
	ORG $+3
$SG63751 DB	'Resource handle is invalid after Load. ResType = %d, Res'
	DB	'Num = %d', 00H
_DATA	ENDS
_TEXT	SEGMENT
$T64730 = -32
_resType$ = 12
_resNum$ = 16
_lock$ = 20
___$ReturnUdt$ = 8
_this$ = -36
_id$ = -28
_attr$ = -8
_obj$ = -24
_index$ = -20
_array$ = -16
_resTag$ = -12
_newIndex$ = -4
?Get@ResourceMgr@@UAE?AVMemID@@W4MemType@@GH@Z PROC NEAR ; ResourceMgr::Get

; 199  : {

  00c76	55		 push	 ebp
  00c77	8b ec		 mov	 ebp, esp
  00c79	83 ec 24	 sub	 esp, 36			; 00000024H
  00c7c	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 200  : 	// either return the MemID or load the resource and return the MemID
; 201  : 
; 202  : 	//	SCI still uses the old numbers
; 203  : 	SCI16ToSCI32ResType(resType);

  00c7f	8d 45 0c	 lea	 eax, DWORD PTR _resType$[ebp]
  00c82	50		 push	 eax
  00c83	e8 00 00 00 00	 call	 ?SCI16ToSCI32ResType@@YAXAAW4MemType@@@Z ; SCI16ToSCI32ResType
  00c88	83 c4 04	 add	 esp, 4

; 204  : 
; 205  : 	MemID		id;

  00c8b	8d 4d e4	 lea	 ecx, DWORD PTR _id$[ebp]
  00c8e	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID

; 206  : 	long		attr = 0;

  00c93	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _attr$[ebp], 0

; 207  : 	
; 208  : 	SOL_ResType*	obj = resources[resType].obj;

  00c9a	8b 4d 0c	 mov	 ecx, DWORD PTR _resType$[ebp]
  00c9d	6b c9 18	 imul	 ecx, 24			; 00000018H
  00ca0	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _resources[ecx]
  00ca6	89 55 e8	 mov	 DWORD PTR _obj$[ebp], edx

; 209  : 
; 210  : 	if (!obj->IsSupported())

  00ca9	8b 45 e8	 mov	 eax, DWORD PTR _obj$[ebp]
  00cac	8b 10		 mov	 edx, DWORD PTR [eax]
  00cae	8b 4d e8	 mov	 ecx, DWORD PTR _obj$[ebp]
  00cb1	ff 52 0c	 call	 DWORD PTR [edx+12]
  00cb4	85 c0		 test	 eax, eax
  00cb6	75 21		 jne	 SHORT $L63733

; 211  : 		msgMgr->Fatal(SrcLoc, Msg_InvalidResType, (int) resType);

  00cb8	8b 45 0c	 mov	 eax, DWORD PTR _resType$[ebp]
  00cbb	50		 push	 eax
  00cbc	6a 62		 push	 98			; 00000062H
  00cbe	68 d3 00 00 00	 push	 211			; 000000d3H
  00cc3	68 00 00 00 00	 push	 OFFSET FLAT:$SG63735
  00cc8	6a 61		 push	 97			; 00000061H
  00cca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00cd0	51		 push	 ecx
  00cd1	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXDPADHHZZ ; MsgMgr::Fatal
  00cd6	83 c4 18	 add	 esp, 24			; 00000018H
$L63733:

; 212  : 
; 213  : 	// See if already in memory
; 214  : 	if (id = Find(resType, resNum)) {

  00cd9	66 8b 55 10	 mov	 dx, WORD PTR _resNum$[ebp]
  00cdd	52		 push	 edx
  00cde	8b 45 0c	 mov	 eax, DWORD PTR _resType$[ebp]
  00ce1	50		 push	 eax
  00ce2	8d 4d e0	 lea	 ecx, DWORD PTR $T64730[ebp]
  00ce5	51		 push	 ecx
  00ce6	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00ce9	8b 02		 mov	 eax, DWORD PTR [edx]
  00ceb	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00cee	ff 50 18	 call	 DWORD PTR [eax+24]
  00cf1	66 8b 08	 mov	 cx, WORD PTR [eax]
  00cf4	66 89 4d e4	 mov	 WORD PTR _id$[ebp], cx
  00cf8	8d 4d e4	 lea	 ecx, DWORD PTR _id$[ebp]
  00cfb	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00d00	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00d05	85 c0		 test	 eax, eax
  00d07	74 61		 je	 SHORT $L63737

; 215  : 		if (lock && (id.Attrs() & MOVEABLE))

  00d09	83 7d 14 00	 cmp	 DWORD PTR _lock$[ebp], 0
  00d0d	74 19		 je	 SHORT $L63738
  00d0f	8d 4d e4	 lea	 ecx, DWORD PTR _id$[ebp]
  00d12	e8 00 00 00 00	 call	 ?Attrs@MemID@@QBEIXZ	; MemID::Attrs
  00d17	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00d1c	85 c0		 test	 eax, eax
  00d1e	74 08		 je	 SHORT $L63738

; 216  : 			id.Lock();

  00d20	8d 4d e4	 lea	 ecx, DWORD PTR _id$[ebp]
  00d23	e8 00 00 00 00	 call	 ?Lock@MemID@@QBEPAXXZ	; MemID::Lock
$L63738:

; 217  : 
; 218  : 		if ( !id.IsValid() )

  00d28	8d 4d e4	 lea	 ecx, DWORD PTR _id$[ebp]
  00d2b	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  00d30	85 c0		 test	 eax, eax
  00d32	75 22		 jne	 SHORT $L63739

; 219  : 			msgMgr->Fatal ( "Resource handle is invalid after Find. ResType = %d, ResNum = %d", resType, resNum ); 

  00d34	8b 55 10	 mov	 edx, DWORD PTR _resNum$[ebp]
  00d37	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00d3d	52		 push	 edx
  00d3e	8b 45 0c	 mov	 eax, DWORD PTR _resType$[ebp]
  00d41	50		 push	 eax
  00d42	68 00 00 00 00	 push	 OFFSET FLAT:$SG63740
  00d47	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00d4d	51		 push	 ecx
  00d4e	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00d53	83 c4 10	 add	 esp, 16			; 00000010H
$L63739:

; 220  : 
; 221  : 		return id;

  00d56	8d 55 e4	 lea	 edx, DWORD PTR _id$[ebp]
  00d59	52		 push	 edx
  00d5a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00d5d	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00d62	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00d65	e9 0c 01 00 00	 jmp	 $L63729
$L63737:

; 223  : 
; 224  : #ifdef DEBUG
; 225  : 	// Going external for resource
; 226  : 	int cursorView;
; 227  : 	int cursorLoop;
; 228  : 	int cursorCel;
; 229  : 	if ((graphMgr != NULL)  						&&
; 230  : 		 configMgr->Get(configMgr->DiskCursor) && 
; 231  : 		 !loadingDiskCursor							&&
; 232  : 		 !unLoadingDiskCursor) {
; 233  : 		loadingDiskCursor = True;
; 234  : 		// Save old cursor information
; 235  : 		Bitmap& bitmap = graphMgr->GCursor().Get();
; 236  : 		cursorView = bitmap.View();
; 237  : 		cursorLoop = bitmap.Loop();
; 238  : 		cursorCel = bitmap.Cel();
; 239  : 		graphMgr->GCursor().Set(configMgr->Val(configMgr->DiskCursor),0,0);
; 240  : 		graphMgr->FrameOut();
; 241  : 		loadingDiskCursor = False;
; 242  : 	}
; 243  : 	char str[13];
; 244  : 	sprintf(str,"%d%s",resNum,obj->GetExtension());
; 245  : #endif
; 246  : 
; 247  : 	//	make a copy and work with that, in case the array moves
; 248  : 	int index = AddIndex ( resType, resNum );

  00d6a	66 8b 45 10	 mov	 ax, WORD PTR _resNum$[ebp]
  00d6e	50		 push	 eax
  00d6f	8b 4d 0c	 mov	 ecx, DWORD PTR _resType$[ebp]
  00d72	51		 push	 ecx
  00d73	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00d76	8b 02		 mov	 eax, DWORD PTR [edx]
  00d78	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d7b	ff 50 54	 call	 DWORD PTR [eax+84]
  00d7e	89 45 ec	 mov	 DWORD PTR _index$[ebp], eax

; 249  : 	ResTag *array = *resources[resType].id;

  00d81	8b 4d 0c	 mov	 ecx, DWORD PTR _resType$[ebp]
  00d84	6b c9 18	 imul	 ecx, 24			; 00000018H
  00d87	81 c1 04 00 00
	00		 add	 ecx, OFFSET FLAT:_resources+4
  00d8d	e8 00 00 00 00	 call	 ??DFakeResTagID@@QBEPAUResTag@@XZ ; FakeResTagID::operator*
  00d92	89 45 f0	 mov	 DWORD PTR _array$[ebp], eax

; 250  : 	ResTag resTag = array[index];

  00d95	8b 4d ec	 mov	 ecx, DWORD PTR _index$[ebp]
  00d98	8b 55 f0	 mov	 edx, DWORD PTR _array$[ebp]
  00d9b	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00d9e	50		 push	 eax
  00d9f	8d 4d f4	 lea	 ecx, DWORD PTR _resTag$[ebp]
  00da2	e8 00 00 00 00	 call	 ??0ResTag@@QAE@ABU0@@Z	; ResTag::ResTag

; 251  : 
; 252  : 	Load(obj, resTag, lock);

  00da7	8b 4d 14	 mov	 ecx, DWORD PTR _lock$[ebp]
  00daa	51		 push	 ecx
  00dab	8d 55 f4	 lea	 edx, DWORD PTR _resTag$[ebp]
  00dae	52		 push	 edx
  00daf	8b 45 e8	 mov	 eax, DWORD PTR _obj$[ebp]
  00db2	50		 push	 eax
  00db3	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00db6	8b 11		 mov	 edx, DWORD PTR [ecx]
  00db8	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00dbb	ff 52 64	 call	 DWORD PTR [edx+100]

; 253  : 
; 254  : 	int newIndex = GetIndex(resType, resNum);

  00dbe	66 8b 45 10	 mov	 ax, WORD PTR _resNum$[ebp]
  00dc2	50		 push	 eax
  00dc3	8b 4d 0c	 mov	 ecx, DWORD PTR _resType$[ebp]
  00dc6	51		 push	 ecx
  00dc7	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00dca	8b 02		 mov	 eax, DWORD PTR [edx]
  00dcc	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00dcf	ff 50 5c	 call	 DWORD PTR [eax+92]
  00dd2	89 45 fc	 mov	 DWORD PTR _newIndex$[ebp], eax

; 255  : 	array[newIndex] = resTag;

  00dd5	8b 4d fc	 mov	 ecx, DWORD PTR _newIndex$[ebp]
  00dd8	8b 55 f0	 mov	 edx, DWORD PTR _array$[ebp]
  00ddb	8b 45 f4	 mov	 eax, DWORD PTR _resTag$[ebp]
  00dde	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 256  : 	id = array[newIndex].id;

  00de1	8b 4d fc	 mov	 ecx, DWORD PTR _newIndex$[ebp]
  00de4	8b 55 f0	 mov	 edx, DWORD PTR _array$[ebp]
  00de7	66 8b 44 8a 02	 mov	 ax, WORD PTR [edx+ecx*4+2]
  00dec	66 89 45 e4	 mov	 WORD PTR _id$[ebp], ax

; 257  : 
; 258  : #ifdef WIN32S
; 259  : 	if (WING) {

  00df0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?WING@@3HA, 0	; WING
  00df7	74 41		 je	 SHORT $L63748

; 260  : 		// Add 10 to the palette index values for views and pics
; 261  : 		if (obj->GetType() == MemResView) 

  00df9	8b 4d e8	 mov	 ecx, DWORD PTR _obj$[ebp]
  00dfc	8b 11		 mov	 edx, DWORD PTR [ecx]
  00dfe	8b 4d e8	 mov	 ecx, DWORD PTR _obj$[ebp]
  00e01	ff 52 30	 call	 DWORD PTR [edx+48]
  00e04	85 c0		 test	 eax, eax
  00e06	75 11		 jne	 SHORT $L63746

; 262  : 		 	ShiftPaletteView((uchar*)*id);

  00e08	8d 4d e4	 lea	 ecx, DWORD PTR _id$[ebp]
  00e0b	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  00e10	50		 push	 eax
  00e11	e8 00 00 00 00	 call	 ?ShiftPaletteView@@YAXPAE@Z ; ShiftPaletteView
  00e16	83 c4 04	 add	 esp, 4
$L63746:

; 263  : 		if (obj->GetType() == MemResPic)

  00e19	8b 45 e8	 mov	 eax, DWORD PTR _obj$[ebp]
  00e1c	8b 10		 mov	 edx, DWORD PTR [eax]
  00e1e	8b 4d e8	 mov	 ecx, DWORD PTR _obj$[ebp]
  00e21	ff 52 30	 call	 DWORD PTR [edx+48]
  00e24	83 f8 01	 cmp	 eax, 1
  00e27	75 11		 jne	 SHORT $L63748

; 264  : 			ShiftPalettePic((uchar*)*id);

  00e29	8d 4d e4	 lea	 ecx, DWORD PTR _id$[ebp]
  00e2c	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  00e31	50		 push	 eax
  00e32	e8 00 00 00 00	 call	 ?ShiftPalettePic@@YAXPAE@Z ; ShiftPalettePic
  00e37	83 c4 04	 add	 esp, 4
$L63748:

; 266  : #endif
; 267  : 
; 268  : #ifdef DEBUG
; 269  : 	if ((graphMgr != NULL)  						&&
; 270  : 		 configMgr->Get(configMgr->DiskCursor)	&&
; 271  : 		 !loadingDiskCursor							&&
; 272  : 		 (cursorView != -1)) {
; 273  : 		unLoadingDiskCursor = True;
; 274  : 		graphMgr->GCursor().Set(cursorView,cursorLoop,cursorCel);
; 275  : 		graphMgr->FrameOut();
; 276  : 		unLoadingDiskCursor = False;
; 277  : 	}
; 278  : 	id.SetChecksum(id.Attrs() & CHECKSUMMABLE);
; 279  : #endif
; 280  : 	if ( !id.IsValid() )

  00e3a	8d 4d e4	 lea	 ecx, DWORD PTR _id$[ebp]
  00e3d	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  00e42	85 c0		 test	 eax, eax
  00e44	75 21		 jne	 SHORT $L63750

; 281  : 		msgMgr->Fatal ( "Resource handle is invalid after Load. ResType = %d, ResNum = %d", resType, resNum ); 

  00e46	8b 45 10	 mov	 eax, DWORD PTR _resNum$[ebp]
  00e49	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00e4e	50		 push	 eax
  00e4f	8b 4d 0c	 mov	 ecx, DWORD PTR _resType$[ebp]
  00e52	51		 push	 ecx
  00e53	68 00 00 00 00	 push	 OFFSET FLAT:$SG63751
  00e58	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00e5e	52		 push	 edx
  00e5f	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00e64	83 c4 10	 add	 esp, 16			; 00000010H
$L63750:

; 282  : 
; 283  : 	return id;

  00e67	8d 45 e4	 lea	 eax, DWORD PTR _id$[ebp]
  00e6a	50		 push	 eax
  00e6b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00e6e	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00e73	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$L63729:

; 284  : }

  00e76	8b e5		 mov	 esp, ebp
  00e78	5d		 pop	 ebp
  00e79	c2 10 00	 ret	 16			; 00000010H
?Get@ResourceMgr@@UAE?AVMemID@@W4MemType@@GH@Z ENDP	; ResourceMgr::Get
_TEXT	ENDS
PUBLIC	?IsValid@MemoryMgr@@QAEHG@Z			; MemoryMgr::IsValid
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsValid@MemID@@QBEHXZ PROC NEAR			; MemID::IsValid, COMDAT

; 62   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 63   : 		return memMgr->IsValid(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?IsValid@MemoryMgr@@QAEHG@Z ; MemoryMgr::IsValid

; 64   : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?IsValid@MemID@@QBEHXZ ENDP				; MemID::IsValid
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -8
_tempID$ = -4
?IsValid@MemoryMgr@@QAEHG@Z PROC NEAR			; MemoryMgr::IsValid, COMDAT

; 475  : 	inline Bool MemoryMgr::IsValid(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 476  : 		unsigned short tempID = (unsigned short)theID;

  00009	66 8b 45 08	 mov	 ax, WORD PTR _theID$[ebp]
  0000d	66 89 45 fc	 mov	 WORD PTR _tempID$[ebp], ax

; 477  : 
; 478  : 		return(
; 479  : 				(tempID)															&&
; 480  : 				(tempID < maxDescriptors)									&&
; 481  : 				(desc[tempID].memInfo.bits.freeDescriptor == False)	&&
; 482  : 				(desc[tempID].memInfo.bits.freeMemory == False)
; 483  : 				);

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _tempID$[ebp]
  00014	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 58		 je	 SHORT $L64733
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _tempID$[ebp]
  00021	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  0002d	73 47		 jae	 SHORT $L64733
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _tempID$[ebp]
  00032	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00038	c1 e1 04	 shl	 ecx, 4
  0003b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00041	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00044	c1 e1 0e	 shl	 ecx, 14			; 0000000eH
  00047	c1 f9 1f	 sar	 ecx, 31			; 0000001fH
  0004a	85 c9		 test	 ecx, ecx
  0004c	75 28		 jne	 SHORT $L64733
  0004e	8b 55 fc	 mov	 edx, DWORD PTR _tempID$[ebp]
  00051	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00057	c1 e2 04	 shl	 edx, 4
  0005a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00060	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00063	c1 e2 14	 shl	 edx, 20			; 00000014H
  00066	c1 fa 1f	 sar	 edx, 31			; 0000001fH
  00069	85 d2		 test	 edx, edx
  0006b	75 09		 jne	 SHORT $L64733
  0006d	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR -12+[ebp], 1
  00074	eb 07		 jmp	 SHORT $L64734
$L64733:
  00076	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR -12+[ebp], 0
$L64734:
  0007d	8b 45 f4	 mov	 eax, DWORD PTR -12+[ebp]

; 484  : 	}

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 04 00	 ret	 4
?IsValid@MemoryMgr@@QAEHG@Z ENDP			; MemoryMgr::IsValid
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4
??BMemID@@QBEGXZ PROC NEAR				; MemID::operator unsigned short, COMDAT

; 93   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   : 		return handle;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 00	 mov	 ax, WORD PTR [eax]

; 95   : 	}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??BMemID@@QBEGXZ ENDP					; MemID::operator unsigned short
_TEXT	ENDS
PUBLIC	?GetAddr@MemoryMgr@@QAEPAXG@Z			; MemoryMgr::GetAddr
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT
_this$ = -4
??DMemID@@QBEPAXXZ PROC NEAR				; MemID::operator*, COMDAT

; 98   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 99   : 		return memMgr->GetAddr(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr

; 100  : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??DMemID@@QBEPAXXZ ENDP					; MemID::operator*
_TEXT	ENDS
EXTRN	__descPtrTable:BYTE
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -4
?GetAddr@MemoryMgr@@QAEPAXG@Z PROC NEAR			; MemoryMgr::GetAddr, COMDAT

; 462  : 	inline void* MemoryMgr::GetAddr(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : //		CheckValid(theID);
; 464  : 		return _descPtrTable[(unsigned int)((unsigned short)theID)];

  00007	8b 45 08	 mov	 eax, DWORD PTR _theID$[ebp]
  0000a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0000f	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR __descPtrTable[eax*4]

; 465  : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?GetAddr@MemoryMgr@@QAEPAXG@Z ENDP			; MemoryMgr::GetAddr
_TEXT	ENDS
;	COMDAT ??DFakeResTagID@@QBEPAUResTag@@XZ
_TEXT	SEGMENT
_this$ = -4
??DFakeResTagID@@QBEPAUResTag@@XZ PROC NEAR		; FakeResTagID::operator*, COMDAT

; 54   : FakeTemplateID(FakeResTagID, ResTag, MemResourceList)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??DFakeResTagID@@QBEPAUResTag@@XZ ENDP			; FakeResTagID::operator*
_TEXT	ENDS
;	COMDAT ?SCI16ToSCI32ResType@@YAXAAW4MemType@@@Z
_TEXT	SEGMENT
_t$ = 8
?SCI16ToSCI32ResType@@YAXAAW4MemType@@@Z PROC NEAR	; SCI16ToSCI32ResType, COMDAT

; 157  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 158  : 	t = MemType(t & ~0x80);

  00003	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	80 e1 7f	 and	 cl, 127			; 0000007fH
  0000b	8b 55 08	 mov	 edx, DWORD PTR _t$[ebp]
  0000e	89 0a		 mov	 DWORD PTR [edx], ecx

; 159  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?SCI16ToSCI32ResType@@YAXAAW4MemType@@@Z ENDP		; SCI16ToSCI32ResType
_TEXT	ENDS
;	COMDAT ??0ResTag@@QAE@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0ResTag@@QAE@ABU0@@Z PROC NEAR			; ResTag::ResTag, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0000d	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00010	66 89 10	 mov	 WORD PTR [eax], dx
  00013	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00016	83 c0 02	 add	 eax, 2
  00019	50		 push	 eax
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 02	 add	 ecx, 2
  00020	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??0ResTag@@QAE@ABU0@@Z ENDP				; ResTag::ResTag
_TEXT	ENDS
PUBLIC	?GetExtType@ResourceMgr@@QAE?AW4MemType@@PAD@Z	; ResourceMgr::GetExtType
EXTRN	__imp__stricmp:NEAR
_TEXT	SEGMENT
_extension$ = 8
_this$ = -12
_i$ = -4
_obj$63763 = -8
?GetExtType@ResourceMgr@@QAE?AW4MemType@@PAD@Z PROC NEAR ; ResourceMgr::GetExtType

; 288  : {

  00e7c	55		 push	 ebp
  00e7d	8b ec		 mov	 ebp, esp
  00e7f	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00e82	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 289  : 	int	i;
; 290  : 
; 291  : 	for (i = 0; i < nResourceTypes; i++) {

  00e85	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00e8c	eb 09		 jmp	 SHORT $L63760
$L63761:
  00e8e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00e91	83 c0 01	 add	 eax, 1
  00e94	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L63760:
  00e97	83 7d fc 18	 cmp	 DWORD PTR _i$[ebp], 24	; 00000018H
  00e9b	7d 3b		 jge	 SHORT $L63762

; 292  : 		SOL_ResType* obj = resources[i].obj;

  00e9d	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00ea0	6b c9 18	 imul	 ecx, 24			; 00000018H
  00ea3	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _resources[ecx]
  00ea9	89 55 f8	 mov	 DWORD PTR _obj$63763[ebp], edx

; 293  : 		if (!stricmp(obj->GetExtension(),extension))

  00eac	8b 45 08	 mov	 eax, DWORD PTR _extension$[ebp]
  00eaf	50		 push	 eax
  00eb0	8b 4d f8	 mov	 ecx, DWORD PTR _obj$63763[ebp]
  00eb3	8b 11		 mov	 edx, DWORD PTR [ecx]
  00eb5	8b 4d f8	 mov	 ecx, DWORD PTR _obj$63763[ebp]
  00eb8	ff 52 08	 call	 DWORD PTR [edx+8]
  00ebb	50		 push	 eax
  00ebc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__stricmp
  00ec2	83 c4 08	 add	 esp, 8
  00ec5	85 c0		 test	 eax, eax
  00ec7	75 0d		 jne	 SHORT $L63764

; 294  : 			return obj->GetType();

  00ec9	8b 45 f8	 mov	 eax, DWORD PTR _obj$63763[ebp]
  00ecc	8b 10		 mov	 edx, DWORD PTR [eax]
  00ece	8b 4d f8	 mov	 ecx, DWORD PTR _obj$63763[ebp]
  00ed1	ff 52 30	 call	 DWORD PTR [edx+48]
  00ed4	eb 04		 jmp	 SHORT $L63758
$L63764:

; 295  : 	}

  00ed6	eb b6		 jmp	 SHORT $L63761
$L63762:

; 296  : 	return (MemType)0;

  00ed8	33 c0		 xor	 eax, eax
$L63758:

; 297  : }

  00eda	8b e5		 mov	 esp, ebp
  00edc	5d		 pop	 ebp
  00edd	c2 04 00	 ret	 4
?GetExtType@ResourceMgr@@QAE?AW4MemType@@PAD@Z ENDP	; ResourceMgr::GetExtType
_TEXT	ENDS
EXTRN	?CanOpen@SOL_ResType@@QAEHGPAD@Z:NEAR		; SOL_ResType::CanOpen
_TEXT	SEGMENT
$T64743 = -8
_resType$ = 8
_resNum$ = 12
_this$ = -12
_obj$ = -4
?Check@ResourceMgr@@UAEHW4MemType@@G@Z PROC NEAR	; ResourceMgr::Check

; 301  : {

  00ee0	55		 push	 ebp
  00ee1	8b ec		 mov	 ebp, esp
  00ee3	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00ee6	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 302  : 	// return TRUE if said resource is locateable
; 303  : 
; 304  : 	//	SCI still uses the old numbers
; 305  : 	SCI16ToSCI32ResType(resType);

  00ee9	8d 45 08	 lea	 eax, DWORD PTR _resType$[ebp]
  00eec	50		 push	 eax
  00eed	e8 00 00 00 00	 call	 ?SCI16ToSCI32ResType@@YAXAAW4MemType@@@Z ; SCI16ToSCI32ResType
  00ef2	83 c4 04	 add	 esp, 4

; 306  : 
; 307  : 	SOL_ResType* obj = resources[resType].obj;

  00ef5	8b 4d 08	 mov	 ecx, DWORD PTR _resType$[ebp]
  00ef8	6b c9 18	 imul	 ecx, 24			; 00000018H
  00efb	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _resources[ecx]
  00f01	89 55 fc	 mov	 DWORD PTR _obj$[ebp], edx

; 308  : 
; 309  : 	if (!obj->IsSupported())

  00f04	8b 45 fc	 mov	 eax, DWORD PTR _obj$[ebp]
  00f07	8b 10		 mov	 edx, DWORD PTR [eax]
  00f09	8b 4d fc	 mov	 ecx, DWORD PTR _obj$[ebp]
  00f0c	ff 52 0c	 call	 DWORD PTR [edx+12]
  00f0f	85 c0		 test	 eax, eax
  00f11	75 04		 jne	 SHORT $L63772

; 310  : 		return False;

  00f13	33 c0		 xor	 eax, eax
  00f15	eb 3e		 jmp	 SHORT $L63770
$L63772:

; 311  : 
; 312  : 	// See if already in memory
; 313  : 	if (Find(resType, resNum))

  00f17	66 8b 45 0c	 mov	 ax, WORD PTR _resNum$[ebp]
  00f1b	50		 push	 eax
  00f1c	8b 4d 08	 mov	 ecx, DWORD PTR _resType$[ebp]
  00f1f	51		 push	 ecx
  00f20	8d 55 f8	 lea	 edx, DWORD PTR $T64743[ebp]
  00f23	52		 push	 edx
  00f24	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00f27	8b 10		 mov	 edx, DWORD PTR [eax]
  00f29	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00f2c	ff 52 18	 call	 DWORD PTR [edx+24]
  00f2f	8b c8		 mov	 ecx, eax
  00f31	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00f36	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00f3b	85 c0		 test	 eax, eax
  00f3d	74 07		 je	 SHORT $L63774

; 314  : 		return True;

  00f3f	b8 01 00 00 00	 mov	 eax, 1
  00f44	eb 0f		 jmp	 SHORT $L63770
$L63774:

; 315  : 
; 316  : 	return obj->CanOpen ( resNum );

  00f46	6a 00		 push	 0
  00f48	66 8b 45 0c	 mov	 ax, WORD PTR _resNum$[ebp]
  00f4c	50		 push	 eax
  00f4d	8b 4d fc	 mov	 ecx, DWORD PTR _obj$[ebp]
  00f50	e8 00 00 00 00	 call	 ?CanOpen@SOL_ResType@@QAEHGPAD@Z ; SOL_ResType::CanOpen
$L63770:

; 317  : }

  00f55	8b e5		 mov	 esp, ebp
  00f57	5d		 pop	 ebp
  00f58	c2 08 00	 ret	 8
?Check@ResourceMgr@@UAEHW4MemType@@G@Z ENDP		; ResourceMgr::Check
$T64745 = -8
_resType$ = 8
_resNum$ = 12
_this$ = -12
_id$ = -4
?Lock@ResourceMgr@@UAEXW4MemType@@G@Z PROC NEAR		; ResourceMgr::Lock

; 321  : {

  00f5b	55		 push	 ebp
  00f5c	8b ec		 mov	 ebp, esp
  00f5e	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00f61	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 322  : 	// See if the given resource is in memory
; 323  : 
; 324  : 	MemID id = Find(resType, resNum);

  00f64	66 8b 45 0c	 mov	 ax, WORD PTR _resNum$[ebp]
  00f68	50		 push	 eax
  00f69	8b 4d 08	 mov	 ecx, DWORD PTR _resType$[ebp]
  00f6c	51		 push	 ecx
  00f6d	8d 55 f8	 lea	 edx, DWORD PTR $T64745[ebp]
  00f70	52		 push	 edx
  00f71	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00f74	8b 10		 mov	 edx, DWORD PTR [eax]
  00f76	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00f79	ff 52 18	 call	 DWORD PTR [edx+24]
  00f7c	50		 push	 eax
  00f7d	8d 4d fc	 lea	 ecx, DWORD PTR _id$[ebp]
  00f80	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID

; 325  : 	if (id)

  00f85	8d 4d fc	 lea	 ecx, DWORD PTR _id$[ebp]
  00f88	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00f8d	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00f92	85 c0		 test	 eax, eax
  00f94	74 08		 je	 SHORT $L63782

; 326  : 		id.Lock();

  00f96	8d 4d fc	 lea	 ecx, DWORD PTR _id$[ebp]
  00f99	e8 00 00 00 00	 call	 ?Lock@MemID@@QBEPAXXZ	; MemID::Lock
$L63782:

; 327  : 
; 328  : }

  00f9e	8b e5		 mov	 esp, ebp
  00fa0	5d		 pop	 ebp
  00fa1	c2 08 00	 ret	 8
?Lock@ResourceMgr@@UAEXW4MemType@@G@Z ENDP		; ResourceMgr::Lock
_TEXT	ENDS
EXTRN	?SetNotDiscardable@MemID@@QBEXXZ:NEAR		; MemID::SetNotDiscardable
_TEXT	SEGMENT
$T64747 = -8
_resType$ = 8
_resNum$ = 12
_this$ = -12
_id$ = -4
?SetNotDiscardable@ResourceMgr@@UAEXW4MemType@@G@Z PROC NEAR ; ResourceMgr::SetNotDiscardable

; 332  : {

  00fa4	55		 push	 ebp
  00fa5	8b ec		 mov	 ebp, esp
  00fa7	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00faa	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 333  : 	// See if the given resource is in memory
; 334  : 
; 335  : 	MemID id = Find(resType, resNum);

  00fad	66 8b 45 0c	 mov	 ax, WORD PTR _resNum$[ebp]
  00fb1	50		 push	 eax
  00fb2	8b 4d 08	 mov	 ecx, DWORD PTR _resType$[ebp]
  00fb5	51		 push	 ecx
  00fb6	8d 55 f8	 lea	 edx, DWORD PTR $T64747[ebp]
  00fb9	52		 push	 edx
  00fba	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00fbd	8b 10		 mov	 edx, DWORD PTR [eax]
  00fbf	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00fc2	ff 52 18	 call	 DWORD PTR [edx+24]
  00fc5	50		 push	 eax
  00fc6	8d 4d fc	 lea	 ecx, DWORD PTR _id$[ebp]
  00fc9	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID

; 336  : 	if (id)

  00fce	8d 4d fc	 lea	 ecx, DWORD PTR _id$[ebp]
  00fd1	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00fd6	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00fdb	85 c0		 test	 eax, eax
  00fdd	74 08		 je	 SHORT $L63790

; 337  : 		id.SetNotDiscardable();

  00fdf	8d 4d fc	 lea	 ecx, DWORD PTR _id$[ebp]
  00fe2	e8 00 00 00 00	 call	 ?SetNotDiscardable@MemID@@QBEXXZ ; MemID::SetNotDiscardable
$L63790:

; 338  : 
; 339  : }

  00fe7	8b e5		 mov	 esp, ebp
  00fe9	5d		 pop	 ebp
  00fea	c2 08 00	 ret	 8
?SetNotDiscardable@ResourceMgr@@UAEXW4MemType@@G@Z ENDP	; ResourceMgr::SetNotDiscardable
_TEXT	ENDS
EXTRN	?SetDiscardable@MemID@@QBEXXZ:NEAR		; MemID::SetDiscardable
_TEXT	SEGMENT
$T64749 = -8
_resType$ = 8
_resNum$ = 12
_this$ = -12
_id$ = -4
?SetDiscardable@ResourceMgr@@UAEXW4MemType@@G@Z PROC NEAR ; ResourceMgr::SetDiscardable

; 343  : {

  00fed	55		 push	 ebp
  00fee	8b ec		 mov	 ebp, esp
  00ff0	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00ff3	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 344  : 	// See if the given resource is in memory
; 345  : 
; 346  : 	MemID id = Find(resType, resNum);

  00ff6	66 8b 45 0c	 mov	 ax, WORD PTR _resNum$[ebp]
  00ffa	50		 push	 eax
  00ffb	8b 4d 08	 mov	 ecx, DWORD PTR _resType$[ebp]
  00ffe	51		 push	 ecx
  00fff	8d 55 f8	 lea	 edx, DWORD PTR $T64749[ebp]
  01002	52		 push	 edx
  01003	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  01006	8b 10		 mov	 edx, DWORD PTR [eax]
  01008	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0100b	ff 52 18	 call	 DWORD PTR [edx+24]
  0100e	50		 push	 eax
  0100f	8d 4d fc	 lea	 ecx, DWORD PTR _id$[ebp]
  01012	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID

; 347  : 	if (id)

  01017	8d 4d fc	 lea	 ecx, DWORD PTR _id$[ebp]
  0101a	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  0101f	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  01024	85 c0		 test	 eax, eax
  01026	74 08		 je	 SHORT $L63798

; 348  : 		id.SetDiscardable();

  01028	8d 4d fc	 lea	 ecx, DWORD PTR _id$[ebp]
  0102b	e8 00 00 00 00	 call	 ?SetDiscardable@MemID@@QBEXXZ ; MemID::SetDiscardable
$L63798:

; 349  : 
; 350  : }

  01030	8b e5		 mov	 esp, ebp
  01032	5d		 pop	 ebp
  01033	c2 08 00	 ret	 8
?SetDiscardable@ResourceMgr@@UAEXW4MemType@@G@Z ENDP	; ResourceMgr::SetDiscardable
_TEXT	ENDS
PUBLIC	??0TextID@@QAE@ABV0@@Z				; TextID::TextID
PUBLIC	?MakeDebugSummaryStr@ResourceList@@QAEXAAVTextID@@@Z ; ResourceList::MakeDebugSummaryStr
PUBLIC	?MakeDebugDetailStr@ResourceList@@QAEXAAVTextID@@@Z ; ResourceList::MakeDebugDetailStr
EXTRN	??0TextID@@QAE@XZ:NEAR				; TextID::TextID
EXTRN	?Add@TextID@@QAEXPBD@Z:NEAR			; TextID::Add
_DATA	SEGMENT
	ORG $+3
$SG63808 DB	0aH, 0aH, 00H
_DATA	ENDS
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -12
_buf$ = -4
_i$ = -8
?MakeDebugDisplayStr@ResourceMgr@@UAE?AVTextID@@XZ PROC NEAR ; ResourceMgr::MakeDebugDisplayStr

; 354  : {

  01036	55		 push	 ebp
  01037	8b ec		 mov	 ebp, esp
  01039	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0103c	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 355  : 	TextID	buf;

  0103f	8d 4d fc	 lea	 ecx, DWORD PTR _buf$[ebp]
  01042	e8 00 00 00 00	 call	 ??0TextID@@QAE@XZ	; TextID::TextID

; 356  : 	int		i;
; 357  : 	
; 358  : 	for (i = 0; i < nResourceTypes; i++)

  01047	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0104e	eb 09		 jmp	 SHORT $L63805
$L63806:
  01050	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01053	83 c0 01	 add	 eax, 1
  01056	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L63805:
  01059	83 7d f8 18	 cmp	 DWORD PTR _i$[ebp], 24	; 00000018H
  0105d	7d 17		 jge	 SHORT $L63807

; 359  : 		resources[i].MakeDebugSummaryStr(buf);

  0105f	8d 4d fc	 lea	 ecx, DWORD PTR _buf$[ebp]
  01062	51		 push	 ecx
  01063	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  01066	6b c9 18	 imul	 ecx, 24			; 00000018H
  01069	81 c1 00 00 00
	00		 add	 ecx, OFFSET FLAT:_resources
  0106f	e8 00 00 00 00	 call	 ?MakeDebugSummaryStr@ResourceList@@QAEXAAVTextID@@@Z ; ResourceList::MakeDebugSummaryStr
  01074	eb da		 jmp	 SHORT $L63806
$L63807:

; 360  : 
; 361  : 	buf.Add("\n\n");

  01076	68 00 00 00 00	 push	 OFFSET FLAT:$SG63808
  0107b	8d 4d fc	 lea	 ecx, DWORD PTR _buf$[ebp]
  0107e	e8 00 00 00 00	 call	 ?Add@TextID@@QAEXPBD@Z	; TextID::Add

; 362  : 	
; 363  : 	for (i = 0; i < nResourceTypes; i++)

  01083	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0108a	eb 09		 jmp	 SHORT $L63809
$L63810:
  0108c	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0108f	83 c2 01	 add	 edx, 1
  01092	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$L63809:
  01095	83 7d f8 18	 cmp	 DWORD PTR _i$[ebp], 24	; 00000018H
  01099	7d 17		 jge	 SHORT $L63811

; 364  : 		resources[i].MakeDebugDetailStr(buf);

  0109b	8d 45 fc	 lea	 eax, DWORD PTR _buf$[ebp]
  0109e	50		 push	 eax
  0109f	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  010a2	6b c9 18	 imul	 ecx, 24			; 00000018H
  010a5	81 c1 00 00 00
	00		 add	 ecx, OFFSET FLAT:_resources
  010ab	e8 00 00 00 00	 call	 ?MakeDebugDetailStr@ResourceList@@QAEXAAVTextID@@@Z ; ResourceList::MakeDebugDetailStr
  010b0	eb da		 jmp	 SHORT $L63810
$L63811:

; 365  : 
; 366  : 	return buf;

  010b2	8d 4d fc	 lea	 ecx, DWORD PTR _buf$[ebp]
  010b5	51		 push	 ecx
  010b6	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  010b9	e8 00 00 00 00	 call	 ??0TextID@@QAE@ABV0@@Z	; TextID::TextID
  010be	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 367  : }

  010c1	8b e5		 mov	 esp, ebp
  010c3	5d		 pop	 ebp
  010c4	c2 04 00	 ret	 4
?MakeDebugDisplayStr@ResourceMgr@@UAE?AVTextID@@XZ ENDP	; ResourceMgr::MakeDebugDisplayStr
_TEXT	ENDS
PUBLIC	??_C@_07MAGC@?$CFs?3?5?$CFu?5?$AA@		; `string'
EXTRN	?Size@MemID@@QBEIXZ:NEAR			; MemID::Size
EXTRN	?AddF@TextID@@QAAXPBDZZ:NEAR			; TextID::AddF
;	COMDAT ??_C@_07MAGC@?$CFs?3?5?$CFu?5?$AA@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\Resource.cpp
_DATA	SEGMENT
??_C@_07MAGC@?$CFs?3?5?$CFu?5?$AA@ DB '%s: %u ', 00H	; `string'
_DATA	ENDS
;	COMDAT ?MakeDebugSummaryStr@ResourceList@@QAEXAAVTextID@@@Z
_TEXT	SEGMENT
_this$ = -16
_resTags$ = -4
_total$ = -8
_i$ = -12
_buf$ = 8
?MakeDebugSummaryStr@ResourceList@@QAEXAAVTextID@@@Z PROC NEAR ; ResourceList::MakeDebugSummaryStr, COMDAT

; 73   : 	MakeDebugSummaryStr(TextID& buf) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 		if (!obj->IsSupported() || !curSize)

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00011	8b 02		 mov	 eax, DWORD PTR [edx]
  00013	8b 10		 mov	 edx, DWORD PTR [eax]
  00015	ff 52 0c	 call	 DWORD PTR [edx+12]
  00018	85 c0		 test	 eax, eax
  0001a	74 09		 je	 SHORT $L63503
  0001c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00023	75 02		 jne	 SHORT $L63502
$L63503:

; 75   : 			return;

  00025	eb 73		 jmp	 SHORT $L63501
$L63502:

; 76   : 
; 77   : 		ResTag* resTags = *id;

  00027	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	83 c1 04	 add	 ecx, 4
  0002d	e8 00 00 00 00	 call	 ??DFakeResTagID@@QBEPAUResTag@@XZ ; FakeResTagID::operator*
  00032	89 45 fc	 mov	 DWORD PTR _resTags$[ebp], eax

; 78   : 		unsigned total = 0;

  00035	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _total$[ebp], 0

; 79   : 		for (int i = 0; i < curSize; i++)

  0003c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00043	eb 09		 jmp	 SHORT $L63507
$L63508:
  00045	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00048	83 c1 01	 add	 ecx, 1
  0004b	89 4d f4	 mov	 DWORD PTR _i$[ebp], ecx
$L63507:
  0004e	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00051	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00054	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00057	7d 19		 jge	 SHORT $L63509

; 80   : 			total += resTags[i].id.Size();

  00059	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0005c	8b 55 fc	 mov	 edx, DWORD PTR _resTags$[ebp]
  0005f	8d 4c 8a 02	 lea	 ecx, DWORD PTR [edx+ecx*4+2]
  00063	e8 00 00 00 00	 call	 ?Size@MemID@@QBEIXZ	; MemID::Size
  00068	8b 4d f8	 mov	 ecx, DWORD PTR _total$[ebp]
  0006b	03 c8		 add	 ecx, eax
  0006d	89 4d f8	 mov	 DWORD PTR _total$[ebp], ecx
  00070	eb d3		 jmp	 SHORT $L63508
$L63509:

; 81   : 		buf.AddF("%s: %u ", obj->GetExtension() + 1, total);

  00072	8b 55 f8	 mov	 edx, DWORD PTR _total$[ebp]
  00075	52		 push	 edx
  00076	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00079	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007b	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0007e	8b 02		 mov	 eax, DWORD PTR [edx]
  00080	8b 10		 mov	 edx, DWORD PTR [eax]
  00082	ff 52 08	 call	 DWORD PTR [edx+8]
  00085	83 c0 01	 add	 eax, 1
  00088	50		 push	 eax
  00089	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07MAGC@?$CFs?3?5?$CFu?5?$AA@ ; `string'
  0008e	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ?AddF@TextID@@QAAXPBDZZ	; TextID::AddF
  00097	83 c4 10	 add	 esp, 16			; 00000010H
$L63501:

; 82   : 	}

  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 04 00	 ret	 4
?MakeDebugSummaryStr@ResourceList@@QAEXAAVTextID@@@Z ENDP ; ResourceList::MakeDebugSummaryStr
_TEXT	ENDS
PUBLIC	??_C@_04HPGM@?$CFs?3?5?$AA@			; `string'
PUBLIC	??_C@_01PIHH@?$CB?$AA@				; `string'
PUBLIC	??_C@_01KHHK@?$FO?$AA@				; `string'
PUBLIC	??_C@_01FDHG@?$CK?$AA@				; `string'
PUBLIC	??_C@_09BLDF@?$CFs?$CFs?$CFs?$CFu?5?$AA@	; `string'
PUBLIC	??_C@_02PIMC@?$AN?6?$AA@			; `string'
PUBLIC	??AResTagID@@QAEAAUResTag@@H@Z			; ResTagID::operator[]
;	COMDAT ??_C@_04HPGM@?$CFs?3?5?$AA@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\Resource.cpp
_DATA	SEGMENT
??_C@_04HPGM@?$CFs?3?5?$AA@ DB '%s: ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_01PIHH@?$CB?$AA@
_DATA	SEGMENT
??_C@_01PIHH@?$CB?$AA@ DB '!', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_01KHHK@?$FO?$AA@
_DATA	SEGMENT
??_C@_01KHHK@?$FO?$AA@ DB '^', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_01FDHG@?$CK?$AA@
_DATA	SEGMENT
??_C@_01FDHG@?$CK?$AA@ DB '*', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_09BLDF@?$CFs?$CFs?$CFs?$CFu?5?$AA@
_DATA	SEGMENT
??_C@_09BLDF@?$CFs?$CFs?$CFs?$CFu?5?$AA@ DB '%s%s%s%u ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_02PIMC@?$AN?6?$AA@
_DATA	SEGMENT
??_C@_02PIMC@?$AN?6?$AA@ DB 0dH, 0aH, 00H		; `string'
_DATA	ENDS
;	COMDAT ?MakeDebugDetailStr@ResourceList@@QAEXAAVTextID@@@Z
_TEXT	SEGMENT
_this$ = -12
_i$ = -4
_attrs$63520 = -8
_buf$ = 8
?MakeDebugDetailStr@ResourceList@@QAEXAAVTextID@@@Z PROC NEAR ; ResourceList::MakeDebugDetailStr, COMDAT

; 85   : 	MakeDebugDetailStr(TextID& buf) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 86   : 		if (!obj->IsSupported() || !curSize)

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00011	8b 02		 mov	 eax, DWORD PTR [edx]
  00013	8b 10		 mov	 edx, DWORD PTR [eax]
  00015	ff 52 0c	 call	 DWORD PTR [edx+12]
  00018	85 c0		 test	 eax, eax
  0001a	74 09		 je	 SHORT $L63514
  0001c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00023	75 05		 jne	 SHORT $L63513
$L63514:

; 87   : 			return;

  00025	e9 fb 00 00 00	 jmp	 $L63512
$L63513:

; 88   : 
; 89   : 		buf.AddF("%s: ", obj->GetExtension() + 1);

  0002a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002f	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00032	8b 02		 mov	 eax, DWORD PTR [edx]
  00034	8b 10		 mov	 edx, DWORD PTR [eax]
  00036	ff 52 08	 call	 DWORD PTR [edx+8]
  00039	83 c0 01	 add	 eax, 1
  0003c	50		 push	 eax
  0003d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04HPGM@?$CFs?3?5?$AA@ ; `string'
  00042	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?AddF@TextID@@QAAXPBDZZ	; TextID::AddF
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 90   : 
; 91   : 		for (int i = 0; i < curSize; i++) {

  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00055	eb 09		 jmp	 SHORT $L63517
$L63518:
  00057	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0005a	83 c1 01	 add	 ecx, 1
  0005d	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L63517:
  00060	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00063	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00066	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00069	0f 8d a9 00 00
	00		 jge	 $L63519

; 92   : 			MemAttrs attrs = id[i].id.Attrs();

  0006f	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00072	51		 push	 ecx
  00073	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	83 c1 04	 add	 ecx, 4
  00079	e8 00 00 00 00	 call	 ??AResTagID@@QAEAAUResTag@@H@Z ; ResTagID::operator[]
  0007e	8b c8		 mov	 ecx, eax
  00080	83 c1 02	 add	 ecx, 2
  00083	e8 00 00 00 00	 call	 ?Attrs@MemID@@QBEIXZ	; MemID::Attrs
  00088	89 45 f8	 mov	 DWORD PTR _attrs$63520[ebp], eax

; 93   : 			buf.AddF("%s%s%s%u ", !(attrs & DISCARDABLE) ? "*" : "", !(attrs & MOVEABLE) ? "^" : "", attrs & CRITICAL ? "!" : "", id[i].resNum);

  0008b	8b 55 f8	 mov	 edx, DWORD PTR _attrs$63520[ebp]
  0008e	81 e2 00 01 00
	00		 and	 edx, 256		; 00000100H
  00094	85 d2		 test	 edx, edx
  00096	74 09		 je	 SHORT $L64753
  00098	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR -16+[ebp], OFFSET FLAT:??_C@_01PIHH@?$CB?$AA@ ; `string'
  0009f	eb 07		 jmp	 SHORT $L64754
$L64753:
  000a1	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR -16+[ebp], OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
$L64754:
  000a8	8b 45 f8	 mov	 eax, DWORD PTR _attrs$63520[ebp]
  000ab	25 00 02 00 00	 and	 eax, 512		; 00000200H
  000b0	85 c0		 test	 eax, eax
  000b2	75 09		 jne	 SHORT $L64755
  000b4	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR -20+[ebp], OFFSET FLAT:??_C@_01KHHK@?$FO?$AA@ ; `string'
  000bb	eb 07		 jmp	 SHORT $L64756
$L64755:
  000bd	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR -20+[ebp], OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
$L64756:
  000c4	8b 4d f8	 mov	 ecx, DWORD PTR _attrs$63520[ebp]
  000c7	81 e1 00 04 00
	00		 and	 ecx, 1024		; 00000400H
  000cd	85 c9		 test	 ecx, ecx
  000cf	75 09		 jne	 SHORT $L64757
  000d1	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR -24+[ebp], OFFSET FLAT:??_C@_01FDHG@?$CK?$AA@ ; `string'
  000d8	eb 07		 jmp	 SHORT $L64758
$L64757:
  000da	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR -24+[ebp], OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
$L64758:
  000e1	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000e4	52		 push	 edx
  000e5	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000e8	83 c1 04	 add	 ecx, 4
  000eb	e8 00 00 00 00	 call	 ??AResTagID@@QAEAAUResTag@@H@Z ; ResTagID::operator[]
  000f0	33 c9		 xor	 ecx, ecx
  000f2	66 8b 08	 mov	 cx, WORD PTR [eax]
  000f5	51		 push	 ecx
  000f6	8b 55 f0	 mov	 edx, DWORD PTR -16+[ebp]
  000f9	52		 push	 edx
  000fa	8b 45 ec	 mov	 eax, DWORD PTR -20+[ebp]
  000fd	50		 push	 eax
  000fe	8b 4d e8	 mov	 ecx, DWORD PTR -24+[ebp]
  00101	51		 push	 ecx
  00102	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09BLDF@?$CFs?$CFs?$CFs?$CFu?5?$AA@ ; `string'
  00107	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  0010a	52		 push	 edx
  0010b	e8 00 00 00 00	 call	 ?AddF@TextID@@QAAXPBDZZ	; TextID::AddF
  00110	83 c4 18	 add	 esp, 24			; 00000018H

; 94   : 		}

  00113	e9 3f ff ff ff	 jmp	 $L63518
$L63519:

; 95   : 		
; 96   : 		buf.Add("\r\n");

  00118	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02PIMC@?$AN?6?$AA@ ; `string'
  0011d	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00120	e8 00 00 00 00	 call	 ?Add@TextID@@QAEXPBD@Z	; TextID::Add
$L63512:

; 97   : 	}

  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c2 04 00	 ret	 4
?MakeDebugDetailStr@ResourceList@@QAEXAAVTextID@@@Z ENDP ; ResourceList::MakeDebugDetailStr
_TEXT	ENDS
;	COMDAT ??AResTagID@@QAEAAUResTag@@H@Z
_TEXT	SEGMENT
_s$ = 8
_this$ = -4
??AResTagID@@QAEAAUResTag@@H@Z PROC NEAR		; ResTagID::operator[], COMDAT

; 59   : 	ResTag&	operator[](int s) { return (**this)[s]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??DFakeResTagID@@QBEPAUResTag@@XZ ; FakeResTagID::operator*
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00012	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
??AResTagID@@QAEAAUResTag@@H@Z ENDP			; ResTagID::operator[]
_TEXT	ENDS
;	COMDAT ??0TextID@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0TextID@@QAE@ABV0@@Z PROC NEAR			; TextID::TextID, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0TextID@@QAE@ABV0@@Z ENDP				; TextID::TextID
_TEXT	ENDS
EXTRN	?Unlock@MemID@@QBEPAXXZ:NEAR			; MemID::Unlock
_TEXT	SEGMENT
$T64762 = -8
_resType$ = 8
_resNum$ = 12
_this$ = -12
_id$ = -4
?Unlock@ResourceMgr@@UAEXW4MemType@@G@Z PROC NEAR	; ResourceMgr::Unlock

; 371  : {

  010c7	55		 push	 ebp
  010c8	8b ec		 mov	 ebp, esp
  010ca	83 ec 0c	 sub	 esp, 12			; 0000000cH
  010cd	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 372  : 	// See if the given resource is in memory
; 373  : 
; 374  : 	MemID id = Find(resType, resNum);

  010d0	66 8b 45 0c	 mov	 ax, WORD PTR _resNum$[ebp]
  010d4	50		 push	 eax
  010d5	8b 4d 08	 mov	 ecx, DWORD PTR _resType$[ebp]
  010d8	51		 push	 ecx
  010d9	8d 55 f8	 lea	 edx, DWORD PTR $T64762[ebp]
  010dc	52		 push	 edx
  010dd	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  010e0	8b 10		 mov	 edx, DWORD PTR [eax]
  010e2	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  010e5	ff 52 18	 call	 DWORD PTR [edx+24]
  010e8	50		 push	 eax
  010e9	8d 4d fc	 lea	 ecx, DWORD PTR _id$[ebp]
  010ec	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID

; 375  : 	if (id)

  010f1	8d 4d fc	 lea	 ecx, DWORD PTR _id$[ebp]
  010f4	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  010f9	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  010fe	85 c0		 test	 eax, eax
  01100	74 08		 je	 SHORT $L63822

; 376  : 		id.Unlock();

  01102	8d 4d fc	 lea	 ecx, DWORD PTR _id$[ebp]
  01105	e8 00 00 00 00	 call	 ?Unlock@MemID@@QBEPAXXZ	; MemID::Unlock
$L63822:

; 377  : }

  0110a	8b e5		 mov	 esp, ebp
  0110c	5d		 pop	 ebp
  0110d	c2 08 00	 ret	 8
?Unlock@ResourceMgr@@UAEXW4MemType@@G@Z ENDP		; ResourceMgr::Unlock
$T64764 = -8
_resType$ = 8
_resNum$ = 12
_this$ = -12
_id$ = -4
?Release@ResourceMgr@@UAEXW4MemType@@G@Z PROC NEAR	; ResourceMgr::Release

; 381  : {

  01110	55		 push	 ebp
  01111	8b ec		 mov	 ebp, esp
  01113	83 ec 0c	 sub	 esp, 12			; 0000000cH
  01116	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 382  : 	MemID id = Find(resType, resNum);

  01119	66 8b 45 0c	 mov	 ax, WORD PTR _resNum$[ebp]
  0111d	50		 push	 eax
  0111e	8b 4d 08	 mov	 ecx, DWORD PTR _resType$[ebp]
  01121	51		 push	 ecx
  01122	8d 55 f8	 lea	 edx, DWORD PTR $T64764[ebp]
  01125	52		 push	 edx
  01126	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  01129	8b 10		 mov	 edx, DWORD PTR [eax]
  0112b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0112e	ff 52 18	 call	 DWORD PTR [edx+24]
  01131	50		 push	 eax
  01132	8d 4d fc	 lea	 ecx, DWORD PTR _id$[ebp]
  01135	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID

; 383  : 	if (id)

  0113a	8d 4d fc	 lea	 ecx, DWORD PTR _id$[ebp]
  0113d	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  01142	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  01147	85 c0		 test	 eax, eax
  01149	74 08		 je	 SHORT $L63830

; 384  : 		id.Free();

  0114b	8d 4d fc	 lea	 ecx, DWORD PTR _id$[ebp]
  0114e	e8 00 00 00 00	 call	 ?Free@MemID@@QAEXXZ	; MemID::Free
$L63830:

; 385  : }

  01153	8b e5		 mov	 esp, ebp
  01155	5d		 pop	 ebp
  01156	c2 08 00	 ret	 8
?Release@ResourceMgr@@UAEXW4MemType@@G@Z ENDP		; ResourceMgr::Release
_TEXT	ENDS
PUBLIC	??0MemID@@QAE@G@Z				; MemID::MemID
_DATA	SEGMENT
	ORG $+1
$SG63841 DB	'Resource has invalid handle(0x%x) during ResourceMgr::Fi'
	DB	'nd ( %d, %d )', 00H
_DATA	ENDS
_TEXT	SEGMENT
_resType$ = 12
_resNum$ = 16
___$ReturnUdt$ = 8
_this$ = -20
_i$ = -4
_array$ = -8
_array$63844 = -12
_array$63848 = -16
?Find@ResourceMgr@@UAE?AVMemID@@W4MemType@@G@Z PROC NEAR ; ResourceMgr::Find

; 389  : {

  01159	55		 push	 ebp
  0115a	8b ec		 mov	 ebp, esp
  0115c	83 ec 14	 sub	 esp, 20			; 00000014H
  0115f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 390  : 	// See if the given resource is in memory
; 391  : 
; 392  : 	SCI16ToSCI32ResType(resType);

  01162	8d 45 0c	 lea	 eax, DWORD PTR _resType$[ebp]
  01165	50		 push	 eax
  01166	e8 00 00 00 00	 call	 ?SCI16ToSCI32ResType@@YAXAAW4MemType@@@Z ; SCI16ToSCI32ResType
  0116b	83 c4 04	 add	 esp, 4

; 393  : 	int i = GetIndex(resType, resNum);

  0116e	66 8b 4d 10	 mov	 cx, WORD PTR _resNum$[ebp]
  01172	51		 push	 ecx
  01173	8b 55 0c	 mov	 edx, DWORD PTR _resType$[ebp]
  01176	52		 push	 edx
  01177	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0117a	8b 10		 mov	 edx, DWORD PTR [eax]
  0117c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0117f	ff 52 5c	 call	 DWORD PTR [edx+92]
  01182	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 394  : 	ResTag* array = *resources[resType].id;

  01185	8b 4d 0c	 mov	 ecx, DWORD PTR _resType$[ebp]
  01188	6b c9 18	 imul	 ecx, 24			; 00000018H
  0118b	81 c1 04 00 00
	00		 add	 ecx, OFFSET FLAT:_resources+4
  01191	e8 00 00 00 00	 call	 ??DFakeResTagID@@QBEPAUResTag@@XZ ; FakeResTagID::operator*
  01196	89 45 f8	 mov	 DWORD PTR _array$[ebp], eax

; 395  : 	if (array[i].resNum == resNum) {

  01199	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0119c	8b 4d f8	 mov	 ecx, DWORD PTR _array$[ebp]
  0119f	33 d2		 xor	 edx, edx
  011a1	66 8b 14 81	 mov	 dx, WORD PTR [ecx+eax*4]
  011a5	8b 45 10	 mov	 eax, DWORD PTR _resNum$[ebp]
  011a8	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  011ad	3b d0		 cmp	 edx, eax
  011af	75 7e		 jne	 SHORT $L63839

; 396  : 		if ( array[i].id && !(array[i].id.IsValid()) )

  011b1	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  011b4	8b 55 f8	 mov	 edx, DWORD PTR _array$[ebp]
  011b7	8d 4c 8a 02	 lea	 ecx, DWORD PTR [edx+ecx*4+2]
  011bb	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  011c0	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  011c5	85 c0		 test	 eax, eax
  011c7	74 4b		 je	 SHORT $L63840
  011c9	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  011cc	8b 4d f8	 mov	 ecx, DWORD PTR _array$[ebp]
  011cf	8d 4c 81 02	 lea	 ecx, DWORD PTR [ecx+eax*4+2]
  011d3	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  011d8	f7 d8		 neg	 eax
  011da	1b c0		 sbb	 eax, eax
  011dc	40		 inc	 eax
  011dd	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  011e2	85 c0		 test	 eax, eax
  011e4	74 2e		 je	 SHORT $L63840

; 397  : 			msgMgr->Fatal ( "Resource has invalid handle(0x%x) during ResourceMgr::Find ( %d, %d )", array[i].id, resType, resNum );

  011e6	8b 55 10	 mov	 edx, DWORD PTR _resNum$[ebp]
  011e9	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  011ef	52		 push	 edx
  011f0	8b 45 0c	 mov	 eax, DWORD PTR _resType$[ebp]
  011f3	50		 push	 eax
  011f4	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  011f7	8b 55 f8	 mov	 edx, DWORD PTR _array$[ebp]
  011fa	66 8b 44 8a 02	 mov	 ax, WORD PTR [edx+ecx*4+2]
  011ff	50		 push	 eax
  01200	68 00 00 00 00	 push	 OFFSET FLAT:$SG63841
  01205	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  0120b	51		 push	 ecx
  0120c	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  01211	83 c4 14	 add	 esp, 20			; 00000014H
$L63840:

; 398  : 		return array[i].id;

  01214	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  01217	8b 45 f8	 mov	 eax, DWORD PTR _array$[ebp]
  0121a	8d 4c 90 02	 lea	 ecx, DWORD PTR [eax+edx*4+2]
  0121e	51		 push	 ecx
  0121f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  01222	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  01227	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0122a	e9 c0 00 00 00	 jmp	 $L63836
$L63839:

; 400  : 
; 401  : 	else if (resType == MemResAudio) {

  0122f	83 7d 0c 0d	 cmp	 DWORD PTR _resType$[ebp], 13 ; 0000000dH
  01233	75 54		 jne	 SHORT $L63843

; 402  : 		i = GetIndex(MemResWAVE, resNum);

  01235	66 8b 55 10	 mov	 dx, WORD PTR _resNum$[ebp]
  01239	52		 push	 edx
  0123a	6a 0c		 push	 12			; 0000000cH
  0123c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0123f	8b 10		 mov	 edx, DWORD PTR [eax]
  01241	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01244	ff 52 5c	 call	 DWORD PTR [edx+92]
  01247	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 403  : 		ResTag* array = *resources[MemResWAVE].id;

  0124a	b9 24 01 00 00	 mov	 ecx, OFFSET FLAT:_resources+292
  0124f	e8 00 00 00 00	 call	 ??DFakeResTagID@@QBEPAUResTag@@XZ ; FakeResTagID::operator*
  01254	89 45 f4	 mov	 DWORD PTR _array$63844[ebp], eax

; 404  : 		if (array[i].resNum == resNum)

  01257	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0125a	8b 4d f4	 mov	 ecx, DWORD PTR _array$63844[ebp]
  0125d	33 d2		 xor	 edx, edx
  0125f	66 8b 14 81	 mov	 dx, WORD PTR [ecx+eax*4]
  01263	8b 45 10	 mov	 eax, DWORD PTR _resNum$[ebp]
  01266	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0126b	3b d0		 cmp	 edx, eax
  0126d	75 18		 jne	 SHORT $L63845

; 405  : 			return array[i].id;

  0126f	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  01272	8b 55 f4	 mov	 edx, DWORD PTR _array$63844[ebp]
  01275	8d 44 8a 02	 lea	 eax, DWORD PTR [edx+ecx*4+2]
  01279	50		 push	 eax
  0127a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0127d	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  01282	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  01285	eb 68		 jmp	 SHORT $L63836
$L63845:

; 406  : 	} else if (resType == MemResWAVE) {

  01287	eb 59		 jmp	 SHORT $L63849
$L63843:
  01289	83 7d 0c 0c	 cmp	 DWORD PTR _resType$[ebp], 12 ; 0000000cH
  0128d	75 53		 jne	 SHORT $L63849

; 407  : 		i = GetIndex(MemResAudio, resNum);

  0128f	66 8b 4d 10	 mov	 cx, WORD PTR _resNum$[ebp]
  01293	51		 push	 ecx
  01294	6a 0d		 push	 13			; 0000000dH
  01296	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  01299	8b 02		 mov	 eax, DWORD PTR [edx]
  0129b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0129e	ff 50 5c	 call	 DWORD PTR [eax+92]
  012a1	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 408  : 		ResTag* array = *resources[MemResAudio].id;

  012a4	b9 3c 01 00 00	 mov	 ecx, OFFSET FLAT:_resources+316
  012a9	e8 00 00 00 00	 call	 ??DFakeResTagID@@QBEPAUResTag@@XZ ; FakeResTagID::operator*
  012ae	89 45 f0	 mov	 DWORD PTR _array$63848[ebp], eax

; 409  : 		if (array[i].resNum == resNum)

  012b1	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  012b4	8b 55 f0	 mov	 edx, DWORD PTR _array$63848[ebp]
  012b7	33 c0		 xor	 eax, eax
  012b9	66 8b 04 8a	 mov	 ax, WORD PTR [edx+ecx*4]
  012bd	8b 4d 10	 mov	 ecx, DWORD PTR _resNum$[ebp]
  012c0	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  012c6	3b c1		 cmp	 eax, ecx
  012c8	75 18		 jne	 SHORT $L63849

; 410  : 			return array[i].id;

  012ca	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  012cd	8b 45 f0	 mov	 eax, DWORD PTR _array$63848[ebp]
  012d0	8d 4c 90 02	 lea	 ecx, DWORD PTR [eax+edx*4+2]
  012d4	51		 push	 ecx
  012d5	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  012d8	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  012dd	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  012e0	eb 0d		 jmp	 SHORT $L63836
$L63849:

; 412  : 	return 0;

  012e2	6a 00		 push	 0
  012e4	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  012e7	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  012ec	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$L63836:

; 413  : }

  012ef	8b e5		 mov	 esp, ebp
  012f1	5d		 pop	 ebp
  012f2	c2 0c 00	 ret	 12			; 0000000cH
?Find@ResourceMgr@@UAE?AVMemID@@W4MemType@@G@Z ENDP	; ResourceMgr::Find
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0MemID@@QAE@G@Z PROC NEAR				; MemID::MemID, COMDAT

; 23   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 4d 08	 mov	 cx, WORD PTR _h$[ebp]
  0000e	66 89 08	 mov	 WORD PTR [eax], cx

; 24   : 	}

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??0MemID@@QAE@G@Z ENDP					; MemID::MemID
_TEXT	ENDS
_TEXT	SEGMENT
_resType$ = 8
_this$ = -8
_array$ = -4
?FindType@ResourceMgr@@UAEGW4MemType@@@Z PROC NEAR	; ResourceMgr::FindType

; 417  : {

  012f5	55		 push	 ebp
  012f6	8b ec		 mov	 ebp, esp
  012f8	83 ec 08	 sub	 esp, 8
  012fb	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 418  : 	// See if any resource of the given type is in memory
; 419  : 
; 420  : 	SCI16ToSCI32ResType(resType);

  012fe	8d 45 08	 lea	 eax, DWORD PTR _resType$[ebp]
  01301	50		 push	 eax
  01302	e8 00 00 00 00	 call	 ?SCI16ToSCI32ResType@@YAXAAW4MemType@@@Z ; SCI16ToSCI32ResType
  01307	83 c4 04	 add	 esp, 4

; 421  : 
; 422  : 	if (!resources[resType].curSize)

  0130a	8b 4d 08	 mov	 ecx, DWORD PTR _resType$[ebp]
  0130d	6b c9 18	 imul	 ecx, 24			; 00000018H
  01310	83 b9 08 00 00
	00 00		 cmp	 DWORD PTR _resources[ecx+8], 0
  01317	75 06		 jne	 SHORT $L63854

; 423  : 		return (ResNum)-1;

  01319	66 0d ff ff	 or	 ax, 65535		; 0000ffffH
  0131d	eb 1a		 jmp	 SHORT $L63853
$L63854:

; 424  : 	ResTag* array = *resources[resType].id;

  0131f	8b 4d 08	 mov	 ecx, DWORD PTR _resType$[ebp]
  01322	6b c9 18	 imul	 ecx, 24			; 00000018H
  01325	81 c1 04 00 00
	00		 add	 ecx, OFFSET FLAT:_resources+4
  0132b	e8 00 00 00 00	 call	 ??DFakeResTagID@@QBEPAUResTag@@XZ ; FakeResTagID::operator*
  01330	89 45 fc	 mov	 DWORD PTR _array$[ebp], eax

; 425  : 	return array[0].resNum;

  01333	8b 55 fc	 mov	 edx, DWORD PTR _array$[ebp]
  01336	66 8b 02	 mov	 ax, WORD PTR [edx]
$L63853:

; 426  : }

  01339	8b e5		 mov	 esp, ebp
  0133b	5d		 pop	 ebp
  0133c	c2 04 00	 ret	 4
?FindType@ResourceMgr@@UAEGW4MemType@@@Z ENDP		; ResourceMgr::FindType
_TEXT	ENDS
_BSS	SEGMENT
_?buf@?1??MakeName@ResourceMgr@@UAEPADW4MemType@@G@Z@4PADA DB 0105H DUP (?)
_BSS	ENDS
_TEXT	SEGMENT
_type$ = 8
_num$ = 12
_this$ = -4
?MakeName@ResourceMgr@@UAEPADW4MemType@@G@Z PROC NEAR	; ResourceMgr::MakeName

; 430  : {

  0133f	55		 push	 ebp
  01340	8b ec		 mov	 ebp, esp
  01342	51		 push	 ecx
  01343	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 431  : 	static char buf[MaxPath + 1];
; 432  : 	resources[type].obj->MakeName(buf, 0, num);

  01346	66 8b 45 0c	 mov	 ax, WORD PTR _num$[ebp]
  0134a	50		 push	 eax
  0134b	6a 00		 push	 0
  0134d	68 00 00 00 00	 push	 OFFSET FLAT:_?buf@?1??MakeName@ResourceMgr@@UAEPADW4MemType@@G@Z@4PADA
  01352	8b 4d 08	 mov	 ecx, DWORD PTR _type$[ebp]
  01355	6b c9 18	 imul	 ecx, 24			; 00000018H
  01358	8b 89 00 00 00
	00		 mov	 ecx, DWORD PTR _resources[ecx]
  0135e	8b 55 08	 mov	 edx, DWORD PTR _type$[ebp]
  01361	6b d2 18	 imul	 edx, 24			; 00000018H
  01364	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _resources[edx]
  0136a	8b 10		 mov	 edx, DWORD PTR [eax]
  0136c	ff 52 18	 call	 DWORD PTR [edx+24]

; 433  : 	return buf;

  0136f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_?buf@?1??MakeName@ResourceMgr@@UAEPADW4MemType@@G@Z@4PADA

; 434  : }

  01374	8b e5		 mov	 esp, ebp
  01376	5d		 pop	 ebp
  01377	c2 08 00	 ret	 8
?MakeName@ResourceMgr@@UAEPADW4MemType@@G@Z ENDP	; ResourceMgr::MakeName
_TEXT	ENDS
EXTRN	__imp__memmove:NEAR
_DATA	SEGMENT
	ORG $+2
$SG63882 DB	'Resource manager asked to free a resource handle that co'
	DB	'uld not be found. (type == %d)', 00H
_DATA	ENDS
_TEXT	SEGMENT
$T64770 = -20
_resType$ = 8
_handle$ = 12
_this$ = -24
_arraySize$ = -4
_array$ = -12
_i$ = -8
_size$63877 = -16
?Free@ResourceMgr@@UAEXW4MemType@@G@Z PROC NEAR		; ResourceMgr::Free

; 438  : {

  0137a	55		 push	 ebp
  0137b	8b ec		 mov	 ebp, esp
  0137d	83 ec 18	 sub	 esp, 24			; 00000018H
  01380	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 439  : 	// Find the index for a resource type and number
; 440  : 	// The index either matches or is the index of the first higher resource
; 441  : 	int		arraySize = resources[resType].curSize;

  01383	8b 45 08	 mov	 eax, DWORD PTR _resType$[ebp]
  01386	6b c0 18	 imul	 eax, 24			; 00000018H
  01389	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR _resources[eax+8]
  0138f	89 4d fc	 mov	 DWORD PTR _arraySize$[ebp], ecx

; 442  : 	ResTag*	array = *resources[resType].id;

  01392	8b 4d 08	 mov	 ecx, DWORD PTR _resType$[ebp]
  01395	6b c9 18	 imul	 ecx, 24			; 00000018H
  01398	81 c1 04 00 00
	00		 add	 ecx, OFFSET FLAT:_resources+4
  0139e	e8 00 00 00 00	 call	 ??DFakeResTagID@@QBEPAUResTag@@XZ ; FakeResTagID::operator*
  013a3	89 45 f4	 mov	 DWORD PTR _array$[ebp], eax

; 443  : 
; 444  : 	int i = 0;

  013a6	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 445  : 
; 446  : 	for ( ; i < arraySize; ++i) {

  013ad	eb 09		 jmp	 SHORT $L63872
$L63873:
  013af	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  013b2	83 c2 01	 add	 edx, 1
  013b5	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$L63872:
  013b8	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  013bb	3b 45 fc	 cmp	 eax, DWORD PTR _arraySize$[ebp]
  013be	0f 8d 9b 00 00
	00		 jge	 $L63874

; 447  : 		if ( ((int)array[i].id) == handle ) {

  013c4	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  013c7	8b 55 f4	 mov	 edx, DWORD PTR _array$[ebp]
  013ca	8d 4c 8a 02	 lea	 ecx, DWORD PTR [edx+ecx*4+2]
  013ce	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  013d3	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  013d8	8b 4d 0c	 mov	 ecx, DWORD PTR _handle$[ebp]
  013db	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  013e1	3b c1		 cmp	 eax, ecx
  013e3	75 75		 jne	 SHORT $L63876

; 448  : 			int size = (arraySize - i - 1) * sizeof(ResTag);

  013e5	8b 55 fc	 mov	 edx, DWORD PTR _arraySize$[ebp]
  013e8	2b 55 f8	 sub	 edx, DWORD PTR _i$[ebp]
  013eb	8d 04 95 fc ff
	ff ff		 lea	 eax, DWORD PTR [edx*4-4]
  013f2	89 45 f0	 mov	 DWORD PTR _size$63877[ebp], eax

; 449  : 			memmove((char *) &array[i], (char *) &array[i+1], size);

  013f5	8b 4d f0	 mov	 ecx, DWORD PTR _size$63877[ebp]
  013f8	51		 push	 ecx
  013f9	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  013fc	8b 45 f4	 mov	 eax, DWORD PTR _array$[ebp]
  013ff	8d 4c 90 04	 lea	 ecx, DWORD PTR [eax+edx*4+4]
  01403	51		 push	 ecx
  01404	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  01407	8b 45 f4	 mov	 eax, DWORD PTR _array$[ebp]
  0140a	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  0140d	51		 push	 ecx
  0140e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  01414	83 c4 0c	 add	 esp, 12			; 0000000cH

; 450  : 
; 451  : 			// Zero the last element
; 452  : 			array[arraySize-1].resNum = 0;

  01417	8b 55 fc	 mov	 edx, DWORD PTR _arraySize$[ebp]
  0141a	8b 45 f4	 mov	 eax, DWORD PTR _array$[ebp]
  0141d	66 c7 44 90 fc
	00 00		 mov	 WORD PTR [eax+edx*4-4], 0

; 453  : 			array[arraySize-1].id = 0;

  01424	6a 00		 push	 0
  01426	8d 4d ec	 lea	 ecx, DWORD PTR $T64770[ebp]
  01429	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  0142e	8b 4d fc	 mov	 ecx, DWORD PTR _arraySize$[ebp]
  01431	8b 55 f4	 mov	 edx, DWORD PTR _array$[ebp]
  01434	66 8b 45 ec	 mov	 ax, WORD PTR $T64770[ebp]
  01438	66 89 44 8a fe	 mov	 WORD PTR [edx+ecx*4-2], ax

; 454  : 
; 455  : 			//decrement the curSize property of the array
; 456  : 			resources[resType].curSize--;

  0143d	8b 4d 08	 mov	 ecx, DWORD PTR _resType$[ebp]
  01440	6b c9 18	 imul	 ecx, 24			; 00000018H
  01443	8b 91 08 00 00
	00		 mov	 edx, DWORD PTR _resources[ecx+8]
  01449	83 ea 01	 sub	 edx, 1
  0144c	8b 45 08	 mov	 eax, DWORD PTR _resType$[ebp]
  0144f	6b c0 18	 imul	 eax, 24			; 00000018H
  01452	89 90 08 00 00
	00		 mov	 DWORD PTR _resources[eax+8], edx

; 457  : 			
; 458  : 			return;

  01458	eb 1d		 jmp	 SHORT $L63868
$L63876:

; 460  : 	}

  0145a	e9 50 ff ff ff	 jmp	 $L63873
$L63874:

; 461  : 
; 462  : 	msgMgr->Fatal ( "Resource manager asked to free a resource handle that could not be found. (type == %d)", resType );

  0145f	8b 4d 08	 mov	 ecx, DWORD PTR _resType$[ebp]
  01462	51		 push	 ecx
  01463	68 00 00 00 00	 push	 OFFSET FLAT:$SG63882
  01468	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  0146e	52		 push	 edx
  0146f	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  01474	83 c4 0c	 add	 esp, 12			; 0000000cH
$L63868:

; 463  : }

  01477	8b e5		 mov	 esp, ebp
  01479	5d		 pop	 ebp
  0147a	c2 08 00	 ret	 8
?Free@ResourceMgr@@UAEXW4MemType@@G@Z ENDP		; ResourceMgr::Free
_resType$ = 8
_resNum$ = 12
_this$ = -16
_arraySize$ = -4
_array$ = -12
_i$ = -8
?GetIndex@ResourceMgr@@MAEHW4MemType@@G@Z PROC NEAR	; ResourceMgr::GetIndex

; 509  : {

  0147d	55		 push	 ebp
  0147e	8b ec		 mov	 ebp, esp
  01480	83 ec 10	 sub	 esp, 16			; 00000010H
  01483	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 510  : 	// Find the index for a resource type and number
; 511  : 	// The index either matches or is the index of the first higher resource
; 512  : 
; 513  : 	int		arraySize = resources[resType].curSize;

  01486	8b 45 08	 mov	 eax, DWORD PTR _resType$[ebp]
  01489	6b c0 18	 imul	 eax, 24			; 00000018H
  0148c	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR _resources[eax+8]
  01492	89 4d fc	 mov	 DWORD PTR _arraySize$[ebp], ecx

; 514  : 	ResTag*	array = *resources[resType].id;

  01495	8b 4d 08	 mov	 ecx, DWORD PTR _resType$[ebp]
  01498	6b c9 18	 imul	 ecx, 24			; 00000018H
  0149b	81 c1 04 00 00
	00		 add	 ecx, OFFSET FLAT:_resources+4
  014a1	e8 00 00 00 00	 call	 ??DFakeResTagID@@QBEPAUResTag@@XZ ; FakeResTagID::operator*
  014a6	89 45 f4	 mov	 DWORD PTR _array$[ebp], eax

; 515  : 
; 516  : 	int i = 0;

  014a9	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 517  : 
; 518  : 	// Linear search
; 519  : 	for ( ; i < arraySize; ++i) {

  014b0	eb 09		 jmp	 SHORT $L63891
$L63892:
  014b2	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  014b5	83 c2 01	 add	 edx, 1
  014b8	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$L63891:
  014bb	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  014be	3b 45 fc	 cmp	 eax, DWORD PTR _arraySize$[ebp]
  014c1	7d 3b		 jge	 SHORT $L63893

; 520  : 		if ( array[i].resNum == resNum )

  014c3	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  014c6	8b 55 f4	 mov	 edx, DWORD PTR _array$[ebp]
  014c9	33 c0		 xor	 eax, eax
  014cb	66 8b 04 8a	 mov	 ax, WORD PTR [edx+ecx*4]
  014cf	8b 4d 0c	 mov	 ecx, DWORD PTR _resNum$[ebp]
  014d2	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  014d8	3b c1		 cmp	 eax, ecx
  014da	75 05		 jne	 SHORT $L63894

; 521  : 			return i;

  014dc	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  014df	eb 20		 jmp	 SHORT $L63887
$L63894:

; 522  : 
; 523  : 		if (array[i].resNum > resNum)

  014e1	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  014e4	8b 45 f4	 mov	 eax, DWORD PTR _array$[ebp]
  014e7	33 c9		 xor	 ecx, ecx
  014e9	66 8b 0c 90	 mov	 cx, WORD PTR [eax+edx*4]
  014ed	8b 55 0c	 mov	 edx, DWORD PTR _resNum$[ebp]
  014f0	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  014f6	3b ca		 cmp	 ecx, edx
  014f8	7e 02		 jle	 SHORT $L63895

; 524  : 			break;

  014fa	eb 02		 jmp	 SHORT $L63893
$L63895:

; 525  : 	}

  014fc	eb b4		 jmp	 SHORT $L63892
$L63893:

; 526  : 
; 527  : 	return i;

  014fe	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
$L63887:

; 528  : }

  01501	8b e5		 mov	 esp, ebp
  01503	5d		 pop	 ebp
  01504	c2 08 00	 ret	 8
?GetIndex@ResourceMgr@@MAEHW4MemType@@G@Z ENDP		; ResourceMgr::GetIndex
_TEXT	ENDS
_DATA	SEGMENT
	ORG $+1
$SG63906 DB	'Out of resource array space on load of ( %d, %d )', 00H
_DATA	ENDS
_TEXT	SEGMENT
$T64773 = -24
_resType$ = 8
_resNum$ = 12
_this$ = -28
_i$ = -8
_array$ = -12
_arraySize$ = -4
_maxSize$ = -16
_size$63908 = -20
?AddIndex@ResourceMgr@@MAEHW4MemType@@G@Z PROC NEAR	; ResourceMgr::AddIndex

; 532  : {

  01507	55		 push	 ebp
  01508	8b ec		 mov	 ebp, esp
  0150a	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0150d	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 533  : 	// Add an entry to an array
; 534  : 
; 535  : 	// Get the index of the first higher resource
; 536  : 	int i = GetIndex(resType, resNum);

  01510	66 8b 45 0c	 mov	 ax, WORD PTR _resNum$[ebp]
  01514	50		 push	 eax
  01515	8b 4d 08	 mov	 ecx, DWORD PTR _resType$[ebp]
  01518	51		 push	 ecx
  01519	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  0151c	8b 02		 mov	 eax, DWORD PTR [edx]
  0151e	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  01521	ff 50 5c	 call	 DWORD PTR [eax+92]
  01524	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax

; 537  : 
; 538  : 	ResTagID array = resources[resType].id;

  01527	8b 4d 08	 mov	 ecx, DWORD PTR _resType$[ebp]
  0152a	6b c9 18	 imul	 ecx, 24			; 00000018H
  0152d	81 c1 04 00 00
	00		 add	 ecx, OFFSET FLAT:_resources+4
  01533	51		 push	 ecx
  01534	8d 4d f4	 lea	 ecx, DWORD PTR _array$[ebp]
  01537	e8 00 00 00 00	 call	 ??0ResTagID@@QAE@ABU0@@Z ; ResTagID::ResTagID

; 539  : 	int arraySize = resources[resType].curSize;

  0153c	8b 55 08	 mov	 edx, DWORD PTR _resType$[ebp]
  0153f	6b d2 18	 imul	 edx, 24			; 00000018H
  01542	8b 82 08 00 00
	00		 mov	 eax, DWORD PTR _resources[edx+8]
  01548	89 45 fc	 mov	 DWORD PTR _arraySize$[ebp], eax

; 540  : 	int maxSize	= resources[resType].maxSize;

  0154b	8b 4d 08	 mov	 ecx, DWORD PTR _resType$[ebp]
  0154e	6b c9 18	 imul	 ecx, 24			; 00000018H
  01551	8b 91 10 00 00
	00		 mov	 edx, DWORD PTR _resources[ecx+16]
  01557	89 55 f0	 mov	 DWORD PTR _maxSize$[ebp], edx

; 541  : 
; 542  : 	if (arraySize == maxSize ) {

  0155a	8b 45 fc	 mov	 eax, DWORD PTR _arraySize$[ebp]
  0155d	3b 45 f0	 cmp	 eax, DWORD PTR _maxSize$[ebp]
  01560	75 21		 jne	 SHORT $L63905

; 543  : 		msgMgr->Fatal ( "Out of resource array space on load of ( %d, %d )", resType, resNum );

  01562	8b 4d 0c	 mov	 ecx, DWORD PTR _resNum$[ebp]
  01565	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0156b	51		 push	 ecx
  0156c	8b 55 08	 mov	 edx, DWORD PTR _resType$[ebp]
  0156f	52		 push	 edx
  01570	68 00 00 00 00	 push	 OFFSET FLAT:$SG63906
  01575	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  0157a	50		 push	 eax
  0157b	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  01580	83 c4 10	 add	 esp, 16			; 00000010H
$L63905:

; 548  : 
; 549  : 	if (i < arraySize) {

  01583	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  01586	3b 4d fc	 cmp	 ecx, DWORD PTR _arraySize$[ebp]
  01589	7d 36		 jge	 SHORT $L63907

; 550  : 		// Shift every resListObj down
; 551  : 		int size = (arraySize - i) * sizeof(ResTag);

  0158b	8b 55 fc	 mov	 edx, DWORD PTR _arraySize$[ebp]
  0158e	2b 55 f8	 sub	 edx, DWORD PTR _i$[ebp]
  01591	c1 e2 02	 shl	 edx, 2
  01594	89 55 ec	 mov	 DWORD PTR _size$63908[ebp], edx

; 552  : 		memmove((char*) &array[i+1], (char*) &array[i], size);

  01597	8b 45 ec	 mov	 eax, DWORD PTR _size$63908[ebp]
  0159a	50		 push	 eax
  0159b	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0159e	51		 push	 ecx
  0159f	8d 4d f4	 lea	 ecx, DWORD PTR _array$[ebp]
  015a2	e8 00 00 00 00	 call	 ??AResTagID@@QAEAAUResTag@@H@Z ; ResTagID::operator[]
  015a7	50		 push	 eax
  015a8	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  015ab	83 c2 01	 add	 edx, 1
  015ae	52		 push	 edx
  015af	8d 4d f4	 lea	 ecx, DWORD PTR _array$[ebp]
  015b2	e8 00 00 00 00	 call	 ??AResTagID@@QAEAAUResTag@@H@Z ; ResTagID::operator[]
  015b7	50		 push	 eax
  015b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  015be	83 c4 0c	 add	 esp, 12			; 0000000cH
$L63907:

; 554  : 	array[i].resNum = resNum;

  015c1	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  015c4	50		 push	 eax
  015c5	8d 4d f4	 lea	 ecx, DWORD PTR _array$[ebp]
  015c8	e8 00 00 00 00	 call	 ??AResTagID@@QAEAAUResTag@@H@Z ; ResTagID::operator[]
  015cd	66 8b 4d 0c	 mov	 cx, WORD PTR _resNum$[ebp]
  015d1	66 89 08	 mov	 WORD PTR [eax], cx

; 555  : 	array[i].id = 0;

  015d4	6a 00		 push	 0
  015d6	8d 4d e8	 lea	 ecx, DWORD PTR $T64773[ebp]
  015d9	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  015de	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  015e1	52		 push	 edx
  015e2	8d 4d f4	 lea	 ecx, DWORD PTR _array$[ebp]
  015e5	e8 00 00 00 00	 call	 ??AResTagID@@QAEAAUResTag@@H@Z ; ResTagID::operator[]
  015ea	66 8b 4d e8	 mov	 cx, WORD PTR $T64773[ebp]
  015ee	66 89 48 02	 mov	 WORD PTR [eax+2], cx

; 556  : 
; 557  : 	//Bump up the curSize property of the array
; 558  : 	resources[resType].curSize++;

  015f2	8b 55 08	 mov	 edx, DWORD PTR _resType$[ebp]
  015f5	6b d2 18	 imul	 edx, 24			; 00000018H
  015f8	8b 82 08 00 00
	00		 mov	 eax, DWORD PTR _resources[edx+8]
  015fe	83 c0 01	 add	 eax, 1
  01601	8b 4d 08	 mov	 ecx, DWORD PTR _resType$[ebp]
  01604	6b c9 18	 imul	 ecx, 24			; 00000018H
  01607	89 81 08 00 00
	00		 mov	 DWORD PTR _resources[ecx+8], eax

; 559  : 	return i;

  0160d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]

; 560  : }

  01610	8b e5		 mov	 esp, ebp
  01612	5d		 pop	 ebp
  01613	c2 08 00	 ret	 8
?AddIndex@ResourceMgr@@MAEHW4MemType@@G@Z ENDP		; ResourceMgr::AddIndex
_TEXT	ENDS
_DATA	SEGMENT
	ORG $+2
$SG63921 DB	'Trying to delete a resource (%d, %d) that is not in the '
	DB	'resource list.', 00H
_DATA	ENDS
_TEXT	SEGMENT
$T64775 = -20
_resType$ = 8
_resNum$ = 12
_this$ = -24
_i$ = -12
_array$ = -16
_arraySize$ = -8
_size$ = -4
?DeleteIndex@ResourceMgr@@MAEXW4MemType@@G@Z PROC NEAR	; ResourceMgr::DeleteIndex

; 564  : {

  01616	55		 push	 ebp
  01617	8b ec		 mov	 ebp, esp
  01619	83 ec 18	 sub	 esp, 24			; 00000018H
  0161c	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 565  : 	// Subtract an entry from a particular array
; 566  : 
; 567  : 	// Check that it's in a resArray
; 568  : 	int i = GetIndex(resType, resNum);

  0161f	66 8b 45 0c	 mov	 ax, WORD PTR _resNum$[ebp]
  01623	50		 push	 eax
  01624	8b 4d 08	 mov	 ecx, DWORD PTR _resType$[ebp]
  01627	51		 push	 ecx
  01628	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0162b	8b 02		 mov	 eax, DWORD PTR [edx]
  0162d	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  01630	ff 50 5c	 call	 DWORD PTR [eax+92]
  01633	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax

; 569  : 	ResTag* array = *resources[resType].id;

  01636	8b 4d 08	 mov	 ecx, DWORD PTR _resType$[ebp]
  01639	6b c9 18	 imul	 ecx, 24			; 00000018H
  0163c	81 c1 04 00 00
	00		 add	 ecx, OFFSET FLAT:_resources+4
  01642	e8 00 00 00 00	 call	 ??DFakeResTagID@@QBEPAUResTag@@XZ ; FakeResTagID::operator*
  01647	89 45 f0	 mov	 DWORD PTR _array$[ebp], eax

; 570  : 
; 571  : 	if (array[i].resNum != resNum) 

  0164a	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0164d	8b 55 f0	 mov	 edx, DWORD PTR _array$[ebp]
  01650	33 c0		 xor	 eax, eax
  01652	66 8b 04 8a	 mov	 ax, WORD PTR [edx+ecx*4]
  01656	8b 4d 0c	 mov	 ecx, DWORD PTR _resNum$[ebp]
  01659	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0165f	3b c1		 cmp	 eax, ecx
  01661	74 22		 je	 SHORT $L63920

; 572  : 		msgMgr->Fatal ( "Trying to delete a resource (%d, %d) that is not in the resource list.", resType, resNum );

  01663	8b 55 0c	 mov	 edx, DWORD PTR _resNum$[ebp]
  01666	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  0166c	52		 push	 edx
  0166d	8b 45 08	 mov	 eax, DWORD PTR _resType$[ebp]
  01670	50		 push	 eax
  01671	68 00 00 00 00	 push	 OFFSET FLAT:$SG63921
  01676	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  0167c	51		 push	 ecx
  0167d	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  01682	83 c4 10	 add	 esp, 16			; 00000010H
$L63920:

; 573  : 
; 574  : 	int arraySize = resources[resType].curSize;

  01685	8b 55 08	 mov	 edx, DWORD PTR _resType$[ebp]
  01688	6b d2 18	 imul	 edx, 24			; 00000018H
  0168b	8b 82 08 00 00
	00		 mov	 eax, DWORD PTR _resources[edx+8]
  01691	89 45 f8	 mov	 DWORD PTR _arraySize$[ebp], eax

; 575  : 
; 576  : 	// Just move every entry below the index up one position
; 577  : 	int size = (arraySize - i - 1) * sizeof(ResTag);

  01694	8b 4d f8	 mov	 ecx, DWORD PTR _arraySize$[ebp]
  01697	2b 4d f4	 sub	 ecx, DWORD PTR _i$[ebp]
  0169a	8d 14 8d fc ff
	ff ff		 lea	 edx, DWORD PTR [ecx*4-4]
  016a1	89 55 fc	 mov	 DWORD PTR _size$[ebp], edx

; 578  : 	memmove((char *) &array[i], (char *) &array[i+1], size);

  016a4	8b 45 fc	 mov	 eax, DWORD PTR _size$[ebp]
  016a7	50		 push	 eax
  016a8	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  016ab	8b 55 f0	 mov	 edx, DWORD PTR _array$[ebp]
  016ae	8d 44 8a 04	 lea	 eax, DWORD PTR [edx+ecx*4+4]
  016b2	50		 push	 eax
  016b3	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  016b6	8b 55 f0	 mov	 edx, DWORD PTR _array$[ebp]
  016b9	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  016bc	50		 push	 eax
  016bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  016c3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 579  : 	// Zero the last element
; 580  : 	array[arraySize-1].resNum = 0;

  016c6	8b 4d f8	 mov	 ecx, DWORD PTR _arraySize$[ebp]
  016c9	8b 55 f0	 mov	 edx, DWORD PTR _array$[ebp]
  016cc	66 c7 44 8a fc
	00 00		 mov	 WORD PTR [edx+ecx*4-4], 0

; 581  : 	array[arraySize-1].id = 0;

  016d3	6a 00		 push	 0
  016d5	8d 4d ec	 lea	 ecx, DWORD PTR $T64775[ebp]
  016d8	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  016dd	8b 45 f8	 mov	 eax, DWORD PTR _arraySize$[ebp]
  016e0	8b 4d f0	 mov	 ecx, DWORD PTR _array$[ebp]
  016e3	66 8b 55 ec	 mov	 dx, WORD PTR $T64775[ebp]
  016e7	66 89 54 81 fe	 mov	 WORD PTR [ecx+eax*4-2], dx

; 582  : 
; 583  : 	//decrement the curSize property of the array
; 584  : 	resources[resType].curSize--;

  016ec	8b 45 08	 mov	 eax, DWORD PTR _resType$[ebp]
  016ef	6b c0 18	 imul	 eax, 24			; 00000018H
  016f2	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR _resources[eax+8]
  016f8	83 e9 01	 sub	 ecx, 1
  016fb	8b 55 08	 mov	 edx, DWORD PTR _resType$[ebp]
  016fe	6b d2 18	 imul	 edx, 24			; 00000018H
  01701	89 8a 08 00 00
	00		 mov	 DWORD PTR _resources[edx+8], ecx

; 585  : }

  01707	8b e5		 mov	 esp, ebp
  01709	5d		 pop	 ebp
  0170a	c2 08 00	 ret	 8
?DeleteIndex@ResourceMgr@@MAEXW4MemType@@G@Z ENDP	; ResourceMgr::DeleteIndex
_TEXT	ENDS
PUBLIC	?LoadResSums@ResourceMgr@@QAEXXZ		; ResourceMgr::LoadResSums
_TEXT	SEGMENT
_this$ = -4
?InitResourceMgr@ResourceMgr@@MAEXXZ PROC NEAR		; ResourceMgr::InitResourceMgr

; 639  : {

  0170d	55		 push	 ebp
  0170e	8b ec		 mov	 ebp, esp
  01710	51		 push	 ecx
  01711	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 640  : #ifdef DEBUG
; 641  : 	rmResList = New RmResList();
; 642  : #endif
; 643  : 	BuildPatchTables();

  01714	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01717	8b 10		 mov	 edx, DWORD PTR [eax]
  01719	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0171c	ff 52 08	 call	 DWORD PTR [edx+8]

; 644  : 	LoadResMaps();

  0171f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01722	8b 10		 mov	 edx, DWORD PTR [eax]
  01724	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01727	ff 52 28	 call	 DWORD PTR [edx+40]

; 645  : 	LoadResSums();

  0172a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0172d	e8 00 00 00 00	 call	 ?LoadResSums@ResourceMgr@@QAEXXZ ; ResourceMgr::LoadResSums

; 646  : }

  01732	8b e5		 mov	 esp, ebp
  01734	5d		 pop	 ebp
  01735	c3		 ret	 0
?InitResourceMgr@ResourceMgr@@MAEXXZ ENDP		; ResourceMgr::InitResourceMgr
_TEXT	ENDS
EXTRN	__imp__malloc:NEAR
EXTRN	__imp__fclose:NEAR
EXTRN	__imp__fopen:NEAR
EXTRN	__imp__fread:NEAR
_DATA	SEGMENT
	ORG $+1
$SG63940 DB	'rb', 00H
	ORG $+1
$SG63941 DB	'ressums.dat', 00H
_DATA	ENDS
_TEXT	SEGMENT
_this$ = -32
_x$ = -4
_file$ = -8
_resType$63943 = -12
_resCount$63944 = -16
_i$63953 = -20
_id$63957 = -28
_sum$63958 = -24
?LoadResSums@ResourceMgr@@QAEXXZ PROC NEAR		; ResourceMgr::LoadResSums

; 649  : {

  01736	55		 push	 ebp
  01737	8b ec		 mov	 ebp, esp
  01739	83 ec 20	 sub	 esp, 32			; 00000020H
  0173c	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 650  : 	for ( int x=0; x<MemResLast; x++ ) {

  0173f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  01746	eb 09		 jmp	 SHORT $L63936
$L63937:
  01748	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  0174b	83 c0 01	 add	 eax, 1
  0174e	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax
$L63936:
  01751	83 7d fc 17	 cmp	 DWORD PTR _x$[ebp], 23	; 00000017H
  01755	7d 2e		 jge	 SHORT $L63938

; 651  : 		resSumID[x] = NULL;

  01757	8b 4d fc	 mov	 ecx, DWORD PTR _x$[ebp]
  0175a	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  0175d	c7 44 8a 06 00
	00 00 00	 mov	 DWORD PTR [edx+ecx*4+6], 0

; 652  : 		resSums[x] = NULL;

  01765	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  01768	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0176b	c7 44 81 62 00
	00 00 00	 mov	 DWORD PTR [ecx+eax*4+98], 0

; 653  : 		resCounts[x] = 0;

  01773	8b 55 fc	 mov	 edx, DWORD PTR _x$[ebp]
  01776	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  01779	66 c7 84 50 be
	00 00 00 00 00	 mov	 WORD PTR [eax+edx*2+190], 0

; 654  : 	}

  01783	eb c3		 jmp	 SHORT $L63937
$L63938:

; 655  : 
; 656  : 	FILE *file = fopen ( "ressums.dat", "rb" );

  01785	68 00 00 00 00	 push	 OFFSET FLAT:$SG63940
  0178a	68 00 00 00 00	 push	 OFFSET FLAT:$SG63941
  0178f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  01795	83 c4 08	 add	 esp, 8
  01798	89 45 f8	 mov	 DWORD PTR _file$[ebp], eax

; 657  : 
; 658  : 	if ( file ) {

  0179b	83 7d f8 00	 cmp	 DWORD PTR _file$[ebp], 0
  0179f	0f 84 38 01 00
	00		 je	 $L63942
$L63946:

; 659  : 		unsigned char resType;
; 660  : 		unsigned short resCount;
; 661  : 
; 662  : 		while ( !feof ( file ) ) {

  017a5	8b 4d f8	 mov	 ecx, DWORD PTR _file$[ebp]
  017a8	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  017ab	83 e2 10	 and	 edx, 16			; 00000010H
  017ae	85 d2		 test	 edx, edx
  017b0	0f 85 1a 01 00
	00		 jne	 $L63947

; 663  : 			// read the type and number of resource checksums in the list
; 664  : 			if ( fread ( &resType, sizeof ( resType ), 1, file ) == 0 )

  017b6	8b 45 f8	 mov	 eax, DWORD PTR _file$[ebp]
  017b9	50		 push	 eax
  017ba	6a 01		 push	 1
  017bc	6a 01		 push	 1
  017be	8d 4d f4	 lea	 ecx, DWORD PTR _resType$63943[ebp]
  017c1	51		 push	 ecx
  017c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  017c8	83 c4 10	 add	 esp, 16			; 00000010H
  017cb	85 c0		 test	 eax, eax
  017cd	75 05		 jne	 SHORT $L63948

; 665  : 				break;

  017cf	e9 fc 00 00 00	 jmp	 $L63947
$L63948:

; 666  : 
; 667  : 			fread ( &resCount, sizeof ( resCount ), 1, file );

  017d4	8b 55 f8	 mov	 edx, DWORD PTR _file$[ebp]
  017d7	52		 push	 edx
  017d8	6a 01		 push	 1
  017da	6a 02		 push	 2
  017dc	8d 45 f0	 lea	 eax, DWORD PTR _resCount$63944[ebp]
  017df	50		 push	 eax
  017e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  017e6	83 c4 10	 add	 esp, 16			; 00000010H

; 668  : 
; 669  : 			// allocate room for the id's and sums for this chunk
; 670  : 			resSumID[resType] = (unsigned short *)malloc ( sizeof ( unsigned short ) * resCount );

  017e9	8b 4d f0	 mov	 ecx, DWORD PTR _resCount$63944[ebp]
  017ec	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  017f2	d1 e1		 shl	 ecx, 1
  017f4	51		 push	 ecx
  017f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  017fb	83 c4 04	 add	 esp, 4
  017fe	8b 55 f4	 mov	 edx, DWORD PTR _resType$63943[ebp]
  01801	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  01807	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0180a	89 44 91 06	 mov	 DWORD PTR [ecx+edx*4+6], eax

; 671  : 			resSums[resType] = (unsigned short *)malloc ( sizeof ( unsigned short ) * resCount );

  0180e	8b 55 f0	 mov	 edx, DWORD PTR _resCount$63944[ebp]
  01811	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  01817	d1 e2		 shl	 edx, 1
  01819	52		 push	 edx
  0181a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  01820	83 c4 04	 add	 esp, 4
  01823	8b 4d f4	 mov	 ecx, DWORD PTR _resType$63943[ebp]
  01826	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0182c	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  0182f	89 44 8a 62	 mov	 DWORD PTR [edx+ecx*4+98], eax

; 672  : 			resCounts[resType] = resCount;

  01833	8b 45 f4	 mov	 eax, DWORD PTR _resType$63943[ebp]
  01836	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0183b	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0183e	66 8b 55 f0	 mov	 dx, WORD PTR _resCount$63944[ebp]
  01842	66 89 94 41 be
	00 00 00	 mov	 WORD PTR [ecx+eax*2+190], dx

; 673  : 
; 674  : 			for ( int i=0; i<resCount; i++ ) {

  0184a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$63953[ebp], 0
  01851	eb 09		 jmp	 SHORT $L63954
$L63955:
  01853	8b 45 ec	 mov	 eax, DWORD PTR _i$63953[ebp]
  01856	83 c0 01	 add	 eax, 1
  01859	89 45 ec	 mov	 DWORD PTR _i$63953[ebp], eax
$L63954:
  0185c	8b 4d f0	 mov	 ecx, DWORD PTR _resCount$63944[ebp]
  0185f	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  01865	39 4d ec	 cmp	 DWORD PTR _i$63953[ebp], ecx
  01868	7d 61		 jge	 SHORT $L63956

; 675  : 				unsigned short id, sum;
; 676  : 				fread ( &id, sizeof ( id ), 1, file );

  0186a	8b 55 f8	 mov	 edx, DWORD PTR _file$[ebp]
  0186d	52		 push	 edx
  0186e	6a 01		 push	 1
  01870	6a 02		 push	 2
  01872	8d 45 e4	 lea	 eax, DWORD PTR _id$63957[ebp]
  01875	50		 push	 eax
  01876	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  0187c	83 c4 10	 add	 esp, 16			; 00000010H

; 677  : 				fread ( &sum, sizeof ( sum ), 1, file );

  0187f	8b 4d f8	 mov	 ecx, DWORD PTR _file$[ebp]
  01882	51		 push	 ecx
  01883	6a 01		 push	 1
  01885	6a 02		 push	 2
  01887	8d 55 e8	 lea	 edx, DWORD PTR _sum$63958[ebp]
  0188a	52		 push	 edx
  0188b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  01891	83 c4 10	 add	 esp, 16			; 00000010H

; 678  : 
; 679  : 				resSumID[resType][i] = id;

  01894	8b 45 f4	 mov	 eax, DWORD PTR _resType$63943[ebp]
  01897	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0189c	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0189f	8b 54 81 06	 mov	 edx, DWORD PTR [ecx+eax*4+6]
  018a3	8b 45 ec	 mov	 eax, DWORD PTR _i$63953[ebp]
  018a6	66 8b 4d e4	 mov	 cx, WORD PTR _id$63957[ebp]
  018aa	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx

; 680  : 				resSums[resType][i] = sum;

  018ae	8b 55 f4	 mov	 edx, DWORD PTR _resType$63943[ebp]
  018b1	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  018b7	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  018ba	8b 4c 90 62	 mov	 ecx, DWORD PTR [eax+edx*4+98]
  018be	8b 55 ec	 mov	 edx, DWORD PTR _i$63953[ebp]
  018c1	66 8b 45 e8	 mov	 ax, WORD PTR _sum$63958[ebp]
  018c5	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax

; 681  : 			}

  018c9	eb 88		 jmp	 SHORT $L63955
$L63956:

; 682  : 		}

  018cb	e9 d5 fe ff ff	 jmp	 $L63946
$L63947:

; 683  : 
; 684  : 		fclose ( file );

  018d0	8b 4d f8	 mov	 ecx, DWORD PTR _file$[ebp]
  018d3	51		 push	 ecx
  018d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  018da	83 c4 04	 add	 esp, 4
$L63942:

; 686  : }

  018dd	8b e5		 mov	 esp, ebp
  018df	5d		 pop	 ebp
  018e0	c3		 ret	 0
?LoadResSums@ResourceMgr@@QAEXXZ ENDP			; ResourceMgr::LoadResSums
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
PUBLIC	??0ResMaps@@QAE@XZ				; ResMaps::ResMaps
EXTRN	__imp__strrchr:NEAR
EXTRN	?Get@ConfigMgr@@QAEPADPADH@Z:NEAR		; ConfigMgr::Get
EXTRN	?GetNum@ConfigMgr@@QAEHPADHH@Z:NEAR		; ConfigMgr::GetNum
EXTRN	?configMgr@@3PAVConfigMgr@@A:DWORD		; configMgr
EXTRN	__imp__atoi:NEAR
EXTRN	__imp__isdigit:NEAR
EXTRN	?Load@MemID@@QAEHW4MemType@@PADIW4ReservedHandle@@@Z:NEAR ; MemID::Load
EXTRN	__imp__sprintf:NEAR
EXTRN	?FirstFile@@YAHPBDIPAU_WIN32_FIND_DATAA@@@Z:NEAR ; FirstFile
EXTRN	?NextFile@@YAHPAU_WIN32_FIND_DATAA@@@Z:NEAR	; NextFile
EXTRN	_strcpy:NEAR
EXTRN	_strcat:NEAR
EXTRN	_strlen:NEAR
_DATA	SEGMENT
$SG63968 DB	'resMap', 00H
	ORG $+1
$SG63972 DB	'\', 00H
	ORG $+2
$SG63973 DB	'%sRESMAP.*', 00H
	ORG $+1
$SG63989 DB	'maxOpenVols', 00H
$SG64002 DB	'%s%s', 00H
	ORG $+3
$SG64004 DB	'Unable to load %s', 00H
_DATA	ENDS
xdata$x	SEGMENT
$T64785	DD	019930520H
	DD	01H
	DD	FLAT:$T64787
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T64787	DD	0ffffffffH
	DD	FLAT:$L64783
xdata$x	ENDS
_TEXT	SEGMENT
$T64779 = -624
$T64780 = -628
__$EHRec$ = -12
_this$ = -632
_fileinfo$ = -608
_ext$ = -612
_n$ = -616
_t$ = -24
_mapName$ = -288
_cp$ = -20
_cp$63970 = -620
_$S31$ = -16
?LoadResMaps@ResourceMgr@@UAEXXZ PROC NEAR		; ResourceMgr::LoadResMaps

; 690  : {

  018e1	55		 push	 ebp
  018e2	8b ec		 mov	 ebp, esp
  018e4	6a ff		 push	 -1
  018e6	68 00 00 00 00	 push	 $L64786
  018eb	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  018f1	50		 push	 eax
  018f2	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  018f9	81 ec 70 02 00
	00		 sub	 esp, 624		; 00000270H
  018ff	89 8d 88 fd ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 691  : 	WIN32_FIND_DATA	fileinfo;
; 692  : 	int	ext, n, t;
; 693  : 	char	mapName[MaxPath+1], *cp;
; 694  : 
; 695  : 	strcpy(volPath, configMgr->Get("resMap",0));

  01905	6a 00		 push	 0
  01907	68 00 00 00 00	 push	 OFFSET FLAT:$SG63968
  0190c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?configMgr@@3PAVConfigMgr@@A ; configMgr
  01912	e8 00 00 00 00	 call	 ?Get@ConfigMgr@@QAEPADPADH@Z ; ConfigMgr::Get
  01917	50		 push	 eax
  01918	68 00 00 00 00	 push	 OFFSET FLAT:?volPath@@3PADA ; volPath
  0191d	e8 00 00 00 00	 call	 _strcpy
  01922	83 c4 08	 add	 esp, 8

; 696  : 	if (strlen(volPath)) {

  01925	68 00 00 00 00	 push	 OFFSET FLAT:?volPath@@3PADA ; volPath
  0192a	e8 00 00 00 00	 call	 _strlen
  0192f	83 c4 04	 add	 esp, 4
  01932	85 c0		 test	 eax, eax
  01934	74 47		 je	 SHORT $L63971

; 697  : 		char* cp = &volPath[strlen(volPath)-1];

  01936	68 00 00 00 00	 push	 OFFSET FLAT:?volPath@@3PADA ; volPath
  0193b	e8 00 00 00 00	 call	 _strlen
  01940	83 c4 04	 add	 esp, 4
  01943	8d 80 ff ff ff
	ff		 lea	 eax, DWORD PTR ?volPath@@3PADA[eax-1]
  01949	89 85 94 fd ff
	ff		 mov	 DWORD PTR _cp$63970[ebp], eax

; 698  : 		if (*cp != ':' && *cp != '\\')

  0194f	8b 8d 94 fd ff
	ff		 mov	 ecx, DWORD PTR _cp$63970[ebp]
  01955	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  01958	83 fa 3a	 cmp	 edx, 58			; 0000003aH
  0195b	74 20		 je	 SHORT $L63971
  0195d	8b 85 94 fd ff
	ff		 mov	 eax, DWORD PTR _cp$63970[ebp]
  01963	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  01966	83 f9 5c	 cmp	 ecx, 92			; 0000005cH
  01969	74 12		 je	 SHORT $L63971

; 699  : 			strcat(volPath,"\\");

  0196b	68 00 00 00 00	 push	 OFFSET FLAT:$SG63972
  01970	68 00 00 00 00	 push	 OFFSET FLAT:?volPath@@3PADA ; volPath
  01975	e8 00 00 00 00	 call	 _strcat
  0197a	83 c4 08	 add	 esp, 8
$L63971:

; 701  : 	sprintf(mapName,"%sRESMAP.*",volPath);

  0197d	68 00 00 00 00	 push	 OFFSET FLAT:?volPath@@3PADA ; volPath
  01982	68 00 00 00 00	 push	 OFFSET FLAT:$SG63973
  01987	8d 95 e0 fe ff
	ff		 lea	 edx, DWORD PTR _mapName$[ebp]
  0198d	52		 push	 edx
  0198e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  01994	83 c4 0c	 add	 esp, 12			; 0000000cH

; 702  : 
; 703  : 	if (!FirstFile(mapName,0,&fileinfo))

  01997	8d 85 a0 fd ff
	ff		 lea	 eax, DWORD PTR _fileinfo$[ebp]
  0199d	50		 push	 eax
  0199e	6a 00		 push	 0
  019a0	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _mapName$[ebp]
  019a6	51		 push	 ecx
  019a7	e8 00 00 00 00	 call	 ?FirstFile@@YAHPBDIPAU_WIN32_FIND_DATAA@@@Z ; FirstFile
  019ac	83 c4 0c	 add	 esp, 12			; 0000000cH
  019af	85 c0		 test	 eax, eax
  019b1	75 05		 jne	 SHORT $L63974

; 704  : 		return;

  019b3	e9 36 03 00 00	 jmp	 $L63961
$L63974:

; 706  : 		if (!(cp = strrchr(fileinfo.cFileName,'.')))

  019b8	6a 2e		 push	 46			; 0000002eH
  019ba	8d 95 cc fd ff
	ff		 lea	 edx, DWORD PTR _fileinfo$[ebp+44]
  019c0	52		 push	 edx
  019c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strrchr
  019c7	83 c4 08	 add	 esp, 8
  019ca	89 45 ec	 mov	 DWORD PTR _cp$[ebp], eax
  019cd	83 7d ec 00	 cmp	 DWORD PTR _cp$[ebp], 0
  019d1	75 02		 jne	 SHORT $L63978

; 707  : 			continue;

  019d3	eb 6b		 jmp	 SHORT $L63976
$L63978:

; 708  : 		if (strlen(++cp) != 3)

  019d5	8b 45 ec	 mov	 eax, DWORD PTR _cp$[ebp]
  019d8	83 c0 01	 add	 eax, 1
  019db	89 45 ec	 mov	 DWORD PTR _cp$[ebp], eax
  019de	8b 4d ec	 mov	 ecx, DWORD PTR _cp$[ebp]
  019e1	51		 push	 ecx
  019e2	e8 00 00 00 00	 call	 _strlen
  019e7	83 c4 04	 add	 esp, 4
  019ea	83 f8 03	 cmp	 eax, 3
  019ed	74 02		 je	 SHORT $L63979

; 709  : 			continue;

  019ef	eb 4f		 jmp	 SHORT $L63976
$L63979:

; 710  : 		if (!isdigit(*cp) || !isdigit(*(cp+1)) || !isdigit(*(cp+2)))

  019f1	8b 55 ec	 mov	 edx, DWORD PTR _cp$[ebp]
  019f4	0f be 02	 movsx	 eax, BYTE PTR [edx]
  019f7	50		 push	 eax
  019f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__isdigit
  019fe	83 c4 04	 add	 esp, 4
  01a01	85 c0		 test	 eax, eax
  01a03	74 2a		 je	 SHORT $L63981
  01a05	8b 4d ec	 mov	 ecx, DWORD PTR _cp$[ebp]
  01a08	0f be 51 01	 movsx	 edx, BYTE PTR [ecx+1]
  01a0c	52		 push	 edx
  01a0d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__isdigit
  01a13	83 c4 04	 add	 esp, 4
  01a16	85 c0		 test	 eax, eax
  01a18	74 15		 je	 SHORT $L63981
  01a1a	8b 45 ec	 mov	 eax, DWORD PTR _cp$[ebp]
  01a1d	0f be 48 02	 movsx	 ecx, BYTE PTR [eax+2]
  01a21	51		 push	 ecx
  01a22	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__isdigit
  01a28	83 c4 04	 add	 esp, 4
  01a2b	85 c0		 test	 eax, eax
  01a2d	75 02		 jne	 SHORT $L63980
$L63981:

; 711  : 			continue;

  01a2f	eb 0f		 jmp	 SHORT $L63976
$L63980:

; 712  : 		maxVolumes++;

  01a31	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?maxVolumes@@3HA ; maxVolumes
  01a37	83 c2 01	 add	 edx, 1
  01a3a	89 15 00 00 00
	00		 mov	 DWORD PTR ?maxVolumes@@3HA, edx ; maxVolumes
$L63976:

; 713  : 	} while (NextFile(&fileinfo));

  01a40	8d 85 a0 fd ff
	ff		 lea	 eax, DWORD PTR _fileinfo$[ebp]
  01a46	50		 push	 eax
  01a47	e8 00 00 00 00	 call	 ?NextFile@@YAHPAU_WIN32_FIND_DATAA@@@Z ; NextFile
  01a4c	83 c4 04	 add	 esp, 4
  01a4f	85 c0		 test	 eax, eax
  01a51	0f 85 61 ff ff
	ff		 jne	 $L63974

; 714  : 	if (!maxVolumes)

  01a57	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?maxVolumes@@3HA, 0 ; maxVolumes
  01a5e	75 05		 jne	 SHORT $L63982

; 715  : 		return;

  01a60	e9 89 02 00 00	 jmp	 $L63961
$L63982:

; 716  : 	resMaps = New ResMaps[maxVolumes];

  01a65	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?maxVolumes@@3HA ; maxVolumes
  01a6b	89 4d f0	 mov	 DWORD PTR _$S31$[ebp], ecx
  01a6e	8b 55 f0	 mov	 edx, DWORD PTR _$S31$[ebp]
  01a71	c1 e2 04	 shl	 edx, 4
  01a74	52		 push	 edx
  01a75	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  01a7a	83 c4 04	 add	 esp, 4
  01a7d	89 85 8c fd ff
	ff		 mov	 DWORD PTR $T64780[ebp], eax
  01a83	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  01a8a	83 bd 8c fd ff
	ff 00		 cmp	 DWORD PTR $T64780[ebp], 0
  01a91	74 25		 je	 SHORT $L64781
  01a93	68 00 00 00 00	 push	 OFFSET FLAT:??0ResMaps@@QAE@XZ ; ResMaps::ResMaps
  01a98	8b 45 f0	 mov	 eax, DWORD PTR _$S31$[ebp]
  01a9b	50		 push	 eax
  01a9c	6a 10		 push	 16			; 00000010H
  01a9e	8b 8d 8c fd ff
	ff		 mov	 ecx, DWORD PTR $T64780[ebp]
  01aa4	51		 push	 ecx
  01aa5	e8 00 00 00 00	 call	 ??_H@YGXPAXIHP6EX0@Z@Z	; `vector constructor iterator'
  01aaa	8b 95 8c fd ff
	ff		 mov	 edx, DWORD PTR $T64780[ebp]
  01ab0	89 95 84 fd ff
	ff		 mov	 DWORD PTR -636+[ebp], edx
  01ab6	eb 0a		 jmp	 SHORT $L64782
$L64781:
  01ab8	c7 85 84 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR -636+[ebp], 0
$L64782:
  01ac2	8b 85 84 fd ff
	ff		 mov	 eax, DWORD PTR -636+[ebp]
  01ac8	89 85 90 fd ff
	ff		 mov	 DWORD PTR $T64779[ebp], eax
  01ace	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01ad5	8b 8d 90 fd ff
	ff		 mov	 ecx, DWORD PTR $T64779[ebp]
  01adb	89 0d 00 00 00
	00		 mov	 DWORD PTR ?resMaps@@3PAUResMaps@@A, ecx ; resMaps

; 717  : 
; 718  : 	maxOpenVolumes = configMgr->GetNum("maxOpenVols", 0, 10);

  01ae1	6a 0a		 push	 10			; 0000000aH
  01ae3	6a 00		 push	 0
  01ae5	68 00 00 00 00	 push	 OFFSET FLAT:$SG63989
  01aea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?configMgr@@3PAVConfigMgr@@A ; configMgr
  01af0	e8 00 00 00 00	 call	 ?GetNum@ConfigMgr@@QAEHPADHH@Z ; ConfigMgr::GetNum
  01af5	a3 00 00 00 00	 mov	 DWORD PTR ?maxOpenVolumes@@3HA, eax ; maxOpenVolumes

; 719  : 
; 720  : 	if (!FirstFile(mapName,0,&fileinfo))

  01afa	8d 95 a0 fd ff
	ff		 lea	 edx, DWORD PTR _fileinfo$[ebp]
  01b00	52		 push	 edx
  01b01	6a 00		 push	 0
  01b03	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _mapName$[ebp]
  01b09	50		 push	 eax
  01b0a	e8 00 00 00 00	 call	 ?FirstFile@@YAHPBDIPAU_WIN32_FIND_DATAA@@@Z ; FirstFile
  01b0f	83 c4 0c	 add	 esp, 12			; 0000000cH
  01b12	85 c0		 test	 eax, eax
  01b14	75 05		 jne	 SHORT $L63990

; 721  : 		return;

  01b16	e9 d3 01 00 00	 jmp	 $L63961
$L63990:

; 722  : 	n = 0;

  01b1b	c7 85 98 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$[ebp], 0
$L63991:

; 724  : 		if (!(cp = strrchr(fileinfo.cFileName,'.')))

  01b25	6a 2e		 push	 46			; 0000002eH
  01b27	8d 8d cc fd ff
	ff		 lea	 ecx, DWORD PTR _fileinfo$[ebp+44]
  01b2d	51		 push	 ecx
  01b2e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strrchr
  01b34	83 c4 08	 add	 esp, 8
  01b37	89 45 ec	 mov	 DWORD PTR _cp$[ebp], eax
  01b3a	83 7d ec 00	 cmp	 DWORD PTR _cp$[ebp], 0
  01b3e	75 05		 jne	 SHORT $L63994

; 725  : 			continue;

  01b40	e9 92 01 00 00	 jmp	 $L63992
$L63994:

; 726  : 		if (strlen(++cp) != 3)

  01b45	8b 55 ec	 mov	 edx, DWORD PTR _cp$[ebp]
  01b48	83 c2 01	 add	 edx, 1
  01b4b	89 55 ec	 mov	 DWORD PTR _cp$[ebp], edx
  01b4e	8b 45 ec	 mov	 eax, DWORD PTR _cp$[ebp]
  01b51	50		 push	 eax
  01b52	e8 00 00 00 00	 call	 _strlen
  01b57	83 c4 04	 add	 esp, 4
  01b5a	83 f8 03	 cmp	 eax, 3
  01b5d	74 05		 je	 SHORT $L63995

; 727  : 			continue;

  01b5f	e9 73 01 00 00	 jmp	 $L63992
$L63995:

; 728  : 		if (!isdigit(*cp) || !isdigit(*(cp+1)) || !isdigit(*(cp+2)))

  01b64	8b 4d ec	 mov	 ecx, DWORD PTR _cp$[ebp]
  01b67	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  01b6a	52		 push	 edx
  01b6b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__isdigit
  01b71	83 c4 04	 add	 esp, 4
  01b74	85 c0		 test	 eax, eax
  01b76	74 2a		 je	 SHORT $L63997
  01b78	8b 45 ec	 mov	 eax, DWORD PTR _cp$[ebp]
  01b7b	0f be 48 01	 movsx	 ecx, BYTE PTR [eax+1]
  01b7f	51		 push	 ecx
  01b80	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__isdigit
  01b86	83 c4 04	 add	 esp, 4
  01b89	85 c0		 test	 eax, eax
  01b8b	74 15		 je	 SHORT $L63997
  01b8d	8b 55 ec	 mov	 edx, DWORD PTR _cp$[ebp]
  01b90	0f be 42 02	 movsx	 eax, BYTE PTR [edx+2]
  01b94	50		 push	 eax
  01b95	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__isdigit
  01b9b	83 c4 04	 add	 esp, 4
  01b9e	85 c0		 test	 eax, eax
  01ba0	75 05		 jne	 SHORT $L63996
$L63997:

; 729  : 			continue;

  01ba2	e9 30 01 00 00	 jmp	 $L63992
$L63996:

; 730  : 		ext = atoi(cp);

  01ba7	8b 4d ec	 mov	 ecx, DWORD PTR _cp$[ebp]
  01baa	51		 push	 ecx
  01bab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  01bb1	83 c4 04	 add	 esp, 4
  01bb4	89 85 9c fd ff
	ff		 mov	 DWORD PTR _ext$[ebp], eax

; 731  : 		// keep maps ordered per largest ext first
; 732  : 		for (t = n; t > 0; t--) {

  01bba	8b 95 98 fd ff
	ff		 mov	 edx, DWORD PTR _n$[ebp]
  01bc0	89 55 e8	 mov	 DWORD PTR _t$[ebp], edx
  01bc3	eb 09		 jmp	 SHORT $L63998
$L63999:
  01bc5	8b 45 e8	 mov	 eax, DWORD PTR _t$[ebp]
  01bc8	83 e8 01	 sub	 eax, 1
  01bcb	89 45 e8	 mov	 DWORD PTR _t$[ebp], eax
$L63998:
  01bce	83 7d e8 00	 cmp	 DWORD PTR _t$[ebp], 0
  01bd2	7e 54		 jle	 SHORT $L64000

; 733  : 			if (ext < resMaps[t-1].ext)

  01bd4	8b 4d e8	 mov	 ecx, DWORD PTR _t$[ebp]
  01bd7	83 e9 01	 sub	 ecx, 1
  01bda	c1 e1 04	 shl	 ecx, 4
  01bdd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?resMaps@@3PAUResMaps@@A ; resMaps
  01be3	8b 85 9c fd ff
	ff		 mov	 eax, DWORD PTR _ext$[ebp]
  01be9	3b 44 0a 0c	 cmp	 eax, DWORD PTR [edx+ecx+12]
  01bed	7d 02		 jge	 SHORT $L64001

; 734  : 				break;

  01bef	eb 37		 jmp	 SHORT $L64000
$L64001:

; 735  : 			resMaps[t] = resMaps[t-1];

  01bf1	8b 4d e8	 mov	 ecx, DWORD PTR _t$[ebp]
  01bf4	83 e9 01	 sub	 ecx, 1
  01bf7	c1 e1 04	 shl	 ecx, 4
  01bfa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?resMaps@@3PAUResMaps@@A ; resMaps
  01c00	03 d1		 add	 edx, ecx
  01c02	8b 45 e8	 mov	 eax, DWORD PTR _t$[ebp]
  01c05	c1 e0 04	 shl	 eax, 4
  01c08	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMaps@@3PAUResMaps@@A ; resMaps
  01c0e	03 c8		 add	 ecx, eax
  01c10	8b 02		 mov	 eax, DWORD PTR [edx]
  01c12	89 01		 mov	 DWORD PTR [ecx], eax
  01c14	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01c17	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  01c1a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  01c1d	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  01c20	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  01c23	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 736  : 		}

  01c26	eb 9d		 jmp	 SHORT $L63999
$L64000:

; 737  : 
; 738  : 		sprintf(mapName,"%s%s",volPath,fileinfo.cFileName);

  01c28	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _fileinfo$[ebp+44]
  01c2e	50		 push	 eax
  01c2f	68 00 00 00 00	 push	 OFFSET FLAT:?volPath@@3PADA ; volPath
  01c34	68 00 00 00 00	 push	 OFFSET FLAT:$SG64002
  01c39	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _mapName$[ebp]
  01c3f	51		 push	 ecx
  01c40	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  01c46	83 c4 10	 add	 esp, 16			; 00000010H

; 739  : 		if (!resMaps[t].id.Load(MemResMap, mapName, PERSIST | MOVEABLE))

  01c49	6a 00		 push	 0
  01c4b	68 00 02 08 00	 push	 524800			; 00080200H
  01c50	8d 95 e0 fe ff
	ff		 lea	 edx, DWORD PTR _mapName$[ebp]
  01c56	52		 push	 edx
  01c57	6a 10		 push	 16			; 00000010H
  01c59	8b 45 e8	 mov	 eax, DWORD PTR _t$[ebp]
  01c5c	c1 e0 04	 shl	 eax, 4
  01c5f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMaps@@3PAUResMaps@@A ; resMaps
  01c65	03 c8		 add	 ecx, eax
  01c67	e8 00 00 00 00	 call	 ?Load@MemID@@QAEHW4MemType@@PADIW4ReservedHandle@@@Z ; MemID::Load
  01c6c	85 c0		 test	 eax, eax
  01c6e	75 1b		 jne	 SHORT $L64003

; 740  : 			msgMgr->Fatal("Unable to load %s",mapName);

  01c70	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _mapName$[ebp]
  01c76	51		 push	 ecx
  01c77	68 00 00 00 00	 push	 OFFSET FLAT:$SG64004
  01c7c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  01c82	52		 push	 edx
  01c83	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  01c88	83 c4 0c	 add	 esp, 12			; 0000000cH
$L64003:

; 741  : 		resMaps[t].volFD = -1;

  01c8b	8b 45 e8	 mov	 eax, DWORD PTR _t$[ebp]
  01c8e	c1 e0 04	 shl	 eax, 4
  01c91	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMaps@@3PAUResMaps@@A ; resMaps
  01c97	c7 44 01 04 ff
	ff ff ff	 mov	 DWORD PTR [ecx+eax+4], -1

; 742  : 		resMaps[t].openOrder = 0;

  01c9f	8b 55 e8	 mov	 edx, DWORD PTR _t$[ebp]
  01ca2	c1 e2 04	 shl	 edx, 4
  01ca5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?resMaps@@3PAUResMaps@@A ; resMaps
  01caa	c7 44 10 08 00
	00 00 00	 mov	 DWORD PTR [eax+edx+8], 0

; 743  : 		resMaps[t].ext = ext;

  01cb2	8b 4d e8	 mov	 ecx, DWORD PTR _t$[ebp]
  01cb5	c1 e1 04	 shl	 ecx, 4
  01cb8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?resMaps@@3PAUResMaps@@A ; resMaps
  01cbe	8b 85 9c fd ff
	ff		 mov	 eax, DWORD PTR _ext$[ebp]
  01cc4	89 44 0a 0c	 mov	 DWORD PTR [edx+ecx+12], eax

; 744  : 		n++;

  01cc8	8b 8d 98 fd ff
	ff		 mov	 ecx, DWORD PTR _n$[ebp]
  01cce	83 c1 01	 add	 ecx, 1
  01cd1	89 8d 98 fd ff
	ff		 mov	 DWORD PTR _n$[ebp], ecx
$L63992:

; 745  : 	} while (NextFile(&fileinfo));

  01cd7	8d 95 a0 fd ff
	ff		 lea	 edx, DWORD PTR _fileinfo$[ebp]
  01cdd	52		 push	 edx
  01cde	e8 00 00 00 00	 call	 ?NextFile@@YAHPAU_WIN32_FIND_DATAA@@@Z ; NextFile
  01ce3	83 c4 04	 add	 esp, 4
  01ce6	85 c0		 test	 eax, eax
  01ce8	0f 85 37 fe ff
	ff		 jne	 $L63991
$L63961:

; 746  : 	assert(n == maxVolumes);
; 747  : }

  01cee	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01cf1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01cf8	8b e5		 mov	 esp, ebp
  01cfa	5d		 pop	 ebp
  01cfb	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L64783:
  00151	8b 85 8c fd ff
	ff		 mov	 eax, DWORD PTR $T64780[ebp]
  00157	50		 push	 eax
  00158	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0015d	59		 pop	 ecx
  0015e	c3		 ret	 0
$L64786:
  0015f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T64785
  00164	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?LoadResMaps@ResourceMgr@@UAEXXZ ENDP			; ResourceMgr::LoadResMaps
;	COMDAT ??0ResMaps@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0ResMaps@@QAE@XZ PROC NEAR				; ResMaps::ResMaps, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0ResMaps@@QAE@XZ ENDP					; ResMaps::ResMaps
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$L64016:
  00003	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00006	83 e8 01	 sub	 eax, 1
  00009	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  0000c	83 7d 10 00	 cmp	 DWORD PTR ___n$[ebp], 0
  00010	7c 11		 jl	 SHORT $L64017
  00012	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00015	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001b	03 4d 0c	 add	 ecx, DWORD PTR ___s$[ebp]
  0001e	89 4d 08	 mov	 DWORD PTR ___t$[ebp], ecx
  00021	eb e0		 jmp	 SHORT $L64016
$L64017:
  00023	5d		 pop	 ebp
  00024	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
EXTRN	__imp___access:NEAR
EXTRN	?Open@@YAHPBDI@Z:NEAR				; Open
_DATA	SEGMENT
	ORG $+2
$SG64033 DB	'%sRESMAP.%03d', 00H
	ORG $+2
$SG64035 DB	'Missing %s. You must re-install the game.', 00H
	ORG $+2
$SG64036 DB	'%sRESSCI.%03d', 00H
	ORG $+2
$SG64038 DB	'Unable to open %s', 00H
_DATA	ENDS
_TEXT	SEGMENT
_ndx$ = 8
_this$ = -536
_volName$ = -532
_mapName$ = -264
_n$ = -268
?OpenVolume@ResourceMgr@@UAEHH@Z PROC NEAR		; ResourceMgr::OpenVolume

; 751  : {

  01cfc	55		 push	 ebp
  01cfd	8b ec		 mov	 ebp, esp
  01cff	81 ec 18 02 00
	00		 sub	 esp, 536		; 00000218H
  01d05	89 8d e8 fd ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 752  : 	char	volName[MaxPath+1];
; 753  : 	char	mapName[MaxPath+1];
; 754  : 
; 755  : 	assert(ndx < maxVolumes);
; 756  : 
; 757  : 	if (resMaps[ndx].volFD != -1)

  01d0b	8b 45 08	 mov	 eax, DWORD PTR _ndx$[ebp]
  01d0e	c1 e0 04	 shl	 eax, 4
  01d11	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMaps@@3PAUResMaps@@A ; resMaps
  01d17	83 7c 01 04 ff	 cmp	 DWORD PTR [ecx+eax+4], -1
  01d1c	74 14		 je	 SHORT $L64026

; 758  : 		return resMaps[ndx].volFD;

  01d1e	8b 55 08	 mov	 edx, DWORD PTR _ndx$[ebp]
  01d21	c1 e2 04	 shl	 edx, 4
  01d24	a1 00 00 00 00	 mov	 eax, DWORD PTR ?resMaps@@3PAUResMaps@@A ; resMaps
  01d29	8b 44 10 04	 mov	 eax, DWORD PTR [eax+edx+4]
  01d2d	e9 c8 01 00 00	 jmp	 $L64022
$L64026:

; 759  : 	for (int n = 0; n < maxVolumes; n++) {

  01d32	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$[ebp], 0
  01d3c	eb 0f		 jmp	 SHORT $L64028
$L64029:
  01d3e	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _n$[ebp]
  01d44	83 c1 01	 add	 ecx, 1
  01d47	89 8d f4 fe ff
	ff		 mov	 DWORD PTR _n$[ebp], ecx
$L64028:
  01d4d	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _n$[ebp]
  01d53	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?maxVolumes@@3HA ; maxVolumes
  01d59	0f 8d fb 00 00
	00		 jge	 $L64030

; 760  : 		if (resMaps[n].openOrder == 0)

  01d5f	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  01d65	c1 e0 04	 shl	 eax, 4
  01d68	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMaps@@3PAUResMaps@@A ; resMaps
  01d6e	83 7c 01 08 00	 cmp	 DWORD PTR [ecx+eax+8], 0
  01d73	75 02		 jne	 SHORT $L64031

; 761  : 			continue;

  01d75	eb c7		 jmp	 SHORT $L64029
$L64031:

; 762  : 		if (++resMaps[n].openOrder > maxOpenVolumes) {

  01d77	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _n$[ebp]
  01d7d	c1 e2 04	 shl	 edx, 4
  01d80	a1 00 00 00 00	 mov	 eax, DWORD PTR ?resMaps@@3PAUResMaps@@A ; resMaps
  01d85	8b 4c 10 08	 mov	 ecx, DWORD PTR [eax+edx+8]
  01d89	83 c1 01	 add	 ecx, 1
  01d8c	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _n$[ebp]
  01d92	c1 e2 04	 shl	 edx, 4
  01d95	a1 00 00 00 00	 mov	 eax, DWORD PTR ?resMaps@@3PAUResMaps@@A ; resMaps
  01d9a	89 4c 10 08	 mov	 DWORD PTR [eax+edx+8], ecx
  01d9e	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _n$[ebp]
  01da4	c1 e1 04	 shl	 ecx, 4
  01da7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?resMaps@@3PAUResMaps@@A ; resMaps
  01dad	8b 44 0a 08	 mov	 eax, DWORD PTR [edx+ecx+8]
  01db1	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?maxOpenVolumes@@3HA ; maxOpenVolumes
  01db7	7e 4a		 jle	 SHORT $L64032

; 763  : 			::Close(resMaps[n].volFD);

  01db9	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _n$[ebp]
  01dbf	c1 e1 04	 shl	 ecx, 4
  01dc2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?resMaps@@3PAUResMaps@@A ; resMaps
  01dc8	8b 44 0a 04	 mov	 eax, DWORD PTR [edx+ecx+4]
  01dcc	50		 push	 eax
  01dcd	e8 00 00 00 00	 call	 ?Close@@YAHH@Z		; Close
  01dd2	83 c4 04	 add	 esp, 4

; 764  : 			resMaps[n].volFD = -1;

  01dd5	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _n$[ebp]
  01ddb	c1 e1 04	 shl	 ecx, 4
  01dde	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?resMaps@@3PAUResMaps@@A ; resMaps
  01de4	c7 44 0a 04 ff
	ff ff ff	 mov	 DWORD PTR [edx+ecx+4], -1

; 765  : 			resMaps[n].openOrder = 0;

  01dec	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  01df2	c1 e0 04	 shl	 eax, 4
  01df5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMaps@@3PAUResMaps@@A ; resMaps
  01dfb	c7 44 01 08 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+8], 0
$L64032:

; 767  : 		sprintf(mapName, "%sRESMAP.%03d",volPath, n);

  01e03	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _n$[ebp]
  01e09	52		 push	 edx
  01e0a	68 00 00 00 00	 push	 OFFSET FLAT:?volPath@@3PADA ; volPath
  01e0f	68 00 00 00 00	 push	 OFFSET FLAT:$SG64033
  01e14	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _mapName$[ebp]
  01e1a	50		 push	 eax
  01e1b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  01e21	83 c4 10	 add	 esp, 16			; 00000010H

; 768  : 
; 769  : 		if( ( _access( mapName, 0 ) ) == -1 )

  01e24	6a 00		 push	 0
  01e26	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _mapName$[ebp]
  01e2c	51		 push	 ecx
  01e2d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___access
  01e33	83 c4 08	 add	 esp, 8
  01e36	83 f8 ff	 cmp	 eax, -1
  01e39	75 1a		 jne	 SHORT $L64034

; 770  : 			msgMgr->Fatal("Missing %s. You must re-install the game.",mapName);

  01e3b	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _mapName$[ebp]
  01e41	52		 push	 edx
  01e42	68 00 00 00 00	 push	 OFFSET FLAT:$SG64035
  01e47	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  01e4c	50		 push	 eax
  01e4d	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  01e52	83 c4 0c	 add	 esp, 12			; 0000000cH
$L64034:

; 771  : 
; 772  : 	}

  01e55	e9 e4 fe ff ff	 jmp	 $L64029
$L64030:

; 773  : 	resMaps[ndx].openOrder = 1;

  01e5a	8b 4d 08	 mov	 ecx, DWORD PTR _ndx$[ebp]
  01e5d	c1 e1 04	 shl	 ecx, 4
  01e60	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?resMaps@@3PAUResMaps@@A ; resMaps
  01e66	c7 44 0a 08 01
	00 00 00	 mov	 DWORD PTR [edx+ecx+8], 1

; 774  : 
; 775  : 	sprintf(volName, "%sRESSCI.%03d", volPath, resMaps[ndx].ext);

  01e6e	8b 45 08	 mov	 eax, DWORD PTR _ndx$[ebp]
  01e71	c1 e0 04	 shl	 eax, 4
  01e74	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMaps@@3PAUResMaps@@A ; resMaps
  01e7a	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  01e7e	52		 push	 edx
  01e7f	68 00 00 00 00	 push	 OFFSET FLAT:?volPath@@3PADA ; volPath
  01e84	68 00 00 00 00	 push	 OFFSET FLAT:$SG64036
  01e89	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _volName$[ebp]
  01e8f	50		 push	 eax
  01e90	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  01e96	83 c4 10	 add	 esp, 16			; 00000010H

; 776  : 	if ((resMaps[ndx].volFD = ::Open(volName, O_RDONLY | O_BINARY)) == -1)

  01e99	68 00 80 00 00	 push	 32768			; 00008000H
  01e9e	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR _volName$[ebp]
  01ea4	51		 push	 ecx
  01ea5	e8 00 00 00 00	 call	 ?Open@@YAHPBDI@Z	; Open
  01eaa	83 c4 08	 add	 esp, 8
  01ead	8b 55 08	 mov	 edx, DWORD PTR _ndx$[ebp]
  01eb0	c1 e2 04	 shl	 edx, 4
  01eb3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMaps@@3PAUResMaps@@A ; resMaps
  01eb9	89 44 11 04	 mov	 DWORD PTR [ecx+edx+4], eax
  01ebd	8b 55 08	 mov	 edx, DWORD PTR _ndx$[ebp]
  01ec0	c1 e2 04	 shl	 edx, 4
  01ec3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?resMaps@@3PAUResMaps@@A ; resMaps
  01ec8	83 7c 10 04 ff	 cmp	 DWORD PTR [eax+edx+4], -1
  01ecd	75 1b		 jne	 SHORT $L64037

; 777  : 		msgMgr->Fatal("Unable to open %s",volName);

  01ecf	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR _volName$[ebp]
  01ed5	51		 push	 ecx
  01ed6	68 00 00 00 00	 push	 OFFSET FLAT:$SG64038
  01edb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  01ee1	52		 push	 edx
  01ee2	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  01ee7	83 c4 0c	 add	 esp, 12			; 0000000cH
$L64037:

; 778  : 
; 779  : 	return resMaps[ndx].volFD;

  01eea	8b 45 08	 mov	 eax, DWORD PTR _ndx$[ebp]
  01eed	c1 e0 04	 shl	 eax, 4
  01ef0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMaps@@3PAUResMaps@@A ; resMaps
  01ef6	8b 44 01 04	 mov	 eax, DWORD PTR [ecx+eax+4]
$L64022:

; 780  : }

  01efa	8b e5		 mov	 esp, ebp
  01efc	5d		 pop	 ebp
  01efd	c2 04 00	 ret	 4
?OpenVolume@ResourceMgr@@UAEHH@Z ENDP			; ResourceMgr::OpenVolume
_fd$ = 8
_this$ = -8
_n$ = -4
?VolumeOpen@ResourceMgr@@UAEHH@Z PROC NEAR		; ResourceMgr::VolumeOpen

; 784  : {

  01f00	55		 push	 ebp
  01f01	8b ec		 mov	 ebp, esp
  01f03	83 ec 08	 sub	 esp, 8
  01f06	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 785  : 	if (fd == -1)

  01f09	83 7d 08 ff	 cmp	 DWORD PTR _fd$[ebp], -1
  01f0d	75 04		 jne	 SHORT $L64043

; 786  : 		return False;

  01f0f	33 c0		 xor	 eax, eax
  01f11	eb 3c		 jmp	 SHORT $L64042
$L64043:

; 787  : 	for (int n = 0; n < maxVolumes; n++)

  01f13	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  01f1a	eb 09		 jmp	 SHORT $L64045
$L64046:
  01f1c	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  01f1f	83 c0 01	 add	 eax, 1
  01f22	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax
$L64045:
  01f25	8b 4d fc	 mov	 ecx, DWORD PTR _n$[ebp]
  01f28	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?maxVolumes@@3HA ; maxVolumes
  01f2e	7d 1d		 jge	 SHORT $L64047

; 788  : 		if (resMaps[n].volFD == fd)

  01f30	8b 55 fc	 mov	 edx, DWORD PTR _n$[ebp]
  01f33	c1 e2 04	 shl	 edx, 4
  01f36	a1 00 00 00 00	 mov	 eax, DWORD PTR ?resMaps@@3PAUResMaps@@A ; resMaps
  01f3b	8b 4c 10 04	 mov	 ecx, DWORD PTR [eax+edx+4]
  01f3f	3b 4d 08	 cmp	 ecx, DWORD PTR _fd$[ebp]
  01f42	75 07		 jne	 SHORT $L64048

; 789  : 			return True;

  01f44	b8 01 00 00 00	 mov	 eax, 1
  01f49	eb 04		 jmp	 SHORT $L64042
$L64048:

; 790  : 	return False;

  01f4b	eb cf		 jmp	 SHORT $L64046
$L64047:
  01f4d	33 c0		 xor	 eax, eax
$L64042:

; 791  : }

  01f4f	8b e5		 mov	 esp, ebp
  01f51	5d		 pop	 ebp
  01f52	c2 04 00	 ret	 4
?VolumeOpen@ResourceMgr@@UAEHH@Z ENDP			; ResourceMgr::VolumeOpen
_ndx$ = 12
___$ReturnUdt$ = 8
_this$ = -4
?GetResMapID@ResourceMgr@@UAE?AVMemID@@H@Z PROC NEAR	; ResourceMgr::GetResMapID

; 795  : {

  01f55	55		 push	 ebp
  01f56	8b ec		 mov	 ebp, esp
  01f58	51		 push	 ecx
  01f59	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 796  : 	return resMaps[ndx].id;

  01f5c	8b 45 0c	 mov	 eax, DWORD PTR _ndx$[ebp]
  01f5f	c1 e0 04	 shl	 eax, 4
  01f62	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMaps@@3PAUResMaps@@A ; resMaps
  01f68	03 c8		 add	 ecx, eax
  01f6a	51		 push	 ecx
  01f6b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  01f6e	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  01f73	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 797  : }

  01f76	8b e5		 mov	 esp, ebp
  01f78	5d		 pop	 ebp
  01f79	c2 08 00	 ret	 8
?GetResMapID@ResourceMgr@@UAE?AVMemID@@H@Z ENDP		; ResourceMgr::GetResMapID
_TEXT	ENDS
PUBLIC	?Get@MemID@@QAEXW4MemType@@IW4ReservedHandle@@I@Z ; MemID::Get
EXTRN	__imp__strupr:NEAR
EXTRN	?GetNTokens@ConfigMgr@@QAEHPAD@Z:NEAR		; ConfigMgr::GetNTokens
EXTRN	?Realloc@MemID@@QBEPAXI@Z:NEAR			; MemID::Realloc
EXTRN	_strcmp:NEAR
_DATA	SEGMENT
	ORG $+2
$SG64075 DB	'patchDir', 00H
	ORG $+3
$SG64081 DB	'patchDir', 00H
	ORG $+3
$SG64101 DB	'patchDir', 00H
	ORG $+3
$SG64102 DB	'\????????.???', 00H
_DATA	ENDS
_TEXT	SEGMENT
_this$ = -640
_filename$ = -272
_fileinfo$ = -612
_alloced$ = -284
_alloced36$ = -280
_ALOC$ = -616
_ALOC36$ = -8
_entry$ = -288
_entry36$ = -4
_dirNum$ = -620
_npatches$ = -292
_npatches36$ = -276
_type$64076 = -624
_id$64086 = -628
_t$64092 = -632
_t$64112 = -636
?BuildPatchTables@ResourceMgr@@UAEXXZ PROC NEAR		; ResourceMgr::BuildPatchTables

; 801  : {

  01f7c	55		 push	 ebp
  01f7d	8b ec		 mov	 ebp, esp
  01f7f	81 ec 80 02 00
	00		 sub	 esp, 640		; 00000280H
  01f85	89 8d 80 fd ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 	char		filename[MaxPath+1];
; 803  : 	WIN32_FIND_DATA	fileinfo;
; 804  : 	int			alloced, alloced36;
; 805  : 	const int	ALOC = 100, ALOC36 = 10;

  01f8b	c7 85 98 fd ff
	ff 64 00 00 00	 mov	 DWORD PTR _ALOC$[ebp], 100 ; 00000064H
  01f95	c7 45 f8 0a 00
	00 00		 mov	 DWORD PTR _ALOC36$[ebp], 10 ; 0000000aH

; 806  : 
; 807  : 	// get the patch tables...
; 808  : 	resPatches.Free();

  01f9c	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?resPatches@@3VMemID@@A ; resPatches
  01fa1	e8 00 00 00 00	 call	 ?Free@MemID@@QAEXXZ	; MemID::Free

; 809  : 	resPatches.Get(MemPatchTable, alloced = ALOC * sizeof(ResPatchEntry),
; 810  : 		PatchTableHandle, MOVEABLE);

  01fa6	68 00 02 00 00	 push	 512			; 00000200H
  01fab	6a 18		 push	 24			; 00000018H
  01fad	c7 85 e4 fe ff
	ff 90 01 00 00	 mov	 DWORD PTR _alloced$[ebp], 400 ; 00000190H
  01fb7	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _alloced$[ebp]
  01fbd	50		 push	 eax
  01fbe	6a 32		 push	 50			; 00000032H
  01fc0	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?resPatches@@3VMemID@@A ; resPatches
  01fc5	e8 00 00 00 00	 call	 ?Get@MemID@@QAEXW4MemType@@IW4ReservedHandle@@I@Z ; MemID::Get

; 811  : 	resPatches36.Free();

  01fca	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?resPatches36@@3VMemID@@A ; resPatches36
  01fcf	e8 00 00 00 00	 call	 ?Free@MemID@@QAEXXZ	; MemID::Free

; 812  : 	resPatches36.Get(MemPatchTable, alloced36 = ALOC36 * sizeof(ResPatch36Entry),
; 813  : 		Patch36TableHandle, MOVEABLE);

  01fd4	68 00 02 00 00	 push	 512			; 00000200H
  01fd9	6a 26		 push	 38			; 00000026H
  01fdb	c7 85 e8 fe ff
	ff 8c 00 00 00	 mov	 DWORD PTR _alloced36$[ebp], 140 ; 0000008cH
  01fe5	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _alloced36$[ebp]
  01feb	51		 push	 ecx
  01fec	6a 32		 push	 50			; 00000032H
  01fee	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?resPatches36@@3VMemID@@A ; resPatches36
  01ff3	e8 00 00 00 00	 call	 ?Get@MemID@@QAEXW4MemType@@IW4ReservedHandle@@I@Z ; MemID::Get

; 814  : 
; 815  : 	// ... and point to the start of them
; 816  : 	ResPatchEntry* entry = (ResPatchEntry *) *resPatches; 

  01ff8	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?resPatches@@3VMemID@@A ; resPatches
  01ffd	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  02002	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _entry$[ebp], eax

; 817  : 	ResPatch36Entry* entry36 = (ResPatch36Entry *) *resPatches36; 

  02008	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?resPatches36@@3VMemID@@A ; resPatches36
  0200d	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  02012	89 45 fc	 mov	 DWORD PTR _entry36$[ebp], eax

; 818  : 
; 819  : 	// locate all (if any) stand-alone resources...
; 820  : 	int dirNum, npatches, npatches36 = 0;

  02015	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _npatches36$[ebp], 0

; 821  : 	for (dirNum = 0, npatches = 0, npatches36 = 0;

  0201f	c7 85 94 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _dirNum$[ebp], 0
  02029	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _npatches$[ebp], 0
  02033	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _npatches36$[ebp], 0

; 822  : 		  dirNum < configMgr->GetNTokens("patchDir"); dirNum++) {

  0203d	eb 0f		 jmp	 SHORT $L64072
$L64073:
  0203f	8b 95 94 fd ff
	ff		 mov	 edx, DWORD PTR _dirNum$[ebp]
  02045	83 c2 01	 add	 edx, 1
  02048	89 95 94 fd ff
	ff		 mov	 DWORD PTR _dirNum$[ebp], edx
$L64072:
  0204e	68 00 00 00 00	 push	 OFFSET FLAT:$SG64075
  02053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?configMgr@@3PAVConfigMgr@@A ; configMgr
  02059	e8 00 00 00 00	 call	 ?GetNTokens@ConfigMgr@@QAEHPAD@Z ; ConfigMgr::GetNTokens
  0205e	39 85 94 fd ff
	ff		 cmp	 DWORD PTR _dirNum$[ebp], eax
  02064	0f 8d dd 03 00
	00		 jge	 $L64074

; 823  : 		// ... resource-type by resource-type...
; 824  : 		for (MemType type = MemResFirst; type <= MemResLast; type = MemType(type + 1)) {

  0206a	c7 85 90 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _type$64076[ebp], 0
  02074	eb 0f		 jmp	 SHORT $L64077
$L64078:
  02076	8b 85 90 fd ff
	ff		 mov	 eax, DWORD PTR _type$64076[ebp]
  0207c	83 c0 01	 add	 eax, 1
  0207f	89 85 90 fd ff
	ff		 mov	 DWORD PTR _type$64076[ebp], eax
$L64077:
  02085	83 bd 90 fd ff
	ff 17		 cmp	 DWORD PTR _type$64076[ebp], 23 ; 00000017H
  0208c	0f 8f f9 01 00
	00		 jg	 $L64079

; 825  : 			if (!resources[type].obj->GetExtension()[0])

  02092	8b 8d 90 fd ff
	ff		 mov	 ecx, DWORD PTR _type$64076[ebp]
  02098	6b c9 18	 imul	 ecx, 24			; 00000018H
  0209b	8b 89 00 00 00
	00		 mov	 ecx, DWORD PTR _resources[ecx]
  020a1	8b 95 90 fd ff
	ff		 mov	 edx, DWORD PTR _type$64076[ebp]
  020a7	6b d2 18	 imul	 edx, 24			; 00000018H
  020aa	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _resources[edx]
  020b0	8b 10		 mov	 edx, DWORD PTR [eax]
  020b2	ff 52 08	 call	 DWORD PTR [edx+8]
  020b5	0f be 00	 movsx	 eax, BYTE PTR [eax]
  020b8	85 c0		 test	 eax, eax
  020ba	75 02		 jne	 SHORT $L64080

; 826  : 				continue;

  020bc	eb b8		 jmp	 SHORT $L64078
$L64080:

; 828  : 				MakeWildName(filename, configMgr->Get("patchDir",dirNum));

  020be	8b 8d 94 fd ff
	ff		 mov	 ecx, DWORD PTR _dirNum$[ebp]
  020c4	51		 push	 ecx
  020c5	68 00 00 00 00	 push	 OFFSET FLAT:$SG64081
  020ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?configMgr@@3PAVConfigMgr@@A ; configMgr
  020d0	e8 00 00 00 00	 call	 ?Get@ConfigMgr@@QAEPADPADH@Z ; ConfigMgr::Get
  020d5	50		 push	 eax
  020d6	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _filename$[ebp]
  020dc	52		 push	 edx
  020dd	8b 85 90 fd ff
	ff		 mov	 eax, DWORD PTR _type$64076[ebp]
  020e3	6b c0 18	 imul	 eax, 24			; 00000018H
  020e6	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _resources[eax]
  020ec	8b 95 90 fd ff
	ff		 mov	 edx, DWORD PTR _type$64076[ebp]
  020f2	6b d2 18	 imul	 edx, 24			; 00000018H
  020f5	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _resources[edx]
  020fb	8b 10		 mov	 edx, DWORD PTR [eax]
  020fd	ff 52 1c	 call	 DWORD PTR [edx+28]

; 829  : 			if (FirstFile(filename,0,&fileinfo)) {

  02100	8d 85 9c fd ff
	ff		 lea	 eax, DWORD PTR _fileinfo$[ebp]
  02106	50		 push	 eax
  02107	6a 00		 push	 0
  02109	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _filename$[ebp]
  0210f	51		 push	 ecx
  02110	e8 00 00 00 00	 call	 ?FirstFile@@YAHPBDIPAU_WIN32_FIND_DATAA@@@Z ; FirstFile
  02115	83 c4 0c	 add	 esp, 12			; 0000000cH
  02118	85 c0		 test	 eax, eax
  0211a	0f 84 66 01 00
	00		 je	 $L64085
$L64083:

; 832  : 					// only consider this file if its basename is numeric...
; 833  : 					int	id;
; 834  : 					if ((id = atoi(fileinfo.cFileName)) || fileinfo.cFileName[0] == '0') {

  02120	8d 95 c8 fd ff
	ff		 lea	 edx, DWORD PTR _fileinfo$[ebp+44]
  02126	52		 push	 edx
  02127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0212d	83 c4 04	 add	 esp, 4
  02130	89 85 8c fd ff
	ff		 mov	 DWORD PTR _id$64086[ebp], eax
  02136	83 bd 8c fd ff
	ff 00		 cmp	 DWORD PTR _id$64086[ebp], 0
  0213d	75 10		 jne	 SHORT $L64088
  0213f	0f be 85 c8 fd
	ff ff		 movsx	 eax, BYTE PTR _fileinfo$[ebp+44]
  02146	83 f8 30	 cmp	 eax, 48			; 00000030H
  02149	0f 85 20 01 00
	00		 jne	 $L64098
$L64088:

; 835  : 						// found one!
; 836  : 						if (!(npatches % ALOC) && npatches >= ALOC) {

  0214f	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _npatches$[ebp]
  02155	99		 cdq
  02156	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0215b	f7 f9		 idiv	 ecx
  0215d	85 d2		 test	 edx, edx
  0215f	75 45		 jne	 SHORT $L64089
  02161	83 bd dc fe ff
	ff 64		 cmp	 DWORD PTR _npatches$[ebp], 100 ; 00000064H
  02168	7c 3c		 jl	 SHORT $L64089

; 837  : 							// increase the patch table size
; 838  : 							resPatches.Realloc(alloced += ALOC * sizeof(ResPatchEntry));

  0216a	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _alloced$[ebp]
  02170	81 c2 90 01 00
	00		 add	 edx, 400		; 00000190H
  02176	89 95 e4 fe ff
	ff		 mov	 DWORD PTR _alloced$[ebp], edx
  0217c	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _alloced$[ebp]
  02182	50		 push	 eax
  02183	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?resPatches@@3VMemID@@A ; resPatches
  02188	e8 00 00 00 00	 call	 ?Realloc@MemID@@QBEPAXI@Z ; MemID::Realloc

; 839  : 							entry = (ResPatchEntry *) *resPatches + npatches; 

  0218d	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?resPatches@@3VMemID@@A ; resPatches
  02192	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  02197	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _npatches$[ebp]
  0219d	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  021a0	89 95 e0 fe ff
	ff		 mov	 DWORD PTR _entry$[ebp], edx
$L64089:

; 843  : 						for (t = (ResPatchEntry *) *resPatches;

  021a6	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?resPatches@@3VMemID@@A ; resPatches
  021ab	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  021b0	89 85 88 fd ff
	ff		 mov	 DWORD PTR _t$64092[ebp], eax

; 844  : 								t != entry; t++)

  021b6	eb 0f		 jmp	 SHORT $L64094
$L64095:
  021b8	8b 85 88 fd ff
	ff		 mov	 eax, DWORD PTR _t$64092[ebp]
  021be	83 c0 04	 add	 eax, 4
  021c1	89 85 88 fd ff
	ff		 mov	 DWORD PTR _t$64092[ebp], eax
$L64094:
  021c7	8b 8d 88 fd ff
	ff		 mov	 ecx, DWORD PTR _t$64092[ebp]
  021cd	3b 8d e0 fe ff
	ff		 cmp	 ecx, DWORD PTR _entry$[ebp]
  021d3	74 2b		 je	 SHORT $L64096

; 845  : 							if (t->resType == type && t->resId == id)

  021d5	8b 95 88 fd ff
	ff		 mov	 edx, DWORD PTR _t$64092[ebp]
  021db	33 c0		 xor	 eax, eax
  021dd	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  021e0	3b 85 90 fd ff
	ff		 cmp	 eax, DWORD PTR _type$64076[ebp]
  021e6	75 16		 jne	 SHORT $L64097
  021e8	8b 8d 88 fd ff
	ff		 mov	 ecx, DWORD PTR _t$64092[ebp]
  021ee	33 d2		 xor	 edx, edx
  021f0	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  021f4	3b 95 8c fd ff
	ff		 cmp	 edx, DWORD PTR _id$64086[ebp]
  021fa	75 02		 jne	 SHORT $L64097

; 846  : 								// it's a dupe!
; 847  : 								break;

  021fc	eb 02		 jmp	 SHORT $L64096
$L64097:

; 848  : 						if (t == entry) {

  021fe	eb b8		 jmp	 SHORT $L64095
$L64096:
  02200	8b 85 88 fd ff
	ff		 mov	 eax, DWORD PTR _t$64092[ebp]
  02206	3b 85 e0 fe ff
	ff		 cmp	 eax, DWORD PTR _entry$[ebp]
  0220c	75 61		 jne	 SHORT $L64098

; 849  : 							// wasn't found so it's a new resource!
; 850  : 							entry->patchDir = dirNum;

  0220e	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _entry$[ebp]
  02214	8a 95 94 fd ff
	ff		 mov	 dl, BYTE PTR _dirNum$[ebp]
  0221a	88 11		 mov	 BYTE PTR [ecx], dl

; 851  : 							if (type == MemResWAVE)

  0221c	83 bd 90 fd ff
	ff 0c		 cmp	 DWORD PTR _type$64076[ebp], 12 ; 0000000cH
  02223	75 0c		 jne	 SHORT $L64099

; 852  : 								entry->resType = MemResAudio;

  02225	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _entry$[ebp]
  0222b	c6 40 01 0d	 mov	 BYTE PTR [eax+1], 13	; 0000000dH

; 853  : 							else

  0222f	eb 0f		 jmp	 SHORT $L64100
$L64099:

; 854  : 								entry->resType = type;

  02231	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _entry$[ebp]
  02237	8a 95 90 fd ff
	ff		 mov	 dl, BYTE PTR _type$64076[ebp]
  0223d	88 51 01	 mov	 BYTE PTR [ecx+1], dl
$L64100:

; 855  : 							entry->resId = id;

  02240	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _entry$[ebp]
  02246	66 8b 8d 8c fd
	ff ff		 mov	 cx, WORD PTR _id$64086[ebp]
  0224d	66 89 48 02	 mov	 WORD PTR [eax+2], cx

; 856  : 							entry++;

  02251	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _entry$[ebp]
  02257	83 c2 04	 add	 edx, 4
  0225a	89 95 e0 fe ff
	ff		 mov	 DWORD PTR _entry$[ebp], edx

; 857  : 							npatches++;

  02260	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _npatches$[ebp]
  02266	83 c0 01	 add	 eax, 1
  02269	89 85 dc fe ff
	ff		 mov	 DWORD PTR _npatches$[ebp], eax
$L64098:

; 860  : 				} while (NextFile(&fileinfo));

  0226f	8d 8d 9c fd ff
	ff		 lea	 ecx, DWORD PTR _fileinfo$[ebp]
  02275	51		 push	 ecx
  02276	e8 00 00 00 00	 call	 ?NextFile@@YAHPAU_WIN32_FIND_DATAA@@@Z ; NextFile
  0227b	83 c4 04	 add	 esp, 4
  0227e	85 c0		 test	 eax, eax
  02280	0f 85 9a fe ff
	ff		 jne	 $L64083
$L64085:

; 862  : 		}

  02286	e9 eb fd ff ff	 jmp	 $L64078
$L64079:

; 863  : 		strcpy(filename,configMgr->Get("patchDir",dirNum));

  0228b	8b 95 94 fd ff
	ff		 mov	 edx, DWORD PTR _dirNum$[ebp]
  02291	52		 push	 edx
  02292	68 00 00 00 00	 push	 OFFSET FLAT:$SG64101
  02297	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?configMgr@@3PAVConfigMgr@@A ; configMgr
  0229d	e8 00 00 00 00	 call	 ?Get@ConfigMgr@@QAEPADPADH@Z ; ConfigMgr::Get
  022a2	50		 push	 eax
  022a3	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _filename$[ebp]
  022a9	50		 push	 eax
  022aa	e8 00 00 00 00	 call	 _strcpy
  022af	83 c4 08	 add	 esp, 8

; 864  : 		strcat(filename,"\\????????.???");

  022b2	68 00 00 00 00	 push	 OFFSET FLAT:$SG64102
  022b7	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _filename$[ebp]
  022bd	51		 push	 ecx
  022be	e8 00 00 00 00	 call	 _strcat
  022c3	83 c4 08	 add	 esp, 8

; 865  : 		if (FirstFile(filename,0,&fileinfo)) {

  022c6	8d 95 9c fd ff
	ff		 lea	 edx, DWORD PTR _fileinfo$[ebp]
  022cc	52		 push	 edx
  022cd	6a 00		 push	 0
  022cf	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _filename$[ebp]
  022d5	50		 push	 eax
  022d6	e8 00 00 00 00	 call	 ?FirstFile@@YAHPBDIPAU_WIN32_FIND_DATAA@@@Z ; FirstFile
  022db	83 c4 0c	 add	 esp, 12			; 0000000cH
  022de	85 c0		 test	 eax, eax
  022e0	0f 84 5c 01 00
	00		 je	 $L64106
$L64104:

; 867  : 				if (strlen(fileinfo.cFileName) != 12)

  022e6	8d 8d c8 fd ff
	ff		 lea	 ecx, DWORD PTR _fileinfo$[ebp+44]
  022ec	51		 push	 ecx
  022ed	e8 00 00 00 00	 call	 _strlen
  022f2	83 c4 04	 add	 esp, 4
  022f5	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  022f8	74 05		 je	 SHORT $L64107

; 868  : 					continue;

  022fa	e9 2c 01 00 00	 jmp	 $L64118
$L64107:

; 869  : 				strupr(fileinfo.cFileName);

  022ff	8d 95 c8 fd ff
	ff		 lea	 edx, DWORD PTR _fileinfo$[ebp+44]
  02305	52		 push	 edx
  02306	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strupr
  0230c	83 c4 04	 add	 esp, 4

; 871  : 					 fileinfo.cFileName[0] != 'B' && fileinfo.cFileName[0] != 'T')

  0230f	0f be 85 c8 fd
	ff ff		 movsx	 eax, BYTE PTR _fileinfo$[ebp+44]
  02316	83 f8 41	 cmp	 eax, 65			; 00000041H
  02319	74 29		 je	 SHORT $L64108
  0231b	0f be 8d c8 fd
	ff ff		 movsx	 ecx, BYTE PTR _fileinfo$[ebp+44]
  02322	83 f9 53	 cmp	 ecx, 83			; 00000053H
  02325	74 1d		 je	 SHORT $L64108
  02327	0f be 95 c8 fd
	ff ff		 movsx	 edx, BYTE PTR _fileinfo$[ebp+44]
  0232e	83 fa 42	 cmp	 edx, 66			; 00000042H
  02331	74 11		 je	 SHORT $L64108
  02333	0f be 85 c8 fd
	ff ff		 movsx	 eax, BYTE PTR _fileinfo$[ebp+44]
  0233a	83 f8 54	 cmp	 eax, 84			; 00000054H
  0233d	74 05		 je	 SHORT $L64108

; 872  : 					continue;

  0233f	e9 e7 00 00 00	 jmp	 $L64118
$L64108:

; 873  : 				if (!(npatches36 % ALOC36) && npatches36 >= ALOC36) {

  02344	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _npatches36$[ebp]
  0234a	99		 cdq
  0234b	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  02350	f7 f9		 idiv	 ecx
  02352	85 d2		 test	 edx, edx
  02354	75 44		 jne	 SHORT $L64109
  02356	83 bd ec fe ff
	ff 0a		 cmp	 DWORD PTR _npatches36$[ebp], 10 ; 0000000aH
  0235d	7c 3b		 jl	 SHORT $L64109

; 874  : 					// increase the patch36 table size
; 875  : 					resPatches36.Realloc(alloced36 += ALOC36 * sizeof(ResPatch36Entry));

  0235f	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _alloced36$[ebp]
  02365	81 c2 8c 00 00
	00		 add	 edx, 140		; 0000008cH
  0236b	89 95 e8 fe ff
	ff		 mov	 DWORD PTR _alloced36$[ebp], edx
  02371	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _alloced36$[ebp]
  02377	50		 push	 eax
  02378	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?resPatches36@@3VMemID@@A ; resPatches36
  0237d	e8 00 00 00 00	 call	 ?Realloc@MemID@@QBEPAXI@Z ; MemID::Realloc

; 876  : 					entry36 = (ResPatch36Entry *) *resPatches36 + npatches36; 

  02382	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?resPatches36@@3VMemID@@A ; resPatches36
  02387	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0238c	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _npatches36$[ebp]
  02392	6b c9 0e	 imul	 ecx, 14			; 0000000eH
  02395	03 c1		 add	 eax, ecx
  02397	89 45 fc	 mov	 DWORD PTR _entry36$[ebp], eax
$L64109:

; 880  : 				for (t = (ResPatch36Entry *) *resPatches36;

  0239a	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?resPatches36@@3VMemID@@A ; resPatches36
  0239f	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  023a4	89 85 84 fd ff
	ff		 mov	 DWORD PTR _t$64112[ebp], eax

; 881  : 						t != entry36; t++)

  023aa	eb 0f		 jmp	 SHORT $L64114
$L64115:
  023ac	8b 95 84 fd ff
	ff		 mov	 edx, DWORD PTR _t$64112[ebp]
  023b2	83 c2 0e	 add	 edx, 14			; 0000000eH
  023b5	89 95 84 fd ff
	ff		 mov	 DWORD PTR _t$64112[ebp], edx
$L64114:
  023bb	8b 85 84 fd ff
	ff		 mov	 eax, DWORD PTR _t$64112[ebp]
  023c1	3b 45 fc	 cmp	 eax, DWORD PTR _entry36$[ebp]
  023c4	74 21		 je	 SHORT $L64116

; 882  : 					if (!strcmp(t->resName,fileinfo.cFileName))

  023c6	8d 8d c8 fd ff
	ff		 lea	 ecx, DWORD PTR _fileinfo$[ebp+44]
  023cc	51		 push	 ecx
  023cd	8b 95 84 fd ff
	ff		 mov	 edx, DWORD PTR _t$64112[ebp]
  023d3	83 c2 01	 add	 edx, 1
  023d6	52		 push	 edx
  023d7	e8 00 00 00 00	 call	 _strcmp
  023dc	83 c4 08	 add	 esp, 8
  023df	85 c0		 test	 eax, eax
  023e1	75 02		 jne	 SHORT $L64117

; 883  : 						// it's a dup!
; 884  : 						break;

  023e3	eb 02		 jmp	 SHORT $L64116
$L64117:

; 885  : 				if (t == entry36) {

  023e5	eb c5		 jmp	 SHORT $L64115
$L64116:
  023e7	8b 85 84 fd ff
	ff		 mov	 eax, DWORD PTR _t$64112[ebp]
  023ed	3b 45 fc	 cmp	 eax, DWORD PTR _entry36$[ebp]
  023f0	75 39		 jne	 SHORT $L64118

; 886  : 					// wasn't found so it's a new resource!
; 887  : 					entry36->patchDir = dirNum;

  023f2	8b 4d fc	 mov	 ecx, DWORD PTR _entry36$[ebp]
  023f5	8a 95 94 fd ff
	ff		 mov	 dl, BYTE PTR _dirNum$[ebp]
  023fb	88 11		 mov	 BYTE PTR [ecx], dl

; 888  : 					strcpy(entry36->resName,fileinfo.cFileName);

  023fd	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR _fileinfo$[ebp+44]
  02403	50		 push	 eax
  02404	8b 4d fc	 mov	 ecx, DWORD PTR _entry36$[ebp]
  02407	83 c1 01	 add	 ecx, 1
  0240a	51		 push	 ecx
  0240b	e8 00 00 00 00	 call	 _strcpy
  02410	83 c4 08	 add	 esp, 8

; 889  : 					entry36++;

  02413	8b 55 fc	 mov	 edx, DWORD PTR _entry36$[ebp]
  02416	83 c2 0e	 add	 edx, 14			; 0000000eH
  02419	89 55 fc	 mov	 DWORD PTR _entry36$[ebp], edx

; 890  : 					npatches36++;

  0241c	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _npatches36$[ebp]
  02422	83 c0 01	 add	 eax, 1
  02425	89 85 ec fe ff
	ff		 mov	 DWORD PTR _npatches36$[ebp], eax
$L64118:

; 892  : 			} while (NextFile(&fileinfo));

  0242b	8d 8d 9c fd ff
	ff		 lea	 ecx, DWORD PTR _fileinfo$[ebp]
  02431	51		 push	 ecx
  02432	e8 00 00 00 00	 call	 ?NextFile@@YAHPAU_WIN32_FIND_DATAA@@@Z ; NextFile
  02437	83 c4 04	 add	 esp, 4
  0243a	85 c0		 test	 eax, eax
  0243c	0f 85 a4 fe ff
	ff		 jne	 $L64104
$L64106:

; 894  : 	}

  02442	e9 f8 fb ff ff	 jmp	 $L64073
$L64074:

; 895  : 
; 896  : 	if (!npatches) {

  02447	83 bd dc fe ff
	ff 00		 cmp	 DWORD PTR _npatches$[ebp], 0
  0244e	75 0c		 jne	 SHORT $L64119

; 897  : 		resPatches.Free();

  02450	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?resPatches@@3VMemID@@A ; resPatches
  02455	e8 00 00 00 00	 call	 ?Free@MemID@@QAEXXZ	; MemID::Free

; 898  : 	} else {

  0245a	eb 22		 jmp	 SHORT $L64120
$L64119:

; 899  : 		// flag the end of the patch table...
; 900  : 		entry->resType = (MemType) -1;

  0245c	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _entry$[ebp]
  02462	c6 42 01 ff	 mov	 BYTE PTR [edx+1], 255	; 000000ffH

; 901  : 		// ...and trim it down to size
; 902  : 		resPatches.Realloc((npatches + 1) * sizeof(ResPatchEntry));

  02466	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _npatches$[ebp]
  0246c	8d 0c 85 04 00
	00 00		 lea	 ecx, DWORD PTR [eax*4+4]
  02473	51		 push	 ecx
  02474	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?resPatches@@3VMemID@@A ; resPatches
  02479	e8 00 00 00 00	 call	 ?Realloc@MemID@@QBEPAXI@Z ; MemID::Realloc
$L64120:

; 904  : 
; 905  : 	if (!npatches36)

  0247e	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _npatches36$[ebp], 0
  02485	75 0c		 jne	 SHORT $L64123

; 906  : 		resPatches36.Free();

  02487	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?resPatches36@@3VMemID@@A ; resPatches36
  0248c	e8 00 00 00 00	 call	 ?Free@MemID@@QAEXXZ	; MemID::Free

; 907  : 	else {

  02491	eb 1e		 jmp	 SHORT $L64124
$L64123:

; 908  : 		// flag the end of the patch table...
; 909  : 		entry36->resName[0] = '\0';

  02493	8b 55 fc	 mov	 edx, DWORD PTR _entry36$[ebp]
  02496	c6 42 01 00	 mov	 BYTE PTR [edx+1], 0

; 910  : 		// ...and trim it down to size
; 911  : 		resPatches36.Realloc((npatches36 + 1) * sizeof(ResPatch36Entry));

  0249a	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _npatches36$[ebp]
  024a0	83 c0 01	 add	 eax, 1
  024a3	6b c0 0e	 imul	 eax, 14			; 0000000eH
  024a6	50		 push	 eax
  024a7	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?resPatches36@@3VMemID@@A ; resPatches36
  024ac	e8 00 00 00 00	 call	 ?Realloc@MemID@@QBEPAXI@Z ; MemID::Realloc
$L64124:

; 913  : }

  024b1	8b e5		 mov	 esp, ebp
  024b3	5d		 pop	 ebp
  024b4	c3		 ret	 0
?BuildPatchTables@ResourceMgr@@UAEXXZ ENDP		; ResourceMgr::BuildPatchTables
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IW4ReservedHandle@@I@Z
_TEXT	SEGMENT
_type$ = 8
_size$ = 12
_h$ = 16
_a$ = 20
_this$ = -4
?Get@MemID@@QAEXW4MemType@@IW4ReservedHandle@@I@Z PROC NEAR ; MemID::Get, COMDAT

; 47   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 48   : 		Get(type, size, a | PERSIST, 0, 0, 0, h);

  00007	8b 45 10	 mov	 eax, DWORD PTR _h$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	6a 00		 push	 0
  0000f	6a 00		 push	 0
  00011	8b 4d 14	 mov	 ecx, DWORD PTR _a$[ebp]
  00014	81 c9 00 00 08
	00		 or	 ecx, 524288		; 00080000H
  0001a	51		 push	 ecx
  0001b	8b 55 0c	 mov	 edx, DWORD PTR _size$[ebp]
  0001e	52		 push	 edx
  0001f	8b 45 08	 mov	 eax, DWORD PTR _type$[ebp]
  00022	50		 push	 eax
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get

; 49   : 	}

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 10 00	 ret	 16			; 00000010H
?Get@MemID@@QAEXW4MemType@@IW4ReservedHandle@@I@Z ENDP	; MemID::Get
_TEXT	ENDS
PUBLIC	?DecompBuffer@ResourceMgr@@QAE?AVMemID@@H@Z	; ResourceMgr::DecompBuffer
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
?DecompBuffer@ResourceMgr@@QAE?AVMemID@@H@Z PROC NEAR	; ResourceMgr::DecompBuffer

; 917  : {

  024b5	55		 push	 ebp
  024b6	8b ec		 mov	 ebp, esp
  024b8	51		 push	 ecx
  024b9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 918  : 	return 0;

  024bc	6a 00		 push	 0
  024be	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  024c1	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  024c6	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 942  : }

  024c9	8b e5		 mov	 esp, ebp
  024cb	5d		 pop	 ebp
  024cc	c2 08 00	 ret	 8
?DecompBuffer@ResourceMgr@@QAE?AVMemID@@H@Z ENDP	; ResourceMgr::DecompBuffer
_TEXT	ENDS
PUBLIC	?SetLanguage@ResourceMgr@@QAEXPAD@Z		; ResourceMgr::SetLanguage
EXTRN	?pm@@3VPMachine@@A:BYTE				; pm
_DATA	SEGMENT
	ORG $+2
$SG64149 DB	'resaud', 00H
	ORG $+1
$SG64153 DB	'\', 00H
	ORG $+2
$SG64155 DB	'\', 00H
	ORG $+2
$SG64156 DB	'RESOURCE.AUD', 00H
_DATA	ENDS
_TEXT	SEGMENT
_langDir$ = 8
_this$ = -284
_path$ = -268
_array$64146 = -276
_cp$64151 = -280
_n$ = -272
_fd$ = -4
?SetLanguage@ResourceMgr@@QAEXPAD@Z PROC NEAR		; ResourceMgr::SetLanguage

; 946  : {

  024cf	55		 push	 ebp
  024d0	8b ec		 mov	 ebp, esp
  024d2	81 ec 1c 01 00
	00		 sub	 esp, 284		; 0000011cH
  024d8	89 8d e4 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
$L64144:

; 947  : 	char		path[MaxPath + 1];
; 948  : 	static	int saveFD = -1;
; 949  : 
; 950  : 	// Flush MAP resources
; 951  : 	while (resources[MemResMap].curSize > 0) {

  024de	83 3d 88 01 00
	00 00		 cmp	 DWORD PTR _resources+392, 0
  024e5	7e 2f		 jle	 SHORT $L64145

; 952  : 		ResTag* array = *resources[MemResMap].id;

  024e7	b9 84 01 00 00	 mov	 ecx, OFFSET FLAT:_resources+388
  024ec	e8 00 00 00 00	 call	 ??DFakeResTagID@@QBEPAUResTag@@XZ ; FakeResTagID::operator*
  024f1	89 85 ec fe ff
	ff		 mov	 DWORD PTR _array$64146[ebp], eax

; 953  : 		resMgr->Release(MemResMap,array[0].resNum);

  024f7	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _array$64146[ebp]
  024fd	66 8b 08	 mov	 cx, WORD PTR [eax]
  02500	51		 push	 ecx
  02501	6a 10		 push	 16			; 00000010H
  02503	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?resMgr@@3PAVResourceMgr@@A ; resMgr
  02509	8b 02		 mov	 eax, DWORD PTR [edx]
  0250b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMgr@@3PAVResourceMgr@@A ; resMgr
  02511	ff 50 40	 call	 DWORD PTR [eax+64]

; 954  : 	}

  02514	eb c8		 jmp	 SHORT $L64144
$L64145:

; 955  : 
; 956  : 	if (strlen(langDir) == 0) {

  02516	8b 4d 08	 mov	 ecx, DWORD PTR _langDir$[ebp]
  02519	51		 push	 ecx
  0251a	e8 00 00 00 00	 call	 _strlen
  0251f	83 c4 04	 add	 esp, 4
  02522	85 c0		 test	 eax, eax
  02524	75 31		 jne	 SHORT $L64147

; 957  : 		if (strlen(langPath)) {

  02526	68 00 00 00 00	 push	 OFFSET FLAT:?langPath@@3PADA ; langPath
  0252b	e8 00 00 00 00	 call	 _strlen
  02530	83 c4 04	 add	 esp, 4
  02533	85 c0		 test	 eax, eax
  02535	74 11		 je	 SHORT $L64148

; 958  : 			langPath[0] = '\0';

  02537	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?langPath@@3PADA, 0

; 959  : 			saveFD = -1;

  0253e	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _?saveFD@?1??SetLanguage@ResourceMgr@@QAEXPAD@Z@4HA, -1
$L64148:

; 961  : 		pm.acc = True;

  02548	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, 1

; 962  : 		return;

  02552	e9 23 01 00 00	 jmp	 $L64139
$L64147:

; 964  : 
; 965  : 	strcpy(path, configMgr->Get("resaud",0));

  02557	6a 00		 push	 0
  02559	68 00 00 00 00	 push	 OFFSET FLAT:$SG64149
  0255e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?configMgr@@3PAVConfigMgr@@A ; configMgr
  02564	e8 00 00 00 00	 call	 ?Get@ConfigMgr@@QAEPADPADH@Z ; ConfigMgr::Get
  02569	50		 push	 eax
  0256a	8d 95 f4 fe ff
	ff		 lea	 edx, DWORD PTR _path$[ebp]
  02570	52		 push	 edx
  02571	e8 00 00 00 00	 call	 _strcpy
  02576	83 c4 08	 add	 esp, 8

; 966  : 	if (strlen(path)) {

  02579	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  0257f	50		 push	 eax
  02580	e8 00 00 00 00	 call	 _strlen
  02585	83 c4 04	 add	 esp, 4
  02588	85 c0		 test	 eax, eax
  0258a	74 4c		 je	 SHORT $L64152

; 967  : 		char* cp = &path[strlen(path)-1];

  0258c	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  02592	51		 push	 ecx
  02593	e8 00 00 00 00	 call	 _strlen
  02598	83 c4 04	 add	 esp, 4
  0259b	8d 94 05 f3 fe
	ff ff		 lea	 edx, DWORD PTR _path$[ebp+eax-1]
  025a2	89 95 e8 fe ff
	ff		 mov	 DWORD PTR _cp$64151[ebp], edx

; 968  : 		if (*cp != ':' && *cp != '\\')

  025a8	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _cp$64151[ebp]
  025ae	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  025b1	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  025b4	74 22		 je	 SHORT $L64152
  025b6	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _cp$64151[ebp]
  025bc	0f be 02	 movsx	 eax, BYTE PTR [edx]
  025bf	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  025c2	74 14		 je	 SHORT $L64152

; 969  : 			strcat(path,"\\");

  025c4	68 00 00 00 00	 push	 OFFSET FLAT:$SG64153
  025c9	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  025cf	51		 push	 ecx
  025d0	e8 00 00 00 00	 call	 _strcat
  025d5	83 c4 08	 add	 esp, 8
$L64152:

; 971  : 	strcat(path,langDir);

  025d8	8b 55 08	 mov	 edx, DWORD PTR _langDir$[ebp]
  025db	52		 push	 edx
  025dc	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  025e2	50		 push	 eax
  025e3	e8 00 00 00 00	 call	 _strcat
  025e8	83 c4 08	 add	 esp, 8

; 972  : 	int n = strlen(path);

  025eb	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  025f1	51		 push	 ecx
  025f2	e8 00 00 00 00	 call	 _strlen
  025f7	83 c4 04	 add	 esp, 4
  025fa	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _n$[ebp], eax

; 973  : 	strcat(path,"\\");

  02600	68 00 00 00 00	 push	 OFFSET FLAT:$SG64155
  02605	8d 95 f4 fe ff
	ff		 lea	 edx, DWORD PTR _path$[ebp]
  0260b	52		 push	 edx
  0260c	e8 00 00 00 00	 call	 _strcat
  02611	83 c4 08	 add	 esp, 8

; 974  : 	strcat(path,AUDVOLNAME);

  02614	68 00 00 00 00	 push	 OFFSET FLAT:$SG64156
  02619	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  0261f	50		 push	 eax
  02620	e8 00 00 00 00	 call	 _strcat
  02625	83 c4 08	 add	 esp, 8

; 975  : 	int fd = ::Open(path, O_RDONLY);

  02628	6a 00		 push	 0
  0262a	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  02630	51		 push	 ecx
  02631	e8 00 00 00 00	 call	 ?Open@@YAHPBDI@Z	; Open
  02636	83 c4 08	 add	 esp, 8
  02639	89 45 fc	 mov	 DWORD PTR _fd$[ebp], eax

; 976  : 	if (fd == -1) {

  0263c	83 7d fc ff	 cmp	 DWORD PTR _fd$[ebp], -1
  02640	75 0c		 jne	 SHORT $L64158

; 977  : 		pm.acc = False;

  02642	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, 0

; 978  : 	} else {

  0264c	eb 2c		 jmp	 SHORT $L64159
$L64158:

; 979  : 		path[n] = '\0';

  0264e	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR _n$[ebp]
  02654	c6 84 15 f4 fe
	ff ff 00	 mov	 BYTE PTR _path$[ebp+edx], 0

; 980  : 		strcpy(langPath,path);

  0265c	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  02662	50		 push	 eax
  02663	68 00 00 00 00	 push	 OFFSET FLAT:?langPath@@3PADA ; langPath
  02668	e8 00 00 00 00	 call	 _strcpy
  0266d	83 c4 08	 add	 esp, 8

; 981  : 		pm.acc = True;

  02670	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, 1
$L64159:
$L64139:

; 983  : }

  0267a	8b e5		 mov	 esp, ebp
  0267c	5d		 pop	 ebp
  0267d	c2 04 00	 ret	 4
?SetLanguage@ResourceMgr@@QAEXPAD@Z ENDP		; ResourceMgr::SetLanguage
_TEXT	ENDS
PUBLIC	?KSetLanguage@@YAXPAF@Z				; KSetLanguage
PUBLIC	??DTextID@@QAEPADXZ				; TextID::operator*
EXTRN	??0TextID@@QAE@G@Z:NEAR				; TextID::TextID
_BSS	SEGMENT
	ALIGN	4

$SG64164 DB	01H DUP (?)
_BSS	ENDS
_TEXT	SEGMENT
$T64798 = -4
_args$ = 8
?KSetLanguage@@YAXPAF@Z PROC NEAR			; KSetLanguage

; 989  : {

  02680	55		 push	 ebp
  02681	8b ec		 mov	 ebp, esp
  02683	51		 push	 ecx

; 990  : 	if (argCount < 1)

  02684	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  02687	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0268a	83 f9 01	 cmp	 ecx, 1
  0268d	7d 12		 jge	 SHORT $L64163

; 991  : 		resMgr->SetLanguage("");		

  0268f	68 00 00 00 00	 push	 OFFSET FLAT:$SG64164
  02694	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMgr@@3PAVResourceMgr@@A ; resMgr
  0269a	e8 00 00 00 00	 call	 ?SetLanguage@ResourceMgr@@QAEXPAD@Z ; ResourceMgr::SetLanguage

; 992  : 	else

  0269f	eb 23		 jmp	 SHORT $L64165
$L64163:

; 993  : 		resMgr->SetLanguage(*(TextID) arg(1));

  026a1	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  026a4	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  026a8	50		 push	 eax
  026a9	8d 4d fc	 lea	 ecx, DWORD PTR $T64798[ebp]
  026ac	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  026b1	8b c8		 mov	 ecx, eax
  026b3	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  026b8	50		 push	 eax
  026b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMgr@@3PAVResourceMgr@@A ; resMgr
  026bf	e8 00 00 00 00	 call	 ?SetLanguage@ResourceMgr@@QAEXPAD@Z ; ResourceMgr::SetLanguage
$L64165:

; 994  : }

  026c4	8b e5		 mov	 esp, ebp
  026c6	5d		 pop	 ebp
  026c7	c3		 ret	 0
?KSetLanguage@@YAXPAF@Z ENDP				; KSetLanguage
_TEXT	ENDS
;	COMDAT ??DTextID@@QAEPADXZ
_TEXT	SEGMENT
_this$ = -4
??DTextID@@QAEPADXZ PROC NEAR				; TextID::operator*, COMDAT

; 24   : 	char	*operator *() { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 25   : 		return handle ? (char *)MemID::operator*() : ""; 

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	33 c9		 xor	 ecx, ecx
  0000e	66 8b 08	 mov	 cx, WORD PTR [eax]
  00011	85 c9		 test	 ecx, ecx
  00013	74 0d		 je	 SHORT $L64800
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0001d	89 45 f8	 mov	 DWORD PTR -8+[ebp], eax
  00020	eb 07		 jmp	 SHORT $L64801
$L64800:
  00022	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
$L64801:
  00029	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]

; 26   : 	}

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??DTextID@@QAEPADXZ ENDP				; TextID::operator*
_TEXT	ENDS
PUBLIC	?KLoad@@YAXPAF@Z				; KLoad
_TEXT	SEGMENT
$T64803 = -8
_args$ = 8
_count$ = -4
?KLoad@@YAXPAF@Z PROC NEAR				; KLoad

; 998  : {

  026c8	55		 push	 ebp
  026c9	8b ec		 mov	 ebp, esp
  026cb	83 ec 08	 sub	 esp, 8

; 999  : 	for (int count = 2; count <= argCount; ++count)

  026ce	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR _count$[ebp], 2
  026d5	eb 09		 jmp	 SHORT $L64172
$L64173:
  026d7	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  026da	83 c0 01	 add	 eax, 1
  026dd	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$L64172:
  026e0	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  026e3	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  026e6	39 55 fc	 cmp	 DWORD PTR _count$[ebp], edx
  026e9	7f 3c		 jg	 SHORT $L64174

; 1000 : 		pm.acc = (Acc) resMgr->Get((MemType) arg(1), (ResNum) arg(count));

  026eb	6a 00		 push	 0
  026ed	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  026f0	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  026f3	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  026f7	52		 push	 edx
  026f8	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  026fb	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  026ff	51		 push	 ecx
  02700	8d 55 f8	 lea	 edx, DWORD PTR $T64803[ebp]
  02703	52		 push	 edx
  02704	a1 00 00 00 00	 mov	 eax, DWORD PTR ?resMgr@@3PAVResourceMgr@@A ; resMgr
  02709	8b 10		 mov	 edx, DWORD PTR [eax]
  0270b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMgr@@3PAVResourceMgr@@A ; resMgr
  02711	ff 52 20	 call	 DWORD PTR [edx+32]
  02714	8b c8		 mov	 ecx, eax
  02716	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  0271b	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  02720	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax
  02725	eb b0		 jmp	 SHORT $L64173
$L64174:

; 1001 : }

  02727	8b e5		 mov	 esp, ebp
  02729	5d		 pop	 ebp
  0272a	c3		 ret	 0
?KLoad@@YAXPAF@Z ENDP					; KLoad
_TEXT	ENDS
PUBLIC	?KUnload@@YAXPAF@Z				; KUnload
_TEXT	SEGMENT
_args$ = 8
_resType$ = -4
_resId$ = -8
?KUnload@@YAXPAF@Z PROC NEAR				; KUnload

; 1005 : {

  0272b	55		 push	 ebp
  0272c	8b ec		 mov	 ebp, esp
  0272e	83 ec 08	 sub	 esp, 8

; 1006 : 	MemType	resType	= (MemType) arg(1);

  02731	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  02734	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  02738	89 4d fc	 mov	 DWORD PTR _resType$[ebp], ecx

; 1007 : 	ResNum	resId		= arg(2);

  0273b	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  0273e	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  02742	66 89 45 f8	 mov	 WORD PTR _resId$[ebp], ax

; 1008 : 
; 1009 : 	//	SCI still uses the old numbers
; 1010 : 	SCI16ToSCI32ResType(resType);

  02746	8d 4d fc	 lea	 ecx, DWORD PTR _resType$[ebp]
  02749	51		 push	 ecx
  0274a	e8 00 00 00 00	 call	 ?SCI16ToSCI32ResType@@YAXAAW4MemType@@@Z ; SCI16ToSCI32ResType
  0274f	83 c4 04	 add	 esp, 4

; 1011 : 
; 1012 : 	resMgr->Release(resType, resId);

  02752	66 8b 55 f8	 mov	 dx, WORD PTR _resId$[ebp]
  02756	52		 push	 edx
  02757	8b 45 fc	 mov	 eax, DWORD PTR _resType$[ebp]
  0275a	50		 push	 eax
  0275b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMgr@@3PAVResourceMgr@@A ; resMgr
  02761	8b 11		 mov	 edx, DWORD PTR [ecx]
  02763	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMgr@@3PAVResourceMgr@@A ; resMgr
  02769	ff 52 40	 call	 DWORD PTR [edx+64]

; 1013 : }

  0276c	8b e5		 mov	 esp, ebp
  0276e	5d		 pop	 ebp
  0276f	c3		 ret	 0
?KUnload@@YAXPAF@Z ENDP					; KUnload
_TEXT	ENDS
PUBLIC	?KFlushResources@@YAXPAF@Z			; KFlushResources
_TEXT	SEGMENT
?KFlushResources@@YAXPAF@Z PROC NEAR			; KFlushResources

; 1017 : {

  02770	55		 push	 ebp
  02771	8b ec		 mov	 ebp, esp

; 1018 : #if 0
; 1019 : 	// If we are tracking resource usage, set the room number of the room
; 1020 : 	// we are about to enter, then flush all unlocked resources.
; 1021 : 
; 1022 : 	newRoomNum = arg(1);
; 1023 : 
; 1024 : 	if (trackResUse)
; 1025 : 		while (!PurgeLast())
; 1026 : 			;
; 1027 : #endif
; 1028 : }

  02773	5d		 pop	 ebp
  02774	c3		 ret	 0
?KFlushResources@@YAXPAF@Z ENDP				; KFlushResources
_TEXT	ENDS
PUBLIC	?KLock@@YAXPAF@Z				; KLock
_TEXT	SEGMENT
$T64807 = -16
_args$ = 8
_resType$ = -4
_resId$ = -8
_yes$ = -12
?KLock@@YAXPAF@Z PROC NEAR				; KLock

; 1032 : {

  02775	55		 push	 ebp
  02776	8b ec		 mov	 ebp, esp
  02778	83 ec 10	 sub	 esp, 16			; 00000010H

; 1033 : 	// Lock or UnLock a resource
; 1034 : 	// pass resource type, resource number and True or False
; 1035 : 	//	to LOCK or UNLOCK
; 1036 : 
; 1037 : 	MemType	resType	= (MemType) arg(1);

  0277b	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  0277e	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  02782	89 4d fc	 mov	 DWORD PTR _resType$[ebp], ecx

; 1038 : 	ResNum	resId		= arg(2);

  02785	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  02788	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  0278c	66 89 45 f8	 mov	 WORD PTR _resId$[ebp], ax

; 1039 : 	Bool		yes		= arg(3);

  02790	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  02793	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  02797	89 55 f4	 mov	 DWORD PTR _yes$[ebp], edx

; 1040 : 
; 1041 : 	//	SCI still uses the old numbers
; 1042 : 	SCI16ToSCI32ResType(resType);

  0279a	8d 45 fc	 lea	 eax, DWORD PTR _resType$[ebp]
  0279d	50		 push	 eax
  0279e	e8 00 00 00 00	 call	 ?SCI16ToSCI32ResType@@YAXAAW4MemType@@@Z ; SCI16ToSCI32ResType
  027a3	83 c4 04	 add	 esp, 4

; 1043 : 
; 1044 : 	if	(yes) {

  027a6	83 7d f4 00	 cmp	 DWORD PTR _yes$[ebp], 0
  027aa	74 3c		 je	 SHORT $L64195

; 1045 : 		resMgr->Get(resType, resId);

  027ac	6a 00		 push	 0
  027ae	66 8b 4d f8	 mov	 cx, WORD PTR _resId$[ebp]
  027b2	51		 push	 ecx
  027b3	8b 55 fc	 mov	 edx, DWORD PTR _resType$[ebp]
  027b6	52		 push	 edx
  027b7	8d 45 f0	 lea	 eax, DWORD PTR $T64807[ebp]
  027ba	50		 push	 eax
  027bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMgr@@3PAVResourceMgr@@A ; resMgr
  027c1	8b 11		 mov	 edx, DWORD PTR [ecx]
  027c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMgr@@3PAVResourceMgr@@A ; resMgr
  027c9	ff 52 20	 call	 DWORD PTR [edx+32]

; 1046 : 		resMgr->SetNotDiscardable(resType, resId);

  027cc	66 8b 45 f8	 mov	 ax, WORD PTR _resId$[ebp]
  027d0	50		 push	 eax
  027d1	8b 4d fc	 mov	 ecx, DWORD PTR _resType$[ebp]
  027d4	51		 push	 ecx
  027d5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?resMgr@@3PAVResourceMgr@@A ; resMgr
  027db	8b 02		 mov	 eax, DWORD PTR [edx]
  027dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMgr@@3PAVResourceMgr@@A ; resMgr
  027e3	ff 50 48	 call	 DWORD PTR [eax+72]

; 1047 : 	} else {

  027e6	eb 19		 jmp	 SHORT $L64197
$L64195:

; 1048 : 		resMgr->SetDiscardable(resType, resId);

  027e8	66 8b 4d f8	 mov	 cx, WORD PTR _resId$[ebp]
  027ec	51		 push	 ecx
  027ed	8b 55 fc	 mov	 edx, DWORD PTR _resType$[ebp]
  027f0	52		 push	 edx
  027f1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?resMgr@@3PAVResourceMgr@@A ; resMgr
  027f6	8b 10		 mov	 edx, DWORD PTR [eax]
  027f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMgr@@3PAVResourceMgr@@A ; resMgr
  027fe	ff 52 44	 call	 DWORD PTR [edx+68]
$L64197:

; 1050 : }

  02801	8b e5		 mov	 esp, ebp
  02803	5d		 pop	 ebp
  02804	c3		 ret	 0
?KLock@@YAXPAF@Z ENDP					; KLock
_TEXT	ENDS
PUBLIC	?KResCheck@@YAXPAF@Z				; KResCheck
_TEXT	SEGMENT
_args$ = 8
_count$ = -272
_type$ = -276
?KResCheck@@YAXPAF@Z PROC NEAR				; KResCheck

; 1054 : {

  02805	55		 push	 ebp
  02806	8b ec		 mov	 ebp, esp
  02808	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H

; 1055 : 	pm.acc = True;

  0280e	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, 1

; 1056 : 	int	count, fd;
; 1057 : 	char	pathName[MaxPath + 1];
; 1058 : 	MemType	type;
; 1059 : 
; 1060 : //	msgMgr->Mono ( "ResCheck start\n" );
; 1061 : 
; 1062 : 	type = (MemType)arg(1);

  02818	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  0281b	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  0281f	89 8d ec fe ff
	ff		 mov	 DWORD PTR _type$[ebp], ecx

; 1063 : 	SCI16ToSCI32ResType(type);

  02825	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _type$[ebp]
  0282b	52		 push	 edx
  0282c	e8 00 00 00 00	 call	 ?SCI16ToSCI32ResType@@YAXAAW4MemType@@@Z ; SCI16ToSCI32ResType
  02831	83 c4 04	 add	 esp, 4

; 1064 : 	switch (type) {

  02834	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _type$[ebp]
  0283a	89 85 e8 fe ff
	ff		 mov	 DWORD PTR -280+[ebp], eax

; 1065 : 		default:
; 1066 : 			for (count = 2; count <= argCount; ++count) {

  02840	c7 85 f0 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR _count$[ebp], 2
  0284a	eb 0f		 jmp	 SHORT $L64211
$L64212:
  0284c	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _count$[ebp]
  02852	83 c1 01	 add	 ecx, 1
  02855	89 8d f0 fe ff
	ff		 mov	 DWORD PTR _count$[ebp], ecx
$L64211:
  0285b	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  0285e	0f bf 02	 movsx	 eax, WORD PTR [edx]
  02861	39 85 f0 fe ff
	ff		 cmp	 DWORD PTR _count$[ebp], eax
  02867	7f 38		 jg	 SHORT $L64213

; 1067 : 				pm.acc = (Acc) resMgr->Check(type, (ResNum) arg(count));

  02869	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _count$[ebp]
  0286f	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  02872	66 8b 04 4a	 mov	 ax, WORD PTR [edx+ecx*2]
  02876	50		 push	 eax
  02877	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _type$[ebp]
  0287d	51		 push	 ecx
  0287e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?resMgr@@3PAVResourceMgr@@A ; resMgr
  02884	8b 02		 mov	 eax, DWORD PTR [edx]
  02886	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMgr@@3PAVResourceMgr@@A ; resMgr
  0288c	ff 50 10	 call	 DWORD PTR [eax+16]
  0288f	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 1068 : 				if (!pm.acc) {

  02894	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?pm@@3VPMachine@@A+4, 0
  0289b	75 02		 jne	 SHORT $L64216

; 1069 : //					msgMgr->Mono ( "ResCheck done\n" );
; 1070 : 					return;

  0289d	eb 02		 jmp	 SHORT $L64200
$L64216:

; 1072 : 			}

  0289f	eb ab		 jmp	 SHORT $L64212
$L64213:
$L64200:

; 1075 : 
; 1076 : //	msgMgr->Mono ( "ResCheck done\n" );
; 1077 : }

  028a1	8b e5		 mov	 esp, ebp
  028a3	5d		 pop	 ebp
  028a4	c3		 ret	 0
?KResCheck@@YAXPAF@Z ENDP				; KResCheck
_TEXT	ENDS
END
