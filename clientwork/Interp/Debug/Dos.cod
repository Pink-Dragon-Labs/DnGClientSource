	TITLE	C:\Documents and Settings\don\Desktop\sciw\Interp\Dos.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MemoryMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckValid@MemoryMgr@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GMemoryMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@V1@III@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AMemID@@QBEAADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8MemID@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??7MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeArrayID@@QBEPAUArrayHeader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ArrayID@@QAE@HW4ArrayType@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@ArrayID@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAE?AVMemID@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAEXVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_List@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@SOL_List@@QAEAAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeDispatchTblID@@QBEPAUDispatchTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeScriptEntryID@@QBEPAUScriptEntry@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntry@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeVariableID@@QBEPAUVariable@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Script@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Object@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGraphicsUpdate@Object@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?selectorDict@Object@@QAEPAVSelectorDict@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AObject@@QAEAAFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddr@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedPropAddr@Object@@QAEPBFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedProperty@Object@@QAEFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddrCheck@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@Object@@QAEFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropOffset@Object@@QAEIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetIndexedProperty@Object@@QAEXHF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetProperty@Object@@QAEXGF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssureValid@ObjectID@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsObject@ObjectID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@ObjectID@@QBEFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeClassTblID@@QBEPAUClassTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@NN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DTextID@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TextID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7MemoryMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?fHandle@@3PAXA					; fHandle
_DATA	SEGMENT
?fHandle@@3PAXA DD 0ffffffffH				; fHandle
_DATA	ENDS
PUBLIC	?KFileIO@@YAXPAF@Z				; KFileIO
PUBLIC	??BMemID@@QBEGXZ				; MemID::operator unsigned short
PUBLIC	??DMemID@@QBEPAXXZ				; MemID::operator*
PUBLIC	??0Array@@QAE@XZ				; Array::Array
PUBLIC	??1Array@@QAE@XZ				; Array::~Array
PUBLIC	?dataID@Array@@QAEXVMemID@@@Z			; Array::dataID
PUBLIC	??DTextID@@QAEPADXZ				; TextID::operator*
PUBLIC	?Exists@@YAHPBD@Z				; Exists
PUBLIC	?Unlink@@YAHPBD@Z				; Unlink
PUBLIC	?FirstFile@@YAHPBDIPAU_WIN32_FIND_DATAA@@@Z	; FirstFile
PUBLIC	?NextFile@@YAHPAU_WIN32_FIND_DATAA@@@Z		; NextFile
PUBLIC	?GetCWD@@YAPADPAD@Z				; GetCWD
PUBLIC	?LSeek@@YAJHJH@Z				; LSeek
PUBLIC	?Creat@@YAHPBDI@Z				; Creat
PUBLIC	?Open@@YAHPBDI@Z				; Open
PUBLIC	?Read@@YAHHPAXH@Z				; Read
PUBLIC	?Write@@YAHHPAXH@Z				; Write
PUBLIC	?Close@@YAHH@Z					; Close
PUBLIC	?Rename@@YAHPBD0@Z				; Rename
PUBLIC	?ReadString@@YAPADPADHH@Z			; ReadString
PUBLIC	??0MemID@@QAE@ABV0@@Z				; MemID::MemID
PUBLIC	??0MemID@@QAE@G@Z				; MemID::MemID
EXTRN	?Realloc@MemID@@QBEPAXI@Z:NEAR			; MemID::Realloc
EXTRN	?Size@MemID@@QBEIXZ:NEAR			; MemID::Size
EXTRN	?calcAddress@Array@@QAEPAXH@Z:NEAR		; Array::calcAddress
EXTRN	?pm@@3VPMachine@@A:BYTE				; pm
EXTRN	??0TextID@@QAE@G@Z:NEAR				; TextID::TextID
EXTRN	??4TextID@@QAEAAV0@PBD@Z:NEAR			; TextID::operator=
EXTRN	?Snug@TextID@@QAEXXZ:NEAR			; TextID::Snug
EXTRN	?Fatal@MsgMgr@@QAAXPADZZ:NEAR			; MsgMgr::Fatal
EXTRN	?msgMgr@@3PAVMsgMgr@@A:DWORD			; msgMgr
EXTRN	_strlen:NEAR
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
_BSS	SEGMENT
_?findFileEntry@?1??KFileIO@@YAXPAF@Z@4U_WIN32_FIND_DATAA@@A DB 0140H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG59893 DB	'Reading too many bytes into an array.', 00H
_DATA	ENDS
xdata$x	SEGMENT
$T60332	DD	019930520H
	DD	01H
	DD	FLAT:$T60336
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T60336	DD	0ffffffffH
	DD	FLAT:$L60328
xdata$x	ENDS
_TEXT	SEGMENT
_args$ = 8
_array$ = -16
_fd$59874 = -24
_buf$59875 = -20
_mode$59876 = -28
_theID$59882 = -40
_start$59886 = -48
_end$59888 = -36
_ptr$59889 = -32
_endRead$59891 = -44
_fd2$59938 = -580
_cnt$59939 = -572
_CPYBUFLEN$59940 = -576
_cpy$59941 = -560
_buf$59942 = -568
_fd$59943 = -564
_id$59959 = -584
$T60307 = -588
$T60308 = -592
$T60309 = -596
$T60310 = -600
$T60311 = -604
$T60312 = -608
$T60315 = -612
$T60316 = -616
$T60317 = -620
$T60318 = -624
$T60319 = -628
$T60320 = -632
$T60321 = -636
$T60322 = -640
$T60323 = -644
$T60324 = -648
$T60327 = -652
__$EHRec$ = -12
?KFileIO@@YAXPAF@Z PROC NEAR				; KFileIO

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 $L60333
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	81 ec 8c 02 00
	00		 sub	 esp, 652		; 0000028cH

; 41   : 	enum {
; 42   : 		FileOpen,
; 43   : 		FileClose,
; 44   : 		FileRead,
; 45   : 		FileWrite,
; 46   : 		FileUnlink,
; 47   : 		FileFGets,
; 48   : 		FileFPuts,
; 49   : 		FileSeek,
; 50   : 		FileFindFirst,
; 51   : 		FileFindNext,
; 52   : 		FileExists,
; 53   : 		FileRename,
; 54   : 		FileCopy,
; 55   : 		FileReadByte,
; 56   : 		FileWriteByte,
; 57   : 		FileReadWord,
; 58   : 		FileWriteWord,
; 59   : 		FileCheckFreeSpace,
; 60   : 		FileGetCWD,
; 61   : 		FileValidPath
; 62   : 	};
; 63   : 
; 64   : 	enum {
; 65   : 		F_APPEND,
; 66   : 		F_READ,
; 67   : 		F_TRUNC
; 68   : 	};
; 69   : 
; 70   : 	static WIN32_FIND_DATA	findFileEntry;
; 71   : 	Array array;

  0001e	8d 4d f0	 lea	 ecx, DWORD PTR _array$[ebp]
  00021	e8 00 00 00 00	 call	 ??0Array@@QAE@XZ	; Array::Array
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 72   : 
; 73   : // BEW CLEANUP 	critErrHandler->SetMethod(CritErrHandler::Retry);
; 74   : 
; 75   : 	switch (arg(1)) {

  0002d	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00030	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00034	89 8d 70 fd ff
	ff		 mov	 DWORD PTR -656+[ebp], ecx
  0003a	83 bd 70 fd ff
	ff 13		 cmp	 DWORD PTR -656+[ebp], 19 ; 00000013H
  00041	0f 87 06 06 00
	00		 ja	 $L59870
  00047	8b 95 70 fd ff
	ff		 mov	 edx, DWORD PTR -656+[ebp]
  0004d	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L60335[edx*4]
$L59873:

; 77   : 			int fd;
; 78   : 			TextID buf(arg(2));

  00054	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00057	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  0005b	51		 push	 ecx
  0005c	8d 4d ec	 lea	 ecx, DWORD PTR _buf$59875[ebp]
  0005f	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID

; 79   : 			int mode = arg(3);

  00064	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00067	0f bf 42 06	 movsx	 eax, WORD PTR [edx+6]
  0006b	89 45 e4	 mov	 DWORD PTR _mode$59876[ebp], eax

; 80   : 			if (mode == F_TRUNC)

  0006e	83 7d e4 02	 cmp	 DWORD PTR _mode$59876[ebp], 2
  00072	75 1b		 jne	 SHORT $L59877

; 81   : 				fd = Creat(*buf, _S_IREAD | _S_IWRITE );

  00074	68 80 01 00 00	 push	 384			; 00000180H
  00079	8d 4d ec	 lea	 ecx, DWORD PTR _buf$59875[ebp]
  0007c	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ?Creat@@YAHPBDI@Z	; Creat
  00087	83 c4 08	 add	 esp, 8
  0008a	89 45 e8	 mov	 DWORD PTR _fd$59874[ebp], eax

; 82   : 			else {

  0008d	eb 19		 jmp	 SHORT $L59878
$L59877:

; 83   : 				fd = Open(*buf, O_RDWR | O_BINARY);

  0008f	68 02 80 00 00	 push	 32770			; 00008002H
  00094	8d 4d ec	 lea	 ecx, DWORD PTR _buf$59875[ebp]
  00097	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 ?Open@@YAHPBDI@Z	; Open
  000a2	83 c4 08	 add	 esp, 8
  000a5	89 45 e8	 mov	 DWORD PTR _fd$59874[ebp], eax
$L59878:

; 91   : 			pm.acc = (Acc) fd;

  000a8	8b 4d e8	 mov	 ecx, DWORD PTR _fd$59874[ebp]
  000ab	89 0d 04 00 00
	00		 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, ecx

; 92   : 			break;

  000b1	e9 97 05 00 00	 jmp	 $L59870
$L59880:

; 94   : 
; 95   : 		case FileClose:
; 96   : 			pm.acc = !Close(arg(2));

  000b6	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  000b9	0f bf 42 04	 movsx	 eax, WORD PTR [edx+4]
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 ?Close@@YAHH@Z		; Close
  000c3	83 c4 04	 add	 esp, 4
  000c6	f7 d8		 neg	 eax
  000c8	1b c0		 sbb	 eax, eax
  000ca	40		 inc	 eax
  000cb	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 97   : 			break;

  000d0	e9 78 05 00 00	 jmp	 $L59870
$L59881:

; 100  : #ifdef DEBUG
; 101  : 			if (((ArrayID)arg(3)).Size() < arg(4)) {
; 102  : 				msgMgr->Fatal("Buffer overflow reading %d bytes into %d bytes",
; 103  : 									arg(4), ((ArrayID)arg(3)).Size());
; 104  : 			}
; 105  : #endif
; 106  : 			MemID theID = (MemID)arg(3);

  000d5	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  000d8	66 8b 51 06	 mov	 dx, WORD PTR [ecx+6]
  000dc	52		 push	 edx
  000dd	8d 8d b4 fd ff
	ff		 lea	 ecx, DWORD PTR $T60307[ebp]
  000e3	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  000e8	50		 push	 eax
  000e9	8d 4d d8	 lea	 ecx, DWORD PTR _theID$59882[ebp]
  000ec	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID

; 107  : 			array.dataID ( theID );

  000f1	51		 push	 ecx
  000f2	8b cc		 mov	 ecx, esp
  000f4	89 a5 b0 fd ff
	ff		 mov	 DWORD PTR $T60308[ebp], esp
  000fa	8d 45 d8	 lea	 eax, DWORD PTR _theID$59882[ebp]
  000fd	50		 push	 eax
  000fe	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00103	8d 4d f0	 lea	 ecx, DWORD PTR _array$[ebp]
  00106	e8 00 00 00 00	 call	 ?dataID@Array@@QAEXVMemID@@@Z ; Array::dataID

; 108  : 
; 109  : 			char *start = (char *)*theID;

  0010b	8d 4d d8	 lea	 ecx, DWORD PTR _theID$59882[ebp]
  0010e	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  00113	89 45 d0	 mov	 DWORD PTR _start$59886[ebp], eax

; 110  : 			char *end = start + theID.Size();

  00116	8d 4d d8	 lea	 ecx, DWORD PTR _theID$59882[ebp]
  00119	e8 00 00 00 00	 call	 ?Size@MemID@@QBEIXZ	; MemID::Size
  0011e	8b 4d d0	 mov	 ecx, DWORD PTR _start$59886[ebp]
  00121	03 c8		 add	 ecx, eax
  00123	89 4d dc	 mov	 DWORD PTR _end$59888[ebp], ecx

; 111  : 
; 112  : 			char *ptr = (char *)array.calcAddress ( 0 );

  00126	6a 00		 push	 0
  00128	8d 4d f0	 lea	 ecx, DWORD PTR _array$[ebp]
  0012b	e8 00 00 00 00	 call	 ?calcAddress@Array@@QAEPAXH@Z ; Array::calcAddress
  00130	89 45 e0	 mov	 DWORD PTR _ptr$59889[ebp], eax

; 113  : 			char *endRead = ptr + arg(4);

  00133	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00136	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  0013a	8b 4d e0	 mov	 ecx, DWORD PTR _ptr$59889[ebp]
  0013d	03 c8		 add	 ecx, eax
  0013f	89 4d d4	 mov	 DWORD PTR _endRead$59891[ebp], ecx

; 114  : 
; 115  : 			if ( endRead > end )

  00142	8b 55 d4	 mov	 edx, DWORD PTR _endRead$59891[ebp]
  00145	3b 55 dc	 cmp	 edx, DWORD PTR _end$59888[ebp]
  00148	76 13		 jbe	 SHORT $L59892

; 116  : 				msgMgr->Fatal ( "Reading too many bytes into an array." );

  0014a	68 00 00 00 00	 push	 OFFSET FLAT:$SG59893
  0014f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00154	50		 push	 eax
  00155	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  0015a	83 c4 08	 add	 esp, 8
$L59892:

; 117  : 
; 118  : 			pm.acc = (Acc) Read(arg(2), array.calcAddress ( 0 ), arg(4));

  0015d	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00160	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  00164	52		 push	 edx
  00165	6a 00		 push	 0
  00167	8d 4d f0	 lea	 ecx, DWORD PTR _array$[ebp]
  0016a	e8 00 00 00 00	 call	 ?calcAddress@Array@@QAEPAXH@Z ; Array::calcAddress
  0016f	50		 push	 eax
  00170	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00173	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  00177	51		 push	 ecx
  00178	e8 00 00 00 00	 call	 ?Read@@YAHHPAXH@Z	; Read
  0017d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00180	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 120  : 
; 121  : 		break;

  00185	e9 c3 04 00 00	 jmp	 $L59870
$L59895:

; 122  : 
; 123  : 		case FileWrite:
; 124  : #ifdef DEBUG
; 125  : 			if (((ArrayID)arg(3)).Size() < arg(4)) {
; 126  : 				msgMgr->Fatal("Buffer underflow writting %d bytes into %d bytes",
; 127  : 									arg(4), ((ArrayID)arg(3)).Size());
; 128  : 			}
; 129  : #endif
; 130  : 			array.dataID ( (MemID)arg(3) );

  0018a	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  0018d	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  00191	50		 push	 eax
  00192	8d 8d a8 fd ff
	ff		 lea	 ecx, DWORD PTR $T60310[ebp]
  00198	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  0019d	51		 push	 ecx
  0019e	8b cc		 mov	 ecx, esp
  001a0	89 a5 ac fd ff
	ff		 mov	 DWORD PTR $T60309[ebp], esp
  001a6	50		 push	 eax
  001a7	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  001ac	8d 4d f0	 lea	 ecx, DWORD PTR _array$[ebp]
  001af	e8 00 00 00 00	 call	 ?dataID@Array@@QAEXVMemID@@@Z ; Array::dataID

; 131  : 			pm.acc = (Acc) Write(arg(2), array.calcAddress ( 0 ), arg(4));

  001b4	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  001b7	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  001bb	52		 push	 edx
  001bc	6a 00		 push	 0
  001be	8d 4d f0	 lea	 ecx, DWORD PTR _array$[ebp]
  001c1	e8 00 00 00 00	 call	 ?calcAddress@Array@@QAEPAXH@Z ; Array::calcAddress
  001c6	50		 push	 eax
  001c7	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  001ca	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  001ce	51		 push	 ecx
  001cf	e8 00 00 00 00	 call	 ?Write@@YAHHPAXH@Z	; Write
  001d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d7	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 132  : 			break;

  001dc	e9 6c 04 00 00	 jmp	 $L59870
$L59900:

; 133  : 
; 134  : 		case FileUnlink:
; 135  : 			pm.acc = (Acc) Unlink(*(TextID) arg(2));

  001e1	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  001e4	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  001e8	50		 push	 eax
  001e9	8d 8d a4 fd ff
	ff		 lea	 ecx, DWORD PTR $T60311[ebp]
  001ef	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  001f4	8b c8		 mov	 ecx, eax
  001f6	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  001fb	50		 push	 eax
  001fc	e8 00 00 00 00	 call	 ?Unlink@@YAHPBD@Z	; Unlink
  00201	83 c4 04	 add	 esp, 4
  00204	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 136  : 			break;

  00209	e9 3f 04 00 00	 jmp	 $L59870
$L59904:

; 137  : 
; 138  : 		case FileFGets:
; 139  : #ifdef DEBUG
; 140  : 			if (((TextID)arg(2)).Size() < arg(3)) {
; 141  : 				msgMgr->Fatal("Buffer overflow getting %d bytes into %d bytes",
; 142  : 									arg(3), ((TextID)arg(2)).Size());
; 143  : 			}
; 144  : #endif
; 145  : 			pm.acc = Acc(ReadString(*(TextID) arg(2),arg(3), arg(4)) ? arg(2) : 0);

  0020e	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00211	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  00215	52		 push	 edx
  00216	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00219	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0021d	51		 push	 ecx
  0021e	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00221	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  00225	50		 push	 eax
  00226	8d 8d a0 fd ff
	ff		 lea	 ecx, DWORD PTR $T60312[ebp]
  0022c	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  00231	8b c8		 mov	 ecx, eax
  00233	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  00238	50		 push	 eax
  00239	e8 00 00 00 00	 call	 ?ReadString@@YAPADPADHH@Z ; ReadString
  0023e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00241	85 c0		 test	 eax, eax
  00243	74 0f		 je	 SHORT $L60313
  00245	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00248	0f bf 51 04	 movsx	 edx, WORD PTR [ecx+4]
  0024c	89 95 6c fd ff
	ff		 mov	 DWORD PTR -660+[ebp], edx
  00252	eb 0a		 jmp	 SHORT $L60314
$L60313:
  00254	c7 85 6c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR -660+[ebp], 0
$L60314:
  0025e	8b 85 6c fd ff
	ff		 mov	 eax, DWORD PTR -660+[ebp]
  00264	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 146  : 			break;

  00269	e9 df 03 00 00	 jmp	 $L59870
$L59907:

; 147  : 
; 148  : 		case FileFPuts:
; 149  : #ifdef DEBUG
; 150  : 			if (((TextID)arg(3)).Size() < strlen(*(TextID)arg(3))) {
; 151  : 				msgMgr->Fatal("Buffer underflow putting %d bytes into %d bytes",
; 152  : 									strlen(*(TextID)arg(3)), ((TextID)arg(3)).Size());
; 153  : 			}
; 154  : #endif
; 155  : 			pm.acc = (Acc) Write(arg(2), *(TextID) arg(3),strlen(*(TextID)arg(3)));

  0026e	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00271	66 8b 51 06	 mov	 dx, WORD PTR [ecx+6]
  00275	52		 push	 edx
  00276	8d 8d 9c fd ff
	ff		 lea	 ecx, DWORD PTR $T60315[ebp]
  0027c	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  00281	8b c8		 mov	 ecx, eax
  00283	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  00288	50		 push	 eax
  00289	e8 00 00 00 00	 call	 _strlen
  0028e	83 c4 04	 add	 esp, 4
  00291	50		 push	 eax
  00292	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00295	66 8b 48 06	 mov	 cx, WORD PTR [eax+6]
  00299	51		 push	 ecx
  0029a	8d 8d 98 fd ff
	ff		 lea	 ecx, DWORD PTR $T60316[ebp]
  002a0	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  002a5	8b c8		 mov	 ecx, eax
  002a7	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  002ac	50		 push	 eax
  002ad	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  002b0	0f bf 42 04	 movsx	 eax, WORD PTR [edx+4]
  002b4	50		 push	 eax
  002b5	e8 00 00 00 00	 call	 ?Write@@YAHHPAXH@Z	; Write
  002ba	83 c4 0c	 add	 esp, 12			; 0000000cH
  002bd	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 156  : 			break;

  002c2	e9 86 03 00 00	 jmp	 $L59870
$L59913:

; 157  : 
; 158  : 		case FileSeek:
; 159  : 			pm.acc = (Acc) LSeek(arg(2), arg(3), arg(4));

  002c7	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  002ca	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  002ce	52		 push	 edx
  002cf	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  002d2	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  002d6	51		 push	 ecx
  002d7	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  002da	0f bf 42 04	 movsx	 eax, WORD PTR [edx+4]
  002de	50		 push	 eax
  002df	e8 00 00 00 00	 call	 ?LSeek@@YAJHJH@Z	; LSeek
  002e4	83 c4 0c	 add	 esp, 12			; 0000000cH
  002e7	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 160  : 			break;

  002ec	e9 5c 03 00 00	 jmp	 $L59870
$L59915:

; 161  : 
; 162  : 		case FileFindFirst:
; 163  : 			pm.acc = (Acc) FirstFile(*(TextID) arg(2), arg(4), &findFileEntry);

  002f1	68 00 00 00 00	 push	 OFFSET FLAT:_?findFileEntry@?1??KFileIO@@YAXPAF@Z@4U_WIN32_FIND_DATAA@@A
  002f6	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  002f9	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  002fd	52		 push	 edx
  002fe	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00301	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  00305	51		 push	 ecx
  00306	8d 8d 94 fd ff
	ff		 lea	 ecx, DWORD PTR $T60317[ebp]
  0030c	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  00311	8b c8		 mov	 ecx, eax
  00313	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  00318	50		 push	 eax
  00319	e8 00 00 00 00	 call	 ?FirstFile@@YAHPBDIPAU_WIN32_FIND_DATAA@@@Z ; FirstFile
  0031e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00321	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 164  : 			if (pm.acc)

  00326	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?pm@@3VPMachine@@A+4, 0
  0032d	74 1f		 je	 SHORT $L59919

; 165  : 				(TextID)arg(3) = findFileEntry.cFileName;

  0032f	68 2c 00 00 00	 push	 OFFSET FLAT:_?findFileEntry@?1??KFileIO@@YAXPAF@Z@4U_WIN32_FIND_DATAA@@A+44
  00334	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00337	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  0033b	50		 push	 eax
  0033c	8d 8d 90 fd ff
	ff		 lea	 ecx, DWORD PTR $T60318[ebp]
  00342	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  00347	8b c8		 mov	 ecx, eax
  00349	e8 00 00 00 00	 call	 ??4TextID@@QAEAAV0@PBD@Z ; TextID::operator=
$L59919:

; 166  : //				strcpy(*(TextID) arg(3), findFileEntry.name);
; 167  : 			break;

  0034e	e9 fa 02 00 00	 jmp	 $L59870
$L59922:

; 168  : 
; 169  : 		case FileFindNext:
; 170  : 			pm.acc = (Acc) NextFile(&findFileEntry);

  00353	68 00 00 00 00	 push	 OFFSET FLAT:_?findFileEntry@?1??KFileIO@@YAXPAF@Z@4U_WIN32_FIND_DATAA@@A
  00358	e8 00 00 00 00	 call	 ?NextFile@@YAHPAU_WIN32_FIND_DATAA@@@Z ; NextFile
  0035d	83 c4 04	 add	 esp, 4
  00360	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 171  : 			if (pm.acc)

  00365	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?pm@@3VPMachine@@A+4, 0
  0036c	74 1f		 je	 SHORT $L59924

; 172  : 				(TextID)arg(2) = findFileEntry.cFileName;

  0036e	68 2c 00 00 00	 push	 OFFSET FLAT:_?findFileEntry@?1??KFileIO@@YAXPAF@Z@4U_WIN32_FIND_DATAA@@A+44
  00373	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00376	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  0037a	52		 push	 edx
  0037b	8d 8d 8c fd ff
	ff		 lea	 ecx, DWORD PTR $T60319[ebp]
  00381	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  00386	8b c8		 mov	 ecx, eax
  00388	e8 00 00 00 00	 call	 ??4TextID@@QAEAAV0@PBD@Z ; TextID::operator=
$L59924:

; 173  : //				strcpy(*(TextID) arg(2), findFileEntry.name);
; 174  : 			break;

  0038d	e9 bb 02 00 00	 jmp	 $L59870
$L59927:

; 175  : 
; 176  : 		case FileExists:
; 177  : 			pm.acc = (Acc) Exists(*(TextID) arg(2));

  00392	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00395	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  00399	51		 push	 ecx
  0039a	8d 8d 88 fd ff
	ff		 lea	 ecx, DWORD PTR $T60320[ebp]
  003a0	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  003a5	8b c8		 mov	 ecx, eax
  003a7	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  003ac	50		 push	 eax
  003ad	e8 00 00 00 00	 call	 ?Exists@@YAHPBD@Z	; Exists
  003b2	83 c4 04	 add	 esp, 4
  003b5	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 178  : 			break;

  003ba	e9 8e 02 00 00	 jmp	 $L59870
$L59931:

; 179  : 
; 180  : 		case FileRename:
; 181  : 			pm.acc = (Acc) Rename(*(TextID) arg(2), *(TextID) arg(3));

  003bf	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  003c2	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  003c6	50		 push	 eax
  003c7	8d 8d 84 fd ff
	ff		 lea	 ecx, DWORD PTR $T60321[ebp]
  003cd	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  003d2	8b c8		 mov	 ecx, eax
  003d4	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  003d9	50		 push	 eax
  003da	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  003dd	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  003e1	52		 push	 edx
  003e2	8d 8d 80 fd ff
	ff		 lea	 ecx, DWORD PTR $T60322[ebp]
  003e8	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  003ed	8b c8		 mov	 ecx, eax
  003ef	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  003f4	50		 push	 eax
  003f5	e8 00 00 00 00	 call	 ?Rename@@YAHPBD0@Z	; Rename
  003fa	83 c4 08	 add	 esp, 8
  003fd	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 182  : 			break;

  00402	e9 46 02 00 00	 jmp	 $L59870
$L59937:

; 186  : 			int	fd2, cnt;
; 187  : 			const unsigned	CPYBUFLEN =	512;

  00407	c7 85 c0 fd ff
	ff 00 02 00 00	 mov	 DWORD PTR _CPYBUFLEN$59940[ebp], 512 ; 00000200H

; 188  : 			char	cpy[CPYBUFLEN];
; 189  : 
; 190  : 			TextID buf(arg(2));

  00411	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00414	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  00418	51		 push	 ecx
  00419	8d 8d c8 fd ff
	ff		 lea	 ecx, DWORD PTR _buf$59942[ebp]
  0041f	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID

; 191  : 			int fd = Open(*buf, O_RDONLY | O_BINARY);

  00424	68 00 80 00 00	 push	 32768			; 00008000H
  00429	8d 8d c8 fd ff
	ff		 lea	 ecx, DWORD PTR _buf$59942[ebp]
  0042f	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  00434	50		 push	 eax
  00435	e8 00 00 00 00	 call	 ?Open@@YAHPBDI@Z	; Open
  0043a	83 c4 08	 add	 esp, 8
  0043d	89 85 cc fd ff
	ff		 mov	 DWORD PTR _fd$59943[ebp], eax

; 192  : // BEW CLEANUP 			if (critErrHandler->Tripped())
; 193  : // BEW CLEANUP 				break;
; 194  : 			buf = (TextID) arg(3);

  00443	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00446	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  0044a	50		 push	 eax
  0044b	8d 8d 7c fd ff
	ff		 lea	 ecx, DWORD PTR $T60323[ebp]
  00451	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  00456	66 8b 08	 mov	 cx, WORD PTR [eax]
  00459	66 89 8d c8 fd
	ff ff		 mov	 WORD PTR _buf$59942[ebp], cx

; 195  : 			fd2 = Creat(*buf, 0);

  00460	6a 00		 push	 0
  00462	8d 8d c8 fd ff
	ff		 lea	 ecx, DWORD PTR _buf$59942[ebp]
  00468	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  0046d	50		 push	 eax
  0046e	e8 00 00 00 00	 call	 ?Creat@@YAHPBDI@Z	; Creat
  00473	83 c4 08	 add	 esp, 8
  00476	89 85 bc fd ff
	ff		 mov	 DWORD PTR _fd2$59938[ebp], eax
$L59947:

; 196  : // BEW CLEANUP 			if (critErrHandler->Tripped()) {
; 197  : // BEW CLEANUP 				Close(fd);
; 198  : // BEW CLEANUP 				break;
; 199  : // BEW CLEANUP 			}
; 200  : 			while ((cnt = Read(fd, cpy, CPYBUFLEN)) != 0) {

  0047c	68 00 02 00 00	 push	 512			; 00000200H
  00481	8d 95 d0 fd ff
	ff		 lea	 edx, DWORD PTR _cpy$59941[ebp]
  00487	52		 push	 edx
  00488	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _fd$59943[ebp]
  0048e	50		 push	 eax
  0048f	e8 00 00 00 00	 call	 ?Read@@YAHHPAXH@Z	; Read
  00494	83 c4 0c	 add	 esp, 12			; 0000000cH
  00497	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _cnt$59939[ebp], eax
  0049d	83 bd c4 fd ff
	ff 00		 cmp	 DWORD PTR _cnt$59939[ebp], 0
  004a4	74 1f		 je	 SHORT $L59948

; 201  : // BEW CLEANUP 				if (critErrHandler->Tripped())
; 202  : // BEW CLEANUP 					break;
; 203  : 				Write(fd2, cpy, cnt);

  004a6	8b 8d c4 fd ff
	ff		 mov	 ecx, DWORD PTR _cnt$59939[ebp]
  004ac	51		 push	 ecx
  004ad	8d 95 d0 fd ff
	ff		 lea	 edx, DWORD PTR _cpy$59941[ebp]
  004b3	52		 push	 edx
  004b4	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR _fd2$59938[ebp]
  004ba	50		 push	 eax
  004bb	e8 00 00 00 00	 call	 ?Write@@YAHHPAXH@Z	; Write
  004c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 204  : // BEW CLEANUP 				if (critErrHandler->Tripped())
; 205  : // BEW CLEANUP 					break;
; 206  : 			}

  004c3	eb b7		 jmp	 SHORT $L59947
$L59948:

; 207  : // BEW CLEANUP 			pm.acc = (Acc) critErrHandler->Tripped();
; 208  : 			Close(fd);

  004c5	8b 8d cc fd ff
	ff		 mov	 ecx, DWORD PTR _fd$59943[ebp]
  004cb	51		 push	 ecx
  004cc	e8 00 00 00 00	 call	 ?Close@@YAHH@Z		; Close
  004d1	83 c4 04	 add	 esp, 4

; 209  : 			Close(fd2);

  004d4	8b 95 bc fd ff
	ff		 mov	 edx, DWORD PTR _fd2$59938[ebp]
  004da	52		 push	 edx
  004db	e8 00 00 00 00	 call	 ?Close@@YAHH@Z		; Close
  004e0	83 c4 04	 add	 esp, 4

; 210  : 			break;

  004e3	e9 65 01 00 00	 jmp	 $L59870
$L59949:

; 212  : 			
; 213  :       case FileReadByte:
; 214  : 			pm.acc = 0;

  004e8	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, 0

; 215  :          Read(arg(2), &pm.acc, 1);

  004f2	6a 01		 push	 1
  004f4	68 04 00 00 00	 push	 OFFSET FLAT:?pm@@3VPMachine@@A+4
  004f9	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  004fc	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  00500	51		 push	 ecx
  00501	e8 00 00 00 00	 call	 ?Read@@YAHHPAXH@Z	; Read
  00506	83 c4 0c	 add	 esp, 12			; 0000000cH

; 216  :          break;

  00509	e9 3f 01 00 00	 jmp	 $L59870
$L59950:

; 217  : 
; 218  :       case FileWriteByte:
; 219  :          Write(arg(2), &arg(3), 1);

  0050e	6a 01		 push	 1
  00510	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00513	83 c2 06	 add	 edx, 6
  00516	52		 push	 edx
  00517	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  0051a	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  0051e	51		 push	 ecx
  0051f	e8 00 00 00 00	 call	 ?Write@@YAHHPAXH@Z	; Write
  00524	83 c4 0c	 add	 esp, 12			; 0000000cH

; 220  :          break;

  00527	e9 21 01 00 00	 jmp	 $L59870
$L59951:

; 221  : 
; 222  :       case FileReadWord:
; 223  : 			pm.acc = 0;

  0052c	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, 0

; 224  :          Read(arg(2), &pm.acc, sizeof(SCIWord));

  00536	6a 02		 push	 2
  00538	68 04 00 00 00	 push	 OFFSET FLAT:?pm@@3VPMachine@@A+4
  0053d	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00540	0f bf 42 04	 movsx	 eax, WORD PTR [edx+4]
  00544	50		 push	 eax
  00545	e8 00 00 00 00	 call	 ?Read@@YAHHPAXH@Z	; Read
  0054a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 225  :          break;

  0054d	e9 fb 00 00 00	 jmp	 $L59870
$L59953:

; 226  : 
; 227  :       case FileWriteWord:
; 228  :          Write(arg(2), &arg(3), sizeof(SCIWord));

  00552	6a 02		 push	 2
  00554	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00557	83 c1 06	 add	 ecx, 6
  0055a	51		 push	 ecx
  0055b	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  0055e	0f bf 42 04	 movsx	 eax, WORD PTR [edx+4]
  00562	50		 push	 eax
  00563	e8 00 00 00 00	 call	 ?Write@@YAHHPAXH@Z	; Write
  00568	83 c4 0c	 add	 esp, 12			; 0000000cH

; 229  :          break;

  0056b	e9 dd 00 00 00	 jmp	 $L59870
$L59955:

; 230  : 
; 231  : 		case FileCheckFreeSpace:
; 232  : 			pm.acc = CheckFreeSpace(arg(2), arg(3) ? *(TextID) arg(3) : 0);

  00570	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00573	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00577	85 d2		 test	 edx, edx
  00579	74 22		 je	 SHORT $L60325
  0057b	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  0057e	66 8b 48 06	 mov	 cx, WORD PTR [eax+6]
  00582	51		 push	 ecx
  00583	8d 8d 78 fd ff
	ff		 lea	 ecx, DWORD PTR $T60324[ebp]
  00589	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  0058e	8b c8		 mov	 ecx, eax
  00590	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  00595	89 85 68 fd ff
	ff		 mov	 DWORD PTR -664+[ebp], eax
  0059b	eb 0a		 jmp	 SHORT $L60326
$L60325:
  0059d	c7 85 68 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR -664+[ebp], 0
$L60326:
  005a7	8b 95 68 fd ff
	ff		 mov	 edx, DWORD PTR -664+[ebp]
  005ad	52		 push	 edx
  005ae	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  005b1	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  005b5	51		 push	 ecx
  005b6	e8 00 00 00 00	 call	 ?CheckFreeSpace@@YAFHPBD@Z ; CheckFreeSpace
  005bb	83 c4 08	 add	 esp, 8
  005be	0f bf d0	 movsx	 edx, ax
  005c1	89 15 04 00 00
	00		 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, edx

; 233  : 			break;

  005c7	e9 81 00 00 00	 jmp	 $L59870
$L59958:

; 236  : 			TextID id(arg(2));

  005cc	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  005cf	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  005d3	51		 push	 ecx
  005d4	8d 8d b8 fd ff
	ff		 lea	 ecx, DWORD PTR _id$59959[ebp]
  005da	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID

; 237  : 			id.Realloc(MaxPath + 1);

  005df	68 05 01 00 00	 push	 261			; 00000105H
  005e4	8d 8d b8 fd ff
	ff		 lea	 ecx, DWORD PTR _id$59959[ebp]
  005ea	e8 00 00 00 00	 call	 ?Realloc@MemID@@QBEPAXI@Z ; MemID::Realloc

; 238  : 			GetCWD(*id);

  005ef	8d 8d b8 fd ff
	ff		 lea	 ecx, DWORD PTR _id$59959[ebp]
  005f5	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  005fa	50		 push	 eax
  005fb	e8 00 00 00 00	 call	 ?GetCWD@@YAPADPAD@Z	; GetCWD
  00600	83 c4 04	 add	 esp, 4

; 239  : 			id.Snug();

  00603	8d 8d b8 fd ff
	ff		 lea	 ecx, DWORD PTR _id$59959[ebp]
  00609	e8 00 00 00 00	 call	 ?Snug@TextID@@QAEXXZ	; TextID::Snug

; 240  : 			pm.acc = id;

  0060e	8d 8d b8 fd ff
	ff		 lea	 ecx, DWORD PTR _id$59959[ebp]
  00614	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00619	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0061e	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 241  : 			break;

  00623	eb 28		 jmp	 SHORT $L59870
$L59960:

; 243  : 
; 244  : 		case FileValidPath:
; 245  : 			pm.acc = CheckValidPath(*(TextID) arg(2));

  00625	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00628	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  0062c	50		 push	 eax
  0062d	8d 8d 74 fd ff
	ff		 lea	 ecx, DWORD PTR $T60327[ebp]
  00633	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  00638	8b c8		 mov	 ecx, eax
  0063a	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  0063f	50		 push	 eax
  00640	e8 00 00 00 00	 call	 ?CheckValidPath@@YAHPBD@Z ; CheckValidPath
  00645	83 c4 04	 add	 esp, 4
  00648	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax
$L59870:

; 248  : 
; 249  : // BEW CLEANUP 	critErrHandler->SetMethod(CritErrHandler::Abort);
; 250  : }

  0064d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00654	8d 4d f0	 lea	 ecx, DWORD PTR _array$[ebp]
  00657	e8 00 00 00 00	 call	 ??1Array@@QAE@XZ	; Array::~Array
  0065c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0065f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00666	8b e5		 mov	 esp, ebp
  00668	5d		 pop	 ebp
  00669	c3		 ret	 0
$L60335:
  0066a	00 00 00 00	 DD	 $L59873
  0066e	00 00 00 00	 DD	 $L59880
  00672	00 00 00 00	 DD	 $L59881
  00676	00 00 00 00	 DD	 $L59895
  0067a	00 00 00 00	 DD	 $L59900
  0067e	00 00 00 00	 DD	 $L59904
  00682	00 00 00 00	 DD	 $L59907
  00686	00 00 00 00	 DD	 $L59913
  0068a	00 00 00 00	 DD	 $L59915
  0068e	00 00 00 00	 DD	 $L59922
  00692	00 00 00 00	 DD	 $L59927
  00696	00 00 00 00	 DD	 $L59931
  0069a	00 00 00 00	 DD	 $L59937
  0069e	00 00 00 00	 DD	 $L59949
  006a2	00 00 00 00	 DD	 $L59950
  006a6	00 00 00 00	 DD	 $L59951
  006aa	00 00 00 00	 DD	 $L59953
  006ae	00 00 00 00	 DD	 $L59955
  006b2	00 00 00 00	 DD	 $L59958
  006b6	00 00 00 00	 DD	 $L59960
_TEXT	ENDS
text$x	SEGMENT
$L60328:
  00000	8d 4d f0	 lea	 ecx, DWORD PTR _array$[ebp]
  00003	e8 00 00 00 00	 call	 ??1Array@@QAE@XZ	; Array::~Array
  00008	c3		 ret	 0
$L60333:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T60332
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?KFileIO@@YAXPAF@Z ENDP					; KFileIO
PUBLIC	?KDeviceInfo@@YAXPAF@Z				; KDeviceInfo
PUBLIC	?IsDriveAOrB@@YAHPBD@Z				; IsDriveAOrB
EXTRN	_strcmp:NEAR
_TEXT	SEGMENT
_args$ = 8
$T60339 = -4
$T60340 = -8
$T60341 = -12
$T60342 = -16
$T60343 = -20
$T60344 = -24
?KDeviceInfo@@YAXPAF@Z PROC NEAR			; KDeviceInfo

; 254  : {

  006ba	55		 push	 ebp
  006bb	8b ec		 mov	 ebp, esp
  006bd	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 255  : 	enum {
; 256  : 		GETDEVICE,
; 257  : 		CURDEVICE,
; 258  : 		SAMEDEVICE,
; 259  : 		DEVREMOVABLE,
; 260  : 		CLOSEDEVICE,
; 261  : 		SAVEDEVICE,
; 262  : 		SAVEDIRMOUNTED,
; 263  : 		MAKESAVEDIRNAME,
; 264  : 		MAKESAVEFILENAME
; 265  : 	};
; 266  : 
; 267  : 	switch (arg(1)) {

  006c0	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  006c3	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  006c7	89 4d e4	 mov	 DWORD PTR -28+[ebp], ecx
  006ca	83 7d e4 06	 cmp	 DWORD PTR -28+[ebp], 6
  006ce	0f 87 f7 00 00
	00		 ja	 $L59977
  006d4	8b 55 e4	 mov	 edx, DWORD PTR -28+[ebp]
  006d7	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L60345[edx*4]
$L59980:

; 268  : 		case GETDEVICE:
; 269  : 			GetDevice(*(TextID) arg(2), *(TextID) arg(3));

  006de	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  006e1	66 8b 48 06	 mov	 cx, WORD PTR [eax+6]
  006e5	51		 push	 ecx
  006e6	8d 4d fc	 lea	 ecx, DWORD PTR $T60339[ebp]
  006e9	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  006ee	8b c8		 mov	 ecx, eax
  006f0	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  006f5	50		 push	 eax
  006f6	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  006f9	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  006fd	50		 push	 eax
  006fe	8d 4d f8	 lea	 ecx, DWORD PTR $T60340[ebp]
  00701	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  00706	8b c8		 mov	 ecx, eax
  00708	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  0070d	50		 push	 eax
  0070e	e8 00 00 00 00	 call	 ?GetDevice@@YAXPAD0@Z	; GetDevice
  00713	83 c4 08	 add	 esp, 8

; 270  : 			pm.acc = arg(3);

  00716	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00719	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  0071d	89 15 04 00 00
	00		 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, edx

; 271  : 			break;

  00723	e9 a3 00 00 00	 jmp	 $L59977
$L59985:

; 272  : 
; 273  : 		case CURDEVICE:
; 274  : 			GetCurDevice(*(TextID) arg(2));

  00728	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  0072b	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  0072f	51		 push	 ecx
  00730	8d 4d f4	 lea	 ecx, DWORD PTR $T60341[ebp]
  00733	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  00738	8b c8		 mov	 ecx, eax
  0073a	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  0073f	50		 push	 eax
  00740	e8 00 00 00 00	 call	 ?GetCurDevice@@YAXPAD@Z	; GetCurDevice
  00745	83 c4 04	 add	 esp, 4

; 275  : 			pm.acc = arg(2);

  00748	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  0074b	0f bf 42 04	 movsx	 eax, WORD PTR [edx+4]
  0074f	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 276  : 			break;

  00754	eb 75		 jmp	 SHORT $L59977
$L59988:

; 277  : 
; 278  : 		case SAMEDEVICE:
; 279  : 			pm.acc = !strcmp(*(TextID) arg(2), *(TextID) arg(3));

  00756	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00759	66 8b 51 06	 mov	 dx, WORD PTR [ecx+6]
  0075d	52		 push	 edx
  0075e	8d 4d f0	 lea	 ecx, DWORD PTR $T60342[ebp]
  00761	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  00766	8b c8		 mov	 ecx, eax
  00768	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  0076d	50		 push	 eax
  0076e	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00771	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  00775	51		 push	 ecx
  00776	8d 4d ec	 lea	 ecx, DWORD PTR $T60343[ebp]
  00779	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  0077e	8b c8		 mov	 ecx, eax
  00780	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  00785	50		 push	 eax
  00786	e8 00 00 00 00	 call	 _strcmp
  0078b	83 c4 08	 add	 esp, 8
  0078e	f7 d8		 neg	 eax
  00790	1b c0		 sbb	 eax, eax
  00792	40		 inc	 eax
  00793	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 280  : 			break;

  00798	eb 31		 jmp	 SHORT $L59977
$L59993:

; 281  : 
; 282  : 		case DEVREMOVABLE:
; 283  : 			pm.acc = (Acc) IsDriveAOrB(*(TextID) arg(2));

  0079a	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  0079d	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  007a1	50		 push	 eax
  007a2	8d 4d e8	 lea	 ecx, DWORD PTR $T60344[ebp]
  007a5	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  007aa	8b c8		 mov	 ecx, eax
  007ac	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  007b1	50		 push	 eax
  007b2	e8 00 00 00 00	 call	 ?IsDriveAOrB@@YAHPBD@Z	; IsDriveAOrB
  007b7	83 c4 04	 add	 esp, 4
  007ba	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 284  : 			break;

  007bf	eb 0a		 jmp	 SHORT $L59977
$L60000:

; 285  : 
; 286  : 		case CLOSEDEVICE:
; 287  : 			// A do-nothing on the IBM, but needed on the Mac and Amiga.
; 288  : 			break;
; 289  : 
; 290  : 		case SAVEDEVICE:
; 291  : 			// Return letter of writeable device in case of CD-ROM-based game.
; 292  : 			// (Presume same device as where file used to start game)
; 293  : 			assert(!"No support for SAVEDEVICE call yet");
; 294  : 			break;
; 295  : 
; 296  : 		case SAVEDIRMOUNTED:
; 297  : 			// A do-nothing on the IBM, but needed on the Mac and Amiga.
; 298  : 			pm.acc = True; // assume save disk is mounted by user

  007c1	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, 1
$L59977:

; 301  : }

  007cb	8b e5		 mov	 esp, ebp
  007cd	5d		 pop	 ebp
  007ce	c3		 ret	 0
$L60345:
  007cf	00 00 00 00	 DD	 $L59980
  007d3	00 00 00 00	 DD	 $L59985
  007d7	00 00 00 00	 DD	 $L59988
  007db	00 00 00 00	 DD	 $L59993
  007df	00 00 00 00	 DD	 $L59977
  007e3	00 00 00 00	 DD	 $L59977
  007e7	00 00 00 00	 DD	 $L60000
?KDeviceInfo@@YAXPAF@Z ENDP				; KDeviceInfo
_TEXT	ENDS
PUBLIC	?AddSlash@@YAPADPAD@Z				; AddSlash
EXTRN	_strcat:NEAR
_DATA	SEGMENT
	ORG $+2
$SG60007 DB	'\', 00H
_DATA	ENDS
_TEXT	SEGMENT
_dir$ = 8
_len$ = -8
_lastChar$ = -4
?AddSlash@@YAPADPAD@Z PROC NEAR				; AddSlash

; 307  : {

  007eb	55		 push	 ebp
  007ec	8b ec		 mov	 ebp, esp
  007ee	83 ec 08	 sub	 esp, 8

; 308  : 	//	add trailing slash to directory so file name can be concatenated onto it
; 309  : 
; 310  : 	int len = strlen(dir);

  007f1	8b 45 08	 mov	 eax, DWORD PTR _dir$[ebp]
  007f4	50		 push	 eax
  007f5	e8 00 00 00 00	 call	 _strlen
  007fa	83 c4 04	 add	 esp, 4
  007fd	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 311  : 	char lastChar = dir[len - 1];

  00800	8b 4d 08	 mov	 ecx, DWORD PTR _dir$[ebp]
  00803	03 4d f8	 add	 ecx, DWORD PTR _len$[ebp]
  00806	8a 51 ff	 mov	 dl, BYTE PTR [ecx-1]
  00809	88 55 fc	 mov	 BYTE PTR _lastChar$[ebp], dl

; 312  : 	if (len && lastChar != '\\' && lastChar != '/' && lastChar != ':')

  0080c	83 7d f8 00	 cmp	 DWORD PTR _len$[ebp], 0
  00810	74 2c		 je	 SHORT $L60006
  00812	0f be 45 fc	 movsx	 eax, BYTE PTR _lastChar$[ebp]
  00816	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  00819	74 23		 je	 SHORT $L60006
  0081b	0f be 4d fc	 movsx	 ecx, BYTE PTR _lastChar$[ebp]
  0081f	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00822	74 1a		 je	 SHORT $L60006
  00824	0f be 55 fc	 movsx	 edx, BYTE PTR _lastChar$[ebp]
  00828	83 fa 3a	 cmp	 edx, 58			; 0000003aH
  0082b	74 11		 je	 SHORT $L60006

; 313  : 		strcat(dir, "\\");

  0082d	68 00 00 00 00	 push	 OFFSET FLAT:$SG60007
  00832	8b 45 08	 mov	 eax, DWORD PTR _dir$[ebp]
  00835	50		 push	 eax
  00836	e8 00 00 00 00	 call	 _strcat
  0083b	83 c4 08	 add	 esp, 8
$L60006:

; 314  : 	return dir;

  0083e	8b 45 08	 mov	 eax, DWORD PTR _dir$[ebp]

; 315  : }

  00841	8b e5		 mov	 esp, ebp
  00843	5d		 pop	 ebp
  00844	c3		 ret	 0
?AddSlash@@YAPADPAD@Z ENDP				; AddSlash
_TEXT	ENDS
PUBLIC	?FullPath@@YAPADPADPBD@Z			; FullPath
EXTRN	__imp__getcwd:NEAR
EXTRN	_strcpy:NEAR
EXTRN	__imp__strchr:NEAR
_TEXT	SEGMENT
_dest$ = 8
_fileName$ = 12
?FullPath@@YAPADPADPBD@Z PROC NEAR			; FullPath

; 319  : {

  00845	55		 push	 ebp
  00846	8b ec		 mov	 ebp, esp

; 320  : 	//	adds current directory to filename
; 321  : 	//	only works with bare filename, without path or drive components
; 322  : 	//	WATCOM's _fullpath() is buggy:  gets correct drive but incorrect path
; 323  : 	
; 324  : 	//	if it already has a directory or drive component, just leave it alone
; 325  : 	if (strchr(fileName, ':') || strchr(fileName, '\\'))

  00848	6a 3a		 push	 58			; 0000003aH
  0084a	8b 45 0c	 mov	 eax, DWORD PTR _fileName$[ebp]
  0084d	50		 push	 eax
  0084e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strchr
  00854	83 c4 08	 add	 esp, 8
  00857	85 c0		 test	 eax, eax
  00859	75 13		 jne	 SHORT $L60013
  0085b	6a 5c		 push	 92			; 0000005cH
  0085d	8b 4d 0c	 mov	 ecx, DWORD PTR _fileName$[ebp]
  00860	51		 push	 ecx
  00861	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strchr
  00867	83 c4 08	 add	 esp, 8
  0086a	85 c0		 test	 eax, eax
  0086c	74 12		 je	 SHORT $L60012
$L60013:

; 326  : 		return strcpy(dest, fileName);

  0086e	8b 55 0c	 mov	 edx, DWORD PTR _fileName$[ebp]
  00871	52		 push	 edx
  00872	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00875	50		 push	 eax
  00876	e8 00 00 00 00	 call	 _strcpy
  0087b	83 c4 08	 add	 esp, 8
  0087e	eb 31		 jmp	 SHORT $L60011
$L60012:

; 327  : 	
; 328  : 	getcwd(dest, _MAX_PATH);

  00880	68 04 01 00 00	 push	 260			; 00000104H
  00885	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00888	51		 push	 ecx
  00889	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__getcwd
  0088f	83 c4 08	 add	 esp, 8

; 329  : 	AddSlash(dest);

  00892	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  00895	52		 push	 edx
  00896	e8 00 00 00 00	 call	 ?AddSlash@@YAPADPAD@Z	; AddSlash
  0089b	83 c4 04	 add	 esp, 4

; 330  : 	strcat(dest, fileName);

  0089e	8b 45 0c	 mov	 eax, DWORD PTR _fileName$[ebp]
  008a1	50		 push	 eax
  008a2	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  008a5	51		 push	 ecx
  008a6	e8 00 00 00 00	 call	 _strcat
  008ab	83 c4 08	 add	 esp, 8

; 331  : 	return dest;

  008ae	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
$L60011:

; 332  : }

  008b1	5d		 pop	 ebp
  008b2	c3		 ret	 0
?FullPath@@YAPADPADPBD@Z ENDP				; FullPath
_TEXT	ENDS
EXTRN	__imp___fmode:DWORD
EXTRN	__imp__creat:NEAR
_TEXT	SEGMENT
_fileName$ = 8
_mode$ = 12
?Creat@@YAHPBDI@Z PROC NEAR				; Creat

; 336  : {

  008b3	55		 push	 ebp
  008b4	8b ec		 mov	 ebp, esp

; 337  : 	//	create a file with name pointed to by 'fname' with attributes set in
; 338  : 	//	'mode'
; 339  : 
; 340  : // BEW CLEANUP 	critErrHandler->Clear();
; 341  : 	_fmode = O_BINARY;

  008b6	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___fmode
  008bb	c7 00 00 80 00
	00		 mov	 DWORD PTR [eax], 32768	; 00008000H

; 342  : 	return creat(fileName, mode);

  008c1	8b 4d 0c	 mov	 ecx, DWORD PTR _mode$[ebp]
  008c4	51		 push	 ecx
  008c5	8b 55 08	 mov	 edx, DWORD PTR _fileName$[ebp]
  008c8	52		 push	 edx
  008c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__creat
  008cf	83 c4 08	 add	 esp, 8

; 343  : }

  008d2	5d		 pop	 ebp
  008d3	c3		 ret	 0
?Creat@@YAHPBDI@Z ENDP					; Creat
_TEXT	ENDS
EXTRN	__imp__open:NEAR
_TEXT	SEGMENT
_name$ = 8
_mode$ = 12
?Open@@YAHPBDI@Z PROC NEAR				; Open

; 347  : {

  008d4	55		 push	 ebp
  008d5	8b ec		 mov	 ebp, esp

; 348  : // BEW CLEANUP 	critErrHandler->Clear();
; 349  : 	_fmode = O_BINARY;

  008d7	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___fmode
  008dc	c7 00 00 80 00
	00		 mov	 DWORD PTR [eax], 32768	; 00008000H

; 350  : 	return open(name, mode);

  008e2	8b 4d 0c	 mov	 ecx, DWORD PTR _mode$[ebp]
  008e5	51		 push	 ecx
  008e6	8b 55 08	 mov	 edx, DWORD PTR _name$[ebp]
  008e9	52		 push	 edx
  008ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__open
  008f0	83 c4 08	 add	 esp, 8

; 351  : }

  008f3	5d		 pop	 ebp
  008f4	c3		 ret	 0
?Open@@YAHPBDI@Z ENDP					; Open
_TEXT	ENDS
PUBLIC	?ReadMemID@@YAHHVMemID@@H@Z			; ReadMemID
_DATA	SEGMENT
	ORG $+2
$SG60028 DB	'ReadMemID: target is not big enough (%d, %d)', 00H
_DATA	ENDS
_TEXT	SEGMENT
_fd$ = 8
_id$ = 12
_size$ = 16
?ReadMemID@@YAHHVMemID@@H@Z PROC NEAR			; ReadMemID

; 356  : {

  008f5	55		 push	 ebp
  008f6	8b ec		 mov	 ebp, esp

; 357  : 	if ( id.Size() < size )

  008f8	8d 4d 0c	 lea	 ecx, DWORD PTR _id$[ebp]
  008fb	e8 00 00 00 00	 call	 ?Size@MemID@@QBEIXZ	; MemID::Size
  00900	3b 45 10	 cmp	 eax, DWORD PTR _size$[ebp]
  00903	73 21		 jae	 SHORT $L60027

; 358  : 		msgMgr->Fatal ( "ReadMemID: target is not big enough (%d, %d)", id.Size(), size );

  00905	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  00908	50		 push	 eax
  00909	8d 4d 0c	 lea	 ecx, DWORD PTR _id$[ebp]
  0090c	e8 00 00 00 00	 call	 ?Size@MemID@@QBEIXZ	; MemID::Size
  00911	50		 push	 eax
  00912	68 00 00 00 00	 push	 OFFSET FLAT:$SG60028
  00917	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  0091d	51		 push	 ecx
  0091e	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00923	83 c4 10	 add	 esp, 16			; 00000010H
$L60027:

; 359  : 
; 360  : 	return Read(fd,*id,size);

  00926	8b 55 10	 mov	 edx, DWORD PTR _size$[ebp]
  00929	52		 push	 edx
  0092a	8d 4d 0c	 lea	 ecx, DWORD PTR _id$[ebp]
  0092d	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  00932	50		 push	 eax
  00933	8b 45 08	 mov	 eax, DWORD PTR _fd$[ebp]
  00936	50		 push	 eax
  00937	e8 00 00 00 00	 call	 ?Read@@YAHHPAXH@Z	; Read
  0093c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 361  : }

  0093f	5d		 pop	 ebp
  00940	c3		 ret	 0
?ReadMemID@@YAHHVMemID@@H@Z ENDP			; ReadMemID
_TEXT	ENDS
EXTRN	__imp__read:NEAR
_TEXT	SEGMENT
_fd$ = 8
_buf$ = 12
_n$ = 16
?Read@@YAHHPAXH@Z PROC NEAR				; Read

; 365  : {

  00941	55		 push	 ebp
  00942	8b ec		 mov	 ebp, esp

; 366  : // BEW CLEANUP 	critErrHandler->Clear();
; 367  : 
; 368  : //#ifndef WIN32S
; 369  : #if 0
; 370  : 	int count = n, numRead = 0, totalRead = 0;
; 371  : 
; 372  : //	msgMgr->Alert ( "have to read %d bytes", count );
; 373  : 
; 374  : 	while ( count ) {
; 375  : 		int realPtr = AllocAlias16 ( ((char *)buf) + numRead );
; 376  : 
; 377  : 		REGS inRegs, outRegs;
; 378  : 		SREGS segRegs;
; 379  : 
; 380  : 		unsigned int numToRead = (count > 65000)? 65000 : count;
; 381  : 		count -= numToRead;
; 382  : 		numRead += numToRead;
; 383  : 
; 384  : //		msgMgr->Alert ( "reading %d bytes, count now %d", numToRead, count );
; 385  : 
; 386  : 		inRegs.h.ah = 0x3f;
; 387  : 		inRegs.x.bx = (unsigned short)fd;
; 388  : 		inRegs.x.cx = numToRead;
; 389  : 
; 390  : 		segRegs.es = segRegs.fs = segRegs.gs = FP_SEG ( &segRegs );
; 391  : 		segRegs.ds = HIWORD ( realPtr );
; 392  : 		inRegs.x.dx = LOWORD ( realPtr );
; 393  : 
; 394  : 		intdosx ( &inRegs, &outRegs, &segRegs );
; 395  : 
; 396  : 		totalRead += outRegs.x.ax;
; 397  : 
; 398  : 		FreeAlias16 ( realPtr );
; 399  : 	}
; 400  : 
; 401  : //	msgMgr->Alert ( "totalRead = %d", totalRead);
; 402  : 
; 403  : 	return totalRead;
; 404  : #else
; 405  : 	return read(fd, buf, n);

  00944	8b 45 10	 mov	 eax, DWORD PTR _n$[ebp]
  00947	50		 push	 eax
  00948	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  0094b	51		 push	 ecx
  0094c	8b 55 08	 mov	 edx, DWORD PTR _fd$[ebp]
  0094f	52		 push	 edx
  00950	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__read
  00956	83 c4 0c	 add	 esp, 12			; 0000000cH

; 406  : #endif
; 407  : }

  00959	5d		 pop	 ebp
  0095a	c3		 ret	 0
?Read@@YAHHPAXH@Z ENDP					; Read
_TEXT	ENDS
EXTRN	__imp__write:NEAR
_TEXT	SEGMENT
_fd$ = 8
_buf$ = 12
_n$ = 16
?Write@@YAHHPAXH@Z PROC NEAR				; Write

; 426  : {

  0095b	55		 push	 ebp
  0095c	8b ec		 mov	 ebp, esp

; 427  : // BEW CLEANUP 	critErrHandler->Clear();
; 428  : 	return write(fd, buf, n);

  0095e	8b 45 10	 mov	 eax, DWORD PTR _n$[ebp]
  00961	50		 push	 eax
  00962	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  00965	51		 push	 ecx
  00966	8b 55 08	 mov	 edx, DWORD PTR _fd$[ebp]
  00969	52		 push	 edx
  0096a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__write
  00970	83 c4 0c	 add	 esp, 12			; 0000000cH

; 429  : }

  00973	5d		 pop	 ebp
  00974	c3		 ret	 0
?Write@@YAHHPAXH@Z ENDP					; Write
_TEXT	ENDS
EXTRN	__imp__close:NEAR
_TEXT	SEGMENT
_fd$ = 8
?Close@@YAHH@Z PROC NEAR				; Close

; 433  : {

  00975	55		 push	 ebp
  00976	8b ec		 mov	 ebp, esp

; 434  : // BEW CLEANUP 	critErrHandler->Clear();
; 435  : 
; 436  : 	if (fd > 0)

  00978	83 7d 08 00	 cmp	 DWORD PTR _fd$[ebp], 0
  0097c	7e 0f		 jle	 SHORT $L60042

; 437  : 		return close(fd);

  0097e	8b 45 08	 mov	 eax, DWORD PTR _fd$[ebp]
  00981	50		 push	 eax
  00982	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__close
  00988	83 c4 04	 add	 esp, 4
  0098b	eb 03		 jmp	 SHORT $L60043
$L60042:

; 439  : 		return -1;

  0098d	83 c8 ff	 or	 eax, -1
$L60043:

; 440  : }

  00990	5d		 pop	 ebp
  00991	c3		 ret	 0
?Close@@YAHH@Z ENDP					; Close
_TEXT	ENDS
EXTRN	__imp__rename:NEAR
_TEXT	SEGMENT
_oldName$ = 8
_newName$ = 12
?Rename@@YAHPBD0@Z PROC NEAR				; Rename

; 444  : {

  00992	55		 push	 ebp
  00993	8b ec		 mov	 ebp, esp

; 445  : // BEW CLEANUP 	critErrHandler->Clear();
; 446  : 	return rename(oldName, newName);

  00995	8b 45 0c	 mov	 eax, DWORD PTR _newName$[ebp]
  00998	50		 push	 eax
  00999	8b 4d 08	 mov	 ecx, DWORD PTR _oldName$[ebp]
  0099c	51		 push	 ecx
  0099d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rename
  009a3	83 c4 08	 add	 esp, 8

; 447  : }

  009a6	5d		 pop	 ebp
  009a7	c3		 ret	 0
?Rename@@YAHPBD0@Z ENDP					; Rename
_str$ = 8
_len$ = 12
_fd$ = 16
_count$ = -12
_c$ = -8
_cp$ = -4
?ReadString@@YAPADPADHH@Z PROC NEAR			; ReadString

; 451  : {

  009a8	55		 push	 ebp
  009a9	8b ec		 mov	 ebp, esp
  009ab	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 452  : 	//	similar to fgets(), but uses a file handle instead of a stream
; 453  : 
; 454  : 	int	count = 0;

  009ae	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 455  : 	char	c;
; 456  : 	char*	cp = str;

  009b5	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  009b8	89 45 fc	 mov	 DWORD PTR _cp$[ebp], eax

; 457  : 
; 458  : // BEW CLEANUP 	critErrHandler->Clear();
; 459  : 
; 460  : 	--len;	//	account for trailing	0

  009bb	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp]
  009be	83 e9 01	 sub	 ecx, 1
  009c1	89 4d 0c	 mov	 DWORD PTR _len$[ebp], ecx
$L60057:

; 461  : 	while (count < len) {

  009c4	8b 55 f4	 mov	 edx, DWORD PTR _count$[ebp]
  009c7	3b 55 0c	 cmp	 edx, DWORD PTR _len$[ebp]
  009ca	7d 4a		 jge	 SHORT $L60058

; 462  : 		if (Read(fd, &c, 1) <= 0) 

  009cc	6a 01		 push	 1
  009ce	8d 45 f8	 lea	 eax, DWORD PTR _c$[ebp]
  009d1	50		 push	 eax
  009d2	8b 4d 10	 mov	 ecx, DWORD PTR _fd$[ebp]
  009d5	51		 push	 ecx
  009d6	e8 00 00 00 00	 call	 ?Read@@YAHHPAXH@Z	; Read
  009db	83 c4 0c	 add	 esp, 12			; 0000000cH
  009de	85 c0		 test	 eax, eax
  009e0	7f 02		 jg	 SHORT $L60059

; 463  : 			break;

  009e2	eb 32		 jmp	 SHORT $L60058
$L60059:

; 464  : 		count++;

  009e4	8b 55 f4	 mov	 edx, DWORD PTR _count$[ebp]
  009e7	83 c2 01	 add	 edx, 1
  009ea	89 55 f4	 mov	 DWORD PTR _count$[ebp], edx

; 465  : 		if (c == '\n') {

  009ed	0f be 45 f8	 movsx	 eax, BYTE PTR _c$[ebp]
  009f1	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  009f4	75 02		 jne	 SHORT $L60060

; 466  : 			break;

  009f6	eb 1e		 jmp	 SHORT $L60058
$L60060:

; 468  : 		if (c == '\r') {

  009f8	0f be 4d f8	 movsx	 ecx, BYTE PTR _c$[ebp]
  009fc	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  009ff	75 02		 jne	 SHORT $L60061

; 469  : 			continue;

  00a01	eb c1		 jmp	 SHORT $L60057
$L60061:

; 471  : 		*cp++ = c;

  00a03	8b 55 fc	 mov	 edx, DWORD PTR _cp$[ebp]
  00a06	8a 45 f8	 mov	 al, BYTE PTR _c$[ebp]
  00a09	88 02		 mov	 BYTE PTR [edx], al
  00a0b	8b 4d fc	 mov	 ecx, DWORD PTR _cp$[ebp]
  00a0e	83 c1 01	 add	 ecx, 1
  00a11	89 4d fc	 mov	 DWORD PTR _cp$[ebp], ecx

; 472  : 	};

  00a14	eb ae		 jmp	 SHORT $L60057
$L60058:

; 473  : 	*cp = '\0';

  00a16	8b 55 fc	 mov	 edx, DWORD PTR _cp$[ebp]
  00a19	c6 02 00	 mov	 BYTE PTR [edx], 0

; 474  : 
; 475  : 	return count ? str : 0;

  00a1c	8b 45 f4	 mov	 eax, DWORD PTR _count$[ebp]
  00a1f	f7 d8		 neg	 eax
  00a21	1b c0		 sbb	 eax, eax
  00a23	23 45 08	 and	 eax, DWORD PTR _str$[ebp]

; 476  : }

  00a26	8b e5		 mov	 esp, ebp
  00a28	5d		 pop	 ebp
  00a29	c3		 ret	 0
?ReadString@@YAPADPADHH@Z ENDP				; ReadString
_TEXT	ENDS
EXTRN	__imp__unlink:NEAR
_TEXT	SEGMENT
_name$ = 8
?Unlink@@YAHPBD@Z PROC NEAR				; Unlink

; 480  : {

  00a2a	55		 push	 ebp
  00a2b	8b ec		 mov	 ebp, esp

; 481  : 	//	erase the file 'fname'
; 482  : 
; 483  : // BEW CLEANUP 	critErrHandler->Clear();
; 484  : 	return unlink(name) != -1;

  00a2d	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  00a30	50		 push	 eax
  00a31	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__unlink
  00a37	83 c4 04	 add	 esp, 4
  00a3a	33 c9		 xor	 ecx, ecx
  00a3c	83 f8 ff	 cmp	 eax, -1
  00a3f	0f 95 c1	 setne	 cl
  00a42	8b c1		 mov	 eax, ecx

; 485  : }

  00a44	5d		 pop	 ebp
  00a45	c3		 ret	 0
?Unlink@@YAHPBD@Z ENDP					; Unlink
_TEXT	ENDS
PUBLIC	?FileLength@@YAKH@Z				; FileLength
_TEXT	SEGMENT
_fd$ = 8
_loc$ = -4
_len$ = -8
?FileLength@@YAKH@Z PROC NEAR				; FileLength

; 489  : {

  00a46	55		 push	 ebp
  00a47	8b ec		 mov	 ebp, esp
  00a49	83 ec 08	 sub	 esp, 8

; 490  : 	//	return the (long) length of the file corresponding to a handle
; 491  : 
; 492  : 	ulong loc = LSeek(fd, 0, SEEK_CUR);

  00a4c	6a 01		 push	 1
  00a4e	6a 00		 push	 0
  00a50	8b 45 08	 mov	 eax, DWORD PTR _fd$[ebp]
  00a53	50		 push	 eax
  00a54	e8 00 00 00 00	 call	 ?LSeek@@YAJHJH@Z	; LSeek
  00a59	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a5c	89 45 fc	 mov	 DWORD PTR _loc$[ebp], eax

; 493  : 	ulong len = LSeek(fd, 0, SEEK_END);

  00a5f	6a 02		 push	 2
  00a61	6a 00		 push	 0
  00a63	8b 4d 08	 mov	 ecx, DWORD PTR _fd$[ebp]
  00a66	51		 push	 ecx
  00a67	e8 00 00 00 00	 call	 ?LSeek@@YAJHJH@Z	; LSeek
  00a6c	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a6f	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 494  : 	LSeek(fd, loc, SEEK_SET);

  00a72	6a 00		 push	 0
  00a74	8b 55 fc	 mov	 edx, DWORD PTR _loc$[ebp]
  00a77	52		 push	 edx
  00a78	8b 45 08	 mov	 eax, DWORD PTR _fd$[ebp]
  00a7b	50		 push	 eax
  00a7c	e8 00 00 00 00	 call	 ?LSeek@@YAJHJH@Z	; LSeek
  00a81	83 c4 0c	 add	 esp, 12			; 0000000cH

; 495  : 	return len;

  00a84	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]

; 496  : }

  00a87	8b e5		 mov	 esp, ebp
  00a89	5d		 pop	 ebp
  00a8a	c3		 ret	 0
?FileLength@@YAKH@Z ENDP				; FileLength
_TEXT	ENDS
EXTRN	__imp__lseek:NEAR
_TEXT	SEGMENT
_fd$ = 8
_offset$ = 12
_fromWhere$ = 16
?LSeek@@YAJHJH@Z PROC NEAR				; LSeek

; 500  : {

  00a8b	55		 push	 ebp
  00a8c	8b ec		 mov	 ebp, esp

; 501  : // BEW CLEANUP 	critErrHandler->Clear();
; 502  : 	return lseek(fd, offset, fromWhere);

  00a8e	8b 45 10	 mov	 eax, DWORD PTR _fromWhere$[ebp]
  00a91	50		 push	 eax
  00a92	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  00a95	51		 push	 ecx
  00a96	8b 55 08	 mov	 edx, DWORD PTR _fd$[ebp]
  00a99	52		 push	 edx
  00a9a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lseek
  00aa0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 503  : }

  00aa3	5d		 pop	 ebp
  00aa4	c3		 ret	 0
?LSeek@@YAJHJH@Z ENDP					; LSeek
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4
_id$ = 8
??0MemID@@QAE@ABV0@@Z PROC NEAR				; MemID::MemID, COMDAT

; 19   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  0000d	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00010	66 89 10	 mov	 WORD PTR [eax], dx

; 20   : 	}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0MemID@@QAE@ABV0@@Z ENDP				; MemID::MemID
_TEXT	ENDS
_TEXT	SEGMENT
_buf$ = 8
?GetCWD@@YAPADPAD@Z PROC NEAR				; GetCWD

; 507  : {

  00aa5	55		 push	 ebp
  00aa6	8b ec		 mov	 ebp, esp

; 508  : 	return getcwd(buf, MaxPath);

  00aa8	68 04 01 00 00	 push	 260			; 00000104H
  00aad	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00ab0	50		 push	 eax
  00ab1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__getcwd
  00ab7	83 c4 08	 add	 esp, 8

; 509  : }

  00aba	5d		 pop	 ebp
  00abb	c3		 ret	 0
?GetCWD@@YAPADPAD@Z ENDP				; GetCWD
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT
_this$ = -4
_h$ = 8
??0MemID@@QAE@G@Z PROC NEAR				; MemID::MemID, COMDAT

; 23   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 4d 08	 mov	 cx, WORD PTR _h$[ebp]
  0000e	66 89 08	 mov	 WORD PTR [eax], cx

; 24   : 	}

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??0MemID@@QAE@G@Z ENDP					; MemID::MemID
_TEXT	ENDS
EXTRN	__imp__FindClose@4:NEAR
EXTRN	__imp__FindFirstFileA@8:NEAR
_TEXT	SEGMENT
_fname$ = 8
_attr$ = 12
_entry$ = 16
?FirstFile@@YAHPBDIPAU_WIN32_FIND_DATAA@@@Z PROC NEAR	; FirstFile

; 514  : FirstFile(const char* fname, uint attr, WIN32_FIND_DATA* entry) {

  00abc	55		 push	 ebp
  00abd	8b ec		 mov	 ebp, esp

; 515  : // BEW CLEANUP 	critErrHandler->Clear();
; 516  : 
; 517  : 	attr = attr;

  00abf	8b 45 0c	 mov	 eax, DWORD PTR _attr$[ebp]
  00ac2	89 45 0c	 mov	 DWORD PTR _attr$[ebp], eax

; 518  : 	if (fHandle != INVALID_HANDLE_VALUE)

  00ac5	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?fHandle@@3PAXA, -1 ; fHandle
  00acc	74 0d		 je	 SHORT $L60086

; 519  : 		FindClose(fHandle);

  00ace	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?fHandle@@3PAXA ; fHandle
  00ad4	51		 push	 ecx
  00ad5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindClose@4
$L60086:

; 520  : 
; 521  : 	fHandle = FindFirstFile((LPSTR) fname, entry);

  00adb	8b 55 10	 mov	 edx, DWORD PTR _entry$[ebp]
  00ade	52		 push	 edx
  00adf	8b 45 08	 mov	 eax, DWORD PTR _fname$[ebp]
  00ae2	50		 push	 eax
  00ae3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindFirstFileA@8
  00ae9	a3 00 00 00 00	 mov	 DWORD PTR ?fHandle@@3PAXA, eax ; fHandle

; 522  : 
; 523  : 	if (fHandle == INVALID_HANDLE_VALUE)

  00aee	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?fHandle@@3PAXA, -1 ; fHandle
  00af5	75 04		 jne	 SHORT $L60089

; 524  : 		return False;

  00af7	33 c0		 xor	 eax, eax
  00af9	eb 05		 jmp	 SHORT $L60084
$L60089:

; 525  : 
; 526  : 	return True;

  00afb	b8 01 00 00 00	 mov	 eax, 1
$L60084:

; 527  : }

  00b00	5d		 pop	 ebp
  00b01	c3		 ret	 0
?FirstFile@@YAHPBDIPAU_WIN32_FIND_DATAA@@@Z ENDP	; FirstFile
_TEXT	ENDS
EXTRN	__imp__FindNextFileA@8:NEAR
_TEXT	SEGMENT
_entry$ = 8
?NextFile@@YAHPAU_WIN32_FIND_DATAA@@@Z PROC NEAR	; NextFile

; 530  : NextFile(WIN32_FIND_DATA* entry) {

  00b02	55		 push	 ebp
  00b03	8b ec		 mov	 ebp, esp

; 531  : // BEW CLEANUP 	critErrHandler->Clear();
; 532  : 
; 533  : 	return FindNextFile(fHandle, entry);

  00b05	8b 45 08	 mov	 eax, DWORD PTR _entry$[ebp]
  00b08	50		 push	 eax
  00b09	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?fHandle@@3PAXA ; fHandle
  00b0f	51		 push	 ecx
  00b10	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindNextFileA@8

; 534  : }

  00b16	5d		 pop	 ebp
  00b17	c3		 ret	 0
?NextFile@@YAHPAU_WIN32_FIND_DATAA@@@Z ENDP		; NextFile
_TEXT	ENDS
PUBLIC	?ExistsDriveAB@@YAHH@Z				; ExistsDriveAB
EXTRN	?MBox@@YAXPAD0@Z:NEAR				; MBox
_BSS	SEGMENT
$SG60096 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
	ORG $+3
$SG60097 DB	'ExistsDriveAB called', 00H
_DATA	ENDS
_TEXT	SEGMENT
_drive$ = 8
?ExistsDriveAB@@YAHH@Z PROC NEAR			; ExistsDriveAB

; 538  : {

  00b18	55		 push	 ebp
  00b19	8b ec		 mov	 ebp, esp

; 539  : #ifndef WIN32S
; 540  : 	//	Check for the validity of drive a: or b: by checking
; 541  : 	//	if there is more than one floppy drive, and how it is assigned
; 542  : 	//
; 543  : 	//		input: drive=0 for drive a: check, 1 for drive b: check
; 544  : 	//
; 545  : 	//	  returns:
; 546  : 	//	    whether drive requested exists
; 547  : 
; 548  : 	REGS	regs;
; 549  : 
; 550  : #ifdef WINDOWS
; 551  : 	// use int86 instead of int386 since int386 is not supported by Windows
; 552  : 	int86(0x11, &regs, &regs);
; 553  : #else
; 554  : 	int386(0x11, &regs, &regs);
; 555  : #endif
; 556  : 
; 557  : 
; 558  : 	//	any floppy drives at all?
; 559  : 	if (!(regs.w.ax & 1))
; 560  : 		return False;
; 561  : 
; 562  : 	//	more than one?
; 563  : 	if (regs.w.ax & 0xC0)
; 564  : 		return True;
; 565  : 
; 566  : #ifndef WINDOWS
; 567  : 	//	if only one, see whether it's currently A: or B:
; 568  : 	Bool driveIsA = !*(char*) 0x504;
; 569  : 	return driveIsA && drive == 0;
; 570  : #else
; 571  : 	// The above test does not work in Windows, and I (kk) can't find
; 572  : 	// a reliable way to do it. The situation is also very unlikely to occur.
; 573  : 	if(drive == 99)
; 574  : 		return False;	// get around the parameter "drive" not used warning
; 575  : 	return True;
; 576  : #endif
; 577  : 
; 578  : #else
; 579  : 	MBox("ExistsDriveAB called","");

  00b1b	68 00 00 00 00	 push	 OFFSET FLAT:$SG60096
  00b20	68 00 00 00 00	 push	 OFFSET FLAT:$SG60097
  00b25	e8 00 00 00 00	 call	 ?MBox@@YAXPAD0@Z	; MBox
  00b2a	83 c4 08	 add	 esp, 8

; 580  : 	drive = drive;

  00b2d	8b 45 08	 mov	 eax, DWORD PTR _drive$[ebp]
  00b30	89 45 08	 mov	 DWORD PTR _drive$[ebp], eax

; 581  : 	return False;

  00b33	33 c0		 xor	 eax, eax

; 582  : #endif
; 583  : }

  00b35	5d		 pop	 ebp
  00b36	c3		 ret	 0
?ExistsDriveAB@@YAHH@Z ENDP				; ExistsDriveAB
_TEXT	ENDS
PUBLIC	?ExistDrive@@YAHD@Z				; ExistDrive
EXTRN	?ToLower@@YAEE@Z:NEAR				; ToLower
_TEXT	SEGMENT
_theDrive$ = 8
_curDisk$ = -4
_driveNum$ = -12
_newDisk$ = -8
?ExistDrive@@YAHD@Z PROC NEAR				; ExistDrive

; 587  : {

  00b37	55		 push	 ebp
  00b38	8b ec		 mov	 ebp, esp
  00b3a	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 588  : 	//	does this drive exist?
; 589  : 
; 590  : // BEW CLEANUP 	critErrHandler->Clear();
; 591  : 
; 592  : 	int curDisk = GetDisk();

  00b3d	e8 00 00 00 00	 call	 ?GetDisk@@YAHXZ		; GetDisk
  00b42	89 45 fc	 mov	 DWORD PTR _curDisk$[ebp], eax

; 593  : 	int driveNum = ToLower(theDrive) - 'a';

  00b45	8a 45 08	 mov	 al, BYTE PTR _theDrive$[ebp]
  00b48	50		 push	 eax
  00b49	e8 00 00 00 00	 call	 ?ToLower@@YAEE@Z	; ToLower
  00b4e	83 c4 04	 add	 esp, 4
  00b51	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00b56	83 e8 61	 sub	 eax, 97			; 00000061H
  00b59	89 45 f4	 mov	 DWORD PTR _driveNum$[ebp], eax

; 594  : 
; 595  : 	if (driveNum <= 1)

  00b5c	83 7d f4 01	 cmp	 DWORD PTR _driveNum$[ebp], 1
  00b60	7f 0e		 jg	 SHORT $L60103

; 596  : 		return ExistsDriveAB(driveNum);

  00b62	8b 4d f4	 mov	 ecx, DWORD PTR _driveNum$[ebp]
  00b65	51		 push	 ecx
  00b66	e8 00 00 00 00	 call	 ?ExistsDriveAB@@YAHH@Z	; ExistsDriveAB
  00b6b	83 c4 04	 add	 esp, 4
  00b6e	eb 2b		 jmp	 SHORT $L60100
$L60103:

; 597  : 
; 598  : 	//	change to new drive to see if it's valid
; 599  : 	SetDisk(driveNum);

  00b70	8b 55 f4	 mov	 edx, DWORD PTR _driveNum$[ebp]
  00b73	52		 push	 edx
  00b74	e8 00 00 00 00	 call	 ?SetDisk@@YAHH@Z	; SetDisk
  00b79	83 c4 04	 add	 esp, 4

; 600  : 	int newDisk = GetDisk();

  00b7c	e8 00 00 00 00	 call	 ?GetDisk@@YAHXZ		; GetDisk
  00b81	89 45 f8	 mov	 DWORD PTR _newDisk$[ebp], eax

; 601  : 	SetDisk(curDisk);

  00b84	8b 45 fc	 mov	 eax, DWORD PTR _curDisk$[ebp]
  00b87	50		 push	 eax
  00b88	e8 00 00 00 00	 call	 ?SetDisk@@YAHH@Z	; SetDisk
  00b8d	83 c4 04	 add	 esp, 4

; 602  : 	return newDisk == driveNum;

  00b90	8b 4d f8	 mov	 ecx, DWORD PTR _newDisk$[ebp]
  00b93	33 c0		 xor	 eax, eax
  00b95	3b 4d f4	 cmp	 ecx, DWORD PTR _driveNum$[ebp]
  00b98	0f 94 c0	 sete	 al
$L60100:

; 603  : }

  00b9b	8b e5		 mov	 esp, ebp
  00b9d	5d		 pop	 ebp
  00b9e	c3		 ret	 0
?ExistDrive@@YAHD@Z ENDP				; ExistDrive
_TEXT	ENDS
PUBLIC	?ResetDisk@@YAXXZ				; ResetDisk
EXTRN	__imp__flushall:NEAR
_TEXT	SEGMENT
?ResetDisk@@YAXXZ PROC NEAR				; ResetDisk

; 607  : {

  00b9f	55		 push	 ebp
  00ba0	8b ec		 mov	 ebp, esp

; 608  : 	//	reset the disk subsystem
; 609  : 
; 610  : //#ifndef WIN32S
; 611  : //	bdos(0x0D, 0, 0);
; 612  : //#else
; 613  : 	// the bdos call won't link under WIN32S
; 614  : 	flushall();

  00ba2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__flushall

; 615  : //#endif
; 616  : }

  00ba8	5d		 pop	 ebp
  00ba9	c3		 ret	 0
?ResetDisk@@YAXXZ ENDP					; ResetDisk
_TEXT	ENDS
PUBLIC	?RGetFreeSpace@@YAKD@Z				; RGetFreeSpace
EXTRN	__imp___getdiskfree:NEAR
_TEXT	SEGMENT
_drive$ = 8
_d$ = -16
?RGetFreeSpace@@YAKD@Z PROC NEAR			; RGetFreeSpace

; 620  : {

  00baa	55		 push	 ebp
  00bab	8b ec		 mov	 ebp, esp
  00bad	83 ec 10	 sub	 esp, 16			; 00000010H

; 621  : 	//	get the amount of free space on the drive passed in 'drive'
; 622  : 	//	if 'drive' is 0 or blank use the default drive
; 623  : 
; 624  : // BEW CLEANUP 	critErrHandler->Clear();
; 625  : 
; 626  : 	if (drive == ' ')

  00bb0	0f be 45 08	 movsx	 eax, BYTE PTR _drive$[ebp]
  00bb4	83 f8 20	 cmp	 eax, 32			; 00000020H
  00bb7	75 04		 jne	 SHORT $L60110

; 627  : 		drive = 0;

  00bb9	c6 45 08 00	 mov	 BYTE PTR _drive$[ebp], 0
$L60110:

; 628  : 	if (drive)

  00bbd	0f be 4d 08	 movsx	 ecx, BYTE PTR _drive$[ebp]
  00bc1	85 c9		 test	 ecx, ecx
  00bc3	74 17		 je	 SHORT $L60111

; 629  : 		drive = (char) (ToLower(drive) - 'a' + 1);

  00bc5	8a 55 08	 mov	 dl, BYTE PTR _drive$[ebp]
  00bc8	52		 push	 edx
  00bc9	e8 00 00 00 00	 call	 ?ToLower@@YAEE@Z	; ToLower
  00bce	83 c4 04	 add	 esp, 4
  00bd1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00bd6	83 e8 60	 sub	 eax, 96			; 00000060H
  00bd9	88 45 08	 mov	 BYTE PTR _drive$[ebp], al
$L60111:

; 632  : 	if (_getdiskfree(drive, &d))

  00bdc	8d 45 f0	 lea	 eax, DWORD PTR _d$[ebp]
  00bdf	50		 push	 eax
  00be0	0f be 4d 08	 movsx	 ecx, BYTE PTR _drive$[ebp]
  00be4	51		 push	 ecx
  00be5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___getdiskfree
  00beb	83 c4 08	 add	 esp, 8
  00bee	85 c0		 test	 eax, eax
  00bf0	74 04		 je	 SHORT $L60114

; 633  : 		return 0;

  00bf2	33 c0		 xor	 eax, eax
  00bf4	eb 0e		 jmp	 SHORT $L60109
$L60114:

; 636  : 		d.bytes_per_sector;

  00bf6	8b 45 f4	 mov	 eax, DWORD PTR _d$[ebp+4]
  00bf9	83 e8 01	 sub	 eax, 1
  00bfc	0f af 45 f8	 imul	 eax, DWORD PTR _d$[ebp+8]
  00c00	0f af 45 fc	 imul	 eax, DWORD PTR _d$[ebp+12]
$L60109:

; 637  : }

  00c04	8b e5		 mov	 esp, ebp
  00c06	5d		 pop	 ebp
  00c07	c3		 ret	 0
?RGetFreeSpace@@YAKD@Z ENDP				; RGetFreeSpace
_TEXT	ENDS
EXTRN	__imp__access:NEAR
_TEXT	SEGMENT
_fileName$ = 8
_rc$ = -4
_drive$60121 = -8
?Exists@@YAHPBD@Z PROC NEAR				; Exists

; 641  : {

  00c08	55		 push	 ebp
  00c09	8b ec		 mov	 ebp, esp
  00c0b	83 ec 08	 sub	 esp, 8

; 642  : 	//	tell whether a file exists without alerting user
; 643  : 
; 644  : 	Bool rc = True;

  00c0e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _rc$[ebp], 1

; 645  : 
; 646  : 	//	special handling if referencing drive A: or B:, since they don't
; 647  : 	//	generate critical errors if there's only one drive and it's not
; 648  : 	//	the current one
; 649  : 	if (fileName[1] == ':') {

  00c15	8b 45 08	 mov	 eax, DWORD PTR _fileName$[ebp]
  00c18	0f be 48 01	 movsx	 ecx, BYTE PTR [eax+1]
  00c1c	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  00c1f	75 32		 jne	 SHORT $L60122

; 650  : 		char drive = ToLower(fileName[0]);

  00c21	8b 55 08	 mov	 edx, DWORD PTR _fileName$[ebp]
  00c24	8a 02		 mov	 al, BYTE PTR [edx]
  00c26	50		 push	 eax
  00c27	e8 00 00 00 00	 call	 ?ToLower@@YAEE@Z	; ToLower
  00c2c	83 c4 04	 add	 esp, 4
  00c2f	88 45 f8	 mov	 BYTE PTR _drive$60121[ebp], al

; 651  : 		if (drive == 'a' || drive == 'b')

  00c32	0f be 4d f8	 movsx	 ecx, BYTE PTR _drive$60121[ebp]
  00c36	83 f9 61	 cmp	 ecx, 97			; 00000061H
  00c39	74 09		 je	 SHORT $L60123
  00c3b	0f be 55 f8	 movsx	 edx, BYTE PTR _drive$60121[ebp]
  00c3f	83 fa 62	 cmp	 edx, 98			; 00000062H
  00c42	75 0f		 jne	 SHORT $L60122
$L60123:

; 652  : 			rc = ExistDrive(drive);

  00c44	8a 45 f8	 mov	 al, BYTE PTR _drive$60121[ebp]
  00c47	50		 push	 eax
  00c48	e8 00 00 00 00	 call	 ?ExistDrive@@YAHD@Z	; ExistDrive
  00c4d	83 c4 04	 add	 esp, 4
  00c50	89 45 fc	 mov	 DWORD PTR _rc$[ebp], eax
$L60122:

; 654  : 
; 655  : 	if (rc) {

  00c53	83 7d fc 00	 cmp	 DWORD PTR _rc$[ebp], 0
  00c57	74 17		 je	 SHORT $L60124

; 656  : // BEW CLEANUP 		critErrHandler->SetMethod(CritErrHandler::Fail);
; 657  : 		rc = access(fileName, 0) == 0; // BEW CLEANUP  && !critErrHandler->Tripped();

  00c59	6a 00		 push	 0
  00c5b	8b 4d 08	 mov	 ecx, DWORD PTR _fileName$[ebp]
  00c5e	51		 push	 ecx
  00c5f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__access
  00c65	83 c4 08	 add	 esp, 8
  00c68	f7 d8		 neg	 eax
  00c6a	1b c0		 sbb	 eax, eax
  00c6c	40		 inc	 eax
  00c6d	89 45 fc	 mov	 DWORD PTR _rc$[ebp], eax
$L60124:

; 660  : 
; 661  : 	return rc;

  00c70	8b 45 fc	 mov	 eax, DWORD PTR _rc$[ebp]

; 662  : }

  00c73	8b e5		 mov	 esp, ebp
  00c75	5d		 pop	 ebp
  00c76	c3		 ret	 0
?Exists@@YAHPBD@Z ENDP					; Exists
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4
??BMemID@@QBEGXZ PROC NEAR				; MemID::operator unsigned short, COMDAT

; 93   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   : 		return handle;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 00	 mov	 ax, WORD PTR [eax]

; 95   : 	}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??BMemID@@QBEGXZ ENDP					; MemID::operator unsigned short
_TEXT	ENDS
PUBLIC	?GetAddr@MemoryMgr@@QAEPAXG@Z			; MemoryMgr::GetAddr
EXTRN	_memMgr:DWORD
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT
_this$ = -4
??DMemID@@QBEPAXXZ PROC NEAR				; MemID::operator*, COMDAT

; 98   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 99   : 		return memMgr->GetAddr(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr

; 100  : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??DMemID@@QBEPAXXZ ENDP					; MemID::operator*
_TEXT	ENDS
EXTRN	__descPtrTable:BYTE
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -4
?GetAddr@MemoryMgr@@QAEPAXG@Z PROC NEAR			; MemoryMgr::GetAddr, COMDAT

; 462  : 	inline void* MemoryMgr::GetAddr(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : //		CheckValid(theID);
; 464  : 		return _descPtrTable[(unsigned int)((unsigned short)theID)];

  00007	8b 45 08	 mov	 eax, DWORD PTR _theID$[ebp]
  0000a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0000f	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR __descPtrTable[eax*4]

; 465  : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?GetAddr@MemoryMgr@@QAEPAXG@Z ENDP			; MemoryMgr::GetAddr
_TEXT	ENDS
_TEXT	SEGMENT
_str$ = 8
?IsDriveAOrB@@YAHPBD@Z PROC NEAR			; IsDriveAOrB

; 666  : {

  00c77	55		 push	 ebp
  00c78	8b ec		 mov	 ebp, esp
  00c7a	51		 push	 ecx

; 667  : 	return str[1] == ':' && (ToLower(*str) == 'a' || ToLower(*str) == 'b');

  00c7b	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00c7e	0f be 48 01	 movsx	 ecx, BYTE PTR [eax+1]
  00c82	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  00c85	75 39		 jne	 SHORT $L60374
  00c87	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00c8a	8a 02		 mov	 al, BYTE PTR [edx]
  00c8c	50		 push	 eax
  00c8d	e8 00 00 00 00	 call	 ?ToLower@@YAEE@Z	; ToLower
  00c92	83 c4 04	 add	 esp, 4
  00c95	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00c9a	83 f8 61	 cmp	 eax, 97			; 00000061H
  00c9d	74 18		 je	 SHORT $L60373
  00c9f	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00ca2	8a 11		 mov	 dl, BYTE PTR [ecx]
  00ca4	52		 push	 edx
  00ca5	e8 00 00 00 00	 call	 ?ToLower@@YAEE@Z	; ToLower
  00caa	83 c4 04	 add	 esp, 4
  00cad	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00cb2	83 f8 62	 cmp	 eax, 98			; 00000062H
  00cb5	75 09		 jne	 SHORT $L60374
$L60373:
  00cb7	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR -4+[ebp], 1
  00cbe	eb 07		 jmp	 SHORT $L60375
$L60374:
  00cc0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR -4+[ebp], 0
$L60375:
  00cc7	8b 45 fc	 mov	 eax, DWORD PTR -4+[ebp]

; 668  : }

  00cca	8b e5		 mov	 esp, ebp
  00ccc	5d		 pop	 ebp
  00ccd	c3		 ret	 0
?IsDriveAOrB@@YAHPBD@Z ENDP				; IsDriveAOrB
_TEXT	ENDS
PUBLIC	?OpenFileInPath@@YAHPADI0@Z			; OpenFileInPath
EXTRN	?gArgv@@3PAPADA:DWORD				; gArgv
EXTRN	__imp___searchenv:NEAR
EXTRN	__imp__strrchr:NEAR
_DATA	SEGMENT
	ORG $+3
$SG60139 DB	'PATH', 00H
_DATA	ENDS
_TEXT	SEGMENT
_fileName$ = 8
_mode$ = 12
_dest$ = 16
_path$ = -268
_fd$ = -4
_cp$60136 = -272
?OpenFileInPath@@YAHPADI0@Z PROC NEAR			; OpenFileInPath

; 673  : {

  00cce	55		 push	 ebp
  00ccf	8b ec		 mov	 ebp, esp
  00cd1	81 ec 10 01 00
	00		 sub	 esp, 272		; 00000110H

; 674  : 	char	path[MaxPath + 1];
; 675  : 	int	fd;
; 676  : 	
; 677  : 	strcpy(path, fileName);

  00cd7	8b 45 08	 mov	 eax, DWORD PTR _fileName$[ebp]
  00cda	50		 push	 eax
  00cdb	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  00ce1	51		 push	 ecx
  00ce2	e8 00 00 00 00	 call	 _strcpy
  00ce7	83 c4 08	 add	 esp, 8

; 678  : 
; 679  : 	//	look first in the current directory
; 680  : 	fd = Open(path, mode);

  00cea	8b 55 0c	 mov	 edx, DWORD PTR _mode$[ebp]
  00ced	52		 push	 edx
  00cee	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00cf4	50		 push	 eax
  00cf5	e8 00 00 00 00	 call	 ?Open@@YAHPBDI@Z	; Open
  00cfa	83 c4 08	 add	 esp, 8
  00cfd	89 45 fc	 mov	 DWORD PTR _fd$[ebp], eax

; 681  : 	
; 682  : 	//	then in the executable's directory
; 683  : 	if (fd == -1) {

  00d00	83 7d fc ff	 cmp	 DWORD PTR _fd$[ebp], -1
  00d04	75 6c		 jne	 SHORT $L60135

; 684  : 		strcpy(path, gArgv[0]);

  00d06	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gArgv@@3PAPADA ; gArgv
  00d0c	8b 11		 mov	 edx, DWORD PTR [ecx]
  00d0e	52		 push	 edx
  00d0f	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00d15	50		 push	 eax
  00d16	e8 00 00 00 00	 call	 _strcpy
  00d1b	83 c4 08	 add	 esp, 8

; 685  : 	
; 686  : 		//	strip off the program name by truncating after last backslash
; 687  : 		char* cp;
; 688  : 		if (cp = strrchr(path, '\\'))

  00d1e	6a 5c		 push	 92			; 0000005cH
  00d20	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  00d26	51		 push	 ecx
  00d27	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strrchr
  00d2d	83 c4 08	 add	 esp, 8
  00d30	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _cp$60136[ebp], eax
  00d36	83 bd f0 fe ff
	ff 00		 cmp	 DWORD PTR _cp$60136[ebp], 0
  00d3d	74 0a		 je	 SHORT $L60137

; 689  : 			cp[1] = 0;

  00d3f	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR _cp$60136[ebp]
  00d45	c6 42 01 00	 mov	 BYTE PTR [edx+1], 0
$L60137:

; 690  : 		strcat(path, fileName);

  00d49	8b 45 08	 mov	 eax, DWORD PTR _fileName$[ebp]
  00d4c	50		 push	 eax
  00d4d	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  00d53	51		 push	 ecx
  00d54	e8 00 00 00 00	 call	 _strcat
  00d59	83 c4 08	 add	 esp, 8

; 691  : 
; 692  : 		fd = Open(path, mode);

  00d5c	8b 55 0c	 mov	 edx, DWORD PTR _mode$[ebp]
  00d5f	52		 push	 edx
  00d60	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00d66	50		 push	 eax
  00d67	e8 00 00 00 00	 call	 ?Open@@YAHPBDI@Z	; Open
  00d6c	83 c4 08	 add	 esp, 8
  00d6f	89 45 fc	 mov	 DWORD PTR _fd$[ebp], eax
$L60135:

; 694  : 	
; 695  : 	//	then along the path
; 696  : 	if (fd == -1) {

  00d72	83 7d fc ff	 cmp	 DWORD PTR _fd$[ebp], -1
  00d76	75 3a		 jne	 SHORT $L60140

; 697  : 		_searchenv(fileName, "PATH", path);

  00d78	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  00d7e	51		 push	 ecx
  00d7f	68 00 00 00 00	 push	 OFFSET FLAT:$SG60139
  00d84	8b 55 08	 mov	 edx, DWORD PTR _fileName$[ebp]
  00d87	52		 push	 edx
  00d88	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___searchenv
  00d8e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 698  : 		if (*path)

  00d91	0f be 85 f4 fe
	ff ff		 movsx	 eax, BYTE PTR _path$[ebp]
  00d98	85 c0		 test	 eax, eax
  00d9a	74 16		 je	 SHORT $L60140

; 699  : 			fd = Open(path, mode);

  00d9c	8b 4d 0c	 mov	 ecx, DWORD PTR _mode$[ebp]
  00d9f	51		 push	 ecx
  00da0	8d 95 f4 fe ff
	ff		 lea	 edx, DWORD PTR _path$[ebp]
  00da6	52		 push	 edx
  00da7	e8 00 00 00 00	 call	 ?Open@@YAHPBDI@Z	; Open
  00dac	83 c4 08	 add	 esp, 8
  00daf	89 45 fc	 mov	 DWORD PTR _fd$[ebp], eax
$L60140:

; 701  : 	
; 702  : 	//	return the name of the file that was found
; 703  : 	if (fd != -1 && dest)

  00db2	83 7d fc ff	 cmp	 DWORD PTR _fd$[ebp], -1
  00db6	74 19		 je	 SHORT $L60141
  00db8	83 7d 10 00	 cmp	 DWORD PTR _dest$[ebp], 0
  00dbc	74 13		 je	 SHORT $L60141

; 704  : 		strcpy(dest, path);

  00dbe	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00dc4	50		 push	 eax
  00dc5	8b 4d 10	 mov	 ecx, DWORD PTR _dest$[ebp]
  00dc8	51		 push	 ecx
  00dc9	e8 00 00 00 00	 call	 _strcpy
  00dce	83 c4 08	 add	 esp, 8
$L60141:

; 705  : 
; 706  : 	return fd;

  00dd1	8b 45 fc	 mov	 eax, DWORD PTR _fd$[ebp]

; 707  : }

  00dd4	8b e5		 mov	 esp, ebp
  00dd6	5d		 pop	 ebp
  00dd7	c3		 ret	 0
?OpenFileInPath@@YAHPADI0@Z ENDP			; OpenFileInPath
_TEXT	ENDS
PUBLIC	?RemoveTrailingSlash@@YAPADPAD@Z		; RemoveTrailingSlash
_TEXT	SEGMENT
_dir$ = 8
_len$ = -4
_dp$60147 = -8
?RemoveTrailingSlash@@YAPADPAD@Z PROC NEAR		; RemoveTrailingSlash

; 711  : {

  00dd8	55		 push	 ebp
  00dd9	8b ec		 mov	 ebp, esp
  00ddb	83 ec 08	 sub	 esp, 8

; 712  : 	// Make sure that the last character of a directory is NOT a '/' or '\'.
; 713  : 
; 714  : 	int len = strlen(dir);

  00dde	8b 45 08	 mov	 eax, DWORD PTR _dir$[ebp]
  00de1	50		 push	 eax
  00de2	e8 00 00 00 00	 call	 _strlen
  00de7	83 c4 04	 add	 esp, 4
  00dea	89 45 fc	 mov	 DWORD PTR _len$[ebp], eax

; 715  : 	if (len) {

  00ded	83 7d fc 00	 cmp	 DWORD PTR _len$[ebp], 0
  00df1	74 29		 je	 SHORT $L60148

; 716  : 		char* dp = &dir[len - 1];

  00df3	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  00df6	8b 55 08	 mov	 edx, DWORD PTR _dir$[ebp]
  00df9	8d 44 0a ff	 lea	 eax, DWORD PTR [edx+ecx-1]
  00dfd	89 45 f8	 mov	 DWORD PTR _dp$60147[ebp], eax

; 717  : 		if (*dp == '/' || *dp == '\\')

  00e00	8b 4d f8	 mov	 ecx, DWORD PTR _dp$60147[ebp]
  00e03	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00e06	83 fa 2f	 cmp	 edx, 47			; 0000002fH
  00e09	74 0b		 je	 SHORT $L60149
  00e0b	8b 45 f8	 mov	 eax, DWORD PTR _dp$60147[ebp]
  00e0e	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00e11	83 f9 5c	 cmp	 ecx, 92			; 0000005cH
  00e14	75 06		 jne	 SHORT $L60148
$L60149:

; 718  : 			*dp = 0;

  00e16	8b 55 f8	 mov	 edx, DWORD PTR _dp$60147[ebp]
  00e19	c6 02 00	 mov	 BYTE PTR [edx], 0
$L60148:

; 720  : 
; 721  : 	return dir;

  00e1c	8b 45 08	 mov	 eax, DWORD PTR _dir$[ebp]

; 722  : }

  00e1f	8b e5		 mov	 esp, ebp
  00e21	5d		 pop	 ebp
  00e22	c3		 ret	 0
?RemoveTrailingSlash@@YAPADPAD@Z ENDP			; RemoveTrailingSlash
_func$ = 8
_path$ = 12
_freeSpace$ = -4
?CheckFreeSpace@@YAFHPBD@Z PROC NEAR			; CheckFreeSpace

; 728  : {

  00e23	55		 push	 ebp
  00e24	8b ec		 mov	 ebp, esp
  00e26	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 729  : 	//	CheckFreeSpace functions
; 730  : 	enum {
; 731  : 		SAVEGAMESIZE,
; 732  : 		FREESPACE,
; 733  : 		ENOUGHSPACETOSAVE
; 734  : 	};
; 735  : 	
; 736  : 	ulong	freeSpace;
; 737  : 
; 738  : 	// Find out how much space there is.
; 739  : 	if (*(path+1) == ':')

  00e29	8b 45 0c	 mov	 eax, DWORD PTR _path$[ebp]
  00e2c	0f be 48 01	 movsx	 ecx, BYTE PTR [eax+1]
  00e30	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  00e33	75 1c		 jne	 SHORT $L60159

; 740  : 		freeSpace = RGetFreeSpace(ToLower(*path));

  00e35	8b 55 0c	 mov	 edx, DWORD PTR _path$[ebp]
  00e38	8a 02		 mov	 al, BYTE PTR [edx]
  00e3a	50		 push	 eax
  00e3b	e8 00 00 00 00	 call	 ?ToLower@@YAEE@Z	; ToLower
  00e40	83 c4 04	 add	 esp, 4
  00e43	50		 push	 eax
  00e44	e8 00 00 00 00	 call	 ?RGetFreeSpace@@YAKD@Z	; RGetFreeSpace
  00e49	83 c4 04	 add	 esp, 4
  00e4c	89 45 fc	 mov	 DWORD PTR _freeSpace$[ebp], eax

; 741  : 	else

  00e4f	eb 0d		 jmp	 SHORT $L60160
$L60159:

; 742  : 		freeSpace = RGetFreeSpace(0);

  00e51	6a 00		 push	 0
  00e53	e8 00 00 00 00	 call	 ?RGetFreeSpace@@YAKD@Z	; RGetFreeSpace
  00e58	83 c4 04	 add	 esp, 4
  00e5b	89 45 fc	 mov	 DWORD PTR _freeSpace$[ebp], eax
$L60160:

; 743  : 		
; 744  :    switch (func)  {

  00e5e	8b 4d 08	 mov	 ecx, DWORD PTR _func$[ebp]
  00e61	89 4d f8	 mov	 DWORD PTR -8+[ebp], ecx
  00e64	83 7d f8 01	 cmp	 DWORD PTR -8+[ebp], 1
  00e68	74 02		 je	 SHORT $L60165
  00e6a	eb 27		 jmp	 SHORT $L60166
$L60165:

; 745  : 	   case FREESPACE:
; 746  :          // Return the amount of free space in K up to 32Meg
; 747  :          freeSpace = freeSpace / 1024L;

  00e6c	8b 55 fc	 mov	 edx, DWORD PTR _freeSpace$[ebp]
  00e6f	c1 ea 0a	 shr	 edx, 10			; 0000000aH
  00e72	89 55 fc	 mov	 DWORD PTR _freeSpace$[ebp], edx

; 748  : 			return freeSpace > 32767L ? 32767 : freeSpace;

  00e75	81 7d fc ff 7f
	00 00		 cmp	 DWORD PTR _freeSpace$[ebp], 32767 ; 00007fffH
  00e7c	76 09		 jbe	 SHORT $L60379
  00e7e	c7 45 f4 ff 7f
	00 00		 mov	 DWORD PTR -12+[ebp], 32767 ; 00007fffH
  00e85	eb 06		 jmp	 SHORT $L60380
$L60379:
  00e87	8b 45 fc	 mov	 eax, DWORD PTR _freeSpace$[ebp]
  00e8a	89 45 f4	 mov	 DWORD PTR -12+[ebp], eax
$L60380:
  00e8d	66 8b 45 f4	 mov	 ax, WORD PTR -12+[ebp]
  00e91	eb 03		 jmp	 SHORT $L60162
$L60166:

; 749  : 
; 750  : 		default:
; 751  : 			assert(!"Invalid CheckFreeSpace function");
; 752  : 			return 0;

  00e93	66 33 c0	 xor	 ax, ax
$L60162:

; 754  : }

  00e96	8b e5		 mov	 esp, ebp
  00e98	5d		 pop	 ebp
  00e99	c3		 ret	 0
?CheckFreeSpace@@YAFHPBD@Z ENDP				; CheckFreeSpace
_p$ = 8
_path$ = -268
_dta$ = -588
_rc$ = -4
_c$60178 = -592
?CheckValidPath@@YAHPBD@Z PROC NEAR			; CheckValidPath

; 758  : {

  00e9a	55		 push	 ebp
  00e9b	8b ec		 mov	 ebp, esp
  00e9d	81 ec 50 02 00
	00		 sub	 esp, 592		; 00000250H

; 759  : 	/* Return True if the passed path is valid, False otherwise.
; 760  : 		Implementation is to do a firstfile() for the directory, specifying
; 761  : 		directory only. */
; 762  : 
; 763  : 	char			path[MaxPath + 1];
; 764  : 	WIN32_FIND_DATA	dta;
; 765  : 	Bool			rc;
; 766  : 
; 767  : 	//	don't mess with original copy
; 768  : 	strcpy(path, p);

  00ea3	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00ea6	50		 push	 eax
  00ea7	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  00ead	51		 push	 ecx
  00eae	e8 00 00 00 00	 call	 _strcpy
  00eb3	83 c4 08	 add	 esp, 8

; 769  : 	RemoveTrailingSlash(path);

  00eb6	8d 95 f4 fe ff
	ff		 lea	 edx, DWORD PTR _path$[ebp]
  00ebc	52		 push	 edx
  00ebd	e8 00 00 00 00	 call	 ?RemoveTrailingSlash@@YAPADPAD@Z ; RemoveTrailingSlash
  00ec2	83 c4 04	 add	 esp, 4

; 770  : 
; 771  : 	// if critical error occurs -- don't display fail/retry message
; 772  : // BEW CLEANUP 	critErrHandler->SetMethod(CritErrHandler::Fail);
; 773  : 
; 774  : 	if (!strlen(path) || strlen(path) == 1 && *path == '.')

  00ec5	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00ecb	50		 push	 eax
  00ecc	e8 00 00 00 00	 call	 _strlen
  00ed1	83 c4 04	 add	 esp, 4
  00ed4	85 c0		 test	 eax, eax
  00ed6	74 20		 je	 SHORT $L60175
  00ed8	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  00ede	51		 push	 ecx
  00edf	e8 00 00 00 00	 call	 _strlen
  00ee4	83 c4 04	 add	 esp, 4
  00ee7	83 f8 01	 cmp	 eax, 1
  00eea	75 18		 jne	 SHORT $L60174
  00eec	0f be 95 f4 fe
	ff ff		 movsx	 edx, BYTE PTR _path$[ebp]
  00ef3	83 fa 2e	 cmp	 edx, 46			; 0000002eH
  00ef6	75 0c		 jne	 SHORT $L60174
$L60175:

; 775  : 		// Current directory is valid.
; 776  : 		rc = True;

  00ef8	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _rc$[ebp], 1

; 777  : 
; 778  : 	else if (path[strlen(path) - 1] == ':') {

  00eff	e9 8b 00 00 00	 jmp	 $L60182
$L60174:
  00f04	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00f0a	50		 push	 eax
  00f0b	e8 00 00 00 00	 call	 _strlen
  00f10	83 c4 04	 add	 esp, 4
  00f13	0f be 8c 05 f3
	fe ff ff	 movsx	 ecx, BYTE PTR _path$[ebp+eax-1]
  00f1b	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  00f1e	75 3e		 jne	 SHORT $L60177

; 779  : 		// Current directory on a specified drive is same as validity of drive.
; 780  : 		char c = ToLower(path[0]);

  00f20	8a 95 f4 fe ff
	ff		 mov	 dl, BYTE PTR _path$[ebp]
  00f26	52		 push	 edx
  00f27	e8 00 00 00 00	 call	 ?ToLower@@YAEE@Z	; ToLower
  00f2c	83 c4 04	 add	 esp, 4
  00f2f	88 85 b0 fd ff
	ff		 mov	 BYTE PTR _c$60178[ebp], al

; 781  : 		if (rc = ExistDrive(c))

  00f35	8a 85 b0 fd ff
	ff		 mov	 al, BYTE PTR _c$60178[ebp]
  00f3b	50		 push	 eax
  00f3c	e8 00 00 00 00	 call	 ?ExistDrive@@YAHD@Z	; ExistDrive
  00f41	83 c4 04	 add	 esp, 4
  00f44	89 45 fc	 mov	 DWORD PTR _rc$[ebp], eax
  00f47	83 7d fc 00	 cmp	 DWORD PTR _rc$[ebp], 0
  00f4b	74 0f		 je	 SHORT $L60179

; 782  : 			RGetFreeSpace(c);

  00f4d	8a 8d b0 fd ff
	ff		 mov	 cl, BYTE PTR _c$60178[ebp]
  00f53	51		 push	 ecx
  00f54	e8 00 00 00 00	 call	 ?RGetFreeSpace@@YAKD@Z	; RGetFreeSpace
  00f59	83 c4 04	 add	 esp, 4
$L60179:

; 783  : // BEW CLEANUP 		if (critErrHandler->Tripped())
; 784  : // BEW CLEANUP 			rc = False;
; 785  : 
; 786  : 	} else if (FirstFile(path, FA_HIDDEN | FA_SYSTEM | FA_DIREC, &dta))

  00f5c	eb 31		 jmp	 SHORT $L60182
$L60177:
  00f5e	8d 95 b4 fd ff
	ff		 lea	 edx, DWORD PTR _dta$[ebp]
  00f64	52		 push	 edx
  00f65	6a 16		 push	 22			; 00000016H
  00f67	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00f6d	50		 push	 eax
  00f6e	e8 00 00 00 00	 call	 ?FirstFile@@YAHPBDIPAU_WIN32_FIND_DATAA@@@Z ; FirstFile
  00f73	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f76	85 c0		 test	 eax, eax
  00f78	74 0e		 je	 SHORT $L60181

; 787  : 		// Check to see if the path is a subdirectory.
; 788  : 		rc = dta.dwFileAttributes | FA_DIREC;

  00f7a	8b 8d b4 fd ff
	ff		 mov	 ecx, DWORD PTR _dta$[ebp]
  00f80	83 c9 10	 or	 ecx, 16			; 00000010H
  00f83	89 4d fc	 mov	 DWORD PTR _rc$[ebp], ecx

; 789  : 	else

  00f86	eb 07		 jmp	 SHORT $L60182
$L60181:

; 790  : 		// Not valid.
; 791  : 		rc = False;

  00f88	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _rc$[ebp], 0
$L60182:

; 792  : 
; 793  : // BEW CLEANUP 	critErrHandler->SetMethod(CritErrHandler::Abort);
; 794  : 	
; 795  : 	return rc;

  00f8f	8b 45 fc	 mov	 eax, DWORD PTR _rc$[ebp]

; 796  : }

  00f92	8b e5		 mov	 esp, ebp
  00f94	5d		 pop	 ebp
  00f95	c3		 ret	 0
?CheckValidPath@@YAHPBD@Z ENDP				; CheckValidPath
_TEXT	ENDS
EXTRN	__imp___getdrive:NEAR
_TEXT	SEGMENT
?GetDisk@@YAHXZ PROC NEAR				; GetDisk

; 799  : GetDisk() {

  00f96	55		 push	 ebp
  00f97	8b ec		 mov	 ebp, esp

; 800  : 	return _getdrive() - 1;		//	0	=	A,	1	=	B, etc.

  00f99	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___getdrive
  00f9f	83 e8 01	 sub	 eax, 1

; 801  : }

  00fa2	5d		 pop	 ebp
  00fa3	c3		 ret	 0
?GetDisk@@YAHXZ ENDP					; GetDisk
_TEXT	ENDS
EXTRN	__imp___chdrive:NEAR
_TEXT	SEGMENT
_disk$ = 8
?SetDisk@@YAHH@Z PROC NEAR				; SetDisk

; 804  : SetDisk(int disk) {

  00fa4	55		 push	 ebp
  00fa5	8b ec		 mov	 ebp, esp

; 805  : 	_chdrive(disk + 1);

  00fa7	8b 45 08	 mov	 eax, DWORD PTR _disk$[ebp]
  00faa	83 c0 01	 add	 eax, 1
  00fad	50		 push	 eax
  00fae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___chdrive
  00fb4	83 c4 04	 add	 esp, 4

; 806  : 	return disk;

  00fb7	8b 45 08	 mov	 eax, DWORD PTR _disk$[ebp]

; 807  : }

  00fba	5d		 pop	 ebp
  00fbb	c3		 ret	 0
?SetDisk@@YAHH@Z ENDP					; SetDisk
_path$ = 8
_device$ = 12
?GetDevice@@YAXPAD0@Z PROC NEAR				; GetDevice

; 811  : {

  00fbc	55		 push	 ebp
  00fbd	8b ec		 mov	 ebp, esp

; 812  : 	if (path[1] != ':')

  00fbf	8b 45 08	 mov	 eax, DWORD PTR _path$[ebp]
  00fc2	0f be 48 01	 movsx	 ecx, BYTE PTR [eax+1]
  00fc6	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  00fc9	74 0e		 je	 SHORT $L60192

; 813  : 		GetCurDevice(device);

  00fcb	8b 55 0c	 mov	 edx, DWORD PTR _device$[ebp]
  00fce	52		 push	 edx
  00fcf	e8 00 00 00 00	 call	 ?GetCurDevice@@YAXPAD@Z	; GetCurDevice
  00fd4	83 c4 04	 add	 esp, 4

; 814  : 	else {

  00fd7	eb 3e		 jmp	 SHORT $L60193
$L60192:

; 815  : 		*device++ = *path++;

  00fd9	8b 45 0c	 mov	 eax, DWORD PTR _device$[ebp]
  00fdc	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  00fdf	8a 11		 mov	 dl, BYTE PTR [ecx]
  00fe1	88 10		 mov	 BYTE PTR [eax], dl
  00fe3	8b 45 0c	 mov	 eax, DWORD PTR _device$[ebp]
  00fe6	83 c0 01	 add	 eax, 1
  00fe9	89 45 0c	 mov	 DWORD PTR _device$[ebp], eax
  00fec	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  00fef	83 c1 01	 add	 ecx, 1
  00ff2	89 4d 08	 mov	 DWORD PTR _path$[ebp], ecx

; 816  : 		*device++ = *path++;

  00ff5	8b 55 0c	 mov	 edx, DWORD PTR _device$[ebp]
  00ff8	8b 45 08	 mov	 eax, DWORD PTR _path$[ebp]
  00ffb	8a 08		 mov	 cl, BYTE PTR [eax]
  00ffd	88 0a		 mov	 BYTE PTR [edx], cl
  00fff	8b 55 0c	 mov	 edx, DWORD PTR _device$[ebp]
  01002	83 c2 01	 add	 edx, 1
  01005	89 55 0c	 mov	 DWORD PTR _device$[ebp], edx
  01008	8b 45 08	 mov	 eax, DWORD PTR _path$[ebp]
  0100b	83 c0 01	 add	 eax, 1
  0100e	89 45 08	 mov	 DWORD PTR _path$[ebp], eax

; 817  : 		*device = '\0';

  01011	8b 4d 0c	 mov	 ecx, DWORD PTR _device$[ebp]
  01014	c6 01 00	 mov	 BYTE PTR [ecx], 0
$L60193:

; 819  : }

  01017	5d		 pop	 ebp
  01018	c3		 ret	 0
?GetDevice@@YAXPAD0@Z ENDP				; GetDevice
_device$ = 8
_path$ = -264
?GetCurDevice@@YAXPAD@Z PROC NEAR			; GetCurDevice

; 823  : {

  01019	55		 push	 ebp
  0101a	8b ec		 mov	 ebp, esp
  0101c	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H

; 824  : 	char	path[MaxPath + 1];
; 825  : 
; 826  : 	GetCWD(path);

  01022	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  01028	50		 push	 eax
  01029	e8 00 00 00 00	 call	 ?GetCWD@@YAPADPAD@Z	; GetCWD
  0102e	83 c4 04	 add	 esp, 4

; 827  : 	GetDevice(path, device);

  01031	8b 4d 08	 mov	 ecx, DWORD PTR _device$[ebp]
  01034	51		 push	 ecx
  01035	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _path$[ebp]
  0103b	52		 push	 edx
  0103c	e8 00 00 00 00	 call	 ?GetDevice@@YAXPAD0@Z	; GetDevice
  01041	83 c4 08	 add	 esp, 8

; 828  : }

  01044	8b e5		 mov	 esp, ebp
  01046	5d		 pop	 ebp
  01047	c3		 ret	 0
?GetCurDevice@@YAXPAD@Z ENDP				; GetCurDevice
_TEXT	ENDS
PUBLIC	??0MemID@@QAE@XZ				; MemID::MemID
;	COMDAT ??0Array@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8
??0Array@@QAE@XZ PROC NEAR				; Array::Array, COMDAT

; 74   : 	Array() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID

; 75   : 		dataID ( 0 );

  00011	51		 push	 ecx
  00012	8b cc		 mov	 ecx, esp
  00014	6a 00		 push	 0
  00016	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?dataID@Array@@QAEXVMemID@@@Z ; Array::dataID

; 76   : 	}

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??0Array@@QAE@XZ ENDP					; Array::Array
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0MemID@@QAE@XZ PROC NEAR				; MemID::MemID, COMDAT

; 15   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 16   : 	}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0MemID@@QAE@XZ ENDP					; MemID::MemID
_TEXT	ENDS
;	COMDAT ??1Array@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1Array@@QAE@XZ PROC NEAR				; Array::~Array, COMDAT

; 88   : 	~Array() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1Array@@QAE@XZ ENDP					; Array::~Array
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAEXVMemID@@@Z
_TEXT	SEGMENT
_memID$ = 8
_this$ = -4
?dataID@Array@@QAEXVMemID@@@Z PROC NEAR			; Array::dataID, COMDAT

; 111  : 	void dataID ( MemID memID ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		_dataID = memID;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 4d 08	 mov	 cx, WORD PTR _memID$[ebp]
  0000e	66 89 08	 mov	 WORD PTR [eax], cx

; 113  : 	}

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?dataID@Array@@QAEXVMemID@@@Z ENDP			; Array::dataID
_TEXT	ENDS
PUBLIC	??_C@_00A@?$AA@					; `string'
;	COMDAT ??_C@_00A@?$AA@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\textid.hpp
_BSS	SEGMENT
??_C@_00A@?$AA@ DB 01H DUP (?)				; `string'
_BSS	ENDS
;	COMDAT ??DTextID@@QAEPADXZ
_TEXT	SEGMENT
_this$ = -4
??DTextID@@QAEPADXZ PROC NEAR				; TextID::operator*, COMDAT

; 24   : 	char	*operator *() { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 25   : 		return handle ? (char *)MemID::operator*() : ""; 

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	33 c9		 xor	 ecx, ecx
  0000e	66 8b 08	 mov	 cx, WORD PTR [eax]
  00011	85 c9		 test	 ecx, ecx
  00013	74 0d		 je	 SHORT $L60392
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0001d	89 45 f8	 mov	 DWORD PTR -8+[ebp], eax
  00020	eb 07		 jmp	 SHORT $L60393
$L60392:
  00022	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
$L60393:
  00029	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]

; 26   : 	}

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??DTextID@@QAEPADXZ ENDP				; TextID::operator*
_TEXT	ENDS
END
