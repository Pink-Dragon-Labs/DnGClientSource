	TITLE	C:\Documents and Settings\don\Desktop\sciw\Interp\Celobj1.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BM@LHED@Instructed?5to?5scale?5to?5zero?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07CCG@ResView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KCEF@?4v56?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06IAEF@ResPic?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04EODC@?4p56?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08OCKJ@ResChunk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PIPI@?4chk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07ICMB@ResHunk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GG@?4scr?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08BLBP@ResSound?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KPDA@?4snd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NNMB@ResVocab?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PGDD@?4voc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FLKK@ResPatch?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CEHK@?4pat?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07MKGC@ResFont?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04IDCK@?4fon?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06DEEM@ResPal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NJLC@?4pal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07HFNL@ResHeap?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GFFD@?4hep?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06HDCC@ResMsg?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JONM@?4msg?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NFDN@ResAudio?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MOHF@?4aud?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BKMJ@ResWave?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MPDF@?4wav?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@IMEI@ResAudio36?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BONB@ResSync?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KFFK@?4syn?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09CBJE@ResSync36?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06MIEL@ResMap?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CFLF@?4map?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@LIAH@ResMsgTranslation?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JFJA@?4trn?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08JLOL@ResRobot?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04LLKI@?4rbt?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06OEMP@ResVMD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04IOID@?4vmd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MemoryMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckValid@MemoryMgr@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GMemoryMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@V1@III@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AMemID@@QBEAADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8MemID@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@NN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SOL_Point@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Rgb24@@QAE@EEE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Rgb24@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Rgb24F@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Ratio@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@HHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@VMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Type@Bitmap@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObj@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Skip@CelObj@@QBEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemapState@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Mirrored@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObj@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjView@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjView@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjView@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjView@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjMem@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjMem@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjMem@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjMem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjColor@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjColor@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjColor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjColor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@AAVSOL_Point@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Set@SOL_Rect@@QAEXHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeEmpty@SOL_Rect@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Xlen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ylen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8SOL_Rect@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Draw@ScreenItem@@QAEXABVBuffer@@ABVSOL_Rect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SOL_Rect@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TopPlane@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TopSCIPlane@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Xdim@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ydim@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?XDim@Buffer@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1PaletteMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GPaletteMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetExtension@SOL_ResType@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSupported@SOL_ResType@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAttrs@SOL_ResType@@UBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResView@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPic@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResChunk@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResScript@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSound@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResVocab@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPatch@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResFont@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPal@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResHeap@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMsg@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResAudio@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResWave@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResAudio36@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSync@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSync36@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMap@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMsgTranslation@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileType@ResMsgTranslation@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResRobot@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResVMD@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7ResPic@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7PaletteMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResView@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResPal@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObj@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResHeap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResWave@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResRobot@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResPatch@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMsgTranslation@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7Buffer@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResScript@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjColor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSync36@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMsg@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjView@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResAudio36@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResAudio@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResFont@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7MemoryMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResVMD@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResChunk@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSync@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjMem@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResVocab@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?maskTable@@3PAEA				; maskTable
_BSS	SEGMENT
?maskTable@@3PAEA DB 0100H DUP (?)			; maskTable
_BSS	ENDS
PUBLIC	?DrawHzFlip@CelObj@@QAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@@Z ; CelObj::DrawHzFlip
PUBLIC	?Xlen@SOL_Rect@@QBEHXZ				; SOL_Rect::Xlen
PUBLIC	?Ylen@SOL_Rect@@QBEHXZ				; SOL_Rect::Ylen
EXTRN	?REMAP_START_COLOR@@3HA:DWORD			; REMAP_START_COLOR
EXTRN	_memset:NEAR
_TEXT	SEGMENT
_dest$ = 8
_toBuffer$ = 12
_ul$ = 16
_this$ = -84
_rowLen$ = -4
_srcCol$ = -40
_srcRow$ = -32
_hRun$ = -16
_vRun$ = -8
_resBuffer$ = -48
_celPtr$ = -24
_controlData$ = -12
_colorData$ = -44
_controlTable$ = -36
_colorTable$ = -20
_i$ = -28
_target$58648 = -64
_controlPtr$58649 = -56
_colorPtr$58650 = -60
_j$58651 = -52
_control$58655 = -68
_k$58661 = -72
_color$58665 = -76
_color$58679 = -80
?DrawHzFlip@CelObj@@QAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@@Z PROC NEAR ; CelObj::DrawHzFlip

; 41   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	56		 push	 esi
  00007	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 42   : 	assert(dest.Assert());
; 43   : 	assert(toBuffer.IsWithin(dest.XDim(), dest.YDim()));
; 44   : 
; 45   : 	// ***********************************************************************
; 46   : 	// Non scaled drawing mirrored.
; 47   : 	// ***********************************************************************
; 48   : 	// Get a pointer to the drawing area(a static buffer).
; 49   : 
; 50   : 	int rowLen = toBuffer.Xlen();

  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  0000d	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  00012	89 45 fc	 mov	 DWORD PTR _rowLen$[ebp], eax

; 51   : 	int srcCol = width - (toBuffer.A.x - ul.x + toBuffer.Xlen());

  00015	8b 45 0c	 mov	 eax, DWORD PTR _toBuffer$[ebp]
  00018	8b 30		 mov	 esi, DWORD PTR [eax]
  0001a	2b 75 10	 sub	 esi, DWORD PTR _ul$[ebp]
  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  00020	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  00025	03 f0		 add	 esi, eax
  00027	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0002d	2b d6		 sub	 edx, esi
  0002f	89 55 d8	 mov	 DWORD PTR _srcCol$[ebp], edx

; 52   : 	int srcRow = toBuffer.A.y - ul.y;

  00032	8b 45 0c	 mov	 eax, DWORD PTR _toBuffer$[ebp]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	2b 4d 14	 sub	 ecx, DWORD PTR _ul$[ebp+4]
  0003b	89 4d e0	 mov	 DWORD PTR _srcRow$[ebp], ecx

; 53   : 	int hRun = width - toBuffer.A.x + ul.x;

  0003e	8b 55 ac	 mov	 edx, DWORD PTR _this$[ebp]
  00041	8b 45 0c	 mov	 eax, DWORD PTR _toBuffer$[ebp]
  00044	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  00047	2b 08		 sub	 ecx, DWORD PTR [eax]
  00049	03 4d 10	 add	 ecx, DWORD PTR _ul$[ebp]
  0004c	89 4d f0	 mov	 DWORD PTR _hRun$[ebp], ecx

; 54   : 	int vRun = toBuffer.Ylen();

  0004f	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  00052	e8 00 00 00 00	 call	 ?Ylen@SOL_Rect@@QBEHXZ	; SOL_Rect::Ylen
  00057	89 45 f8	 mov	 DWORD PTR _vRun$[ebp], eax

; 55   : 
; 56   : 	// The view can't move until the draw is done!
; 57   : 	// Get a pointer to the cel.
; 58   : 	uchar* resBuffer = ResPointer();

  0005a	8b 55 ac	 mov	 edx, DWORD PTR _this$[ebp]
  0005d	8b 02		 mov	 eax, DWORD PTR [edx]
  0005f	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	ff 50 14	 call	 DWORD PTR [eax+20]
  00065	89 45 d0	 mov	 DWORD PTR _resBuffer$[ebp], eax

; 59   : 	CelHeader* celPtr = (CelHeader*) (resBuffer + celOffset);

  00068	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	8b 55 d0	 mov	 edx, DWORD PTR _resBuffer$[ebp]
  0006e	03 51 18	 add	 edx, DWORD PTR [ecx+24]
  00071	89 55 e8	 mov	 DWORD PTR _celPtr$[ebp], edx

; 60   : 
; 61   : 	uchar* controlData = resBuffer + celPtr->controlOffset;

  00074	8b 45 e8	 mov	 eax, DWORD PTR _celPtr$[ebp]
  00077	8b 4d d0	 mov	 ecx, DWORD PTR _resBuffer$[ebp]
  0007a	03 48 18	 add	 ecx, DWORD PTR [eax+24]
  0007d	89 4d f4	 mov	 DWORD PTR _controlData$[ebp], ecx

; 62   : 	uchar* colorData = resBuffer + celPtr->colorOffset;

  00080	8b 55 e8	 mov	 edx, DWORD PTR _celPtr$[ebp]
  00083	8b 45 d0	 mov	 eax, DWORD PTR _resBuffer$[ebp]
  00086	03 42 1c	 add	 eax, DWORD PTR [edx+28]
  00089	89 45 d4	 mov	 DWORD PTR _colorData$[ebp], eax

; 63   : 
; 64   : 	long* controlTable = (long *) (resBuffer + celPtr->rowTableOffset);

  0008c	8b 4d e8	 mov	 ecx, DWORD PTR _celPtr$[ebp]
  0008f	8b 55 d0	 mov	 edx, DWORD PTR _resBuffer$[ebp]
  00092	03 51 20	 add	 edx, DWORD PTR [ecx+32]
  00095	89 55 dc	 mov	 DWORD PTR _controlTable$[ebp], edx

; 65   : 	long* colorTable = controlTable + height;

  00098	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0009e	8b 55 dc	 mov	 edx, DWORD PTR _controlTable$[ebp]
  000a1	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  000a4	89 45 ec	 mov	 DWORD PTR _colorTable$[ebp], eax

; 66   : 
; 67   : 	// Draw the inset rectangle
; 68   : 	for (int i = 0;i < vRun;++i,++srcRow) {

  000a7	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000ae	eb 12		 jmp	 SHORT $L58645
$L58646:
  000b0	8b 4d e4	 mov	 ecx, DWORD PTR _i$[ebp]
  000b3	83 c1 01	 add	 ecx, 1
  000b6	89 4d e4	 mov	 DWORD PTR _i$[ebp], ecx
  000b9	8b 55 e0	 mov	 edx, DWORD PTR _srcRow$[ebp]
  000bc	83 c2 01	 add	 edx, 1
  000bf	89 55 e0	 mov	 DWORD PTR _srcRow$[ebp], edx
$L58645:
  000c2	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  000c5	3b 45 f8	 cmp	 eax, DWORD PTR _vRun$[ebp]
  000c8	0f 8d 05 03 00
	00		 jge	 $L58647

; 69   : 		// Find the row data
; 70   : 		uchar* target = dest.Addr(toBuffer.A.x, toBuffer.A.y + i) + rowLen - 1;

  000ce	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  000d1	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d4	03 55 e4	 add	 edx, DWORD PTR _i$[ebp]
  000d7	52		 push	 edx
  000d8	8b 45 0c	 mov	 eax, DWORD PTR _toBuffer$[ebp]
  000db	8b 08		 mov	 ecx, DWORD PTR [eax]
  000dd	51		 push	 ecx
  000de	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  000e1	8b 02		 mov	 eax, DWORD PTR [edx]
  000e3	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  000e6	ff 10		 call	 DWORD PTR [eax]
  000e8	8b 4d fc	 mov	 ecx, DWORD PTR _rowLen$[ebp]
  000eb	8d 54 08 ff	 lea	 edx, DWORD PTR [eax+ecx-1]
  000ef	89 55 c0	 mov	 DWORD PTR _target$58648[ebp], edx

; 71   : 		uchar* controlPtr = controlData + controlTable[srcRow];

  000f2	8b 45 e0	 mov	 eax, DWORD PTR _srcRow$[ebp]
  000f5	8b 4d dc	 mov	 ecx, DWORD PTR _controlTable$[ebp]
  000f8	8b 55 f4	 mov	 edx, DWORD PTR _controlData$[ebp]
  000fb	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  000fe	89 55 c8	 mov	 DWORD PTR _controlPtr$58649[ebp], edx

; 72   : 		uchar* colorPtr = colorData + colorTable[srcRow];

  00101	8b 45 e0	 mov	 eax, DWORD PTR _srcRow$[ebp]
  00104	8b 4d ec	 mov	 ecx, DWORD PTR _colorTable$[ebp]
  00107	8b 55 d4	 mov	 edx, DWORD PTR _colorData$[ebp]
  0010a	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  0010d	89 55 c4	 mov	 DWORD PTR _colorPtr$58650[ebp], edx

; 73   : 
; 74   : 		// Draw a line
; 75   : 		for (int j = 0;j <hRun;) {

  00110	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _j$58651[ebp], 0
$L58653:
  00117	8b 45 cc	 mov	 eax, DWORD PTR _j$58651[ebp]
  0011a	3b 45 f0	 cmp	 eax, DWORD PTR _hRun$[ebp]
  0011d	0f 8d ab 02 00
	00		 jge	 $L58654

; 76   : 			// Get the control character
; 77   : 			uchar control = *controlPtr++;

  00123	8b 4d c8	 mov	 ecx, DWORD PTR _controlPtr$58649[ebp]
  00126	8a 11		 mov	 dl, BYTE PTR [ecx]
  00128	88 55 bc	 mov	 BYTE PTR _control$58655[ebp], dl
  0012b	8b 45 c8	 mov	 eax, DWORD PTR _controlPtr$58649[ebp]
  0012e	83 c0 01	 add	 eax, 1
  00131	89 45 c8	 mov	 DWORD PTR _controlPtr$58649[ebp], eax

; 78   : 			if (!(control & REPEATC)) {

  00134	8b 4d bc	 mov	 ecx, DWORD PTR _control$58655[ebp]
  00137	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0013d	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00143	85 c9		 test	 ecx, ecx
  00145	0f 85 fd 00 00
	00		 jne	 $L58656

; 79   : 				// Do a run of unique bytes
; 80   : 				if ((j + control) < srcCol) {

  0014b	8b 55 bc	 mov	 edx, DWORD PTR _control$58655[ebp]
  0014e	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00154	8b 45 cc	 mov	 eax, DWORD PTR _j$58651[ebp]
  00157	03 c2		 add	 eax, edx
  00159	3b 45 d8	 cmp	 eax, DWORD PTR _srcCol$[ebp]
  0015c	7d 26		 jge	 SHORT $L58657

; 81   : 					j += control;

  0015e	8b 4d bc	 mov	 ecx, DWORD PTR _control$58655[ebp]
  00161	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00167	8b 55 cc	 mov	 edx, DWORD PTR _j$58651[ebp]
  0016a	03 d1		 add	 edx, ecx
  0016c	89 55 cc	 mov	 DWORD PTR _j$58651[ebp], edx

; 82   : 					colorPtr += control;

  0016f	8b 45 bc	 mov	 eax, DWORD PTR _control$58655[ebp]
  00172	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00177	8b 4d c4	 mov	 ecx, DWORD PTR _colorPtr$58650[ebp]
  0017a	03 c8		 add	 ecx, eax
  0017c	89 4d c4	 mov	 DWORD PTR _colorPtr$58650[ebp], ecx

; 84   : 				else {

  0017f	e9 bf 00 00 00	 jmp	 $L58664
$L58657:

; 85   : 					if (j < srcCol) {

  00184	8b 55 cc	 mov	 edx, DWORD PTR _j$58651[ebp]
  00187	3b 55 d8	 cmp	 edx, DWORD PTR _srcCol$[ebp]
  0018a	7d 22		 jge	 SHORT $L58659

; 86   : 						control -= srcCol - j;

  0018c	8b 45 d8	 mov	 eax, DWORD PTR _srcCol$[ebp]
  0018f	2b 45 cc	 sub	 eax, DWORD PTR _j$58651[ebp]
  00192	8a 4d bc	 mov	 cl, BYTE PTR _control$58655[ebp]
  00195	2a c8		 sub	 cl, al
  00197	88 4d bc	 mov	 BYTE PTR _control$58655[ebp], cl

; 87   : 						colorPtr += srcCol - j;

  0019a	8b 55 d8	 mov	 edx, DWORD PTR _srcCol$[ebp]
  0019d	2b 55 cc	 sub	 edx, DWORD PTR _j$58651[ebp]
  001a0	8b 45 c4	 mov	 eax, DWORD PTR _colorPtr$58650[ebp]
  001a3	03 c2		 add	 eax, edx
  001a5	89 45 c4	 mov	 DWORD PTR _colorPtr$58650[ebp], eax

; 88   : 						j = srcCol;

  001a8	8b 4d d8	 mov	 ecx, DWORD PTR _srcCol$[ebp]
  001ab	89 4d cc	 mov	 DWORD PTR _j$58651[ebp], ecx
$L58659:

; 90   : 					if (j + control > hRun) {

  001ae	8b 55 bc	 mov	 edx, DWORD PTR _control$58655[ebp]
  001b1	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  001b7	8b 45 cc	 mov	 eax, DWORD PTR _j$58651[ebp]
  001ba	03 c2		 add	 eax, edx
  001bc	3b 45 f0	 cmp	 eax, DWORD PTR _hRun$[ebp]
  001bf	7e 09		 jle	 SHORT $L58660

; 91   : 						control = hRun - j;

  001c1	8b 4d f0	 mov	 ecx, DWORD PTR _hRun$[ebp]
  001c4	2b 4d cc	 sub	 ecx, DWORD PTR _j$58651[ebp]
  001c7	88 4d bc	 mov	 BYTE PTR _control$58655[ebp], cl
$L58660:

; 93   : 					j += control;

  001ca	8b 55 bc	 mov	 edx, DWORD PTR _control$58655[ebp]
  001cd	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  001d3	8b 45 cc	 mov	 eax, DWORD PTR _j$58651[ebp]
  001d6	03 c2		 add	 eax, edx
  001d8	89 45 cc	 mov	 DWORD PTR _j$58651[ebp], eax

; 94   : 					for (int k = 0;k<control;++k) {

  001db	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _k$58661[ebp], 0
  001e2	eb 09		 jmp	 SHORT $L58662
$L58663:
  001e4	8b 4d b8	 mov	 ecx, DWORD PTR _k$58661[ebp]
  001e7	83 c1 01	 add	 ecx, 1
  001ea	89 4d b8	 mov	 DWORD PTR _k$58661[ebp], ecx
$L58662:
  001ed	8b 55 bc	 mov	 edx, DWORD PTR _control$58655[ebp]
  001f0	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  001f6	39 55 b8	 cmp	 DWORD PTR _k$58661[ebp], edx
  001f9	7d 48		 jge	 SHORT $L58664

; 95   : 						uchar color = *colorPtr++;

  001fb	8b 45 c4	 mov	 eax, DWORD PTR _colorPtr$58650[ebp]
  001fe	8a 08		 mov	 cl, BYTE PTR [eax]
  00200	88 4d b4	 mov	 BYTE PTR _color$58665[ebp], cl
  00203	8b 55 c4	 mov	 edx, DWORD PTR _colorPtr$58650[ebp]
  00206	83 c2 01	 add	 edx, 1
  00209	89 55 c4	 mov	 DWORD PTR _colorPtr$58650[ebp], edx

; 96   : 						if (color != skip  &&  color < REMAP_START_COLOR) {

  0020c	8b 45 b4	 mov	 eax, DWORD PTR _color$58665[ebp]
  0020f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00214	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00217	33 d2		 xor	 edx, edx
  00219	8a 51 38	 mov	 dl, BYTE PTR [ecx+56]
  0021c	3b c2		 cmp	 eax, edx
  0021e	74 18		 je	 SHORT $L58666
  00220	8b 45 b4	 mov	 eax, DWORD PTR _color$58665[ebp]
  00223	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00228	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?REMAP_START_COLOR@@3HA ; REMAP_START_COLOR
  0022e	7d 08		 jge	 SHORT $L58666

; 97   : 							*target = color;

  00230	8b 4d c0	 mov	 ecx, DWORD PTR _target$58648[ebp]
  00233	8a 55 b4	 mov	 dl, BYTE PTR _color$58665[ebp]
  00236	88 11		 mov	 BYTE PTR [ecx], dl
$L58666:

; 99   : 						target--;

  00238	8b 45 c0	 mov	 eax, DWORD PTR _target$58648[ebp]
  0023b	83 e8 01	 sub	 eax, 1
  0023e	89 45 c0	 mov	 DWORD PTR _target$58648[ebp], eax

; 100  : 					}

  00241	eb a1		 jmp	 SHORT $L58663
$L58664:

; 103  : 			else {

  00243	e9 81 01 00 00	 jmp	 $L58676
$L58656:

; 104  : 				if (control & REPSKIP) {

  00248	8b 4d bc	 mov	 ecx, DWORD PTR _control$58655[ebp]
  0024b	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00251	83 e1 40	 and	 ecx, 64			; 00000040H
  00254	85 c9		 test	 ecx, ecx
  00256	0f 84 8d 00 00
	00		 je	 $L58668

; 105  : 					// Do a run of repeated skip
; 106  : 					control &= 0x3f;

  0025c	8a 55 bc	 mov	 dl, BYTE PTR _control$58655[ebp]
  0025f	80 e2 3f	 and	 dl, 63			; 0000003fH
  00262	88 55 bc	 mov	 BYTE PTR _control$58655[ebp], dl

; 107  : 					if ((j + (int) control) < srcCol) {

  00265	8b 45 bc	 mov	 eax, DWORD PTR _control$58655[ebp]
  00268	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0026d	8b 4d cc	 mov	 ecx, DWORD PTR _j$58651[ebp]
  00270	03 c8		 add	 ecx, eax
  00272	3b 4d d8	 cmp	 ecx, DWORD PTR _srcCol$[ebp]
  00275	7d 13		 jge	 SHORT $L58670

; 108  : 						j += control;

  00277	8b 55 bc	 mov	 edx, DWORD PTR _control$58655[ebp]
  0027a	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00280	8b 45 cc	 mov	 eax, DWORD PTR _j$58651[ebp]
  00283	03 c2		 add	 eax, edx
  00285	89 45 cc	 mov	 DWORD PTR _j$58651[ebp], eax

; 110  : 					else {

  00288	eb 5a		 jmp	 SHORT $L58671
$L58670:

; 111  : 						if (j < srcCol) {

  0028a	8b 4d cc	 mov	 ecx, DWORD PTR _j$58651[ebp]
  0028d	3b 4d d8	 cmp	 ecx, DWORD PTR _srcCol$[ebp]
  00290	7d 14		 jge	 SHORT $L58672

; 112  : 							control -= srcCol - j;

  00292	8b 55 d8	 mov	 edx, DWORD PTR _srcCol$[ebp]
  00295	2b 55 cc	 sub	 edx, DWORD PTR _j$58651[ebp]
  00298	8a 45 bc	 mov	 al, BYTE PTR _control$58655[ebp]
  0029b	2a c2		 sub	 al, dl
  0029d	88 45 bc	 mov	 BYTE PTR _control$58655[ebp], al

; 113  : 							j = srcCol;

  002a0	8b 4d d8	 mov	 ecx, DWORD PTR _srcCol$[ebp]
  002a3	89 4d cc	 mov	 DWORD PTR _j$58651[ebp], ecx
$L58672:

; 115  : 						if (j + control > hRun) {

  002a6	8b 55 bc	 mov	 edx, DWORD PTR _control$58655[ebp]
  002a9	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  002af	8b 45 cc	 mov	 eax, DWORD PTR _j$58651[ebp]
  002b2	03 c2		 add	 eax, edx
  002b4	3b 45 f0	 cmp	 eax, DWORD PTR _hRun$[ebp]
  002b7	7e 09		 jle	 SHORT $L58673

; 116  : 							control = hRun - j;

  002b9	8b 4d f0	 mov	 ecx, DWORD PTR _hRun$[ebp]
  002bc	2b 4d cc	 sub	 ecx, DWORD PTR _j$58651[ebp]
  002bf	88 4d bc	 mov	 BYTE PTR _control$58655[ebp], cl
$L58673:

; 118  : 						j += control;

  002c2	8b 55 bc	 mov	 edx, DWORD PTR _control$58655[ebp]
  002c5	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  002cb	8b 45 cc	 mov	 eax, DWORD PTR _j$58651[ebp]
  002ce	03 c2		 add	 eax, edx
  002d0	89 45 cc	 mov	 DWORD PTR _j$58651[ebp], eax

; 119  : 						target -= control;

  002d3	8b 4d bc	 mov	 ecx, DWORD PTR _control$58655[ebp]
  002d6	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  002dc	8b 55 c0	 mov	 edx, DWORD PTR _target$58648[ebp]
  002df	2b d1		 sub	 edx, ecx
  002e1	89 55 c0	 mov	 DWORD PTR _target$58648[ebp], edx
$L58671:

; 122  : 				else {

  002e4	e9 e0 00 00 00	 jmp	 $L58676
$L58668:

; 123  : 					// Do a run of repeated color
; 124  : 					control &= 0x3f;

  002e9	8a 45 bc	 mov	 al, BYTE PTR _control$58655[ebp]
  002ec	24 3f		 and	 al, 63			; 0000003fH
  002ee	88 45 bc	 mov	 BYTE PTR _control$58655[ebp], al

; 125  : 					if ((j + control) < srcCol) {

  002f1	8b 4d bc	 mov	 ecx, DWORD PTR _control$58655[ebp]
  002f4	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  002fa	8b 55 cc	 mov	 edx, DWORD PTR _j$58651[ebp]
  002fd	03 d1		 add	 edx, ecx
  002ff	3b 55 d8	 cmp	 edx, DWORD PTR _srcCol$[ebp]
  00302	7d 1e		 jge	 SHORT $L58675

; 126  : 						j += control;

  00304	8b 45 bc	 mov	 eax, DWORD PTR _control$58655[ebp]
  00307	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0030c	8b 4d cc	 mov	 ecx, DWORD PTR _j$58651[ebp]
  0030f	03 c8		 add	 ecx, eax
  00311	89 4d cc	 mov	 DWORD PTR _j$58651[ebp], ecx

; 127  : 						colorPtr++;

  00314	8b 55 c4	 mov	 edx, DWORD PTR _colorPtr$58650[ebp]
  00317	83 c2 01	 add	 edx, 1
  0031a	89 55 c4	 mov	 DWORD PTR _colorPtr$58650[ebp], edx

; 129  : 					else {

  0031d	e9 a7 00 00 00	 jmp	 $L58676
$L58675:

; 130  : 						if (j < srcCol) {

  00322	8b 45 cc	 mov	 eax, DWORD PTR _j$58651[ebp]
  00325	3b 45 d8	 cmp	 eax, DWORD PTR _srcCol$[ebp]
  00328	7d 14		 jge	 SHORT $L58677

; 131  : 							control -= srcCol - j;

  0032a	8b 4d d8	 mov	 ecx, DWORD PTR _srcCol$[ebp]
  0032d	2b 4d cc	 sub	 ecx, DWORD PTR _j$58651[ebp]
  00330	8a 55 bc	 mov	 dl, BYTE PTR _control$58655[ebp]
  00333	2a d1		 sub	 dl, cl
  00335	88 55 bc	 mov	 BYTE PTR _control$58655[ebp], dl

; 132  : 							j = srcCol;

  00338	8b 45 d8	 mov	 eax, DWORD PTR _srcCol$[ebp]
  0033b	89 45 cc	 mov	 DWORD PTR _j$58651[ebp], eax
$L58677:

; 134  : 						if (j + control > hRun) {

  0033e	8b 4d bc	 mov	 ecx, DWORD PTR _control$58655[ebp]
  00341	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00347	8b 55 cc	 mov	 edx, DWORD PTR _j$58651[ebp]
  0034a	03 d1		 add	 edx, ecx
  0034c	3b 55 f0	 cmp	 edx, DWORD PTR _hRun$[ebp]
  0034f	7e 09		 jle	 SHORT $L58678

; 135  : 							control = hRun - j;

  00351	8b 45 f0	 mov	 eax, DWORD PTR _hRun$[ebp]
  00354	2b 45 cc	 sub	 eax, DWORD PTR _j$58651[ebp]
  00357	88 45 bc	 mov	 BYTE PTR _control$58655[ebp], al
$L58678:

; 137  : 						uchar color = *colorPtr++;

  0035a	8b 4d c4	 mov	 ecx, DWORD PTR _colorPtr$58650[ebp]
  0035d	8a 11		 mov	 dl, BYTE PTR [ecx]
  0035f	88 55 b0	 mov	 BYTE PTR _color$58679[ebp], dl
  00362	8b 45 c4	 mov	 eax, DWORD PTR _colorPtr$58650[ebp]
  00365	83 c0 01	 add	 eax, 1
  00368	89 45 c4	 mov	 DWORD PTR _colorPtr$58650[ebp], eax

; 138  : 						target -= control - 1;

  0036b	8b 4d bc	 mov	 ecx, DWORD PTR _control$58655[ebp]
  0036e	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00374	83 e9 01	 sub	 ecx, 1
  00377	8b 55 c0	 mov	 edx, DWORD PTR _target$58648[ebp]
  0037a	2b d1		 sub	 edx, ecx
  0037c	89 55 c0	 mov	 DWORD PTR _target$58648[ebp], edx

; 139  :                   if (color < REMAP_START_COLOR)

  0037f	8b 45 b0	 mov	 eax, DWORD PTR _color$58679[ebp]
  00382	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00387	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?REMAP_START_COLOR@@3HA ; REMAP_START_COLOR
  0038d	7d 20		 jge	 SHORT $L58680

; 140  : 						   memset(target,color,control);

  0038f	8b 4d bc	 mov	 ecx, DWORD PTR _control$58655[ebp]
  00392	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00398	51		 push	 ecx
  00399	8b 55 b0	 mov	 edx, DWORD PTR _color$58679[ebp]
  0039c	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  003a2	52		 push	 edx
  003a3	8b 45 c0	 mov	 eax, DWORD PTR _target$58648[ebp]
  003a6	50		 push	 eax
  003a7	e8 00 00 00 00	 call	 _memset
  003ac	83 c4 0c	 add	 esp, 12			; 0000000cH
$L58680:

; 141  : 
; 142  : 						--target;

  003af	8b 4d c0	 mov	 ecx, DWORD PTR _target$58648[ebp]
  003b2	83 e9 01	 sub	 ecx, 1
  003b5	89 4d c0	 mov	 DWORD PTR _target$58648[ebp], ecx

; 143  : 						j += control;

  003b8	8b 55 bc	 mov	 edx, DWORD PTR _control$58655[ebp]
  003bb	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  003c1	8b 45 cc	 mov	 eax, DWORD PTR _j$58651[ebp]
  003c4	03 c2		 add	 eax, edx
  003c6	89 45 cc	 mov	 DWORD PTR _j$58651[ebp], eax
$L58676:

; 147  : 		}

  003c9	e9 49 fd ff ff	 jmp	 $L58653
$L58654:

; 148  : 	}

  003ce	e9 dd fc ff ff	 jmp	 $L58646
$L58647:

; 149  : }

  003d3	5e		 pop	 esi
  003d4	8b e5		 mov	 esp, ebp
  003d6	5d		 pop	 ebp
  003d7	c2 10 00	 ret	 16			; 00000010H
?DrawHzFlip@CelObj@@QAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@@Z ENDP ; CelObj::DrawHzFlip
_TEXT	ENDS
PUBLIC	?DrawNoFlip@CelObj@@QAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@@Z ; CelObj::DrawNoFlip
_TEXT	SEGMENT
_dest$ = 8
_toBuffer$ = 12
_ul$ = 16
_this$ = -84
_rowLen$ = -4
_srcCol$ = -40
_srcRow$ = -32
_hRun$ = -16
_vRun$ = -8
_resBuffer$ = -48
_celPtr$ = -24
_controlData$ = -12
_colorData$ = -44
_controlTable$ = -36
_colorTable$ = -20
_i$ = -28
_target$58706 = -64
_controlPtr$58707 = -56
_colorPtr$58708 = -60
_j$58709 = -52
_control$58713 = -68
_k$58719 = -72
_color$58723 = -76
_color$58737 = -80
?DrawNoFlip@CelObj@@QAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@@Z PROC NEAR ; CelObj::DrawNoFlip

; 159  : {

  003da	55		 push	 ebp
  003db	8b ec		 mov	 ebp, esp
  003dd	83 ec 54	 sub	 esp, 84			; 00000054H
  003e0	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 160  : 	assert(dest.Assert());
; 161  : 	assert(toBuffer.IsWithin(dest.XDim(), dest.YDim()));
; 162  : 
; 163  : 	// ***********************************************************************
; 164  : 	// Non scaled drawing.
; 165  : 	// ***********************************************************************
; 166  : 	// Get a pointer to the drawing area(a static buffer).
; 167  : 
; 168  : 	int rowLen = toBuffer.Xlen();

  003e3	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  003e6	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  003eb	89 45 fc	 mov	 DWORD PTR _rowLen$[ebp], eax

; 169  : 	int srcCol = toBuffer.A.x - ul.x;

  003ee	8b 45 0c	 mov	 eax, DWORD PTR _toBuffer$[ebp]
  003f1	8b 08		 mov	 ecx, DWORD PTR [eax]
  003f3	2b 4d 10	 sub	 ecx, DWORD PTR _ul$[ebp]
  003f6	89 4d d8	 mov	 DWORD PTR _srcCol$[ebp], ecx

; 170  : 	int srcRow = toBuffer.A.y - ul.y;

  003f9	8b 55 0c	 mov	 edx, DWORD PTR _toBuffer$[ebp]
  003fc	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  003ff	2b 45 14	 sub	 eax, DWORD PTR _ul$[ebp+4]
  00402	89 45 e0	 mov	 DWORD PTR _srcRow$[ebp], eax

; 171  : 	int hRun = toBuffer.B.x - ul.x + 1;

  00405	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  00408	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0040b	2b 55 10	 sub	 edx, DWORD PTR _ul$[ebp]
  0040e	83 c2 01	 add	 edx, 1
  00411	89 55 f0	 mov	 DWORD PTR _hRun$[ebp], edx

; 172  : 	int vRun = toBuffer.Ylen();

  00414	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  00417	e8 00 00 00 00	 call	 ?Ylen@SOL_Rect@@QBEHXZ	; SOL_Rect::Ylen
  0041c	89 45 f8	 mov	 DWORD PTR _vRun$[ebp], eax

; 173  : 
; 174  : 	// The view can't move until the draw is done!
; 175  : 	// Get a pointer to the cel.
; 176  : 	uchar* resBuffer = ResPointer();

  0041f	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  00422	8b 10		 mov	 edx, DWORD PTR [eax]
  00424	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00427	ff 52 14	 call	 DWORD PTR [edx+20]
  0042a	89 45 d0	 mov	 DWORD PTR _resBuffer$[ebp], eax

; 177  : 	CelHeader* celPtr = (CelHeader*) (resBuffer + celOffset);

  0042d	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  00430	8b 4d d0	 mov	 ecx, DWORD PTR _resBuffer$[ebp]
  00433	03 48 18	 add	 ecx, DWORD PTR [eax+24]
  00436	89 4d e8	 mov	 DWORD PTR _celPtr$[ebp], ecx

; 178  : 
; 179  : 	uchar* controlData = resBuffer + celPtr->controlOffset;

  00439	8b 55 e8	 mov	 edx, DWORD PTR _celPtr$[ebp]
  0043c	8b 45 d0	 mov	 eax, DWORD PTR _resBuffer$[ebp]
  0043f	03 42 18	 add	 eax, DWORD PTR [edx+24]
  00442	89 45 f4	 mov	 DWORD PTR _controlData$[ebp], eax

; 180  : 	uchar* colorData = resBuffer + celPtr->colorOffset;

  00445	8b 4d e8	 mov	 ecx, DWORD PTR _celPtr$[ebp]
  00448	8b 55 d0	 mov	 edx, DWORD PTR _resBuffer$[ebp]
  0044b	03 51 1c	 add	 edx, DWORD PTR [ecx+28]
  0044e	89 55 d4	 mov	 DWORD PTR _colorData$[ebp], edx

; 181  : 
; 182  : 	long* controlTable = (long *) (resBuffer + celPtr->rowTableOffset);

  00451	8b 45 e8	 mov	 eax, DWORD PTR _celPtr$[ebp]
  00454	8b 4d d0	 mov	 ecx, DWORD PTR _resBuffer$[ebp]
  00457	03 48 20	 add	 ecx, DWORD PTR [eax+32]
  0045a	89 4d dc	 mov	 DWORD PTR _controlTable$[ebp], ecx

; 183  : 	long* colorTable = controlTable + height;

  0045d	8b 55 ac	 mov	 edx, DWORD PTR _this$[ebp]
  00460	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00463	8b 4d dc	 mov	 ecx, DWORD PTR _controlTable$[ebp]
  00466	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00469	89 55 ec	 mov	 DWORD PTR _colorTable$[ebp], edx

; 184  : 
; 185  : 	// Draw the inset rectangle
; 186  : 	for (int i = 0;i < vRun;++i,++srcRow) {

  0046c	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00473	eb 12		 jmp	 SHORT $L58703
$L58704:
  00475	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  00478	83 c0 01	 add	 eax, 1
  0047b	89 45 e4	 mov	 DWORD PTR _i$[ebp], eax
  0047e	8b 4d e0	 mov	 ecx, DWORD PTR _srcRow$[ebp]
  00481	83 c1 01	 add	 ecx, 1
  00484	89 4d e0	 mov	 DWORD PTR _srcRow$[ebp], ecx
$L58703:
  00487	8b 55 e4	 mov	 edx, DWORD PTR _i$[ebp]
  0048a	3b 55 f8	 cmp	 edx, DWORD PTR _vRun$[ebp]
  0048d	0f 8d f2 02 00
	00		 jge	 $L58705

; 187  : 		// Find the row data
; 188  : 		uchar* target = dest.Addr(toBuffer.A.x, toBuffer.A.y + i);

  00493	8b 45 0c	 mov	 eax, DWORD PTR _toBuffer$[ebp]
  00496	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00499	03 4d e4	 add	 ecx, DWORD PTR _i$[ebp]
  0049c	51		 push	 ecx
  0049d	8b 55 0c	 mov	 edx, DWORD PTR _toBuffer$[ebp]
  004a0	8b 02		 mov	 eax, DWORD PTR [edx]
  004a2	50		 push	 eax
  004a3	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  004a6	8b 11		 mov	 edx, DWORD PTR [ecx]
  004a8	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  004ab	ff 12		 call	 DWORD PTR [edx]
  004ad	89 45 c0	 mov	 DWORD PTR _target$58706[ebp], eax

; 189  : 		uchar* controlPtr = controlData + controlTable[srcRow];

  004b0	8b 45 e0	 mov	 eax, DWORD PTR _srcRow$[ebp]
  004b3	8b 4d dc	 mov	 ecx, DWORD PTR _controlTable$[ebp]
  004b6	8b 55 f4	 mov	 edx, DWORD PTR _controlData$[ebp]
  004b9	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  004bc	89 55 c8	 mov	 DWORD PTR _controlPtr$58707[ebp], edx

; 190  : 		uchar* colorPtr = colorData + colorTable[srcRow];

  004bf	8b 45 e0	 mov	 eax, DWORD PTR _srcRow$[ebp]
  004c2	8b 4d ec	 mov	 ecx, DWORD PTR _colorTable$[ebp]
  004c5	8b 55 d4	 mov	 edx, DWORD PTR _colorData$[ebp]
  004c8	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  004cb	89 55 c4	 mov	 DWORD PTR _colorPtr$58708[ebp], edx

; 191  : 
; 192  : 		// Draw a line
; 193  : 		for (int j = 0;j <hRun;) {

  004ce	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _j$58709[ebp], 0
$L58711:
  004d5	8b 45 cc	 mov	 eax, DWORD PTR _j$58709[ebp]
  004d8	3b 45 f0	 cmp	 eax, DWORD PTR _hRun$[ebp]
  004db	0f 8d 9f 02 00
	00		 jge	 $L58712

; 194  : 			// Get the control character
; 195  : 			uchar control = *controlPtr++;

  004e1	8b 4d c8	 mov	 ecx, DWORD PTR _controlPtr$58707[ebp]
  004e4	8a 11		 mov	 dl, BYTE PTR [ecx]
  004e6	88 55 bc	 mov	 BYTE PTR _control$58713[ebp], dl
  004e9	8b 45 c8	 mov	 eax, DWORD PTR _controlPtr$58707[ebp]
  004ec	83 c0 01	 add	 eax, 1
  004ef	89 45 c8	 mov	 DWORD PTR _controlPtr$58707[ebp], eax

; 196  : 			if (!(control & REPEATC)) {

  004f2	8b 4d bc	 mov	 ecx, DWORD PTR _control$58713[ebp]
  004f5	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  004fb	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00501	85 c9		 test	 ecx, ecx
  00503	0f 85 fd 00 00
	00		 jne	 $L58714

; 197  : 				// Do a run of unique bytes
; 198  : 				if ((j + control) < srcCol) {

  00509	8b 55 bc	 mov	 edx, DWORD PTR _control$58713[ebp]
  0050c	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00512	8b 45 cc	 mov	 eax, DWORD PTR _j$58709[ebp]
  00515	03 c2		 add	 eax, edx
  00517	3b 45 d8	 cmp	 eax, DWORD PTR _srcCol$[ebp]
  0051a	7d 26		 jge	 SHORT $L58715

; 199  : 					j += control;

  0051c	8b 4d bc	 mov	 ecx, DWORD PTR _control$58713[ebp]
  0051f	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00525	8b 55 cc	 mov	 edx, DWORD PTR _j$58709[ebp]
  00528	03 d1		 add	 edx, ecx
  0052a	89 55 cc	 mov	 DWORD PTR _j$58709[ebp], edx

; 200  : 					colorPtr += control;

  0052d	8b 45 bc	 mov	 eax, DWORD PTR _control$58713[ebp]
  00530	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00535	8b 4d c4	 mov	 ecx, DWORD PTR _colorPtr$58708[ebp]
  00538	03 c8		 add	 ecx, eax
  0053a	89 4d c4	 mov	 DWORD PTR _colorPtr$58708[ebp], ecx

; 202  : 				else {

  0053d	e9 bf 00 00 00	 jmp	 $L58722
$L58715:

; 203  : 					if (j < srcCol) {

  00542	8b 55 cc	 mov	 edx, DWORD PTR _j$58709[ebp]
  00545	3b 55 d8	 cmp	 edx, DWORD PTR _srcCol$[ebp]
  00548	7d 22		 jge	 SHORT $L58717

; 204  : 						control -= srcCol - j;

  0054a	8b 45 d8	 mov	 eax, DWORD PTR _srcCol$[ebp]
  0054d	2b 45 cc	 sub	 eax, DWORD PTR _j$58709[ebp]
  00550	8a 4d bc	 mov	 cl, BYTE PTR _control$58713[ebp]
  00553	2a c8		 sub	 cl, al
  00555	88 4d bc	 mov	 BYTE PTR _control$58713[ebp], cl

; 205  : 						colorPtr += srcCol - j;

  00558	8b 55 d8	 mov	 edx, DWORD PTR _srcCol$[ebp]
  0055b	2b 55 cc	 sub	 edx, DWORD PTR _j$58709[ebp]
  0055e	8b 45 c4	 mov	 eax, DWORD PTR _colorPtr$58708[ebp]
  00561	03 c2		 add	 eax, edx
  00563	89 45 c4	 mov	 DWORD PTR _colorPtr$58708[ebp], eax

; 206  : 						j = srcCol;

  00566	8b 4d d8	 mov	 ecx, DWORD PTR _srcCol$[ebp]
  00569	89 4d cc	 mov	 DWORD PTR _j$58709[ebp], ecx
$L58717:

; 208  : 					if (j + control > hRun) {

  0056c	8b 55 bc	 mov	 edx, DWORD PTR _control$58713[ebp]
  0056f	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00575	8b 45 cc	 mov	 eax, DWORD PTR _j$58709[ebp]
  00578	03 c2		 add	 eax, edx
  0057a	3b 45 f0	 cmp	 eax, DWORD PTR _hRun$[ebp]
  0057d	7e 09		 jle	 SHORT $L58718

; 209  : 						control = hRun - j;

  0057f	8b 4d f0	 mov	 ecx, DWORD PTR _hRun$[ebp]
  00582	2b 4d cc	 sub	 ecx, DWORD PTR _j$58709[ebp]
  00585	88 4d bc	 mov	 BYTE PTR _control$58713[ebp], cl
$L58718:

; 211  : 					j += control;

  00588	8b 55 bc	 mov	 edx, DWORD PTR _control$58713[ebp]
  0058b	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00591	8b 45 cc	 mov	 eax, DWORD PTR _j$58709[ebp]
  00594	03 c2		 add	 eax, edx
  00596	89 45 cc	 mov	 DWORD PTR _j$58709[ebp], eax

; 212  : 					for (int k = 0;k<control;++k) {

  00599	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _k$58719[ebp], 0
  005a0	eb 09		 jmp	 SHORT $L58720
$L58721:
  005a2	8b 4d b8	 mov	 ecx, DWORD PTR _k$58719[ebp]
  005a5	83 c1 01	 add	 ecx, 1
  005a8	89 4d b8	 mov	 DWORD PTR _k$58719[ebp], ecx
$L58720:
  005ab	8b 55 bc	 mov	 edx, DWORD PTR _control$58713[ebp]
  005ae	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  005b4	39 55 b8	 cmp	 DWORD PTR _k$58719[ebp], edx
  005b7	7d 48		 jge	 SHORT $L58722

; 213  : 						uchar color = *colorPtr++;

  005b9	8b 45 c4	 mov	 eax, DWORD PTR _colorPtr$58708[ebp]
  005bc	8a 08		 mov	 cl, BYTE PTR [eax]
  005be	88 4d b4	 mov	 BYTE PTR _color$58723[ebp], cl
  005c1	8b 55 c4	 mov	 edx, DWORD PTR _colorPtr$58708[ebp]
  005c4	83 c2 01	 add	 edx, 1
  005c7	89 55 c4	 mov	 DWORD PTR _colorPtr$58708[ebp], edx

; 214  : 						if (color != skip  &&  color < REMAP_START_COLOR)   

  005ca	8b 45 b4	 mov	 eax, DWORD PTR _color$58723[ebp]
  005cd	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  005d2	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  005d5	33 d2		 xor	 edx, edx
  005d7	8a 51 38	 mov	 dl, BYTE PTR [ecx+56]
  005da	3b c2		 cmp	 eax, edx
  005dc	74 18		 je	 SHORT $L58724
  005de	8b 45 b4	 mov	 eax, DWORD PTR _color$58723[ebp]
  005e1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  005e6	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?REMAP_START_COLOR@@3HA ; REMAP_START_COLOR
  005ec	7d 08		 jge	 SHORT $L58724

; 215  : 							*target = color;

  005ee	8b 4d c0	 mov	 ecx, DWORD PTR _target$58706[ebp]
  005f1	8a 55 b4	 mov	 dl, BYTE PTR _color$58723[ebp]
  005f4	88 11		 mov	 BYTE PTR [ecx], dl
$L58724:

; 216  : 						
; 217  : 						target++;

  005f6	8b 45 c0	 mov	 eax, DWORD PTR _target$58706[ebp]
  005f9	83 c0 01	 add	 eax, 1
  005fc	89 45 c0	 mov	 DWORD PTR _target$58706[ebp], eax

; 218  : 					}

  005ff	eb a1		 jmp	 SHORT $L58721
$L58722:

; 221  : 			else {

  00601	e9 75 01 00 00	 jmp	 $L58734
$L58714:

; 222  : 				if (control & REPSKIP) {

  00606	8b 4d bc	 mov	 ecx, DWORD PTR _control$58713[ebp]
  00609	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0060f	83 e1 40	 and	 ecx, 64			; 00000040H
  00612	85 c9		 test	 ecx, ecx
  00614	0f 84 8d 00 00
	00		 je	 $L58726

; 223  : 					// Do a run of repeated skip
; 224  : 					control &= 0x3f;

  0061a	8a 55 bc	 mov	 dl, BYTE PTR _control$58713[ebp]
  0061d	80 e2 3f	 and	 dl, 63			; 0000003fH
  00620	88 55 bc	 mov	 BYTE PTR _control$58713[ebp], dl

; 225  : 					if ((j + (int) control) < srcCol) {

  00623	8b 45 bc	 mov	 eax, DWORD PTR _control$58713[ebp]
  00626	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0062b	8b 4d cc	 mov	 ecx, DWORD PTR _j$58709[ebp]
  0062e	03 c8		 add	 ecx, eax
  00630	3b 4d d8	 cmp	 ecx, DWORD PTR _srcCol$[ebp]
  00633	7d 13		 jge	 SHORT $L58728

; 226  : 						j += control;

  00635	8b 55 bc	 mov	 edx, DWORD PTR _control$58713[ebp]
  00638	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0063e	8b 45 cc	 mov	 eax, DWORD PTR _j$58709[ebp]
  00641	03 c2		 add	 eax, edx
  00643	89 45 cc	 mov	 DWORD PTR _j$58709[ebp], eax

; 228  : 					else {

  00646	eb 5a		 jmp	 SHORT $L58729
$L58728:

; 229  : 						if (j < srcCol) {

  00648	8b 4d cc	 mov	 ecx, DWORD PTR _j$58709[ebp]
  0064b	3b 4d d8	 cmp	 ecx, DWORD PTR _srcCol$[ebp]
  0064e	7d 14		 jge	 SHORT $L58730

; 230  : 							control -= srcCol - j;

  00650	8b 55 d8	 mov	 edx, DWORD PTR _srcCol$[ebp]
  00653	2b 55 cc	 sub	 edx, DWORD PTR _j$58709[ebp]
  00656	8a 45 bc	 mov	 al, BYTE PTR _control$58713[ebp]
  00659	2a c2		 sub	 al, dl
  0065b	88 45 bc	 mov	 BYTE PTR _control$58713[ebp], al

; 231  : 							j = srcCol;

  0065e	8b 4d d8	 mov	 ecx, DWORD PTR _srcCol$[ebp]
  00661	89 4d cc	 mov	 DWORD PTR _j$58709[ebp], ecx
$L58730:

; 233  : 						if (j + control > hRun) {

  00664	8b 55 bc	 mov	 edx, DWORD PTR _control$58713[ebp]
  00667	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0066d	8b 45 cc	 mov	 eax, DWORD PTR _j$58709[ebp]
  00670	03 c2		 add	 eax, edx
  00672	3b 45 f0	 cmp	 eax, DWORD PTR _hRun$[ebp]
  00675	7e 09		 jle	 SHORT $L58731

; 234  : 							control = hRun - j;

  00677	8b 4d f0	 mov	 ecx, DWORD PTR _hRun$[ebp]
  0067a	2b 4d cc	 sub	 ecx, DWORD PTR _j$58709[ebp]
  0067d	88 4d bc	 mov	 BYTE PTR _control$58713[ebp], cl
$L58731:

; 236  : 						j += control;

  00680	8b 55 bc	 mov	 edx, DWORD PTR _control$58713[ebp]
  00683	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00689	8b 45 cc	 mov	 eax, DWORD PTR _j$58709[ebp]
  0068c	03 c2		 add	 eax, edx
  0068e	89 45 cc	 mov	 DWORD PTR _j$58709[ebp], eax

; 237  : 						target += control;

  00691	8b 4d bc	 mov	 ecx, DWORD PTR _control$58713[ebp]
  00694	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0069a	8b 55 c0	 mov	 edx, DWORD PTR _target$58706[ebp]
  0069d	03 d1		 add	 edx, ecx
  0069f	89 55 c0	 mov	 DWORD PTR _target$58706[ebp], edx
$L58729:

; 240  : 				else {

  006a2	e9 d4 00 00 00	 jmp	 $L58734
$L58726:

; 241  : 					// Do a run of repeated color
; 242  : 					control &= 0x3f;

  006a7	8a 45 bc	 mov	 al, BYTE PTR _control$58713[ebp]
  006aa	24 3f		 and	 al, 63			; 0000003fH
  006ac	88 45 bc	 mov	 BYTE PTR _control$58713[ebp], al

; 243  : 					if ((j + control) < srcCol) {

  006af	8b 4d bc	 mov	 ecx, DWORD PTR _control$58713[ebp]
  006b2	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  006b8	8b 55 cc	 mov	 edx, DWORD PTR _j$58709[ebp]
  006bb	03 d1		 add	 edx, ecx
  006bd	3b 55 d8	 cmp	 edx, DWORD PTR _srcCol$[ebp]
  006c0	7d 1e		 jge	 SHORT $L58733

; 244  : 						j += control;

  006c2	8b 45 bc	 mov	 eax, DWORD PTR _control$58713[ebp]
  006c5	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006ca	8b 4d cc	 mov	 ecx, DWORD PTR _j$58709[ebp]
  006cd	03 c8		 add	 ecx, eax
  006cf	89 4d cc	 mov	 DWORD PTR _j$58709[ebp], ecx

; 245  : 						colorPtr++;

  006d2	8b 55 c4	 mov	 edx, DWORD PTR _colorPtr$58708[ebp]
  006d5	83 c2 01	 add	 edx, 1
  006d8	89 55 c4	 mov	 DWORD PTR _colorPtr$58708[ebp], edx

; 247  : 					else {

  006db	e9 9b 00 00 00	 jmp	 $L58734
$L58733:

; 248  : 						if (j < srcCol) {

  006e0	8b 45 cc	 mov	 eax, DWORD PTR _j$58709[ebp]
  006e3	3b 45 d8	 cmp	 eax, DWORD PTR _srcCol$[ebp]
  006e6	7d 14		 jge	 SHORT $L58735

; 249  : 							control -= srcCol - j;

  006e8	8b 4d d8	 mov	 ecx, DWORD PTR _srcCol$[ebp]
  006eb	2b 4d cc	 sub	 ecx, DWORD PTR _j$58709[ebp]
  006ee	8a 55 bc	 mov	 dl, BYTE PTR _control$58713[ebp]
  006f1	2a d1		 sub	 dl, cl
  006f3	88 55 bc	 mov	 BYTE PTR _control$58713[ebp], dl

; 250  : 							j = srcCol;

  006f6	8b 45 d8	 mov	 eax, DWORD PTR _srcCol$[ebp]
  006f9	89 45 cc	 mov	 DWORD PTR _j$58709[ebp], eax
$L58735:

; 252  : 						if (j + control > hRun) {

  006fc	8b 4d bc	 mov	 ecx, DWORD PTR _control$58713[ebp]
  006ff	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00705	8b 55 cc	 mov	 edx, DWORD PTR _j$58709[ebp]
  00708	03 d1		 add	 edx, ecx
  0070a	3b 55 f0	 cmp	 edx, DWORD PTR _hRun$[ebp]
  0070d	7e 09		 jle	 SHORT $L58736

; 253  : 							control = hRun - j;

  0070f	8b 45 f0	 mov	 eax, DWORD PTR _hRun$[ebp]
  00712	2b 45 cc	 sub	 eax, DWORD PTR _j$58709[ebp]
  00715	88 45 bc	 mov	 BYTE PTR _control$58713[ebp], al
$L58736:

; 255  : 
; 256  :                   uchar color = *colorPtr++;

  00718	8b 4d c4	 mov	 ecx, DWORD PTR _colorPtr$58708[ebp]
  0071b	8a 11		 mov	 dl, BYTE PTR [ecx]
  0071d	88 55 b0	 mov	 BYTE PTR _color$58737[ebp], dl
  00720	8b 45 c4	 mov	 eax, DWORD PTR _colorPtr$58708[ebp]
  00723	83 c0 01	 add	 eax, 1
  00726	89 45 c4	 mov	 DWORD PTR _colorPtr$58708[ebp], eax

; 257  : 						if (color < REMAP_START_COLOR)  

  00729	8b 4d b0	 mov	 ecx, DWORD PTR _color$58737[ebp]
  0072c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00732	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?REMAP_START_COLOR@@3HA ; REMAP_START_COLOR
  00738	7d 1f		 jge	 SHORT $L58738

; 258  : 							memset(target,color,control);

  0073a	8b 55 bc	 mov	 edx, DWORD PTR _control$58713[ebp]
  0073d	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00743	52		 push	 edx
  00744	8b 45 b0	 mov	 eax, DWORD PTR _color$58737[ebp]
  00747	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0074c	50		 push	 eax
  0074d	8b 4d c0	 mov	 ecx, DWORD PTR _target$58706[ebp]
  00750	51		 push	 ecx
  00751	e8 00 00 00 00	 call	 _memset
  00756	83 c4 0c	 add	 esp, 12			; 0000000cH
$L58738:

; 259  : 						 
; 260  : 						j += control;

  00759	8b 55 bc	 mov	 edx, DWORD PTR _control$58713[ebp]
  0075c	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00762	8b 45 cc	 mov	 eax, DWORD PTR _j$58709[ebp]
  00765	03 c2		 add	 eax, edx
  00767	89 45 cc	 mov	 DWORD PTR _j$58709[ebp], eax

; 261  : 						target += control;

  0076a	8b 4d bc	 mov	 ecx, DWORD PTR _control$58713[ebp]
  0076d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00773	8b 55 c0	 mov	 edx, DWORD PTR _target$58706[ebp]
  00776	03 d1		 add	 edx, ecx
  00778	89 55 c0	 mov	 DWORD PTR _target$58706[ebp], edx
$L58734:

; 265  : 		}

  0077b	e9 55 fd ff ff	 jmp	 $L58711
$L58712:

; 266  : 	}

  00780	e9 f0 fc ff ff	 jmp	 $L58704
$L58705:

; 267  : }

  00785	8b e5		 mov	 esp, ebp
  00787	5d		 pop	 ebp
  00788	c2 10 00	 ret	 16			; 00000010H
?DrawNoFlip@CelObj@@QAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@@Z ENDP ; CelObj::DrawNoFlip
_TEXT	ENDS
PUBLIC	?DrawUncompNoFlip@CelObj@@QAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@@Z ; CelObj::DrawUncompNoFlip
PUBLIC	?XDim@Buffer@@QBEHXZ				; Buffer::XDim
_TEXT	SEGMENT
_dest$ = 8
_toBuffer$ = 12
_ul$ = 16
_this$ = -56
_hRun$ = -8
_vRun$ = -4
_xSize$ = -16
_resBuffer$ = -36
_celPtr$ = -12
_colorData$ = -32
_srcCol$ = -28
_srcRow$ = -24
_y$ = -20
_target$58760 = -48
_src$58761 = -44
_x$58762 = -40
_color$58766 = -52
?DrawUncompNoFlip@CelObj@@QAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@@Z PROC NEAR ; CelObj::DrawUncompNoFlip

; 271  : {

  0078b	55		 push	 ebp
  0078c	8b ec		 mov	 ebp, esp
  0078e	83 ec 38	 sub	 esp, 56			; 00000038H
  00791	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx

; 272  : 	assert(dest.Assert());
; 273  : 	assert(toBuffer.IsWithin(dest.XDim(), dest.YDim()));
; 274  : 
; 275  : 	// ***********************************************************************
; 276  : 	// Non scaled drawing.
; 277  : 	// ***********************************************************************
; 278  : 
; 279  : 	int hRun = toBuffer.Xlen();

  00794	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  00797	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  0079c	89 45 f8	 mov	 DWORD PTR _hRun$[ebp], eax

; 280  : 	int vRun = toBuffer.Ylen();

  0079f	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  007a2	e8 00 00 00 00	 call	 ?Ylen@SOL_Rect@@QBEHXZ	; SOL_Rect::Ylen
  007a7	89 45 fc	 mov	 DWORD PTR _vRun$[ebp], eax

; 281  : 	int xSize = dest.XDim();

  007aa	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  007ad	e8 00 00 00 00	 call	 ?XDim@Buffer@@QBEHXZ	; Buffer::XDim
  007b2	89 45 f0	 mov	 DWORD PTR _xSize$[ebp], eax

; 282  : 
; 283  : 	uchar* resBuffer = ResPointer();

  007b5	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  007b8	8b 10		 mov	 edx, DWORD PTR [eax]
  007ba	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  007bd	ff 52 14	 call	 DWORD PTR [edx+20]
  007c0	89 45 dc	 mov	 DWORD PTR _resBuffer$[ebp], eax

; 284  : 	CelHeader* celPtr = (CelHeader*) (resBuffer + celOffset);

  007c3	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  007c6	8b 4d dc	 mov	 ecx, DWORD PTR _resBuffer$[ebp]
  007c9	03 48 18	 add	 ecx, DWORD PTR [eax+24]
  007cc	89 4d f4	 mov	 DWORD PTR _celPtr$[ebp], ecx

; 285  : 	uchar* colorData = resBuffer + celPtr->controlOffset;	//  Correct !

  007cf	8b 55 f4	 mov	 edx, DWORD PTR _celPtr$[ebp]
  007d2	8b 45 dc	 mov	 eax, DWORD PTR _resBuffer$[ebp]
  007d5	03 42 18	 add	 eax, DWORD PTR [edx+24]
  007d8	89 45 e0	 mov	 DWORD PTR _colorData$[ebp], eax

; 286  : 	int srcCol = toBuffer.A.x - ul.x;

  007db	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  007de	8b 11		 mov	 edx, DWORD PTR [ecx]
  007e0	2b 55 10	 sub	 edx, DWORD PTR _ul$[ebp]
  007e3	89 55 e4	 mov	 DWORD PTR _srcCol$[ebp], edx

; 287  : 	int srcRow = toBuffer.A.y - ul.y;

  007e6	8b 45 0c	 mov	 eax, DWORD PTR _toBuffer$[ebp]
  007e9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  007ec	2b 4d 14	 sub	 ecx, DWORD PTR _ul$[ebp+4]
  007ef	89 4d e8	 mov	 DWORD PTR _srcRow$[ebp], ecx

; 288  : 	colorData += (srcRow * width) + srcCol;

  007f2	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  007f5	8b 45 e8	 mov	 eax, DWORD PTR _srcRow$[ebp]
  007f8	0f af 42 20	 imul	 eax, DWORD PTR [edx+32]
  007fc	03 45 e4	 add	 eax, DWORD PTR _srcCol$[ebp]
  007ff	8b 4d e0	 mov	 ecx, DWORD PTR _colorData$[ebp]
  00802	03 c8		 add	 ecx, eax
  00804	89 4d e0	 mov	 DWORD PTR _colorData$[ebp], ecx

; 289  : 
; 290  : 
; 291  : 	// Draw the inset rectangle
; 292  : 	for (int y = 0; y < vRun; y++)

  00807	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  0080e	eb 09		 jmp	 SHORT $L58757
$L58758:
  00810	8b 55 ec	 mov	 edx, DWORD PTR _y$[ebp]
  00813	83 c2 01	 add	 edx, 1
  00816	89 55 ec	 mov	 DWORD PTR _y$[ebp], edx
$L58757:
  00819	8b 45 ec	 mov	 eax, DWORD PTR _y$[ebp]
  0081c	3b 45 fc	 cmp	 eax, DWORD PTR _vRun$[ebp]
  0081f	0f 8d 98 00 00
	00		 jge	 $L58759

; 294  : 		uchar* target = dest.Addr(toBuffer.A.x, toBuffer.A.y + y);

  00825	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  00828	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0082b	03 55 ec	 add	 edx, DWORD PTR _y$[ebp]
  0082e	52		 push	 edx
  0082f	8b 45 0c	 mov	 eax, DWORD PTR _toBuffer$[ebp]
  00832	8b 08		 mov	 ecx, DWORD PTR [eax]
  00834	51		 push	 ecx
  00835	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  00838	8b 02		 mov	 eax, DWORD PTR [edx]
  0083a	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  0083d	ff 10		 call	 DWORD PTR [eax]
  0083f	89 45 d0	 mov	 DWORD PTR _target$58760[ebp], eax

; 295  : 		uchar* src = colorData;

  00842	8b 4d e0	 mov	 ecx, DWORD PTR _colorData$[ebp]
  00845	89 4d d4	 mov	 DWORD PTR _src$58761[ebp], ecx

; 296  : 
; 297  : 		for (int x = 0; x < hRun; x++)

  00848	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _x$58762[ebp], 0
  0084f	eb 09		 jmp	 SHORT $L58763
$L58764:
  00851	8b 55 d8	 mov	 edx, DWORD PTR _x$58762[ebp]
  00854	83 c2 01	 add	 edx, 1
  00857	89 55 d8	 mov	 DWORD PTR _x$58762[ebp], edx
$L58763:
  0085a	8b 45 d8	 mov	 eax, DWORD PTR _x$58762[ebp]
  0085d	3b 45 f8	 cmp	 eax, DWORD PTR _hRun$[ebp]
  00860	7d 4a		 jge	 SHORT $L58765

; 299  : 			uchar color = *src++;

  00862	8b 4d d4	 mov	 ecx, DWORD PTR _src$58761[ebp]
  00865	8a 11		 mov	 dl, BYTE PTR [ecx]
  00867	88 55 cc	 mov	 BYTE PTR _color$58766[ebp], dl
  0086a	8b 45 d4	 mov	 eax, DWORD PTR _src$58761[ebp]
  0086d	83 c0 01	 add	 eax, 1
  00870	89 45 d4	 mov	 DWORD PTR _src$58761[ebp], eax

; 300  : 			if (color != skip  &&  color < REMAP_START_COLOR)

  00873	8b 4d cc	 mov	 ecx, DWORD PTR _color$58766[ebp]
  00876	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0087c	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  0087f	33 c0		 xor	 eax, eax
  00881	8a 42 38	 mov	 al, BYTE PTR [edx+56]
  00884	3b c8		 cmp	 ecx, eax
  00886	74 19		 je	 SHORT $L58767
  00888	8b 4d cc	 mov	 ecx, DWORD PTR _color$58766[ebp]
  0088b	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00891	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?REMAP_START_COLOR@@3HA ; REMAP_START_COLOR
  00897	7d 08		 jge	 SHORT $L58767

; 301  : 				*target = color;

  00899	8b 55 d0	 mov	 edx, DWORD PTR _target$58760[ebp]
  0089c	8a 45 cc	 mov	 al, BYTE PTR _color$58766[ebp]
  0089f	88 02		 mov	 BYTE PTR [edx], al
$L58767:

; 302  : 			target++;

  008a1	8b 4d d0	 mov	 ecx, DWORD PTR _target$58760[ebp]
  008a4	83 c1 01	 add	 ecx, 1
  008a7	89 4d d0	 mov	 DWORD PTR _target$58760[ebp], ecx

; 303  : 		}

  008aa	eb a5		 jmp	 SHORT $L58764
$L58765:

; 304  : 		colorData += width;

  008ac	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  008af	8b 45 e0	 mov	 eax, DWORD PTR _colorData$[ebp]
  008b2	03 42 20	 add	 eax, DWORD PTR [edx+32]
  008b5	89 45 e0	 mov	 DWORD PTR _colorData$[ebp], eax

; 305  : 	}

  008b8	e9 53 ff ff ff	 jmp	 $L58758
$L58759:

; 306  : }

  008bd	8b e5		 mov	 esp, ebp
  008bf	5d		 pop	 ebp
  008c0	c2 10 00	 ret	 16			; 00000010H
?DrawUncompNoFlip@CelObj@@QAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@@Z ENDP ; CelObj::DrawUncompNoFlip
_TEXT	ENDS
PUBLIC	?DrawUncompHzFlip@CelObj@@QAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@@Z ; CelObj::DrawUncompHzFlip
_TEXT	SEGMENT
_dest$ = 8
_toBuffer$ = 12
_ul$ = 16
_this$ = -56
_resBuffer$ = -36
_celPtr$ = -12
_hRun$ = -8
_vRun$ = -4
_xSize$ = -16
_colorData$ = -32
_srcCol$ = -28
_srcRow$ = -24
_y$ = -20
_target$58789 = -48
_src$58790 = -44
_x$58791 = -40
_color$58795 = -52
?DrawUncompHzFlip@CelObj@@QAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@@Z PROC NEAR ; CelObj::DrawUncompHzFlip

; 311  : {

  008c3	55		 push	 ebp
  008c4	8b ec		 mov	 ebp, esp
  008c6	83 ec 38	 sub	 esp, 56			; 00000038H
  008c9	56		 push	 esi
  008ca	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx

; 312  : 	assert(dest.Assert());
; 313  : 	assert(toBuffer.IsWithin(dest.XDim(), dest.YDim()));
; 314  : 
; 315  : 	// ***********************************************************************
; 316  : 	// Non scaled drawing mirrored.
; 317  : 	// ***********************************************************************
; 318  : 
; 319  : 	uchar* resBuffer = ResPointer();

  008cd	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  008d0	8b 10		 mov	 edx, DWORD PTR [eax]
  008d2	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  008d5	ff 52 14	 call	 DWORD PTR [edx+20]
  008d8	89 45 dc	 mov	 DWORD PTR _resBuffer$[ebp], eax

; 320  : 	CelHeader* celPtr = (CelHeader*) (resBuffer + celOffset);

  008db	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  008de	8b 4d dc	 mov	 ecx, DWORD PTR _resBuffer$[ebp]
  008e1	03 48 18	 add	 ecx, DWORD PTR [eax+24]
  008e4	89 4d f4	 mov	 DWORD PTR _celPtr$[ebp], ecx

; 321  : 
; 322  : 	int hRun = toBuffer.Xlen();

  008e7	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  008ea	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  008ef	89 45 f8	 mov	 DWORD PTR _hRun$[ebp], eax

; 323  : 	int vRun = toBuffer.Ylen();

  008f2	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  008f5	e8 00 00 00 00	 call	 ?Ylen@SOL_Rect@@QBEHXZ	; SOL_Rect::Ylen
  008fa	89 45 fc	 mov	 DWORD PTR _vRun$[ebp], eax

; 324  : 	int xSize = dest.XDim();

  008fd	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00900	e8 00 00 00 00	 call	 ?XDim@Buffer@@QBEHXZ	; Buffer::XDim
  00905	89 45 f0	 mov	 DWORD PTR _xSize$[ebp], eax

; 325  : 
; 326  : 	uchar* colorData = resBuffer + celPtr->controlOffset;	//  Correct !

  00908	8b 55 f4	 mov	 edx, DWORD PTR _celPtr$[ebp]
  0090b	8b 45 dc	 mov	 eax, DWORD PTR _resBuffer$[ebp]
  0090e	03 42 18	 add	 eax, DWORD PTR [edx+24]
  00911	89 45 e0	 mov	 DWORD PTR _colorData$[ebp], eax

; 327  : 	int srcCol = width - (toBuffer.A.x - ul.x + toBuffer.Xlen());

  00914	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  00917	8b 31		 mov	 esi, DWORD PTR [ecx]
  00919	2b 75 10	 sub	 esi, DWORD PTR _ul$[ebp]
  0091c	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  0091f	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  00924	03 f0		 add	 esi, eax
  00926	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  00929	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0092c	2b c6		 sub	 eax, esi
  0092e	89 45 e4	 mov	 DWORD PTR _srcCol$[ebp], eax

; 328  : 	int srcRow = toBuffer.A.y - ul.y;

  00931	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  00934	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00937	2b 55 14	 sub	 edx, DWORD PTR _ul$[ebp+4]
  0093a	89 55 e8	 mov	 DWORD PTR _srcRow$[ebp], edx

; 329  : 	colorData += (srcRow * width) + srcCol;

  0093d	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  00940	8b 4d e8	 mov	 ecx, DWORD PTR _srcRow$[ebp]
  00943	0f af 48 20	 imul	 ecx, DWORD PTR [eax+32]
  00947	03 4d e4	 add	 ecx, DWORD PTR _srcCol$[ebp]
  0094a	8b 55 e0	 mov	 edx, DWORD PTR _colorData$[ebp]
  0094d	03 d1		 add	 edx, ecx
  0094f	89 55 e0	 mov	 DWORD PTR _colorData$[ebp], edx

; 330  : 
; 331  : 
; 332  : 	// Draw the inset rectangle
; 333  : 	for (int y = 0; y < vRun; y++)

  00952	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  00959	eb 09		 jmp	 SHORT $L58786
$L58787:
  0095b	8b 45 ec	 mov	 eax, DWORD PTR _y$[ebp]
  0095e	83 c0 01	 add	 eax, 1
  00961	89 45 ec	 mov	 DWORD PTR _y$[ebp], eax
$L58786:
  00964	8b 4d ec	 mov	 ecx, DWORD PTR _y$[ebp]
  00967	3b 4d fc	 cmp	 ecx, DWORD PTR _vRun$[ebp]
  0096a	0f 8d 9d 00 00
	00		 jge	 $L58788

; 335  : 		uchar* target = dest.Addr(toBuffer.A.x, toBuffer.A.y + y) + hRun - 1;

  00970	8b 55 0c	 mov	 edx, DWORD PTR _toBuffer$[ebp]
  00973	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00976	03 45 ec	 add	 eax, DWORD PTR _y$[ebp]
  00979	50		 push	 eax
  0097a	8b 4d 0c	 mov	 ecx, DWORD PTR _toBuffer$[ebp]
  0097d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0097f	52		 push	 edx
  00980	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00983	8b 10		 mov	 edx, DWORD PTR [eax]
  00985	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00988	ff 12		 call	 DWORD PTR [edx]
  0098a	8b 4d f8	 mov	 ecx, DWORD PTR _hRun$[ebp]
  0098d	8d 54 08 ff	 lea	 edx, DWORD PTR [eax+ecx-1]
  00991	89 55 d0	 mov	 DWORD PTR _target$58789[ebp], edx

; 336  : 		uchar* src = colorData;

  00994	8b 45 e0	 mov	 eax, DWORD PTR _colorData$[ebp]
  00997	89 45 d4	 mov	 DWORD PTR _src$58790[ebp], eax

; 337  : 
; 338  : 		for (int x = 0; x < hRun; x++)

  0099a	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _x$58791[ebp], 0
  009a1	eb 09		 jmp	 SHORT $L58792
$L58793:
  009a3	8b 4d d8	 mov	 ecx, DWORD PTR _x$58791[ebp]
  009a6	83 c1 01	 add	 ecx, 1
  009a9	89 4d d8	 mov	 DWORD PTR _x$58791[ebp], ecx
$L58792:
  009ac	8b 55 d8	 mov	 edx, DWORD PTR _x$58791[ebp]
  009af	3b 55 f8	 cmp	 edx, DWORD PTR _hRun$[ebp]
  009b2	7d 48		 jge	 SHORT $L58794

; 340  : 			uchar color = *src++;

  009b4	8b 45 d4	 mov	 eax, DWORD PTR _src$58790[ebp]
  009b7	8a 08		 mov	 cl, BYTE PTR [eax]
  009b9	88 4d cc	 mov	 BYTE PTR _color$58795[ebp], cl
  009bc	8b 55 d4	 mov	 edx, DWORD PTR _src$58790[ebp]
  009bf	83 c2 01	 add	 edx, 1
  009c2	89 55 d4	 mov	 DWORD PTR _src$58790[ebp], edx

; 341  : 			if (color != skip  &&  color < REMAP_START_COLOR)

  009c5	8b 45 cc	 mov	 eax, DWORD PTR _color$58795[ebp]
  009c8	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  009cd	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  009d0	33 d2		 xor	 edx, edx
  009d2	8a 51 38	 mov	 dl, BYTE PTR [ecx+56]
  009d5	3b c2		 cmp	 eax, edx
  009d7	74 18		 je	 SHORT $L58796
  009d9	8b 45 cc	 mov	 eax, DWORD PTR _color$58795[ebp]
  009dc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  009e1	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?REMAP_START_COLOR@@3HA ; REMAP_START_COLOR
  009e7	7d 08		 jge	 SHORT $L58796

; 342  : 				*target = color;

  009e9	8b 4d d0	 mov	 ecx, DWORD PTR _target$58789[ebp]
  009ec	8a 55 cc	 mov	 dl, BYTE PTR _color$58795[ebp]
  009ef	88 11		 mov	 BYTE PTR [ecx], dl
$L58796:

; 343  : 			target--;

  009f1	8b 45 d0	 mov	 eax, DWORD PTR _target$58789[ebp]
  009f4	83 e8 01	 sub	 eax, 1
  009f7	89 45 d0	 mov	 DWORD PTR _target$58789[ebp], eax

; 344  : 		}

  009fa	eb a7		 jmp	 SHORT $L58793
$L58794:

; 345  : 		colorData += width;

  009fc	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  009ff	8b 55 e0	 mov	 edx, DWORD PTR _colorData$[ebp]
  00a02	03 51 20	 add	 edx, DWORD PTR [ecx+32]
  00a05	89 55 e0	 mov	 DWORD PTR _colorData$[ebp], edx

; 346  : 	}

  00a08	e9 4e ff ff ff	 jmp	 $L58787
$L58788:

; 347  : }

  00a0d	5e		 pop	 esi
  00a0e	8b e5		 mov	 esp, ebp
  00a10	5d		 pop	 ebp
  00a11	c2 10 00	 ret	 16			; 00000010H
?DrawUncompHzFlip@CelObj@@QAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@@Z ENDP ; CelObj::DrawUncompHzFlip
_TEXT	ENDS
PUBLIC	?ScaleDraw@CelObj@@QAEXABVBuffer@@ABVRatio@@1ABVSOL_Rect@@ABVSOL_Point@@@Z ; CelObj::ScaleDraw
EXTRN	_memcpy:NEAR
EXTRN	?ScaleTables@CelObj@@QAEXABVRatio@@0@Z:NEAR	; CelObj::ScaleTables
EXTRN	?scaleX1@CelObj@@2PAHA:BYTE			; CelObj::scaleX1
EXTRN	?scaleY1@CelObj@@2PAHA:BYTE			; CelObj::scaleY1
EXTRN	?line@CelObj@@2PAEA:BYTE			; CelObj::line
EXTRN	?scaleX@CelObj@@2PAHA:DWORD			; CelObj::scaleX
EXTRN	?scaleY@CelObj@@2PAHA:DWORD			; CelObj::scaleY
_TEXT	SEGMENT
_dest$ = 8
_ratioX$ = 12
_ratioY$ = 16
_drawRect$ = 20
_pt$ = 24
_this$ = -108
_x1$ = -32
_y1$ = -52
_x2$ = -40
_y2$ = -56
_celX1$ = -4
_celY1$ = -16
_y$ = -36
_hBuild$ = -12
_maxx$58822 = -68
_x$58823 = -64
_x$58830 = -72
_resBuffer$ = -60
_celPtr$ = -24
_controlData$ = -8
_colorData$ = -48
_controlTable$ = -44
_colorTable$ = -20
_lastyi$ = -28
_target$58853 = -80
_controlPtr$58855 = -88
_colorPtr$58856 = -92
_j$58857 = -84
_control$58861 = -96
_color$58866 = -100
_x$58867 = -76
_color$58871 = -104
?ScaleDraw@CelObj@@QAEXABVBuffer@@ABVRatio@@1ABVSOL_Rect@@ABVSOL_Point@@@Z PROC NEAR ; CelObj::ScaleDraw

; 352  : {

  00a14	55		 push	 ebp
  00a15	8b ec		 mov	 ebp, esp
  00a17	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00a1a	89 4d 94	 mov	 DWORD PTR _this$[ebp], ecx

; 353  : 	assert(dest.Assert());
; 354  : 	assert(drawRect.IsWithin(dest.XDim(), dest.YDim()));
; 355  : 	assert(ratioX.Assert());
; 356  : 	assert(ratioY.Assert());
; 357  : 
; 358  : 	// Calculate the scaling tables
; 359  : 	ScaleTables(ratioX, ratioY);

  00a1d	8b 45 10	 mov	 eax, DWORD PTR _ratioY$[ebp]
  00a20	50		 push	 eax
  00a21	8b 4d 0c	 mov	 ecx, DWORD PTR _ratioX$[ebp]
  00a24	51		 push	 ecx
  00a25	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00a28	e8 00 00 00 00	 call	 ?ScaleTables@CelObj@@QAEXABVRatio@@0@Z ; CelObj::ScaleTables

; 360  : 
; 361  : 	// Get a pointer to the drawing area(a static buffer).
; 362  : 	int x1 = drawRect.A.x;

  00a2d	8b 55 14	 mov	 edx, DWORD PTR _drawRect$[ebp]
  00a30	8b 02		 mov	 eax, DWORD PTR [edx]
  00a32	89 45 e0	 mov	 DWORD PTR _x1$[ebp], eax

; 363  : 	int y1 = drawRect.A.y;

  00a35	8b 4d 14	 mov	 ecx, DWORD PTR _drawRect$[ebp]
  00a38	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00a3b	89 55 cc	 mov	 DWORD PTR _y1$[ebp], edx

; 364  : 	int x2 = drawRect.B.x;

  00a3e	8b 45 14	 mov	 eax, DWORD PTR _drawRect$[ebp]
  00a41	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00a44	89 4d d8	 mov	 DWORD PTR _x2$[ebp], ecx

; 365  : 	int y2 = drawRect.B.y;

  00a47	8b 55 14	 mov	 edx, DWORD PTR _drawRect$[ebp]
  00a4a	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00a4d	89 45 c8	 mov	 DWORD PTR _y2$[ebp], eax

; 366  : 	int celX1 = pt.x;

  00a50	8b 4d 18	 mov	 ecx, DWORD PTR _pt$[ebp]
  00a53	8b 11		 mov	 edx, DWORD PTR [ecx]
  00a55	89 55 fc	 mov	 DWORD PTR _celX1$[ebp], edx

; 367  : 	int celY1 = pt.y;

  00a58	8b 45 18	 mov	 eax, DWORD PTR _pt$[ebp]
  00a5b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00a5e	89 4d f0	 mov	 DWORD PTR _celY1$[ebp], ecx

; 368  : 	int y;
; 369  : 
; 370  : 	assert(x1 <= x2);
; 371  : 	assert(y1 <= y2);
; 372  : 	assert(celX1 <= x1);
; 373  : 	assert(celY1 <= y1);
; 374  : 
; 375  : 	int hBuild;
; 376  : 	if (horzFlip)

  00a61	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  00a64	83 7a 4c 00	 cmp	 DWORD PTR [edx+76], 0
  00a68	74 51		 je	 SHORT $L58821

; 378  : 		int maxx = width - 1;

  00a6a	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  00a6d	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00a70	83 e9 01	 sub	 ecx, 1
  00a73	89 4d bc	 mov	 DWORD PTR _maxx$58822[ebp], ecx

; 379  : 		for (int x = x1; x <= x2; x++)

  00a76	8b 55 e0	 mov	 edx, DWORD PTR _x1$[ebp]
  00a79	89 55 c0	 mov	 DWORD PTR _x$58823[ebp], edx
  00a7c	eb 09		 jmp	 SHORT $L58824
$L58825:
  00a7e	8b 45 c0	 mov	 eax, DWORD PTR _x$58823[ebp]
  00a81	83 c0 01	 add	 eax, 1
  00a84	89 45 c0	 mov	 DWORD PTR _x$58823[ebp], eax
$L58824:
  00a87	8b 4d c0	 mov	 ecx, DWORD PTR _x$58823[ebp]
  00a8a	3b 4d d8	 cmp	 ecx, DWORD PTR _x2$[ebp]
  00a8d	7f 1d		 jg	 SHORT $L58826

; 381  : 			scaleX1[x] = maxx - (scaleX[x - celX1]);

  00a8f	8b 55 c0	 mov	 edx, DWORD PTR _x$58823[ebp]
  00a92	2b 55 fc	 sub	 edx, DWORD PTR _celX1$[ebp]
  00a95	a1 00 00 00 00	 mov	 eax, DWORD PTR ?scaleX@CelObj@@2PAHA ; CelObj::scaleX
  00a9a	8b 4d bc	 mov	 ecx, DWORD PTR _maxx$58822[ebp]
  00a9d	2b 0c 90	 sub	 ecx, DWORD PTR [eax+edx*4]
  00aa0	8b 55 c0	 mov	 edx, DWORD PTR _x$58823[ebp]
  00aa3	89 0c 95 00 00
	00 00		 mov	 DWORD PTR ?scaleX1@CelObj@@2PAHA[edx*4], ecx

; 382  : 			assert(scaleX1[x] >= 0);
; 383  : 			assert(scaleX1[x] < width);
; 384  : 		}

  00aaa	eb d2		 jmp	 SHORT $L58825
$L58826:

; 385  : 
; 386  : 		hBuild = scaleX1[x1];

  00aac	8b 45 e0	 mov	 eax, DWORD PTR _x1$[ebp]
  00aaf	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?scaleX1@CelObj@@2PAHA[eax*4]
  00ab6	89 4d f4	 mov	 DWORD PTR _hBuild$[ebp], ecx

; 388  : 	else

  00ab9	eb 41		 jmp	 SHORT $L58829
$L58821:

; 390  : 		for (int x = x1; x <= x2; x++)

  00abb	8b 55 e0	 mov	 edx, DWORD PTR _x1$[ebp]
  00abe	89 55 b8	 mov	 DWORD PTR _x$58830[ebp], edx
  00ac1	eb 09		 jmp	 SHORT $L58831
$L58832:
  00ac3	8b 45 b8	 mov	 eax, DWORD PTR _x$58830[ebp]
  00ac6	83 c0 01	 add	 eax, 1
  00ac9	89 45 b8	 mov	 DWORD PTR _x$58830[ebp], eax
$L58831:
  00acc	8b 4d b8	 mov	 ecx, DWORD PTR _x$58830[ebp]
  00acf	3b 4d d8	 cmp	 ecx, DWORD PTR _x2$[ebp]
  00ad2	7f 1b		 jg	 SHORT $L58833

; 392  : 			scaleX1[x] = scaleX[x - celX1];

  00ad4	8b 55 b8	 mov	 edx, DWORD PTR _x$58830[ebp]
  00ad7	2b 55 fc	 sub	 edx, DWORD PTR _celX1$[ebp]
  00ada	8b 45 b8	 mov	 eax, DWORD PTR _x$58830[ebp]
  00add	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?scaleX@CelObj@@2PAHA ; CelObj::scaleX
  00ae3	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  00ae6	89 14 85 00 00
	00 00		 mov	 DWORD PTR ?scaleX1@CelObj@@2PAHA[eax*4], edx

; 393  : 			assert(scaleX1[x] >= 0);
; 394  : 			assert(scaleX1[x] < width);
; 395  : 		}

  00aed	eb d4		 jmp	 SHORT $L58832
$L58833:

; 396  : 
; 397  : 		hBuild = scaleX1[x2];

  00aef	8b 45 d8	 mov	 eax, DWORD PTR _x2$[ebp]
  00af2	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?scaleX1@CelObj@@2PAHA[eax*4]
  00af9	89 4d f4	 mov	 DWORD PTR _hBuild$[ebp], ecx
$L58829:

; 399  : 
; 400  : 	hBuild++;

  00afc	8b 55 f4	 mov	 edx, DWORD PTR _hBuild$[ebp]
  00aff	83 c2 01	 add	 edx, 1
  00b02	89 55 f4	 mov	 DWORD PTR _hBuild$[ebp], edx

; 401  : 	for (y = y1; y <= y2; y++)

  00b05	8b 45 cc	 mov	 eax, DWORD PTR _y1$[ebp]
  00b08	89 45 dc	 mov	 DWORD PTR _y$[ebp], eax
  00b0b	eb 09		 jmp	 SHORT $L58836
$L58837:
  00b0d	8b 4d dc	 mov	 ecx, DWORD PTR _y$[ebp]
  00b10	83 c1 01	 add	 ecx, 1
  00b13	89 4d dc	 mov	 DWORD PTR _y$[ebp], ecx
$L58836:
  00b16	8b 55 dc	 mov	 edx, DWORD PTR _y$[ebp]
  00b19	3b 55 c8	 cmp	 edx, DWORD PTR _y2$[ebp]
  00b1c	7f 1b		 jg	 SHORT $L58838

; 403  : 		scaleY1[y] = scaleY[y - celY1];

  00b1e	8b 45 dc	 mov	 eax, DWORD PTR _y$[ebp]
  00b21	2b 45 f0	 sub	 eax, DWORD PTR _celY1$[ebp]
  00b24	8b 4d dc	 mov	 ecx, DWORD PTR _y$[ebp]
  00b27	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?scaleY@CelObj@@2PAHA ; CelObj::scaleY
  00b2d	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  00b30	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?scaleY1@CelObj@@2PAHA[ecx*4], eax

; 404  : 		assert(scaleY1[y] >= 0);
; 405  : 		assert(scaleY1[y] < height);
; 406  : 	}

  00b37	eb d4		 jmp	 SHORT $L58837
$L58838:

; 407  : 
; 408  : 	uchar* resBuffer = ResPointer();

  00b39	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00b3c	8b 11		 mov	 edx, DWORD PTR [ecx]
  00b3e	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00b41	ff 52 14	 call	 DWORD PTR [edx+20]
  00b44	89 45 c4	 mov	 DWORD PTR _resBuffer$[ebp], eax

; 409  : 	CelHeader* celPtr = (CelHeader*) (resBuffer + celOffset);

  00b47	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  00b4a	8b 4d c4	 mov	 ecx, DWORD PTR _resBuffer$[ebp]
  00b4d	03 48 18	 add	 ecx, DWORD PTR [eax+24]
  00b50	89 4d e8	 mov	 DWORD PTR _celPtr$[ebp], ecx

; 410  : 	uchar* controlData = resBuffer + celPtr->controlOffset;

  00b53	8b 55 e8	 mov	 edx, DWORD PTR _celPtr$[ebp]
  00b56	8b 45 c4	 mov	 eax, DWORD PTR _resBuffer$[ebp]
  00b59	03 42 18	 add	 eax, DWORD PTR [edx+24]
  00b5c	89 45 f8	 mov	 DWORD PTR _controlData$[ebp], eax

; 411  : 	uchar* colorData = resBuffer + celPtr->colorOffset;

  00b5f	8b 4d e8	 mov	 ecx, DWORD PTR _celPtr$[ebp]
  00b62	8b 55 c4	 mov	 edx, DWORD PTR _resBuffer$[ebp]
  00b65	03 51 1c	 add	 edx, DWORD PTR [ecx+28]
  00b68	89 55 d0	 mov	 DWORD PTR _colorData$[ebp], edx

; 412  : 
; 413  : 	long* controlTable = (long *) (resBuffer + celPtr->rowTableOffset);

  00b6b	8b 45 e8	 mov	 eax, DWORD PTR _celPtr$[ebp]
  00b6e	8b 4d c4	 mov	 ecx, DWORD PTR _resBuffer$[ebp]
  00b71	03 48 20	 add	 ecx, DWORD PTR [eax+32]
  00b74	89 4d d4	 mov	 DWORD PTR _controlTable$[ebp], ecx

; 414  : 	long* colorTable = controlTable + height;

  00b77	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  00b7a	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00b7d	8b 4d d4	 mov	 ecx, DWORD PTR _controlTable$[ebp]
  00b80	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00b83	89 55 ec	 mov	 DWORD PTR _colorTable$[ebp], edx

; 415  : 
; 416  : 	// Draw the inset rectangle
; 417  : 	int lastyi = -1;

  00b86	c7 45 e4 ff ff
	ff ff		 mov	 DWORD PTR _lastyi$[ebp], -1

; 418  : 	for (y = y1; y <= y2; y++)

  00b8d	8b 45 cc	 mov	 eax, DWORD PTR _y1$[ebp]
  00b90	89 45 dc	 mov	 DWORD PTR _y$[ebp], eax
  00b93	eb 09		 jmp	 SHORT $L58850
$L58851:
  00b95	8b 4d dc	 mov	 ecx, DWORD PTR _y$[ebp]
  00b98	83 c1 01	 add	 ecx, 1
  00b9b	89 4d dc	 mov	 DWORD PTR _y$[ebp], ecx
$L58850:
  00b9e	8b 55 dc	 mov	 edx, DWORD PTR _y$[ebp]
  00ba1	3b 55 c8	 cmp	 edx, DWORD PTR _y2$[ebp]
  00ba4	0f 8f dc 01 00
	00		 jg	 $L58852

; 420  : 		uchar* target = dest.Addr(x1, y);

  00baa	8b 45 dc	 mov	 eax, DWORD PTR _y$[ebp]
  00bad	50		 push	 eax
  00bae	8b 4d e0	 mov	 ecx, DWORD PTR _x1$[ebp]
  00bb1	51		 push	 ecx
  00bb2	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  00bb5	8b 02		 mov	 eax, DWORD PTR [edx]
  00bb7	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00bba	ff 10		 call	 DWORD PTR [eax]
  00bbc	89 45 b0	 mov	 DWORD PTR _target$58853[ebp], eax

; 421  : 		if (lastyi != scaleY1[y])

  00bbf	8b 4d dc	 mov	 ecx, DWORD PTR _y$[ebp]
  00bc2	8b 55 e4	 mov	 edx, DWORD PTR _lastyi$[ebp]
  00bc5	3b 14 8d 00 00
	00 00		 cmp	 edx, DWORD PTR ?scaleY1@CelObj@@2PAHA[ecx*4]
  00bcc	0f 84 4a 01 00
	00		 je	 $L58860

; 423  : 			// Find the row data
; 424  : 			lastyi = scaleY1[y];

  00bd2	8b 45 dc	 mov	 eax, DWORD PTR _y$[ebp]
  00bd5	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?scaleY1@CelObj@@2PAHA[eax*4]
  00bdc	89 4d e4	 mov	 DWORD PTR _lastyi$[ebp], ecx

; 425  : 			uchar* controlPtr = controlData + controlTable[lastyi];

  00bdf	8b 55 e4	 mov	 edx, DWORD PTR _lastyi$[ebp]
  00be2	8b 45 d4	 mov	 eax, DWORD PTR _controlTable$[ebp]
  00be5	8b 4d f8	 mov	 ecx, DWORD PTR _controlData$[ebp]
  00be8	03 0c 90	 add	 ecx, DWORD PTR [eax+edx*4]
  00beb	89 4d a8	 mov	 DWORD PTR _controlPtr$58855[ebp], ecx

; 426  : 			uchar* colorPtr = colorData + colorTable[lastyi];

  00bee	8b 55 e4	 mov	 edx, DWORD PTR _lastyi$[ebp]
  00bf1	8b 45 ec	 mov	 eax, DWORD PTR _colorTable$[ebp]
  00bf4	8b 4d d0	 mov	 ecx, DWORD PTR _colorData$[ebp]
  00bf7	03 0c 90	 add	 ecx, DWORD PTR [eax+edx*4]
  00bfa	89 4d a4	 mov	 DWORD PTR _colorPtr$58856[ebp], ecx

; 427  : 
; 428  : 			// Build a line
; 429  : 			for (int j = 0; j < hBuild; )

  00bfd	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _j$58857[ebp], 0
$L58859:
  00c04	8b 55 ac	 mov	 edx, DWORD PTR _j$58857[ebp]
  00c07	3b 55 f4	 cmp	 edx, DWORD PTR _hBuild$[ebp]
  00c0a	0f 8d 0c 01 00
	00		 jge	 $L58860

; 431  : 				// Get the control character
; 432  : 				uchar control = *controlPtr++;

  00c10	8b 45 a8	 mov	 eax, DWORD PTR _controlPtr$58855[ebp]
  00c13	8a 08		 mov	 cl, BYTE PTR [eax]
  00c15	88 4d a0	 mov	 BYTE PTR _control$58861[ebp], cl
  00c18	8b 55 a8	 mov	 edx, DWORD PTR _controlPtr$58855[ebp]
  00c1b	83 c2 01	 add	 edx, 1
  00c1e	89 55 a8	 mov	 DWORD PTR _controlPtr$58855[ebp], edx

; 433  : 				if (!(control & REPEATC))

  00c21	8b 45 a0	 mov	 eax, DWORD PTR _control$58861[ebp]
  00c24	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00c29	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00c2e	85 c0		 test	 eax, eax
  00c30	75 45		 jne	 SHORT $L58862

; 435  : 					// Do a run of unique bytes
; 436  : 					memcpy(&line[j], colorPtr, control);

  00c32	8b 4d a0	 mov	 ecx, DWORD PTR _control$58861[ebp]
  00c35	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00c3b	51		 push	 ecx
  00c3c	8b 55 a4	 mov	 edx, DWORD PTR _colorPtr$58856[ebp]
  00c3f	52		 push	 edx
  00c40	8b 45 ac	 mov	 eax, DWORD PTR _j$58857[ebp]
  00c43	05 00 00 00 00	 add	 eax, OFFSET FLAT:?line@CelObj@@2PAEA ; CelObj::line
  00c48	50		 push	 eax
  00c49	e8 00 00 00 00	 call	 _memcpy
  00c4e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 437  : 					colorPtr += control;

  00c51	8b 4d a0	 mov	 ecx, DWORD PTR _control$58861[ebp]
  00c54	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00c5a	8b 55 a4	 mov	 edx, DWORD PTR _colorPtr$58856[ebp]
  00c5d	03 d1		 add	 edx, ecx
  00c5f	89 55 a4	 mov	 DWORD PTR _colorPtr$58856[ebp], edx

; 438  : 					j += control;

  00c62	8b 45 a0	 mov	 eax, DWORD PTR _control$58861[ebp]
  00c65	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00c6a	8b 4d ac	 mov	 ecx, DWORD PTR _j$58857[ebp]
  00c6d	03 c8		 add	 ecx, eax
  00c6f	89 4d ac	 mov	 DWORD PTR _j$58857[ebp], ecx

; 440  : 				else

  00c72	e9 a0 00 00 00	 jmp	 $L58865
$L58862:

; 442  : 					if (control & REPSKIP)

  00c77	8b 55 a0	 mov	 edx, DWORD PTR _control$58861[ebp]
  00c7a	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00c80	83 e2 40	 and	 edx, 64			; 00000040H
  00c83	85 d2		 test	 edx, edx
  00c85	74 40		 je	 SHORT $L58864

; 444  : 						// Do a run of repeated skip
; 445  : 						control &= 0x3f;

  00c87	8a 45 a0	 mov	 al, BYTE PTR _control$58861[ebp]
  00c8a	24 3f		 and	 al, 63			; 0000003fH
  00c8c	88 45 a0	 mov	 BYTE PTR _control$58861[ebp], al

; 446  : 						memset(&line[j],skip,control);

  00c8f	8b 4d a0	 mov	 ecx, DWORD PTR _control$58861[ebp]
  00c92	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00c98	51		 push	 ecx
  00c99	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  00c9c	33 c0		 xor	 eax, eax
  00c9e	8a 42 38	 mov	 al, BYTE PTR [edx+56]
  00ca1	50		 push	 eax
  00ca2	8b 4d ac	 mov	 ecx, DWORD PTR _j$58857[ebp]
  00ca5	81 c1 00 00 00
	00		 add	 ecx, OFFSET FLAT:?line@CelObj@@2PAEA ; CelObj::line
  00cab	51		 push	 ecx
  00cac	e8 00 00 00 00	 call	 _memset
  00cb1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 447  : 						j += control;

  00cb4	8b 55 a0	 mov	 edx, DWORD PTR _control$58861[ebp]
  00cb7	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00cbd	8b 45 ac	 mov	 eax, DWORD PTR _j$58857[ebp]
  00cc0	03 c2		 add	 eax, edx
  00cc2	89 45 ac	 mov	 DWORD PTR _j$58857[ebp], eax

; 449  : 					else

  00cc5	eb 50		 jmp	 SHORT $L58865
$L58864:

; 451  : 						// Do a run of repeated color
; 452  : 						control &= 0x3f;

  00cc7	8a 4d a0	 mov	 cl, BYTE PTR _control$58861[ebp]
  00cca	80 e1 3f	 and	 cl, 63			; 0000003fH
  00ccd	88 4d a0	 mov	 BYTE PTR _control$58861[ebp], cl

; 453  : 						uchar color = *colorPtr++;

  00cd0	8b 55 a4	 mov	 edx, DWORD PTR _colorPtr$58856[ebp]
  00cd3	8a 02		 mov	 al, BYTE PTR [edx]
  00cd5	88 45 9c	 mov	 BYTE PTR _color$58866[ebp], al
  00cd8	8b 4d a4	 mov	 ecx, DWORD PTR _colorPtr$58856[ebp]
  00cdb	83 c1 01	 add	 ecx, 1
  00cde	89 4d a4	 mov	 DWORD PTR _colorPtr$58856[ebp], ecx

; 454  : 						memset(&line[j],color,control);

  00ce1	8b 55 a0	 mov	 edx, DWORD PTR _control$58861[ebp]
  00ce4	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00cea	52		 push	 edx
  00ceb	8b 45 9c	 mov	 eax, DWORD PTR _color$58866[ebp]
  00cee	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00cf3	50		 push	 eax
  00cf4	8b 4d ac	 mov	 ecx, DWORD PTR _j$58857[ebp]
  00cf7	81 c1 00 00 00
	00		 add	 ecx, OFFSET FLAT:?line@CelObj@@2PAEA ; CelObj::line
  00cfd	51		 push	 ecx
  00cfe	e8 00 00 00 00	 call	 _memset
  00d03	83 c4 0c	 add	 esp, 12			; 0000000cH

; 455  : 						j += control;

  00d06	8b 55 a0	 mov	 edx, DWORD PTR _control$58861[ebp]
  00d09	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00d0f	8b 45 ac	 mov	 eax, DWORD PTR _j$58857[ebp]
  00d12	03 c2		 add	 eax, edx
  00d14	89 45 ac	 mov	 DWORD PTR _j$58857[ebp], eax
$L58865:

; 458  : 			}

  00d17	e9 e8 fe ff ff	 jmp	 $L58859
$L58860:

; 460  : 
; 461  : 		// Draw a line
; 462  : 		for (int x = x1; x <= x2; x++)

  00d1c	8b 4d e0	 mov	 ecx, DWORD PTR _x1$[ebp]
  00d1f	89 4d b4	 mov	 DWORD PTR _x$58867[ebp], ecx
  00d22	eb 09		 jmp	 SHORT $L58868
$L58869:
  00d24	8b 55 b4	 mov	 edx, DWORD PTR _x$58867[ebp]
  00d27	83 c2 01	 add	 edx, 1
  00d2a	89 55 b4	 mov	 DWORD PTR _x$58867[ebp], edx
$L58868:
  00d2d	8b 45 b4	 mov	 eax, DWORD PTR _x$58867[ebp]
  00d30	3b 45 d8	 cmp	 eax, DWORD PTR _x2$[ebp]
  00d33	7f 4c		 jg	 SHORT $L58870

; 464  : 			uchar color = line[scaleX1[x]];

  00d35	8b 4d b4	 mov	 ecx, DWORD PTR _x$58867[ebp]
  00d38	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?scaleX1@CelObj@@2PAHA[ecx*4]
  00d3f	8a 82 00 00 00
	00		 mov	 al, BYTE PTR ?line@CelObj@@2PAEA[edx]
  00d45	88 45 98	 mov	 BYTE PTR _color$58871[ebp], al

; 465  : 			if (color != skip  &&  color < REMAP_START_COLOR)

  00d48	8b 4d 98	 mov	 ecx, DWORD PTR _color$58871[ebp]
  00d4b	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00d51	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  00d54	33 c0		 xor	 eax, eax
  00d56	8a 42 38	 mov	 al, BYTE PTR [edx+56]
  00d59	3b c8		 cmp	 ecx, eax
  00d5b	74 19		 je	 SHORT $L58872
  00d5d	8b 4d 98	 mov	 ecx, DWORD PTR _color$58871[ebp]
  00d60	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00d66	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?REMAP_START_COLOR@@3HA ; REMAP_START_COLOR
  00d6c	7d 08		 jge	 SHORT $L58872

; 466  : 				*target = color;

  00d6e	8b 55 b0	 mov	 edx, DWORD PTR _target$58853[ebp]
  00d71	8a 45 98	 mov	 al, BYTE PTR _color$58871[ebp]
  00d74	88 02		 mov	 BYTE PTR [edx], al
$L58872:

; 467  : 			target++;

  00d76	8b 4d b0	 mov	 ecx, DWORD PTR _target$58853[ebp]
  00d79	83 c1 01	 add	 ecx, 1
  00d7c	89 4d b0	 mov	 DWORD PTR _target$58853[ebp], ecx

; 468  : 		}

  00d7f	eb a3		 jmp	 SHORT $L58869
$L58870:

; 469  : 	}

  00d81	e9 0f fe ff ff	 jmp	 $L58851
$L58852:

; 470  : }

  00d86	8b e5		 mov	 esp, ebp
  00d88	5d		 pop	 ebp
  00d89	c2 14 00	 ret	 20			; 00000014H
?ScaleDraw@CelObj@@QAEXABVBuffer@@ABVRatio@@1ABVSOL_Rect@@ABVSOL_Point@@@Z ENDP ; CelObj::ScaleDraw
_TEXT	ENDS
PUBLIC	?ScaleDrawUncomp@CelObj@@QAEXABVBuffer@@ABVRatio@@1ABVSOL_Rect@@ABVSOL_Point@@@Z ; CelObj::ScaleDrawUncomp
_TEXT	SEGMENT
_dest$ = 8
_ratioX$ = 12
_ratioY$ = 16
_drawRect$ = 20
_pt$ = 24
_this$ = -80
_x1$ = -16
_y1$ = -36
_x2$ = -24
_y2$ = -44
_celX1$ = -4
_celY1$ = -8
_y$ = -20
_maxx$58893 = -60
_x$58894 = -56
_x$58899 = -64
_resBuffer$ = -52
_celPtr$ = -12
_colorData$ = -28
_theWidth$ = -32
_nextLine$ = -40
_target$ = -48
_colorPtr$58916 = -72
_x$58917 = -68
_color$58921 = -76
?ScaleDrawUncomp@CelObj@@QAEXABVBuffer@@ABVRatio@@1ABVSOL_Rect@@ABVSOL_Point@@@Z PROC NEAR ; CelObj::ScaleDrawUncomp

; 476  : {

  00d8c	55		 push	 ebp
  00d8d	8b ec		 mov	 ebp, esp
  00d8f	83 ec 50	 sub	 esp, 80			; 00000050H
  00d92	89 4d b0	 mov	 DWORD PTR _this$[ebp], ecx

; 477  : 	assert(dest.Assert());
; 478  : 	assert(drawRect.IsWithin(dest.XDim(), dest.YDim()));
; 479  : 	assert(ratioX.Assert());
; 480  : 	assert(ratioY.Assert());
; 481  : 
; 482  : 	// Calculate the scaling tables
; 483  : 	ScaleTables(ratioX, ratioY);

  00d95	8b 45 10	 mov	 eax, DWORD PTR _ratioY$[ebp]
  00d98	50		 push	 eax
  00d99	8b 4d 0c	 mov	 ecx, DWORD PTR _ratioX$[ebp]
  00d9c	51		 push	 ecx
  00d9d	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00da0	e8 00 00 00 00	 call	 ?ScaleTables@CelObj@@QAEXABVRatio@@0@Z ; CelObj::ScaleTables

; 484  : 
; 485  : 	int x1 = drawRect.A.x;

  00da5	8b 55 14	 mov	 edx, DWORD PTR _drawRect$[ebp]
  00da8	8b 02		 mov	 eax, DWORD PTR [edx]
  00daa	89 45 f0	 mov	 DWORD PTR _x1$[ebp], eax

; 486  : 	int y1 = drawRect.A.y;

  00dad	8b 4d 14	 mov	 ecx, DWORD PTR _drawRect$[ebp]
  00db0	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00db3	89 55 dc	 mov	 DWORD PTR _y1$[ebp], edx

; 487  : 	int x2 = drawRect.B.x;

  00db6	8b 45 14	 mov	 eax, DWORD PTR _drawRect$[ebp]
  00db9	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00dbc	89 4d e8	 mov	 DWORD PTR _x2$[ebp], ecx

; 488  : 	int y2 = drawRect.B.y;

  00dbf	8b 55 14	 mov	 edx, DWORD PTR _drawRect$[ebp]
  00dc2	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00dc5	89 45 d4	 mov	 DWORD PTR _y2$[ebp], eax

; 489  : 	int celX1 = pt.x;

  00dc8	8b 4d 18	 mov	 ecx, DWORD PTR _pt$[ebp]
  00dcb	8b 11		 mov	 edx, DWORD PTR [ecx]
  00dcd	89 55 fc	 mov	 DWORD PTR _celX1$[ebp], edx

; 490  : 	int celY1 = pt.y;

  00dd0	8b 45 18	 mov	 eax, DWORD PTR _pt$[ebp]
  00dd3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00dd6	89 4d f8	 mov	 DWORD PTR _celY1$[ebp], ecx

; 491  : 	int y;
; 492  : 
; 493  : 	if (horzFlip)

  00dd9	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  00ddc	83 7a 4c 00	 cmp	 DWORD PTR [edx+76], 0
  00de0	74 44		 je	 SHORT $L58892

; 495  : 		int maxx = width - 1;

  00de2	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00de5	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00de8	83 e9 01	 sub	 ecx, 1
  00deb	89 4d c4	 mov	 DWORD PTR _maxx$58893[ebp], ecx

; 496  : 		for (int x = x1; x <= x2; x++)

  00dee	8b 55 f0	 mov	 edx, DWORD PTR _x1$[ebp]
  00df1	89 55 c8	 mov	 DWORD PTR _x$58894[ebp], edx
  00df4	eb 09		 jmp	 SHORT $L58895
$L58896:
  00df6	8b 45 c8	 mov	 eax, DWORD PTR _x$58894[ebp]
  00df9	83 c0 01	 add	 eax, 1
  00dfc	89 45 c8	 mov	 DWORD PTR _x$58894[ebp], eax
$L58895:
  00dff	8b 4d c8	 mov	 ecx, DWORD PTR _x$58894[ebp]
  00e02	3b 4d e8	 cmp	 ecx, DWORD PTR _x2$[ebp]
  00e05	7f 1d		 jg	 SHORT $L58897

; 498  : 			scaleX1[x] = maxx - (scaleX[x - celX1]);

  00e07	8b 55 c8	 mov	 edx, DWORD PTR _x$58894[ebp]
  00e0a	2b 55 fc	 sub	 edx, DWORD PTR _celX1$[ebp]
  00e0d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?scaleX@CelObj@@2PAHA ; CelObj::scaleX
  00e12	8b 4d c4	 mov	 ecx, DWORD PTR _maxx$58893[ebp]
  00e15	2b 0c 90	 sub	 ecx, DWORD PTR [eax+edx*4]
  00e18	8b 55 c8	 mov	 edx, DWORD PTR _x$58894[ebp]
  00e1b	89 0c 95 00 00
	00 00		 mov	 DWORD PTR ?scaleX1@CelObj@@2PAHA[edx*4], ecx

; 499  : 		}

  00e22	eb d2		 jmp	 SHORT $L58896
$L58897:

; 501  : 	else

  00e24	eb 34		 jmp	 SHORT $L58902
$L58892:

; 503  : 		for (int x = x1; x <= x2; x++)

  00e26	8b 45 f0	 mov	 eax, DWORD PTR _x1$[ebp]
  00e29	89 45 c0	 mov	 DWORD PTR _x$58899[ebp], eax
  00e2c	eb 09		 jmp	 SHORT $L58900
$L58901:
  00e2e	8b 4d c0	 mov	 ecx, DWORD PTR _x$58899[ebp]
  00e31	83 c1 01	 add	 ecx, 1
  00e34	89 4d c0	 mov	 DWORD PTR _x$58899[ebp], ecx
$L58900:
  00e37	8b 55 c0	 mov	 edx, DWORD PTR _x$58899[ebp]
  00e3a	3b 55 e8	 cmp	 edx, DWORD PTR _x2$[ebp]
  00e3d	7f 1b		 jg	 SHORT $L58902

; 505  : 			scaleX1[x] = scaleX[x - celX1];

  00e3f	8b 45 c0	 mov	 eax, DWORD PTR _x$58899[ebp]
  00e42	2b 45 fc	 sub	 eax, DWORD PTR _celX1$[ebp]
  00e45	8b 4d c0	 mov	 ecx, DWORD PTR _x$58899[ebp]
  00e48	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?scaleX@CelObj@@2PAHA ; CelObj::scaleX
  00e4e	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  00e51	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?scaleX1@CelObj@@2PAHA[ecx*4], eax

; 506  : 		}

  00e58	eb d4		 jmp	 SHORT $L58901
$L58902:

; 508  : 
; 509  : 	for (y = y1; y <= y2; y++)

  00e5a	8b 4d dc	 mov	 ecx, DWORD PTR _y1$[ebp]
  00e5d	89 4d ec	 mov	 DWORD PTR _y$[ebp], ecx
  00e60	eb 09		 jmp	 SHORT $L58903
$L58904:
  00e62	8b 55 ec	 mov	 edx, DWORD PTR _y$[ebp]
  00e65	83 c2 01	 add	 edx, 1
  00e68	89 55 ec	 mov	 DWORD PTR _y$[ebp], edx
$L58903:
  00e6b	8b 45 ec	 mov	 eax, DWORD PTR _y$[ebp]
  00e6e	3b 45 d4	 cmp	 eax, DWORD PTR _y2$[ebp]
  00e71	7f 1a		 jg	 SHORT $L58905

; 511  : 		scaleY1[y] = scaleY[y - celY1];

  00e73	8b 4d ec	 mov	 ecx, DWORD PTR _y$[ebp]
  00e76	2b 4d f8	 sub	 ecx, DWORD PTR _celY1$[ebp]
  00e79	8b 55 ec	 mov	 edx, DWORD PTR _y$[ebp]
  00e7c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?scaleY@CelObj@@2PAHA ; CelObj::scaleY
  00e81	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  00e84	89 0c 95 00 00
	00 00		 mov	 DWORD PTR ?scaleY1@CelObj@@2PAHA[edx*4], ecx

; 512  : 	}

  00e8b	eb d5		 jmp	 SHORT $L58904
$L58905:

; 513  : 
; 514  : 	//  Get a pointer to the cel
; 515  : 	uchar* resBuffer = ResPointer();

  00e8d	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  00e90	8b 02		 mov	 eax, DWORD PTR [edx]
  00e92	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00e95	ff 50 14	 call	 DWORD PTR [eax+20]
  00e98	89 45 cc	 mov	 DWORD PTR _resBuffer$[ebp], eax

; 516  : 	CelHeader* celPtr = (CelHeader*) (resBuffer + celOffset);

  00e9b	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00e9e	8b 55 cc	 mov	 edx, DWORD PTR _resBuffer$[ebp]
  00ea1	03 51 18	 add	 edx, DWORD PTR [ecx+24]
  00ea4	89 55 f4	 mov	 DWORD PTR _celPtr$[ebp], edx

; 517  : 	uchar* colorData = resBuffer + celPtr->controlOffset;

  00ea7	8b 45 f4	 mov	 eax, DWORD PTR _celPtr$[ebp]
  00eaa	8b 4d cc	 mov	 ecx, DWORD PTR _resBuffer$[ebp]
  00ead	03 48 18	 add	 ecx, DWORD PTR [eax+24]
  00eb0	89 4d e4	 mov	 DWORD PTR _colorData$[ebp], ecx

; 518  : 
; 519  : 	int theWidth = x2 - x1 + 1;

  00eb3	8b 55 e8	 mov	 edx, DWORD PTR _x2$[ebp]
  00eb6	2b 55 f0	 sub	 edx, DWORD PTR _x1$[ebp]
  00eb9	83 c2 01	 add	 edx, 1
  00ebc	89 55 e0	 mov	 DWORD PTR _theWidth$[ebp], edx

; 520  : 	int nextLine = -(dest.XDim() + theWidth);

  00ebf	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00ec2	e8 00 00 00 00	 call	 ?XDim@Buffer@@QBEHXZ	; Buffer::XDim
  00ec7	03 45 e0	 add	 eax, DWORD PTR _theWidth$[ebp]
  00eca	f7 d8		 neg	 eax
  00ecc	89 45 d8	 mov	 DWORD PTR _nextLine$[ebp], eax

; 521  : 
; 522  :   	uchar *target = dest.Addr(x1, y1);

  00ecf	8b 45 dc	 mov	 eax, DWORD PTR _y1$[ebp]
  00ed2	50		 push	 eax
  00ed3	8b 4d f0	 mov	 ecx, DWORD PTR _x1$[ebp]
  00ed6	51		 push	 ecx
  00ed7	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  00eda	8b 02		 mov	 eax, DWORD PTR [edx]
  00edc	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00edf	ff 10		 call	 DWORD PTR [eax]
  00ee1	89 45 d0	 mov	 DWORD PTR _target$[ebp], eax

; 523  : 
; 524  : //	maskTable[skip] = 255;
; 525  : 
; 526  : 	//  Draw the inset rectangle
; 527  : 	for (y = y1; y <= y2; y++)

  00ee4	8b 4d dc	 mov	 ecx, DWORD PTR _y1$[ebp]
  00ee7	89 4d ec	 mov	 DWORD PTR _y$[ebp], ecx
  00eea	eb 09		 jmp	 SHORT $L58913
$L58914:
  00eec	8b 55 ec	 mov	 edx, DWORD PTR _y$[ebp]
  00eef	83 c2 01	 add	 edx, 1
  00ef2	89 55 ec	 mov	 DWORD PTR _y$[ebp], edx
$L58913:
  00ef5	8b 45 ec	 mov	 eax, DWORD PTR _y$[ebp]
  00ef8	3b 45 d4	 cmp	 eax, DWORD PTR _y2$[ebp]
  00efb	7f 7a		 jg	 SHORT $L58915

; 529  : 		uchar* colorPtr = colorData + (width * scaleY1[y]);

  00efd	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00f00	8b 55 ec	 mov	 edx, DWORD PTR _y$[ebp]
  00f03	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00f06	0f af 04 95 00
	00 00 00	 imul	 eax, DWORD PTR ?scaleY1@CelObj@@2PAHA[edx*4]
  00f0e	8b 4d e4	 mov	 ecx, DWORD PTR _colorData$[ebp]
  00f11	03 c8		 add	 ecx, eax
  00f13	89 4d b8	 mov	 DWORD PTR _colorPtr$58916[ebp], ecx

; 530  : 
; 531  : 		for (int x = x1; x <= x2; x++)

  00f16	8b 55 f0	 mov	 edx, DWORD PTR _x1$[ebp]
  00f19	89 55 bc	 mov	 DWORD PTR _x$58917[ebp], edx
  00f1c	eb 09		 jmp	 SHORT $L58918
$L58919:
  00f1e	8b 45 bc	 mov	 eax, DWORD PTR _x$58917[ebp]
  00f21	83 c0 01	 add	 eax, 1
  00f24	89 45 bc	 mov	 DWORD PTR _x$58917[ebp], eax
$L58918:
  00f27	8b 4d bc	 mov	 ecx, DWORD PTR _x$58917[ebp]
  00f2a	3b 4d e8	 cmp	 ecx, DWORD PTR _x2$[ebp]
  00f2d	7f 3a		 jg	 SHORT $L58920

; 533  : 			uchar color = colorPtr[scaleX1[x]];

  00f2f	8b 55 bc	 mov	 edx, DWORD PTR _x$58917[ebp]
  00f32	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?scaleX1@CelObj@@2PAHA[edx*4]
  00f39	8b 4d b8	 mov	 ecx, DWORD PTR _colorPtr$58916[ebp]
  00f3c	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  00f3f	88 55 b4	 mov	 BYTE PTR _color$58921[ebp], dl

; 534  : 
; 535  : 			if ( color != skip )

  00f42	8b 45 b4	 mov	 eax, DWORD PTR _color$58921[ebp]
  00f45	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00f4a	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00f4d	33 d2		 xor	 edx, edx
  00f4f	8a 51 38	 mov	 dl, BYTE PTR [ecx+56]
  00f52	3b c2		 cmp	 eax, edx
  00f54	74 08		 je	 SHORT $L58922

; 536  : 				*target = color;

  00f56	8b 45 d0	 mov	 eax, DWORD PTR _target$[ebp]
  00f59	8a 4d b4	 mov	 cl, BYTE PTR _color$58921[ebp]
  00f5c	88 08		 mov	 BYTE PTR [eax], cl
$L58922:

; 537  : 
; 538  : 			target++;

  00f5e	8b 55 d0	 mov	 edx, DWORD PTR _target$[ebp]
  00f61	83 c2 01	 add	 edx, 1
  00f64	89 55 d0	 mov	 DWORD PTR _target$[ebp], edx

; 539  : 		}

  00f67	eb b5		 jmp	 SHORT $L58919
$L58920:

; 540  : 
; 541  : 		target += nextLine;

  00f69	8b 45 d0	 mov	 eax, DWORD PTR _target$[ebp]
  00f6c	03 45 d8	 add	 eax, DWORD PTR _nextLine$[ebp]
  00f6f	89 45 d0	 mov	 DWORD PTR _target$[ebp], eax

; 542  : 	}

  00f72	e9 75 ff ff ff	 jmp	 $L58914
$L58915:

; 543  : 
; 544  : //	maskTable[skip] = 0;
; 545  : }

  00f77	8b e5		 mov	 esp, ebp
  00f79	5d		 pop	 ebp
  00f7a	c2 14 00	 ret	 20			; 00000014H
?ScaleDrawUncomp@CelObj@@QAEXABVBuffer@@ABVRatio@@1ABVSOL_Rect@@ABVSOL_Point@@@Z ENDP ; CelObj::ScaleDrawUncomp
_TEXT	ENDS
;	COMDAT ?Xlen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Xlen@SOL_Rect@@QBEHXZ PROC NEAR			; SOL_Rect::Xlen, COMDAT

; 153  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 154  : 	return B.x - A.x + 1;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00010	2b 01		 sub	 eax, DWORD PTR [ecx]
  00012	83 c0 01	 add	 eax, 1

; 155  : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?Xlen@SOL_Rect@@QBEHXZ ENDP				; SOL_Rect::Xlen
_TEXT	ENDS
;	COMDAT ?Ylen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Ylen@SOL_Rect@@QBEHXZ PROC NEAR			; SOL_Rect::Ylen, COMDAT

; 161  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 	return B.y - A.y + 1;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00010	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00013	83 c0 01	 add	 eax, 1

; 163  : }

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?Ylen@SOL_Rect@@QBEHXZ ENDP				; SOL_Rect::Ylen
_TEXT	ENDS
;	COMDAT ?XDim@Buffer@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?XDim@Buffer@@QBEHXZ PROC NEAR				; Buffer::XDim, COMDAT

; 12   : 	int		XDim() const							{return xDim;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?XDim@Buffer@@QBEHXZ ENDP				; Buffer::XDim
_TEXT	ENDS
END
