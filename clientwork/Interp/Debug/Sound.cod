	TITLE	C:\Documents and Settings\don\Desktop\sciw\Interp\Sound.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07CCG@ResView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KCEF@?4v56?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06IAEF@ResPic?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04EODC@?4p56?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08OCKJ@ResChunk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PIPI@?4chk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07ICMB@ResHunk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GG@?4scr?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08BLBP@ResSound?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KPDA@?4snd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NNMB@ResVocab?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PGDD@?4voc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FLKK@ResPatch?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CEHK@?4pat?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07MKGC@ResFont?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04IDCK@?4fon?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06DEEM@ResPal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NJLC@?4pal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07HFNL@ResHeap?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GFFD@?4hep?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06HDCC@ResMsg?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JONM@?4msg?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NFDN@ResAudio?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MOHF@?4aud?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BKMJ@ResWave?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MPDF@?4wav?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@IMEI@ResAudio36?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BONB@ResSync?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KFFK@?4syn?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09CBJE@ResSync36?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06MIEL@ResMap?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CFLF@?4map?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@LIAH@ResMsgTranslation?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JFJA@?4trn?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08JLOL@ResRobot?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04LLKI@?4rbt?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06OEMP@ResVMD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04IOID@?4vmd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@LHED@Instructed?5to?5scale?5to?5zero?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MemoryMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckValid@MemoryMgr@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GMemoryMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@V1@III@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AMemID@@QBEAADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8MemID@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??7MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeArrayID@@QBEPAUArrayHeader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ArrayID@@QAE@HW4ArrayType@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@ArrayID@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAE?AVMemID@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAEXVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_List@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@SOL_List@@QAEAAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeDispatchTblID@@QBEPAUDispatchTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeScriptEntryID@@QBEPAUScriptEntry@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntry@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeVariableID@@QBEPAUVariable@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Script@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Object@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGraphicsUpdate@Object@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?selectorDict@Object@@QAEPAVSelectorDict@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AObject@@QAEAAFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddr@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedPropAddr@Object@@QAEPBFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedProperty@Object@@QAEFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddrCheck@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@Object@@QAEFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropOffset@Object@@QAEIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetIndexedProperty@Object@@QAEXHF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetProperty@Object@@QAEXGF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssureValid@ObjectID@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsObject@ObjectID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeClassTblID@@QBEPAUClassTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@NN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SOL_Point@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetExtension@SOL_ResType@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSupported@SOL_ResType@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAttrs@SOL_ResType@@UBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResView@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPic@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResChunk@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResScript@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSound@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResVocab@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPatch@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResFont@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPal@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResHeap@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMsg@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResAudio@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResWave@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResAudio36@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSync@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSync36@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMap@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMsgTranslation@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileType@ResMsgTranslation@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResRobot@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResVMD@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@AAVSOL_Point@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Set@SOL_Rect@@QAEXHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeEmpty@SOL_Rect@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Xlen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ylen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8SOL_Rect@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Ratio@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Rgb24@@QAE@EEE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Rgb24@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Rgb24F@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@HHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@VMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Type@Bitmap@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObj@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Skip@CelObj@@QBEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemapState@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Mirrored@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObj@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjView@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjView@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjView@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjView@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjMem@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjMem@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjMem@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjMem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjColor@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjColor@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjColor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjColor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Draw@ScreenItem@@QAEXABVBuffer@@ABVSOL_Rect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SOL_Rect@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TopPlane@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TopSCIPlane@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Xdim@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ydim@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4Screen@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1PaletteMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GPaletteMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Current@PaletteMgrIndex@@UBEABVSOLPalette@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Source@PaletteMgrIndex@@UBEABVSOLPalette@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Next@PaletteMgrIndex@@UBEABVSOLPalette@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CycleMap@PaletteMgrIndex@@UBEPBEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VaryPercent@PaletteMgrIndex@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VaryPause@PaletteMgrIndex@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0PaletteMgrTrue@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GPaletteMgrTrue@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1PaletteMgrTrue@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1PaletteMgrIWin@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateHardware@PaletteMgrIWin@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GPaletteMgrIWin@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1PaletteMgrTWin@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateHardware@PaletteMgrTWin@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GPaletteMgrTWin@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1SOL_Cursor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GSOL_Cursor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GMemoryMgrWin@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1PointerDevice@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GPointerDevice@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1SOL_Mouse@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSwiftInfo@SOL_Mouse@@UBEHPAH000@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSwift@SOL_Mouse@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Vibrate@SOL_Mouse@@UBEXHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetHotRectangleStatus@SOL_Mouse@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GSOL_Mouse@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1KbdMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GKbdMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1TimeMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reset@TimeMgr@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GTimeMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GSoundMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GSoundResMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7ResPic@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7PaletteMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResView@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResPal@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObj@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResHeap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResWave@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResRobot@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResPatch@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMsgTranslation@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7Buffer@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResScript@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjColor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSync36@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMsg@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7SOL_Cursor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjView@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7SoundMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResAudio36@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7PaletteMgrTrue@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResAudio@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7PointerDevice@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResFont@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7SOL_Mouse@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7MemoryMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7PaletteMgrIWin@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7TimeMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResVMD@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResChunk@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSync@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjMem@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7SoundResMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResVocab@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7PaletteMgrTWin@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7KbdMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7MemoryMgrWin@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?soundMgr@@3PAVSoundMgr@@A			; soundMgr
PUBLIC	?gSoundDir@@3PADA				; gSoundDir
PUBLIC	?gSoundMemory@@3HA				; gSoundMemory
_BSS	SEGMENT
?soundMgr@@3PAVSoundMgr@@A DD 01H DUP (?)		; soundMgr
?gSoundMemory@@3HA DD 01H DUP (?)			; gSoundMemory
_BSS	ENDS
_DATA	SEGMENT
?gSoundDir@@3PADA DB '.', 00H				; gSoundDir
	ORG $+126
_DATA	ENDS
PUBLIC	?unload@SoundResMgr@@QAEXPAX@Z			; SoundResMgr::unload
PUBLIC	?freeSndID@SoundMgr@@QAEXH@Z			; SoundMgr::freeSndID
PUBLIC	?sampleDoneCallback@@YGXPAU_SAMPLE@@@Z		; sampleDoneCallback
_TEXT	SEGMENT
_i$ = -4
_id$64517 = -8
_sample$ = 8
?sampleDoneCallback@@YGXPAU_SAMPLE@@@Z PROC NEAR	; sampleDoneCallback

; 35   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 36   : 	for ( int i=0; i<_MAX_SFX; i++ ) {

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000d	eb 09		 jmp	 SHORT $L64513
$L64514:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00012	83 c0 01	 add	 eax, 1
  00015	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L64513:
  00018	83 7d fc 64	 cmp	 DWORD PTR _i$[ebp], 100	; 00000064H
  0001c	0f 8d 85 00 00
	00		 jge	 $L64515

; 37   : 		if ( soundMgr->sfxTbl[i] == sample ) {

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00025	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?soundMgr@@3PAVSoundMgr@@A ; soundMgr
  0002b	8b 44 8a 10	 mov	 eax, DWORD PTR [edx+ecx*4+16]
  0002f	3b 45 08	 cmp	 eax, DWORD PTR _sample$[ebp]
  00032	75 6e		 jne	 SHORT $L64516

; 38   : 			soundMgr->resMgr.unload ( soundMgr->sfxDataTbl[i] );

  00034	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00037	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?soundMgr@@3PAVSoundMgr@@A ; soundMgr
  0003d	8b 84 8a a0 01
	00 00		 mov	 eax, DWORD PTR [edx+ecx*4+416]
  00044	50		 push	 eax
  00045	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?soundMgr@@3PAVSoundMgr@@A ; soundMgr
  0004b	81 c1 0c 19 00
	00		 add	 ecx, 6412		; 0000190cH
  00051	e8 00 00 00 00	 call	 ?unload@SoundResMgr@@QAEXPAX@Z ; SoundResMgr::unload

; 39   : 			soundMgr->sfxDataTbl[i] = NULL;

  00056	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00059	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?soundMgr@@3PAVSoundMgr@@A ; soundMgr
  0005f	c7 84 8a a0 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [edx+ecx*4+416], 0

; 40   : 
; 41   : 			// clear my id for future use
; 42   : 			int id = soundMgr->sfxIDTbl[i];

  0006a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0006d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?soundMgr@@3PAVSoundMgr@@A ; soundMgr
  00073	8b 94 81 30 03
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+816]
  0007a	89 55 f8	 mov	 DWORD PTR _id$64517[ebp], edx

; 43   : 			soundMgr->sfxIDTbl[i] = 0;

  0007d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00080	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?soundMgr@@3PAVSoundMgr@@A ; soundMgr
  00086	c7 84 81 30 03
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax*4+816], 0

; 44   : 			soundMgr->freeSndID ( id );

  00091	8b 55 f8	 mov	 edx, DWORD PTR _id$64517[ebp]
  00094	52		 push	 edx
  00095	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?soundMgr@@3PAVSoundMgr@@A ; soundMgr
  0009b	e8 00 00 00 00	 call	 ?freeSndID@SoundMgr@@QAEXH@Z ; SoundMgr::freeSndID

; 45   : 
; 46   : 			return;

  000a0	eb 05		 jmp	 SHORT $L64511
$L64516:

; 48   : 	}

  000a2	e9 68 ff ff ff	 jmp	 $L64514
$L64515:
$L64511:

; 49   : }

  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c2 04 00	 ret	 4
?sampleDoneCallback@@YGXPAU_SAMPLE@@@Z ENDP		; sampleDoneCallback
_TEXT	ENDS
PUBLIC	?sequenceDoneCallback@@YGXPAU_SEQUENCE@@@Z	; sequenceDoneCallback
_TEXT	SEGMENT
_sequence$ = 8
_i$ = -4
_id$64526 = -8
?sequenceDoneCallback@@YGXPAU_SEQUENCE@@@Z PROC NEAR	; sequenceDoneCallback

; 52   : {

  000ad	55		 push	 ebp
  000ae	8b ec		 mov	 ebp, esp
  000b0	83 ec 08	 sub	 esp, 8

; 53   : 	for ( int i=0; i<_MAX_MIDI; i++ ) {

  000b3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000ba	eb 09		 jmp	 SHORT $L64522
$L64523:
  000bc	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000bf	83 c0 01	 add	 eax, 1
  000c2	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L64522:
  000c5	83 7d fc 10	 cmp	 DWORD PTR _i$[ebp], 16	; 00000010H
  000c9	0f 8d 88 00 00
	00		 jge	 $L64524

; 54   : 		if ( soundMgr->midiTbl[i] == sequence ) {

  000cf	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000d2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?soundMgr@@3PAVSoundMgr@@A ; soundMgr
  000d8	8b 84 8a c0 04
	00 00		 mov	 eax, DWORD PTR [edx+ecx*4+1216]
  000df	3b 45 08	 cmp	 eax, DWORD PTR _sequence$[ebp]
  000e2	75 6e		 jne	 SHORT $L64525

; 55   : 			soundMgr->resMgr.unload ( soundMgr->midiDataTbl[i] );

  000e4	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000e7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?soundMgr@@3PAVSoundMgr@@A ; soundMgr
  000ed	8b 84 8a 00 05
	00 00		 mov	 eax, DWORD PTR [edx+ecx*4+1280]
  000f4	50		 push	 eax
  000f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?soundMgr@@3PAVSoundMgr@@A ; soundMgr
  000fb	81 c1 0c 19 00
	00		 add	 ecx, 6412		; 0000190cH
  00101	e8 00 00 00 00	 call	 ?unload@SoundResMgr@@QAEXPAX@Z ; SoundResMgr::unload

; 56   : 			soundMgr->midiDataTbl[i] = NULL;

  00106	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00109	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?soundMgr@@3PAVSoundMgr@@A ; soundMgr
  0010f	c7 84 8a 00 05
	00 00 00 00 00
	00		 mov	 DWORD PTR [edx+ecx*4+1280], 0

; 57   : 
; 58   : 			// clear my id for future use
; 59   : 			int id = soundMgr->midiIDTbl[i];

  0011a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0011d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?soundMgr@@3PAVSoundMgr@@A ; soundMgr
  00123	8b 94 81 40 05
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+1344]
  0012a	89 55 f8	 mov	 DWORD PTR _id$64526[ebp], edx

; 60   : 			soundMgr->midiIDTbl[i] = 0;

  0012d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00130	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?soundMgr@@3PAVSoundMgr@@A ; soundMgr
  00136	c7 84 81 40 05
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax*4+1344], 0

; 61   : 			soundMgr->freeSndID ( id );

  00141	8b 55 f8	 mov	 edx, DWORD PTR _id$64526[ebp]
  00144	52		 push	 edx
  00145	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?soundMgr@@3PAVSoundMgr@@A ; soundMgr
  0014b	e8 00 00 00 00	 call	 ?freeSndID@SoundMgr@@QAEXH@Z ; SoundMgr::freeSndID

; 62   : 
; 63   : 			return;

  00150	eb 05		 jmp	 SHORT $L64520
$L64525:

; 65   : 	}

  00152	e9 65 ff ff ff	 jmp	 $L64523
$L64524:
$L64520:

; 66   : }

  00157	8b e5		 mov	 esp, ebp
  00159	5d		 pop	 ebp
  0015a	c2 04 00	 ret	 4
?sequenceDoneCallback@@YGXPAU_SEQUENCE@@@Z ENDP		; sequenceDoneCallback
_TEXT	ENDS
PUBLIC	??0SoundResMgr@@QAE@XZ				; SoundResMgr::SoundResMgr
PUBLIC	??0SoundMgr@@QAE@XZ				; SoundMgr::SoundMgr
PUBLIC	??_7SoundMgr@@6B@				; SoundMgr::`vftable'
PUBLIC	??_GSoundMgr@@UAEPAXI@Z				; SoundMgr::`scalar deleting destructor'
PUBLIC	??_ESoundMgr@@UAEPAXI@Z				; SoundMgr::`vector deleting destructor'
EXTRN	__imp__AIL_startup@0:NEAR
EXTRN	__imp__AIL_set_preference@8:NEAR
EXTRN	__imp__AIL_waveOutOpen@16:NEAR
EXTRN	__imp__AIL_waveOutClose@4:NEAR
EXTRN	__imp__AIL_allocate_sample_handle@4:NEAR
EXTRN	__imp__AIL_init_sample@4:NEAR
EXTRN	__imp__MessageBoxA@16:NEAR
EXTRN	__imp__AIL_midiOutOpen@12:NEAR
EXTRN	__imp__AIL_midiOutClose@4:NEAR
EXTRN	__imp__AIL_allocate_sequence_handle@4:NEAR
EXTRN	__imp__GetFocus@0:NEAR
EXTRN	_memset:NEAR
_BSS	SEGMENT
_?sWaveFormat@?2???0SoundMgr@@QAE@XZ@4Upcmwaveformat_tag@@A DB 010H DUP (?)
_BSS	ENDS
;	COMDAT ??_7SoundMgr@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\Sound.cpp
CONST	SEGMENT
??_7SoundMgr@@6B@ DD FLAT:??_ESoundMgr@@UAEPAXI@Z	; SoundMgr::`vftable'
CONST	ENDS
_DATA	SEGMENT
$SG64567 DB	'Initialization Error', 00H
	ORG $+3
$SG64568 DB	'We could not initialize your sound effects device.  This'
	DB	' is usually caused by some conflict with another program that'
	DB	' uses sound effects that is running at the same time as The R'
	DB	'ealm.  This has also been caused by some Sound Blaster AWE 32'
	DB	'/64 cards that have outdated drivers.  Sound effects have bee'
	DB	'n disabled.', 00H
$SG64571 DB	'Initialization Error', 00H
	ORG $+3
$SG64572 DB	'We could not initialize your MIDI device.  This is usual'
	DB	'ly caused by some conflict with another program that uses MID'
	DB	'I music that is running at the same time as The Realm.  This '
	DB	'has also been caused by some Sound Blaster AWE 32/64 cards th'
	DB	'at have outdated drivers.  MIDI music has been disabled.', 00H
$SG64574 DB	'Initialization Error', 00H
	ORG $+3
$SG64575 DB	'We could not initialize your MIDI device or your sound e'
	DB	'ffects device.  This is usually caused by some conflict with '
	DB	'another program that is using your sound card running at the '
	DB	'same time as The Realm.  Sound support has been disabled.', 00H
_DATA	ENDS
_TEXT	SEGMENT
_this$ = -236
_aOptions$64530 = -208
_nOptionIndex$64533 = -212
_nResult$64534 = -216
_pOption$64538 = -220
_nResult$64544 = -224
_i$64552 = -228
_i$64559 = -232
??0SoundMgr@@QAE@XZ PROC NEAR				; SoundMgr::SoundMgr

; 71   : {

  0015d	55		 push	 ebp
  0015e	8b ec		 mov	 ebp, esp
  00160	81 ec ec 00 00
	00		 sub	 esp, 236		; 000000ecH
  00166	89 8d 14 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  0016c	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00172	81 c1 0c 19 00
	00		 add	 ecx, 6412		; 0000190cH
  00178	e8 00 00 00 00	 call	 ??0SoundResMgr@@QAE@XZ	; SoundResMgr::SoundResMgr
  0017d	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00183	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7SoundMgr@@6B@ ; SoundMgr::`vftable'

; 72   : #ifdef _SOUND_ENABLED
; 73   : 	dig = 0;

  00189	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0018f	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 74   : 	mid = 0;

  00196	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0019c	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 75   : 	dls = 0;

  001a3	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001a9	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 76   : 
; 77   : 	// initialize the sound system...
; 78   : 	AIL_startup();

  001b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_startup@0

; 82   : 		const digitalsnd_t aOptions[] = {
; 83   : 			{ 22050, 16, 2, true },

  001b6	c7 85 30 ff ff
	ff 22 56 00 00	 mov	 DWORD PTR _aOptions$64530[ebp], 22050 ; 00005622H
  001c0	c7 85 34 ff ff
	ff 10 00 00 00	 mov	 DWORD PTR _aOptions$64530[ebp+4], 16 ; 00000010H
  001ca	c7 85 38 ff ff
	ff 02 00 00 00	 mov	 DWORD PTR _aOptions$64530[ebp+8], 2
  001d4	c6 85 3c ff ff
	ff 01		 mov	 BYTE PTR _aOptions$64530[ebp+12], 1

; 84   : 			{ 22050, 8, 2, true },

  001db	c7 85 40 ff ff
	ff 22 56 00 00	 mov	 DWORD PTR _aOptions$64530[ebp+16], 22050 ; 00005622H
  001e5	c7 85 44 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR _aOptions$64530[ebp+20], 8
  001ef	c7 85 48 ff ff
	ff 02 00 00 00	 mov	 DWORD PTR _aOptions$64530[ebp+24], 2
  001f9	c6 85 4c ff ff
	ff 01		 mov	 BYTE PTR _aOptions$64530[ebp+28], 1

; 85   : 			{ 11025, 16, 2, true },

  00200	c7 85 50 ff ff
	ff 11 2b 00 00	 mov	 DWORD PTR _aOptions$64530[ebp+32], 11025 ; 00002b11H
  0020a	c7 85 54 ff ff
	ff 10 00 00 00	 mov	 DWORD PTR _aOptions$64530[ebp+36], 16 ; 00000010H
  00214	c7 85 58 ff ff
	ff 02 00 00 00	 mov	 DWORD PTR _aOptions$64530[ebp+40], 2
  0021e	c6 85 5c ff ff
	ff 01		 mov	 BYTE PTR _aOptions$64530[ebp+44], 1

; 86   : 			{ 11025, 8, 2, true },

  00225	c7 85 60 ff ff
	ff 11 2b 00 00	 mov	 DWORD PTR _aOptions$64530[ebp+48], 11025 ; 00002b11H
  0022f	c7 85 64 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR _aOptions$64530[ebp+52], 8
  00239	c7 85 68 ff ff
	ff 02 00 00 00	 mov	 DWORD PTR _aOptions$64530[ebp+56], 2
  00243	c6 85 6c ff ff
	ff 01		 mov	 BYTE PTR _aOptions$64530[ebp+60], 1

; 87   : 			{ 22050, 16, 1, true },

  0024a	c7 85 70 ff ff
	ff 22 56 00 00	 mov	 DWORD PTR _aOptions$64530[ebp+64], 22050 ; 00005622H
  00254	c7 85 74 ff ff
	ff 10 00 00 00	 mov	 DWORD PTR _aOptions$64530[ebp+68], 16 ; 00000010H
  0025e	c7 85 78 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _aOptions$64530[ebp+72], 1
  00268	c6 85 7c ff ff
	ff 01		 mov	 BYTE PTR _aOptions$64530[ebp+76], 1

; 88   : 			{ 22050, 8, 1, true },

  0026f	c7 45 80 22 56
	00 00		 mov	 DWORD PTR _aOptions$64530[ebp+80], 22050 ; 00005622H
  00276	c7 45 84 08 00
	00 00		 mov	 DWORD PTR _aOptions$64530[ebp+84], 8
  0027d	c7 45 88 01 00
	00 00		 mov	 DWORD PTR _aOptions$64530[ebp+88], 1
  00284	c6 45 8c 01	 mov	 BYTE PTR _aOptions$64530[ebp+92], 1

; 89   : 			{ 11025, 16, 1, true },

  00288	c7 45 90 11 2b
	00 00		 mov	 DWORD PTR _aOptions$64530[ebp+96], 11025 ; 00002b11H
  0028f	c7 45 94 10 00
	00 00		 mov	 DWORD PTR _aOptions$64530[ebp+100], 16 ; 00000010H
  00296	c7 45 98 01 00
	00 00		 mov	 DWORD PTR _aOptions$64530[ebp+104], 1
  0029d	c6 45 9c 01	 mov	 BYTE PTR _aOptions$64530[ebp+108], 1

; 90   : 			{ 11025, 8, 1, true },

  002a1	c7 45 a0 11 2b
	00 00		 mov	 DWORD PTR _aOptions$64530[ebp+112], 11025 ; 00002b11H
  002a8	c7 45 a4 08 00
	00 00		 mov	 DWORD PTR _aOptions$64530[ebp+116], 8
  002af	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR _aOptions$64530[ebp+120], 1
  002b6	c6 45 ac 01	 mov	 BYTE PTR _aOptions$64530[ebp+124], 1

; 91   : 			{ 22050, 16, 1, false },

  002ba	c7 45 b0 22 56
	00 00		 mov	 DWORD PTR _aOptions$64530[ebp+128], 22050 ; 00005622H
  002c1	c7 45 b4 10 00
	00 00		 mov	 DWORD PTR _aOptions$64530[ebp+132], 16 ; 00000010H
  002c8	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR _aOptions$64530[ebp+136], 1
  002cf	c6 45 bc 00	 mov	 BYTE PTR _aOptions$64530[ebp+140], 0

; 92   : 			{ 22050, 8, 1, false },

  002d3	c7 45 c0 22 56
	00 00		 mov	 DWORD PTR _aOptions$64530[ebp+144], 22050 ; 00005622H
  002da	c7 45 c4 08 00
	00 00		 mov	 DWORD PTR _aOptions$64530[ebp+148], 8
  002e1	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _aOptions$64530[ebp+152], 1
  002e8	c6 45 cc 00	 mov	 BYTE PTR _aOptions$64530[ebp+156], 0

; 93   : 			{ 11025, 16, 1, false },

  002ec	c7 45 d0 11 2b
	00 00		 mov	 DWORD PTR _aOptions$64530[ebp+160], 11025 ; 00002b11H
  002f3	c7 45 d4 10 00
	00 00		 mov	 DWORD PTR _aOptions$64530[ebp+164], 16 ; 00000010H
  002fa	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _aOptions$64530[ebp+168], 1
  00301	c6 45 dc 00	 mov	 BYTE PTR _aOptions$64530[ebp+172], 0

; 94   : 			{ 11025, 8, 1, false },

  00305	c7 45 e0 11 2b
	00 00		 mov	 DWORD PTR _aOptions$64530[ebp+176], 11025 ; 00002b11H
  0030c	c7 45 e4 08 00
	00 00		 mov	 DWORD PTR _aOptions$64530[ebp+180], 8
  00313	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _aOptions$64530[ebp+184], 1
  0031a	c6 45 ec 00	 mov	 BYTE PTR _aOptions$64530[ebp+188], 0

; 95   : 			{ -1, -1, -1, false }

  0031e	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _aOptions$64530[ebp+192], -1
  00325	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _aOptions$64530[ebp+196], -1
  0032c	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _aOptions$64530[ebp+200], -1
  00333	c6 45 fc 00	 mov	 BYTE PTR _aOptions$64530[ebp+204], 0

; 96   : 		};
; 97   : 
; 98   : 		static PCMWAVEFORMAT sWaveFormat;
; 99   : 
; 100  : 		// try all of the configuration options until we get one that works...
; 101  : 		int nOptionIndex = 0, nResult = 1;

  00337	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _nOptionIndex$64533[ebp], 0
  00341	c7 85 28 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _nResult$64534[ebp], 1
$L64536:

; 105  : 			// get the current option information
; 106  : 			const digitalsnd_t *pOption = &aOptions[nOptionIndex];

  0034b	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _nOptionIndex$64533[ebp]
  00351	c1 e1 04	 shl	 ecx, 4
  00354	8d 94 0d 30 ff
	ff ff		 lea	 edx, DWORD PTR _aOptions$64530[ebp+ecx]
  0035b	89 95 24 ff ff
	ff		 mov	 DWORD PTR _pOption$64538[ebp], edx

; 107  : 
; 108  : 			// if there are no more options, escape!
; 109  : 			if ( pOption->m_nRate == -1 ) {

  00361	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _pOption$64538[ebp]
  00367	83 38 ff	 cmp	 DWORD PTR [eax], -1
  0036a	75 05		 jne	 SHORT $L64539

; 110  : 				break;

  0036c	e9 df 00 00 00	 jmp	 $L64537
$L64539:

; 112  : 
; 113  : 			// setup the wave format information...
; 114  : 			sWaveFormat.wf.wFormatTag = WAVE_FORMAT_PCM;

  00371	66 c7 05 00 00
	00 00 01 00	 mov	 WORD PTR _?sWaveFormat@?2???0SoundMgr@@QAE@XZ@4Upcmwaveformat_tag@@A, 1

; 115  : 			sWaveFormat.wf.nChannels = pOption->m_nChannels;

  0037a	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _pOption$64538[ebp]
  00380	66 8b 51 08	 mov	 dx, WORD PTR [ecx+8]
  00384	66 89 15 02 00
	00 00		 mov	 WORD PTR _?sWaveFormat@?2???0SoundMgr@@QAE@XZ@4Upcmwaveformat_tag@@A+2, dx

; 116  : 			sWaveFormat.wf.nSamplesPerSec = pOption->m_nRate;

  0038b	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _pOption$64538[ebp]
  00391	8b 08		 mov	 ecx, DWORD PTR [eax]
  00393	89 0d 04 00 00
	00		 mov	 DWORD PTR _?sWaveFormat@?2???0SoundMgr@@QAE@XZ@4Upcmwaveformat_tag@@A+4, ecx

; 117  : 			sWaveFormat.wf.nAvgBytesPerSec = pOption->m_nRate * (pOption->m_nBits / 8) * pOption->m_nChannels;

  00399	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _pOption$64538[ebp]
  0039f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  003a2	99		 cdq
  003a3	83 e2 07	 and	 edx, 7
  003a6	03 c2		 add	 eax, edx
  003a8	c1 f8 03	 sar	 eax, 3
  003ab	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _pOption$64538[ebp]
  003b1	8b 11		 mov	 edx, DWORD PTR [ecx]
  003b3	0f af d0	 imul	 edx, eax
  003b6	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _pOption$64538[ebp]
  003bc	0f af 50 08	 imul	 edx, DWORD PTR [eax+8]
  003c0	89 15 08 00 00
	00		 mov	 DWORD PTR _?sWaveFormat@?2???0SoundMgr@@QAE@XZ@4Upcmwaveformat_tag@@A+8, edx

; 118  : 			sWaveFormat.wf.nBlockAlign = (pOption->m_nBits / 8) * pOption->m_nChannels;

  003c6	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _pOption$64538[ebp]
  003cc	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  003cf	99		 cdq
  003d0	83 e2 07	 and	 edx, 7
  003d3	03 c2		 add	 eax, edx
  003d5	c1 f8 03	 sar	 eax, 3
  003d8	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _pOption$64538[ebp]
  003de	0f af 42 08	 imul	 eax, DWORD PTR [edx+8]
  003e2	66 a3 0c 00 00
	00		 mov	 WORD PTR _?sWaveFormat@?2???0SoundMgr@@QAE@XZ@4Upcmwaveformat_tag@@A+12, ax

; 119  : 			sWaveFormat.wBitsPerSample = pOption->m_nBits;

  003e8	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _pOption$64538[ebp]
  003ee	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  003f2	66 89 0d 0e 00
	00 00		 mov	 WORD PTR _?sWaveFormat@?2???0SoundMgr@@QAE@XZ@4Upcmwaveformat_tag@@A+14, cx

; 120  : 
; 121  : 			// set the direct sound settings...
; 122  : 			AIL_set_preference ( DIG_USE_WAVEOUT, !pOption->m_bDirectX );

  003f9	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _pOption$64538[ebp]
  003ff	33 c0		 xor	 eax, eax
  00401	8a 42 0c	 mov	 al, BYTE PTR [edx+12]
  00404	f7 d8		 neg	 eax
  00406	1b c0		 sbb	 eax, eax
  00408	40		 inc	 eax
  00409	50		 push	 eax
  0040a	6a 0f		 push	 15			; 0000000fH
  0040c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_set_preference@8

; 123  : 
; 124  : 			// set the reverb settings...
; 125  : //			AIL_set_preference ( DIG_REVERB_BUFFER_SIZE, 262144 );
; 126  : 
; 127  : 			// attempt the wave out open...
; 128  : 			nResult = AIL_waveOutOpen ( &dig, 0, WAVE_MAPPER, (LPWAVEFORMAT)&sWaveFormat );

  00412	68 00 00 00 00	 push	 OFFSET FLAT:_?sWaveFormat@?2???0SoundMgr@@QAE@XZ@4Upcmwaveformat_tag@@A
  00417	6a ff		 push	 -1
  00419	6a 00		 push	 0
  0041b	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00421	83 c1 04	 add	 ecx, 4
  00424	51		 push	 ecx
  00425	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_waveOutOpen@16
  0042b	89 85 28 ff ff
	ff		 mov	 DWORD PTR _nResult$64534[ebp], eax

; 129  : 
; 130  : 			// handle a successful initialization...
; 131  : 			if ( nResult == 0 ) {

  00431	83 bd 28 ff ff
	ff 00		 cmp	 DWORD PTR _nResult$64534[ebp], 0
  00438	75 02		 jne	 SHORT $L64542

; 132  : 				break;

  0043a	eb 14		 jmp	 SHORT $L64537
$L64542:

; 134  : 
; 135  : 			// point to the next option...
; 136  : 			nOptionIndex++;

  0043c	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _nOptionIndex$64533[ebp]
  00442	83 c2 01	 add	 edx, 1
  00445	89 95 2c ff ff
	ff		 mov	 DWORD PTR _nOptionIndex$64533[ebp], edx

; 137  : 		}

  0044b	e9 fb fe ff ff	 jmp	 $L64536
$L64537:

; 138  : 
; 139  : 		// if nResult is still set, no digital driver could be opened...
; 140  : 		if ( nResult ) {

  00450	83 bd 28 ff ff
	ff 00		 cmp	 DWORD PTR _nResult$64534[ebp], 0
  00457	74 1d		 je	 SHORT $L64543

; 141  : 			AIL_waveOutClose ( dig );

  00459	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0045f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00462	51		 push	 ecx
  00463	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_waveOutClose@4

; 142  : 			dig = NULL;

  00469	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0046f	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
$L64543:

; 148  : 		int nResult = AIL_midiOutOpen ( &mid, NULL, MIDI_MAPPER );

  00476	6a ff		 push	 -1
  00478	6a 00		 push	 0
  0047a	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00480	83 c0 08	 add	 eax, 8
  00483	50		 push	 eax
  00484	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_midiOutOpen@12
  0048a	89 85 20 ff ff
	ff		 mov	 DWORD PTR _nResult$64544[ebp], eax

; 149  : 
; 150  : 		if ( nResult ) {

  00490	83 bd 20 ff ff
	ff 00		 cmp	 DWORD PTR _nResult$64544[ebp], 0
  00497	74 3d		 je	 SHORT $L64547

; 151  : 			nResult = AIL_midiOutOpen ( &mid, NULL, 0 );

  00499	6a 00		 push	 0
  0049b	6a 00		 push	 0
  0049d	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004a3	83 c1 08	 add	 ecx, 8
  004a6	51		 push	 ecx
  004a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_midiOutOpen@12
  004ad	89 85 20 ff ff
	ff		 mov	 DWORD PTR _nResult$64544[ebp], eax

; 152  : 
; 153  : 			if ( nResult )

  004b3	83 bd 20 ff ff
	ff 00		 cmp	 DWORD PTR _nResult$64544[ebp], 0
  004ba	74 1a		 je	 SHORT $L64547

; 154  : 				nResult = AIL_midiOutOpen ( &mid, NULL, MIDI_NULL_DRIVER );

  004bc	6a fe		 push	 -2			; fffffffeH
  004be	6a 00		 push	 0
  004c0	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  004c6	83 c2 08	 add	 edx, 8
  004c9	52		 push	 edx
  004ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_midiOutOpen@12
  004d0	89 85 20 ff ff
	ff		 mov	 DWORD PTR _nResult$64544[ebp], eax
$L64547:

; 156  : 
; 157  : 
; 158  : 		// if nResult is still set, we could not open a MIDI driver...
; 159  : 		if ( nResult ) {

  004d6	83 bd 20 ff ff
	ff 00		 cmp	 DWORD PTR _nResult$64544[ebp], 0
  004dd	74 1d		 je	 SHORT $L64550

; 160  : 			AIL_midiOutClose ( mid );

  004df	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  004e5	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  004e8	51		 push	 ecx
  004e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_midiOutClose@4

; 161  : 			mid = NULL;

  004ef	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  004f5	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
$L64550:

; 164  : 
; 165  : 	if ( dig ) {

  004fc	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00502	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00506	0f 84 8b 00 00
	00		 je	 $L64555

; 166  : 		for ( int i=0; i<_MAX_SFX; i++ ) {

  0050c	c7 85 1c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$64552[ebp], 0
  00516	eb 0f		 jmp	 SHORT $L64553
$L64554:
  00518	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _i$64552[ebp]
  0051e	83 c1 01	 add	 ecx, 1
  00521	89 8d 1c ff ff
	ff		 mov	 DWORD PTR _i$64552[ebp], ecx
$L64553:
  00527	83 bd 1c ff ff
	ff 64		 cmp	 DWORD PTR _i$64552[ebp], 100 ; 00000064H
  0052e	7d 67		 jge	 SHORT $L64555

; 167  : 			sfxTbl[i] = AIL_allocate_sample_handle ( (HDIGDRIVER)dig );

  00530	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00536	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00539	50		 push	 eax
  0053a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_allocate_sample_handle@4
  00540	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _i$64552[ebp]
  00546	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0054c	89 44 8a 10	 mov	 DWORD PTR [edx+ecx*4+16], eax

; 168  : 			AIL_init_sample ( (HSAMPLE)sfxTbl[i] );

  00550	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _i$64552[ebp]
  00556	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0055c	8b 54 81 10	 mov	 edx, DWORD PTR [ecx+eax*4+16]
  00560	52		 push	 edx
  00561	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_init_sample@4

; 169  : 			sfxDataTbl[i] = NULL;

  00567	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _i$64552[ebp]
  0056d	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00573	c7 84 81 a0 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax*4+416], 0

; 170  : 			sfxIDTbl[i] = -1;

  0057e	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _i$64552[ebp]
  00584	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0058a	c7 84 90 30 03
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [eax+edx*4+816], -1

; 171  : 		}

  00595	eb 81		 jmp	 SHORT $L64554
$L64555:

; 173  : 
; 174  : 	if ( mid ) {

  00597	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0059d	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  005a1	74 77		 je	 SHORT $L64562

; 175  : 		for ( int i=0; i<_MAX_MIDI; i++ ) {

  005a3	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$64559[ebp], 0
  005ad	eb 0f		 jmp	 SHORT $L64560
$L64561:
  005af	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _i$64559[ebp]
  005b5	83 c2 01	 add	 edx, 1
  005b8	89 95 18 ff ff
	ff		 mov	 DWORD PTR _i$64559[ebp], edx
$L64560:
  005be	83 bd 18 ff ff
	ff 10		 cmp	 DWORD PTR _i$64559[ebp], 16 ; 00000010H
  005c5	7d 53		 jge	 SHORT $L64562

; 176  : 			midiTbl[i] = AIL_allocate_sequence_handle ( (HMDIDRIVER)mid );

  005c7	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  005cd	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  005d0	51		 push	 ecx
  005d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_allocate_sequence_handle@4
  005d7	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _i$64559[ebp]
  005dd	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  005e3	89 84 91 c0 04
	00 00		 mov	 DWORD PTR [ecx+edx*4+1216], eax

; 177  : 
; 178  : 			midiDataTbl[i] = NULL;

  005ea	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _i$64559[ebp]
  005f0	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  005f6	c7 84 90 00 05
	00 00 00 00 00
	00		 mov	 DWORD PTR [eax+edx*4+1280], 0

; 179  : 			midiIDTbl[i] = -1;

  00601	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _i$64559[ebp]
  00607	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0060d	c7 84 8a 40 05
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [edx+ecx*4+1344], -1

; 180  : 		}

  00618	eb 95		 jmp	 SHORT $L64561
$L64562:

; 182  : 
; 183  : #if 1
; 184  : 	if ( !mid || !dig ) {

  0061a	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00620	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00624	74 0c		 je	 SHORT $L64565
  00626	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0062c	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00630	75 67		 jne	 SHORT $L64573
$L64565:

; 185  : 		// complain that the digital system did not initialize properly
; 186  : 		if ( mid ) {

  00632	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00638	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  0063c	74 1b		 je	 SHORT $L64566

; 187  : 			MessageBox ( GetFocus(), "We could not initialize your sound effects device.  This is usually caused by some conflict with another program that uses sound effects that is running at the same time as The Realm.  This has also been caused by some Sound Blaster AWE 32/64 cards that have outdated drivers.  Sound effects have been disabled.", "Initialization Error", MB_OK );

  0063e	6a 00		 push	 0
  00640	68 00 00 00 00	 push	 OFFSET FLAT:$SG64567
  00645	68 00 00 00 00	 push	 OFFSET FLAT:$SG64568
  0064a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFocus@0
  00650	50		 push	 eax
  00651	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 189  : 
; 190  : 		else if ( dig ) {

  00657	eb 40		 jmp	 SHORT $L64573
$L64566:
  00659	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0065f	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00663	74 1b		 je	 SHORT $L64570

; 191  : 			MessageBox ( GetFocus(), "We could not initialize your MIDI device.  This is usually caused by some conflict with another program that uses MIDI music that is running at the same time as The Realm.  This has also been caused by some Sound Blaster AWE 32/64 cards that have outdated drivers.  MIDI music has been disabled.", "Initialization Error", MB_OK );

  00665	6a 00		 push	 0
  00667	68 00 00 00 00	 push	 OFFSET FLAT:$SG64571
  0066c	68 00 00 00 00	 push	 OFFSET FLAT:$SG64572
  00671	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFocus@0
  00677	50		 push	 eax
  00678	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 193  : 
; 194  : 		else {

  0067e	eb 19		 jmp	 SHORT $L64573
$L64570:

; 195  : 			MessageBox ( GetFocus(), "We could not initialize your MIDI device or your sound effects device.  This is usually caused by some conflict with another program that is using your sound card running at the same time as The Realm.  Sound support has been disabled.", "Initialization Error", MB_OK );

  00680	6a 00		 push	 0
  00682	68 00 00 00 00	 push	 OFFSET FLAT:$SG64574
  00687	68 00 00 00 00	 push	 OFFSET FLAT:$SG64575
  0068c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFocus@0
  00692	50		 push	 eax
  00693	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
$L64573:

; 198  : #endif
; 199  : 
; 200  : 	curSndID = 0;

  00699	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0069f	c7 81 80 05 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1408], 0

; 201  : 	memset ( sndIDTrackingTbl, 0, sizeof ( sndIDTrackingTbl ) );

  006a9	68 88 13 00 00	 push	 5000			; 00001388H
  006ae	6a 00		 push	 0
  006b0	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  006b6	81 c2 84 05 00
	00		 add	 edx, 1412		; 00000584H
  006bc	52		 push	 edx
  006bd	e8 00 00 00 00	 call	 _memset
  006c2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 202  : #endif
; 203  : }

  006c5	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  006cb	8b e5		 mov	 esp, ebp
  006cd	5d		 pop	 ebp
  006ce	c3		 ret	 0
??0SoundMgr@@QAE@XZ ENDP				; SoundMgr::SoundMgr
_TEXT	ENDS
PUBLIC	??1SoundMgr@@UAE@XZ				; SoundMgr::~SoundMgr
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
;	COMDAT ??_GSoundMgr@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GSoundMgr@@UAEPAXI@Z PROC NEAR			; SoundMgr::`scalar deleting destructor', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1SoundMgr@@UAE@XZ	; SoundMgr::~SoundMgr
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L64579
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L64579:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GSoundMgr@@UAEPAXI@Z ENDP				; SoundMgr::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1SoundResMgr@@UAE@XZ				; SoundResMgr::~SoundResMgr
EXTRN	__imp__AIL_shutdown@0:NEAR
_TEXT	SEGMENT
_this$ = -4
??1SoundMgr@@UAE@XZ PROC NEAR				; SoundMgr::~SoundMgr

; 206  : {

  006cf	55		 push	 ebp
  006d0	8b ec		 mov	 ebp, esp
  006d2	51		 push	 ecx
  006d3	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  006d6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  006d9	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7SoundMgr@@6B@ ; SoundMgr::`vftable'

; 207  : #ifdef _SOUND_ENABLED
; 208  : 	AIL_shutdown();

  006df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_shutdown@0

; 209  : #endif
; 210  : }

  006e5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006e8	81 c1 0c 19 00
	00		 add	 ecx, 6412		; 0000190cH
  006ee	e8 00 00 00 00	 call	 ??1SoundResMgr@@UAE@XZ	; SoundResMgr::~SoundResMgr
  006f3	8b e5		 mov	 esp, ebp
  006f5	5d		 pop	 ebp
  006f6	c3		 ret	 0
??1SoundMgr@@UAE@XZ ENDP				; SoundMgr::~SoundMgr
_TEXT	ENDS
PUBLIC	?allocateSndID@SoundMgr@@QAEHXZ			; SoundMgr::allocateSndID
_TEXT	SEGMENT
_this$ = -8
_index$ = -4
?allocateSndID@SoundMgr@@QAEHXZ PROC NEAR		; SoundMgr::allocateSndID

; 214  : {

  006f7	55		 push	 ebp
  006f8	8b ec		 mov	 ebp, esp
  006fa	83 ec 08	 sub	 esp, 8
  006fd	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 215  : 	int index = curSndID;

  00700	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00703	8b 88 80 05 00
	00		 mov	 ecx, DWORD PTR [eax+1408]
  00709	89 4d fc	 mov	 DWORD PTR _index$[ebp], ecx
$L64589:

; 216  : 
; 217  : 	while ( 1 ) {

  0070c	ba 01 00 00 00	 mov	 edx, 1
  00711	85 d2		 test	 edx, edx
  00713	74 4d		 je	 SHORT $L64590

; 218  : 		if ( index > _MAX_SND_ID )

  00715	81 7d fc 88 13
	00 00		 cmp	 DWORD PTR _index$[ebp], 5000 ; 00001388H
  0071c	7e 07		 jle	 SHORT $L64591

; 219  : 			index = 0;

  0071e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _index$[ebp], 0
$L64591:

; 220  : 
; 221  : 		if ( !sndIDTrackingTbl[index] ) {

  00725	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00728	03 45 fc	 add	 eax, DWORD PTR _index$[ebp]
  0072b	0f be 88 84 05
	00 00		 movsx	 ecx, BYTE PTR [eax+1412]
  00732	85 c9		 test	 ecx, ecx
  00734	75 21		 jne	 SHORT $L64592

; 222  : 			sndIDTrackingTbl[index] = 1;

  00736	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00739	03 55 fc	 add	 edx, DWORD PTR _index$[ebp]
  0073c	c6 82 84 05 00
	00 01		 mov	 BYTE PTR [edx+1412], 1

; 223  : 			curSndID = index + 1;

  00743	8b 45 fc	 mov	 eax, DWORD PTR _index$[ebp]
  00746	83 c0 01	 add	 eax, 1
  00749	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0074c	89 81 80 05 00
	00		 mov	 DWORD PTR [ecx+1408], eax

; 224  : 
; 225  : 			return index;

  00752	8b 45 fc	 mov	 eax, DWORD PTR _index$[ebp]
  00755	eb 0e		 jmp	 SHORT $L64586
$L64592:

; 227  : 
; 228  : 		index++;

  00757	8b 55 fc	 mov	 edx, DWORD PTR _index$[ebp]
  0075a	83 c2 01	 add	 edx, 1
  0075d	89 55 fc	 mov	 DWORD PTR _index$[ebp], edx

; 229  : 	}

  00760	eb aa		 jmp	 SHORT $L64589
$L64590:

; 230  : 
; 231  : 	return -1;

  00762	83 c8 ff	 or	 eax, -1
$L64586:

; 232  : }

  00765	8b e5		 mov	 esp, ebp
  00767	5d		 pop	 ebp
  00768	c3		 ret	 0
?allocateSndID@SoundMgr@@QAEHXZ ENDP			; SoundMgr::allocateSndID
_id$ = 8
_this$ = -4
?freeSndID@SoundMgr@@QAEXH@Z PROC NEAR			; SoundMgr::freeSndID

; 236  : {

  00769	55		 push	 ebp
  0076a	8b ec		 mov	 ebp, esp
  0076c	51		 push	 ecx
  0076d	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 237  : 	sndIDTrackingTbl[id] = 0;

  00770	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00773	03 45 08	 add	 eax, DWORD PTR _id$[ebp]
  00776	c6 80 84 05 00
	00 00		 mov	 BYTE PTR [eax+1412], 0

; 238  : }

  0077d	8b e5		 mov	 esp, ebp
  0077f	5d		 pop	 ebp
  00780	c2 04 00	 ret	 4
?freeSndID@SoundMgr@@QAEXH@Z ENDP			; SoundMgr::freeSndID
_TEXT	ENDS
PUBLIC	?load@SoundResMgr@@QAEPAXPAD@Z			; SoundResMgr::load
PUBLIC	?play@SoundMgr@@QAEHPADH@Z			; SoundMgr::play
EXTRN	?Fatal@MsgMgr@@QAAXPADZZ:NEAR			; MsgMgr::Fatal
EXTRN	?msgMgr@@3PAVMsgMgr@@A:DWORD			; msgMgr
EXTRN	__imp__AIL_set_sample_file@12:NEAR
EXTRN	__imp__AIL_start_sample@4:NEAR
EXTRN	__imp__AIL_set_sample_loop_count@8:NEAR
EXTRN	__imp__AIL_register_EOS_callback@8:NEAR
EXTRN	__imp__AIL_init_sequence@12:NEAR
EXTRN	__imp__AIL_start_sequence@4:NEAR
EXTRN	__imp__AIL_set_sequence_loop_count@8:NEAR
EXTRN	__imp__AIL_register_sequence_callback@8:NEAR
EXTRN	__imp__strstr:NEAR
_DATA	SEGMENT
$SG64604 DB	'Error invalid sound file', 00H
	ORG $+3
$SG64606 DB	'.wav', 00H
	ORG $+3
$SG64619 DB	'.xmi', 00H
_DATA	ENDS
_TEXT	SEGMENT
_name$ = 8
_loopCount$ = 12
_this$ = -36
_i$ = -4
_sample$64607 = -8
_data$64614 = -12
_id$64616 = -16
_sequence$64620 = -24
_i$64621 = -20
_data$64628 = -28
_id$64630 = -32
?play@SoundMgr@@QAEHPADH@Z PROC NEAR			; SoundMgr::play

; 242  : {

  00783	55		 push	 ebp
  00784	8b ec		 mov	 ebp, esp
  00786	83 ec 24	 sub	 esp, 36			; 00000024H
  00789	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 243  : 	int i = 0;

  0078c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 244  : 
; 245  : #ifdef _SOUND_ENABLED
; 246  : 	if ( !name ) {

  00793	83 7d 08 00	 cmp	 DWORD PTR _name$[ebp], 0
  00797	75 13		 jne	 SHORT $L64603

; 247  : 		msgMgr->Fatal( "Error invalid sound file" );

  00799	68 00 00 00 00	 push	 OFFSET FLAT:$SG64604
  0079e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  007a3	50		 push	 eax
  007a4	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  007a9	83 c4 08	 add	 esp, 8
$L64603:

; 249  : 
; 250  : 	if ( dig && strstr ( name, ".wav" ) ) {

  007ac	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  007af	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  007b3	0f 84 ff 00 00
	00		 je	 $L64605
  007b9	68 00 00 00 00	 push	 OFFSET FLAT:$SG64606
  007be	8b 55 08	 mov	 edx, DWORD PTR _name$[ebp]
  007c1	52		 push	 edx
  007c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strstr
  007c8	83 c4 08	 add	 esp, 8
  007cb	85 c0		 test	 eax, eax
  007cd	0f 84 e5 00 00
	00		 je	 $L64605

; 251  : 		HSAMPLE sample = NULL;

  007d3	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _sample$64607[ebp], 0

; 252  : 		
; 253  : 		for (i=0; i<_MAX_SFX; i++ ) {

  007da	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  007e1	eb 09		 jmp	 SHORT $L64608
$L64609:
  007e3	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  007e6	83 c0 01	 add	 eax, 1
  007e9	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L64608:
  007ec	83 7d fc 64	 cmp	 DWORD PTR _i$[ebp], 100	; 00000064H
  007f0	7d 28		 jge	 SHORT $L64610

; 254  : 			sample = (HSAMPLE)sfxTbl[i];

  007f2	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  007f5	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  007f8	8b 44 8a 10	 mov	 eax, DWORD PTR [edx+ecx*4+16]
  007fc	89 45 f8	 mov	 DWORD PTR _sample$64607[ebp], eax

; 255  : 
; 256  : 			if ( sfxDataTbl[i] == NULL ) {

  007ff	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00802	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00805	83 bc 8a a0 01
	00 00 00	 cmp	 DWORD PTR [edx+ecx*4+416], 0
  0080d	75 02		 jne	 SHORT $L64612

; 257  : 				break;

  0080f	eb 09		 jmp	 SHORT $L64610
$L64612:

; 259  : 
; 260  : 			sample = NULL;

  00811	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _sample$64607[ebp], 0

; 261  : 		}

  00818	eb c9		 jmp	 SHORT $L64609
$L64610:

; 262  : 
; 263  : 		if ( sample ) {

  0081a	83 7d f8 00	 cmp	 DWORD PTR _sample$64607[ebp], 0
  0081e	0f 84 8f 00 00
	00		 je	 $L64615

; 264  : 			void far *data = resMgr.load ( name );

  00824	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  00827	50		 push	 eax
  00828	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0082b	81 c1 0c 19 00
	00		 add	 ecx, 6412		; 0000190cH
  00831	e8 00 00 00 00	 call	 ?load@SoundResMgr@@QAEPAXPAD@Z ; SoundResMgr::load
  00836	89 45 f4	 mov	 DWORD PTR _data$64614[ebp], eax

; 265  : 
; 266  : 			if ( data ) {

  00839	83 7d f4 00	 cmp	 DWORD PTR _data$64614[ebp], 0
  0083d	74 74		 je	 SHORT $L64615

; 267  : 				// find a new sfxID
; 268  : 				int id = allocateSndID();

  0083f	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00842	e8 00 00 00 00	 call	 ?allocateSndID@SoundMgr@@QAEHXZ ; SoundMgr::allocateSndID
  00847	89 45 f0	 mov	 DWORD PTR _id$64616[ebp], eax

; 269  : 				sfxIDTbl[i] = id;

  0084a	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0084d	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00850	8b 45 f0	 mov	 eax, DWORD PTR _id$64616[ebp]
  00853	89 84 8a 30 03
	00 00		 mov	 DWORD PTR [edx+ecx*4+816], eax

; 270  : 			
; 271  : 				sfxDataTbl[i] = data;

  0085a	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0085d	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00860	8b 45 f4	 mov	 eax, DWORD PTR _data$64614[ebp]
  00863	89 84 8a a0 01
	00 00		 mov	 DWORD PTR [edx+ecx*4+416], eax

; 272  : 
; 273  : 				AIL_init_sample ( sample );

  0086a	8b 4d f8	 mov	 ecx, DWORD PTR _sample$64607[ebp]
  0086d	51		 push	 ecx
  0086e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_init_sample@4

; 274  : 				AIL_set_sample_file ( sample, data, 0 );

  00874	6a 00		 push	 0
  00876	8b 55 f4	 mov	 edx, DWORD PTR _data$64614[ebp]
  00879	52		 push	 edx
  0087a	8b 45 f8	 mov	 eax, DWORD PTR _sample$64607[ebp]
  0087d	50		 push	 eax
  0087e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_set_sample_file@12

; 275  : 				AIL_register_EOS_callback ( sample, sampleDoneCallback );

  00884	68 00 00 00 00	 push	 OFFSET FLAT:?sampleDoneCallback@@YGXPAU_SAMPLE@@@Z ; sampleDoneCallback
  00889	8b 4d f8	 mov	 ecx, DWORD PTR _sample$64607[ebp]
  0088c	51		 push	 ecx
  0088d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_register_EOS_callback@8

; 276  : 				AIL_set_sample_loop_count ( sample, loopCount );

  00893	8b 55 0c	 mov	 edx, DWORD PTR _loopCount$[ebp]
  00896	52		 push	 edx
  00897	8b 45 f8	 mov	 eax, DWORD PTR _sample$64607[ebp]
  0089a	50		 push	 eax
  0089b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_set_sample_loop_count@8

; 277  : 				AIL_start_sample ( sample );

  008a1	8b 4d f8	 mov	 ecx, DWORD PTR _sample$64607[ebp]
  008a4	51		 push	 ecx
  008a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_start_sample@4

; 278  : 
; 279  : 				return id;

  008ab	8b 45 f0	 mov	 eax, DWORD PTR _id$64616[ebp]
  008ae	e9 f8 00 00 00	 jmp	 $L64601
$L64615:

; 283  : 
; 284  : 	else if ( strstr ( name, ".xmi" ) ) {

  008b3	e9 f0 00 00 00	 jmp	 $L64629
$L64605:
  008b8	68 00 00 00 00	 push	 OFFSET FLAT:$SG64619
  008bd	8b 55 08	 mov	 edx, DWORD PTR _name$[ebp]
  008c0	52		 push	 edx
  008c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strstr
  008c7	83 c4 08	 add	 esp, 8
  008ca	85 c0		 test	 eax, eax
  008cc	0f 84 d6 00 00
	00		 je	 $L64629

; 285  : 		HSEQUENCE sequence = NULL;

  008d2	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _sequence$64620[ebp], 0

; 286  : 
; 287  : 		for ( int i=0; i<_MAX_MIDI; i++ ) {

  008d9	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$64621[ebp], 0
  008e0	eb 09		 jmp	 SHORT $L64622
$L64623:
  008e2	8b 45 ec	 mov	 eax, DWORD PTR _i$64621[ebp]
  008e5	83 c0 01	 add	 eax, 1
  008e8	89 45 ec	 mov	 DWORD PTR _i$64621[ebp], eax
$L64622:
  008eb	83 7d ec 10	 cmp	 DWORD PTR _i$64621[ebp], 16 ; 00000010H
  008ef	7d 2b		 jge	 SHORT $L64624

; 288  : 			sequence = (HSEQUENCE)midiTbl[i];

  008f1	8b 4d ec	 mov	 ecx, DWORD PTR _i$64621[ebp]
  008f4	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  008f7	8b 84 8a c0 04
	00 00		 mov	 eax, DWORD PTR [edx+ecx*4+1216]
  008fe	89 45 e8	 mov	 DWORD PTR _sequence$64620[ebp], eax

; 289  : 
; 290  : 			if ( midiDataTbl[i] == NULL ) {

  00901	8b 4d ec	 mov	 ecx, DWORD PTR _i$64621[ebp]
  00904	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00907	83 bc 8a 00 05
	00 00 00	 cmp	 DWORD PTR [edx+ecx*4+1280], 0
  0090f	75 02		 jne	 SHORT $L64626

; 291  : 				break;

  00911	eb 09		 jmp	 SHORT $L64624
$L64626:

; 293  : 
; 294  : 			sequence = NULL;

  00913	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _sequence$64620[ebp], 0

; 295  : 		}

  0091a	eb c6		 jmp	 SHORT $L64623
$L64624:

; 296  : 
; 297  : 		if ( sequence ) {

  0091c	83 7d e8 00	 cmp	 DWORD PTR _sequence$64620[ebp], 0
  00920	0f 84 82 00 00
	00		 je	 $L64629

; 298  : 			void far *data = resMgr.load ( name );

  00926	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  00929	50		 push	 eax
  0092a	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0092d	81 c1 0c 19 00
	00		 add	 ecx, 6412		; 0000190cH
  00933	e8 00 00 00 00	 call	 ?load@SoundResMgr@@QAEPAXPAD@Z ; SoundResMgr::load
  00938	89 45 e4	 mov	 DWORD PTR _data$64628[ebp], eax

; 299  : 
; 300  : 			if ( data ) {

  0093b	83 7d e4 00	 cmp	 DWORD PTR _data$64628[ebp], 0
  0093f	74 67		 je	 SHORT $L64629

; 301  : 				// find a new sndID
; 302  : 				int id = allocateSndID();

  00941	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00944	e8 00 00 00 00	 call	 ?allocateSndID@SoundMgr@@QAEHXZ ; SoundMgr::allocateSndID
  00949	89 45 e0	 mov	 DWORD PTR _id$64630[ebp], eax

; 303  : 				midiIDTbl[i] = id;

  0094c	8b 4d ec	 mov	 ecx, DWORD PTR _i$64621[ebp]
  0094f	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00952	8b 45 e0	 mov	 eax, DWORD PTR _id$64630[ebp]
  00955	89 84 8a 40 05
	00 00		 mov	 DWORD PTR [edx+ecx*4+1344], eax

; 304  : 			
; 305  : 				midiDataTbl[i] = data;

  0095c	8b 4d ec	 mov	 ecx, DWORD PTR _i$64621[ebp]
  0095f	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00962	8b 45 e4	 mov	 eax, DWORD PTR _data$64628[ebp]
  00965	89 84 8a 00 05
	00 00		 mov	 DWORD PTR [edx+ecx*4+1280], eax

; 306  : 
; 307  : 				AIL_init_sequence ( sequence, data, 0 );

  0096c	6a 00		 push	 0
  0096e	8b 4d e4	 mov	 ecx, DWORD PTR _data$64628[ebp]
  00971	51		 push	 ecx
  00972	8b 55 e8	 mov	 edx, DWORD PTR _sequence$64620[ebp]
  00975	52		 push	 edx
  00976	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_init_sequence@12

; 308  : 				AIL_register_sequence_callback ( sequence, sequenceDoneCallback );

  0097c	68 00 00 00 00	 push	 OFFSET FLAT:?sequenceDoneCallback@@YGXPAU_SEQUENCE@@@Z ; sequenceDoneCallback
  00981	8b 45 e8	 mov	 eax, DWORD PTR _sequence$64620[ebp]
  00984	50		 push	 eax
  00985	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_register_sequence_callback@8

; 309  : 				AIL_set_sequence_loop_count ( sequence, loopCount );

  0098b	8b 4d 0c	 mov	 ecx, DWORD PTR _loopCount$[ebp]
  0098e	51		 push	 ecx
  0098f	8b 55 e8	 mov	 edx, DWORD PTR _sequence$64620[ebp]
  00992	52		 push	 edx
  00993	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_set_sequence_loop_count@8

; 310  : 				AIL_start_sequence ( sequence );

  00999	8b 45 e8	 mov	 eax, DWORD PTR _sequence$64620[ebp]
  0099c	50		 push	 eax
  0099d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_start_sequence@4

; 311  : 
; 312  : 				return id;

  009a3	8b 45 e0	 mov	 eax, DWORD PTR _id$64630[ebp]
  009a6	eb 03		 jmp	 SHORT $L64601
$L64629:

; 316  : #endif
; 317  : 
; 318  : 	return -1;

  009a8	83 c8 ff	 or	 eax, -1
$L64601:

; 319  : }

  009ab	8b e5		 mov	 esp, ebp
  009ad	5d		 pop	 ebp
  009ae	c2 08 00	 ret	 8
?play@SoundMgr@@QAEHPADH@Z ENDP				; SoundMgr::play
_TEXT	ENDS
PUBLIC	?findSfxByID@SoundMgr@@QAEPAXH@Z		; SoundMgr::findSfxByID
_TEXT	SEGMENT
_id$ = 8
_this$ = -8
_i$64636 = -4
?findSfxByID@SoundMgr@@QAEPAXH@Z PROC NEAR		; SoundMgr::findSfxByID

; 322  : {

  009b1	55		 push	 ebp
  009b2	8b ec		 mov	 ebp, esp
  009b4	83 ec 08	 sub	 esp, 8
  009b7	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 323  : 	if ( dig ) {

  009ba	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  009bd	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  009c1	74 38		 je	 SHORT $L64639

; 324  : 		for ( int i=0; i<_MAX_SFX; i++ ) {

  009c3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$64636[ebp], 0
  009ca	eb 09		 jmp	 SHORT $L64637
$L64638:
  009cc	8b 4d fc	 mov	 ecx, DWORD PTR _i$64636[ebp]
  009cf	83 c1 01	 add	 ecx, 1
  009d2	89 4d fc	 mov	 DWORD PTR _i$64636[ebp], ecx
$L64637:
  009d5	83 7d fc 64	 cmp	 DWORD PTR _i$64636[ebp], 100 ; 00000064H
  009d9	7d 20		 jge	 SHORT $L64639

; 325  : 			if ( sfxIDTbl[i] == id )

  009db	8b 55 fc	 mov	 edx, DWORD PTR _i$64636[ebp]
  009de	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  009e1	8b 8c 90 30 03
	00 00		 mov	 ecx, DWORD PTR [eax+edx*4+816]
  009e8	3b 4d 08	 cmp	 ecx, DWORD PTR _id$[ebp]
  009eb	75 0c		 jne	 SHORT $L64640

; 326  : 				return sfxTbl[i];

  009ed	8b 55 fc	 mov	 edx, DWORD PTR _i$64636[ebp]
  009f0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  009f3	8b 44 90 10	 mov	 eax, DWORD PTR [eax+edx*4+16]
  009f7	eb 04		 jmp	 SHORT $L64634
$L64640:

; 327  : 		}

  009f9	eb d1		 jmp	 SHORT $L64638
$L64639:

; 329  : 
; 330  : 	return NULL;

  009fb	33 c0		 xor	 eax, eax
$L64634:

; 331  : }

  009fd	8b e5		 mov	 esp, ebp
  009ff	5d		 pop	 ebp
  00a00	c2 04 00	 ret	 4
?findSfxByID@SoundMgr@@QAEPAXH@Z ENDP			; SoundMgr::findSfxByID
_TEXT	ENDS
PUBLIC	?findMIDIByID@SoundMgr@@QAEPAXH@Z		; SoundMgr::findMIDIByID
_TEXT	SEGMENT
_id$ = 8
_this$ = -8
_i$64646 = -4
?findMIDIByID@SoundMgr@@QAEPAXH@Z PROC NEAR		; SoundMgr::findMIDIByID

; 334  : {

  00a03	55		 push	 ebp
  00a04	8b ec		 mov	 ebp, esp
  00a06	83 ec 08	 sub	 esp, 8
  00a09	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 335  : 	if ( mid ) {

  00a0c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00a0f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00a13	74 3b		 je	 SHORT $L64649

; 336  : 		for ( int i=0; i<_MAX_MIDI; i++ ) {

  00a15	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$64646[ebp], 0
  00a1c	eb 09		 jmp	 SHORT $L64647
$L64648:
  00a1e	8b 4d fc	 mov	 ecx, DWORD PTR _i$64646[ebp]
  00a21	83 c1 01	 add	 ecx, 1
  00a24	89 4d fc	 mov	 DWORD PTR _i$64646[ebp], ecx
$L64647:
  00a27	83 7d fc 10	 cmp	 DWORD PTR _i$64646[ebp], 16 ; 00000010H
  00a2b	7d 23		 jge	 SHORT $L64649

; 337  : 			if ( midiIDTbl[i] == id )

  00a2d	8b 55 fc	 mov	 edx, DWORD PTR _i$64646[ebp]
  00a30	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00a33	8b 8c 90 40 05
	00 00		 mov	 ecx, DWORD PTR [eax+edx*4+1344]
  00a3a	3b 4d 08	 cmp	 ecx, DWORD PTR _id$[ebp]
  00a3d	75 0f		 jne	 SHORT $L64650

; 338  : 				return midiTbl[i];

  00a3f	8b 55 fc	 mov	 edx, DWORD PTR _i$64646[ebp]
  00a42	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00a45	8b 84 90 c0 04
	00 00		 mov	 eax, DWORD PTR [eax+edx*4+1216]
  00a4c	eb 04		 jmp	 SHORT $L64644
$L64650:

; 339  : 		}

  00a4e	eb ce		 jmp	 SHORT $L64648
$L64649:

; 341  : 
; 342  : 	return NULL;

  00a50	33 c0		 xor	 eax, eax
$L64644:

; 343  : }

  00a52	8b e5		 mov	 esp, ebp
  00a54	5d		 pop	 ebp
  00a55	c2 04 00	 ret	 4
?findMIDIByID@SoundMgr@@QAEPAXH@Z ENDP			; SoundMgr::findMIDIByID
_TEXT	ENDS
PUBLIC	?stop@SoundMgr@@QAEHH@Z				; SoundMgr::stop
EXTRN	__imp__AIL_end_sample@4:NEAR
EXTRN	__imp__AIL_end_sequence@4:NEAR
_TEXT	SEGMENT
_handle$ = 8
_this$ = -12
_sample$64656 = -4
_sequence$64660 = -8
?stop@SoundMgr@@QAEHH@Z PROC NEAR			; SoundMgr::stop

; 346  : {

  00a58	55		 push	 ebp
  00a59	8b ec		 mov	 ebp, esp
  00a5b	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00a5e	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 347  : #ifdef _SOUND_ENABLED
; 348  : 	if ( dig ) {

  00a61	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00a64	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00a68	74 26		 je	 SHORT $L64658

; 349  : 		HSAMPLE sample = (HSAMPLE)findSfxByID ( handle );

  00a6a	8b 4d 08	 mov	 ecx, DWORD PTR _handle$[ebp]
  00a6d	51		 push	 ecx
  00a6e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00a71	e8 00 00 00 00	 call	 ?findSfxByID@SoundMgr@@QAEPAXH@Z ; SoundMgr::findSfxByID
  00a76	89 45 fc	 mov	 DWORD PTR _sample$64656[ebp], eax

; 350  : 	
; 351  : 		if ( sample ) {

  00a79	83 7d fc 00	 cmp	 DWORD PTR _sample$64656[ebp], 0
  00a7d	74 11		 je	 SHORT $L64658

; 352  : 			AIL_end_sample ( sample );

  00a7f	8b 55 fc	 mov	 edx, DWORD PTR _sample$64656[ebp]
  00a82	52		 push	 edx
  00a83	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_end_sample@4

; 353  : 			return 1;

  00a89	b8 01 00 00 00	 mov	 eax, 1
  00a8e	eb 32		 jmp	 SHORT $L64654
$L64658:

; 356  : 
; 357  : 	if ( mid ) {

  00a90	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00a93	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00a97	74 26		 je	 SHORT $L64662

; 358  : 		HSEQUENCE sequence = (HSEQUENCE)findMIDIByID ( handle );

  00a99	8b 4d 08	 mov	 ecx, DWORD PTR _handle$[ebp]
  00a9c	51		 push	 ecx
  00a9d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00aa0	e8 00 00 00 00	 call	 ?findMIDIByID@SoundMgr@@QAEPAXH@Z ; SoundMgr::findMIDIByID
  00aa5	89 45 f8	 mov	 DWORD PTR _sequence$64660[ebp], eax

; 359  : 	
; 360  : 		if ( sequence ) {

  00aa8	83 7d f8 00	 cmp	 DWORD PTR _sequence$64660[ebp], 0
  00aac	74 11		 je	 SHORT $L64662

; 361  : 			AIL_end_sequence ( sequence );

  00aae	8b 55 f8	 mov	 edx, DWORD PTR _sequence$64660[ebp]
  00ab1	52		 push	 edx
  00ab2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_end_sequence@4

; 362  : 			return 1;

  00ab8	b8 01 00 00 00	 mov	 eax, 1
  00abd	eb 03		 jmp	 SHORT $L64654
$L64662:

; 365  : #endif
; 366  : 
; 367  : 	return -1;

  00abf	83 c8 ff	 or	 eax, -1
$L64654:

; 368  : }

  00ac2	8b e5		 mov	 esp, ebp
  00ac4	5d		 pop	 ebp
  00ac5	c2 04 00	 ret	 4
?stop@SoundMgr@@QAEHH@Z ENDP				; SoundMgr::stop
_TEXT	ENDS
PUBLIC	?setPan@SoundMgr@@QAEHHH@Z			; SoundMgr::setPan
EXTRN	__imp__AIL_set_sample_pan@8:NEAR
_TEXT	SEGMENT
_handle$ = 8
_pan$ = 12
_this$ = -8
_sample$ = -4
?setPan@SoundMgr@@QAEHHH@Z PROC NEAR			; SoundMgr::setPan

; 371  : {

  00ac8	55		 push	 ebp
  00ac9	8b ec		 mov	 ebp, esp
  00acb	83 ec 08	 sub	 esp, 8
  00ace	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 372  : #ifdef _SOUND_ENABLED
; 373  : 	HSAMPLE sample = (HSAMPLE)findSfxByID ( handle );

  00ad1	8b 45 08	 mov	 eax, DWORD PTR _handle$[ebp]
  00ad4	50		 push	 eax
  00ad5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00ad8	e8 00 00 00 00	 call	 ?findSfxByID@SoundMgr@@QAEPAXH@Z ; SoundMgr::findSfxByID
  00add	89 45 fc	 mov	 DWORD PTR _sample$[ebp], eax

; 374  : 
; 375  : 	if ( sample ) {

  00ae0	83 7d fc 00	 cmp	 DWORD PTR _sample$[ebp], 0
  00ae4	74 15		 je	 SHORT $L64670

; 376  : 		AIL_set_sample_pan ( sample, pan );

  00ae6	8b 4d 0c	 mov	 ecx, DWORD PTR _pan$[ebp]
  00ae9	51		 push	 ecx
  00aea	8b 55 fc	 mov	 edx, DWORD PTR _sample$[ebp]
  00aed	52		 push	 edx
  00aee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_set_sample_pan@8

; 377  : 		return 1;

  00af4	b8 01 00 00 00	 mov	 eax, 1
  00af9	eb 03		 jmp	 SHORT $L64667
$L64670:

; 379  : #endif
; 380  : 
; 381  : 	return -1;

  00afb	83 c8 ff	 or	 eax, -1
$L64667:

; 382  : }

  00afe	8b e5		 mov	 esp, ebp
  00b00	5d		 pop	 ebp
  00b01	c2 08 00	 ret	 8
?setPan@SoundMgr@@QAEHHH@Z ENDP				; SoundMgr::setPan
_TEXT	ENDS
PUBLIC	?setVolume@SoundMgr@@QAEHHH@Z			; SoundMgr::setVolume
EXTRN	__imp__AIL_set_sample_volume@8:NEAR
EXTRN	__imp__AIL_set_sequence_volume@12:NEAR
_TEXT	SEGMENT
_handle$ = 8
_volume$ = 12
_this$ = -12
_sample$ = -4
_sequence$ = -8
?setVolume@SoundMgr@@QAEHHH@Z PROC NEAR			; SoundMgr::setVolume

; 385  : {

  00b04	55		 push	 ebp
  00b05	8b ec		 mov	 ebp, esp
  00b07	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00b0a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 386  : #ifdef _SOUND_ENABLED
; 387  : 	HSAMPLE sample = (HSAMPLE)findSfxByID ( handle );

  00b0d	8b 45 08	 mov	 eax, DWORD PTR _handle$[ebp]
  00b10	50		 push	 eax
  00b11	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00b14	e8 00 00 00 00	 call	 ?findSfxByID@SoundMgr@@QAEPAXH@Z ; SoundMgr::findSfxByID
  00b19	89 45 fc	 mov	 DWORD PTR _sample$[ebp], eax

; 388  : 
; 389  : 	if ( sample ) {

  00b1c	83 7d fc 00	 cmp	 DWORD PTR _sample$[ebp], 0
  00b20	74 15		 je	 SHORT $L64678

; 390  : 		AIL_set_sample_volume ( sample, volume );

  00b22	8b 4d 0c	 mov	 ecx, DWORD PTR _volume$[ebp]
  00b25	51		 push	 ecx
  00b26	8b 55 fc	 mov	 edx, DWORD PTR _sample$[ebp]
  00b29	52		 push	 edx
  00b2a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_set_sample_volume@8

; 391  : 		return 1;

  00b30	b8 01 00 00 00	 mov	 eax, 1
  00b35	eb 2f		 jmp	 SHORT $L64675
$L64678:

; 393  : 
; 394  : 	HSEQUENCE sequence = (HSEQUENCE)findMIDIByID ( handle );

  00b37	8b 45 08	 mov	 eax, DWORD PTR _handle$[ebp]
  00b3a	50		 push	 eax
  00b3b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00b3e	e8 00 00 00 00	 call	 ?findMIDIByID@SoundMgr@@QAEPAXH@Z ; SoundMgr::findMIDIByID
  00b43	89 45 f8	 mov	 DWORD PTR _sequence$[ebp], eax

; 395  : 
; 396  : 	if ( sequence ) {

  00b46	83 7d f8 00	 cmp	 DWORD PTR _sequence$[ebp], 0
  00b4a	74 17		 je	 SHORT $L64681

; 397  : 		AIL_set_sequence_volume ( sequence, volume, 0 );

  00b4c	6a 00		 push	 0
  00b4e	8b 4d 0c	 mov	 ecx, DWORD PTR _volume$[ebp]
  00b51	51		 push	 ecx
  00b52	8b 55 f8	 mov	 edx, DWORD PTR _sequence$[ebp]
  00b55	52		 push	 edx
  00b56	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_set_sequence_volume@12

; 398  : 		return 1;

  00b5c	b8 01 00 00 00	 mov	 eax, 1
  00b61	eb 03		 jmp	 SHORT $L64675
$L64681:

; 400  : #endif
; 401  : 
; 402  : 	return -1;

  00b63	83 c8 ff	 or	 eax, -1
$L64675:

; 403  : }

  00b66	8b e5		 mov	 esp, ebp
  00b68	5d		 pop	 ebp
  00b69	c2 08 00	 ret	 8
?setVolume@SoundMgr@@QAEHHH@Z ENDP			; SoundMgr::setVolume
_TEXT	ENDS
PUBLIC	?getSfxMasterVolume@SoundMgr@@QAEHXZ		; SoundMgr::getSfxMasterVolume
EXTRN	__imp__AIL_digital_master_volume@4:NEAR
_TEXT	SEGMENT
_this$ = -4
?getSfxMasterVolume@SoundMgr@@QAEHXZ PROC NEAR		; SoundMgr::getSfxMasterVolume

; 407  : {

  00b6c	55		 push	 ebp
  00b6d	8b ec		 mov	 ebp, esp
  00b6f	51		 push	 ecx
  00b70	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 408  : #ifdef _SOUND_ENABLED
; 409  : 	if ( dig )

  00b73	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b76	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00b7a	74 0f		 je	 SHORT $L64685

; 410  : 		return AIL_digital_master_volume( (HDIGDRIVER) dig );

  00b7c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b7f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00b82	52		 push	 edx
  00b83	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_digital_master_volume@4
  00b89	eb 03		 jmp	 SHORT $L64684
$L64685:

; 411  : #endif
; 412  : 
; 413  : 	return -1;

  00b8b	83 c8 ff	 or	 eax, -1
$L64684:

; 414  : }

  00b8e	8b e5		 mov	 esp, ebp
  00b90	5d		 pop	 ebp
  00b91	c3		 ret	 0
?getSfxMasterVolume@SoundMgr@@QAEHXZ ENDP		; SoundMgr::getSfxMasterVolume
_TEXT	ENDS
PUBLIC	?setSfxMasterVolume@SoundMgr@@QAEHH@Z		; SoundMgr::setSfxMasterVolume
EXTRN	__imp__AIL_set_digital_master_volume@8:NEAR
_TEXT	SEGMENT
_volume$ = 8
_this$ = -4
?setSfxMasterVolume@SoundMgr@@QAEHH@Z PROC NEAR		; SoundMgr::setSfxMasterVolume

; 418  : {

  00b92	55		 push	 ebp
  00b93	8b ec		 mov	 ebp, esp
  00b95	51		 push	 ecx
  00b96	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 419  : #ifdef _SOUND_ENABLED
; 420  : 	if ( dig )

  00b99	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b9c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00ba0	74 11		 je	 SHORT $L64691

; 421  : 		AIL_set_digital_master_volume( (HDIGDRIVER) dig, volume );

  00ba2	8b 4d 08	 mov	 ecx, DWORD PTR _volume$[ebp]
  00ba5	51		 push	 ecx
  00ba6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00ba9	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00bac	50		 push	 eax
  00bad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_set_digital_master_volume@8
$L64691:

; 422  : 
; 423  : 	return 1;

  00bb3	b8 01 00 00 00	 mov	 eax, 1

; 424  : #endif
; 425  : 
; 426  : 	return -1;
; 427  : }

  00bb8	8b e5		 mov	 esp, ebp
  00bba	5d		 pop	 ebp
  00bbb	c2 04 00	 ret	 4
?setSfxMasterVolume@SoundMgr@@QAEHH@Z ENDP		; SoundMgr::setSfxMasterVolume
_TEXT	ENDS
PUBLIC	?getMidiMasterVolume@SoundMgr@@QAEHXZ		; SoundMgr::getMidiMasterVolume
EXTRN	__imp__AIL_XMIDI_master_volume@4:NEAR
_TEXT	SEGMENT
_this$ = -4
?getMidiMasterVolume@SoundMgr@@QAEHXZ PROC NEAR		; SoundMgr::getMidiMasterVolume

; 431  : {

  00bbe	55		 push	 ebp
  00bbf	8b ec		 mov	 ebp, esp
  00bc1	51		 push	 ecx
  00bc2	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 432  : #ifdef _SOUND_ENABLED
; 433  : 	if ( mid )

  00bc5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00bc8	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00bcc	74 0f		 je	 SHORT $L64696

; 434  : 		return AIL_XMIDI_master_volume( (HMDIDRIVER) mid );

  00bce	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00bd1	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00bd4	52		 push	 edx
  00bd5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_XMIDI_master_volume@4
  00bdb	eb 03		 jmp	 SHORT $L64695
$L64696:

; 435  : #endif
; 436  : 
; 437  : 	return -1;

  00bdd	83 c8 ff	 or	 eax, -1
$L64695:

; 438  : }

  00be0	8b e5		 mov	 esp, ebp
  00be2	5d		 pop	 ebp
  00be3	c3		 ret	 0
?getMidiMasterVolume@SoundMgr@@QAEHXZ ENDP		; SoundMgr::getMidiMasterVolume
_TEXT	ENDS
PUBLIC	?setMidiMasterVolume@SoundMgr@@QAEHH@Z		; SoundMgr::setMidiMasterVolume
EXTRN	__imp__AIL_set_XMIDI_master_volume@8:NEAR
_TEXT	SEGMENT
_volume$ = 8
_this$ = -4
?setMidiMasterVolume@SoundMgr@@QAEHH@Z PROC NEAR	; SoundMgr::setMidiMasterVolume

; 442  : {

  00be4	55		 push	 ebp
  00be5	8b ec		 mov	 ebp, esp
  00be7	51		 push	 ecx
  00be8	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 443  : #ifdef _SOUND_ENABLED
; 444  : 	if ( mid )

  00beb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00bee	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00bf2	74 11		 je	 SHORT $L64702

; 445  : 		AIL_set_XMIDI_master_volume( (HMDIDRIVER) mid, volume );

  00bf4	8b 4d 08	 mov	 ecx, DWORD PTR _volume$[ebp]
  00bf7	51		 push	 ecx
  00bf8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00bfb	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00bfe	50		 push	 eax
  00bff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_set_XMIDI_master_volume@8
$L64702:

; 446  : 
; 447  : 	return 1;

  00c05	b8 01 00 00 00	 mov	 eax, 1

; 448  : #endif
; 449  : 
; 450  : 	return -1;
; 451  : }

  00c0a	8b e5		 mov	 esp, ebp
  00c0c	5d		 pop	 ebp
  00c0d	c2 04 00	 ret	 4
?setMidiMasterVolume@SoundMgr@@QAEHH@Z ENDP		; SoundMgr::setMidiMasterVolume
_TEXT	ENDS
PUBLIC	?setLoopCount@SoundMgr@@QAEHHH@Z		; SoundMgr::setLoopCount
_TEXT	SEGMENT
_handle$ = 8
_count$ = 12
_this$ = -12
_sample$ = -4
_sequence$ = -8
?setLoopCount@SoundMgr@@QAEHHH@Z PROC NEAR		; SoundMgr::setLoopCount

; 454  : {

  00c10	55		 push	 ebp
  00c11	8b ec		 mov	 ebp, esp
  00c13	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00c16	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 455  : #ifdef _SOUND_ENABLED
; 456  : 	HSAMPLE sample = (HSAMPLE)findSfxByID ( handle );

  00c19	8b 45 08	 mov	 eax, DWORD PTR _handle$[ebp]
  00c1c	50		 push	 eax
  00c1d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00c20	e8 00 00 00 00	 call	 ?findSfxByID@SoundMgr@@QAEPAXH@Z ; SoundMgr::findSfxByID
  00c25	89 45 fc	 mov	 DWORD PTR _sample$[ebp], eax

; 457  : 
; 458  : 	if ( sample ) {

  00c28	83 7d fc 00	 cmp	 DWORD PTR _sample$[ebp], 0
  00c2c	74 15		 je	 SHORT $L64711

; 459  : 		AIL_set_sample_loop_count ( sample, count );

  00c2e	8b 4d 0c	 mov	 ecx, DWORD PTR _count$[ebp]
  00c31	51		 push	 ecx
  00c32	8b 55 fc	 mov	 edx, DWORD PTR _sample$[ebp]
  00c35	52		 push	 edx
  00c36	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_set_sample_loop_count@8

; 460  : 		return 1;

  00c3c	b8 01 00 00 00	 mov	 eax, 1
  00c41	eb 2d		 jmp	 SHORT $L64708
$L64711:

; 462  : 
; 463  : 	HSEQUENCE sequence = (HSEQUENCE)findMIDIByID ( handle );

  00c43	8b 45 08	 mov	 eax, DWORD PTR _handle$[ebp]
  00c46	50		 push	 eax
  00c47	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00c4a	e8 00 00 00 00	 call	 ?findMIDIByID@SoundMgr@@QAEPAXH@Z ; SoundMgr::findMIDIByID
  00c4f	89 45 f8	 mov	 DWORD PTR _sequence$[ebp], eax

; 464  : 
; 465  : 	if ( sequence ) {

  00c52	83 7d f8 00	 cmp	 DWORD PTR _sequence$[ebp], 0
  00c56	74 15		 je	 SHORT $L64714

; 466  : 		AIL_set_sequence_loop_count ( sequence, count );

  00c58	8b 4d 0c	 mov	 ecx, DWORD PTR _count$[ebp]
  00c5b	51		 push	 ecx
  00c5c	8b 55 f8	 mov	 edx, DWORD PTR _sequence$[ebp]
  00c5f	52		 push	 edx
  00c60	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_set_sequence_loop_count@8

; 467  : 		return 1;

  00c66	b8 01 00 00 00	 mov	 eax, 1
  00c6b	eb 03		 jmp	 SHORT $L64708
$L64714:

; 469  : #endif
; 470  : 
; 471  : 	return -1;

  00c6d	83 c8 ff	 or	 eax, -1
$L64708:

; 472  : }

  00c70	8b e5		 mov	 esp, ebp
  00c72	5d		 pop	 ebp
  00c73	c2 08 00	 ret	 8
?setLoopCount@SoundMgr@@QAEHHH@Z ENDP			; SoundMgr::setLoopCount
_TEXT	ENDS
PUBLIC	??_7SoundResMgr@@6B@				; SoundResMgr::`vftable'
PUBLIC	??_GSoundResMgr@@UAEPAXI@Z			; SoundResMgr::`scalar deleting destructor'
PUBLIC	??_ESoundResMgr@@UAEPAXI@Z			; SoundResMgr::`vector deleting destructor'
;	COMDAT ??_7SoundResMgr@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\Sound.cpp
CONST	SEGMENT
??_7SoundResMgr@@6B@ DD FLAT:??_ESoundResMgr@@UAEPAXI@Z	; SoundResMgr::`vftable'
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4
??0SoundResMgr@@QAE@XZ PROC NEAR			; SoundResMgr::SoundResMgr

; 475  : {

  00c76	55		 push	 ebp
  00c77	8b ec		 mov	 ebp, esp
  00c79	51		 push	 ecx
  00c7a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00c7d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00c80	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7SoundResMgr@@6B@ ; SoundResMgr::`vftable'

; 476  : 	count = 0;

  00c86	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c89	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 477  : 	memset ( &resources, 0, sizeof ( resources ) );

  00c90	68 00 1c 00 00	 push	 7168			; 00001c00H
  00c95	6a 00		 push	 0
  00c97	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00c9a	83 c2 08	 add	 edx, 8
  00c9d	52		 push	 edx
  00c9e	e8 00 00 00 00	 call	 _memset
  00ca3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 478  : }

  00ca6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00ca9	8b e5		 mov	 esp, ebp
  00cab	5d		 pop	 ebp
  00cac	c3		 ret	 0
??0SoundResMgr@@QAE@XZ ENDP				; SoundResMgr::SoundResMgr
_TEXT	ENDS
;	COMDAT ??_GSoundResMgr@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GSoundResMgr@@UAEPAXI@Z PROC NEAR			; SoundResMgr::`scalar deleting destructor', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1SoundResMgr@@UAE@XZ	; SoundResMgr::~SoundResMgr
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L64721
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L64721:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GSoundResMgr@@UAEPAXI@Z ENDP				; SoundResMgr::`scalar deleting destructor'
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4
??1SoundResMgr@@UAE@XZ PROC NEAR			; SoundResMgr::~SoundResMgr

; 481  : {

  00cad	55		 push	 ebp
  00cae	8b ec		 mov	 ebp, esp
  00cb0	51		 push	 ecx
  00cb1	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00cb4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00cb7	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7SoundResMgr@@6B@ ; SoundResMgr::`vftable'

; 482  : }

  00cbd	8b e5		 mov	 esp, ebp
  00cbf	5d		 pop	 ebp
  00cc0	c3		 ret	 0
??1SoundResMgr@@UAE@XZ ENDP				; SoundResMgr::~SoundResMgr
_TEXT	ENDS
EXTRN	__imp__AIL_mem_free_lock@4:NEAR
EXTRN	__imp__AIL_file_size@4:NEAR
EXTRN	__imp__AIL_file_read@8:NEAR
EXTRN	__imp__sprintf:NEAR
EXTRN	_strcpy:NEAR
EXTRN	_strcmp:NEAR
_DATA	SEGMENT
	ORG $+3
$SG64747 DB	'%s\%s', 00H
_DATA	ENDS
_TEXT	SEGMENT
_name$ = 8
_this$ = -1036
_i$ = -4
_filename$64746 = -1032
_size$64749 = -8
?load@SoundResMgr@@QAEPAXPAD@Z PROC NEAR		; SoundResMgr::load

; 485  : {

  00cc1	55		 push	 ebp
  00cc2	8b ec		 mov	 ebp, esp
  00cc4	81 ec 0c 04 00
	00		 sub	 esp, 1036		; 0000040cH
  00cca	89 8d f4 fb ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 486  : 	int i;
; 487  : #ifdef _SOUND_ENABLED
; 488  : 	// look for the resource to already be loaded
; 489  : 	for (i=0; i<_MAX_SND_RES; i++ ) {

  00cd0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00cd7	eb 09		 jmp	 SHORT $L64730
$L64731:
  00cd9	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00cdc	83 c0 01	 add	 eax, 1
  00cdf	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L64730:
  00ce2	81 7d fc 00 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 256	; 00000100H
  00ce9	7d 6e		 jge	 SHORT $L64732

; 490  : 		if ( resources[i].data != NULL && !strcmp ( resources[i].name, name ) ) {

  00ceb	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00cee	6b c9 1c	 imul	 ecx, 28			; 0000001cH
  00cf1	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00cf7	83 7c 0a 18 00	 cmp	 DWORD PTR [edx+ecx+24], 0
  00cfc	74 59		 je	 SHORT $L64733
  00cfe	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  00d01	50		 push	 eax
  00d02	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00d05	6b c9 1c	 imul	 ecx, 28			; 0000001cH
  00d08	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00d0e	8d 44 0a 08	 lea	 eax, DWORD PTR [edx+ecx+8]
  00d12	50		 push	 eax
  00d13	e8 00 00 00 00	 call	 _strcmp
  00d18	83 c4 08	 add	 esp, 8
  00d1b	85 c0		 test	 eax, eax
  00d1d	75 38		 jne	 SHORT $L64733

; 491  : 			resources[i].refCount++;

  00d1f	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00d22	6b c9 1c	 imul	 ecx, 28			; 0000001cH
  00d25	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00d2b	8b 44 0a 20	 mov	 eax, DWORD PTR [edx+ecx+32]
  00d2f	83 c0 01	 add	 eax, 1
  00d32	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00d35	6b c9 1c	 imul	 ecx, 28			; 0000001cH
  00d38	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00d3e	89 44 0a 20	 mov	 DWORD PTR [edx+ecx+32], eax

; 492  : 			return resources[i].data;

  00d42	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00d45	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00d48	8b 8d f4 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00d4e	8b 44 01 18	 mov	 eax, DWORD PTR [ecx+eax+24]
  00d52	e9 a0 01 00 00	 jmp	 $L64728
$L64733:

; 494  : 	}

  00d57	eb 80		 jmp	 SHORT $L64731
$L64732:

; 495  : 
; 496  : 	// scan and free sound resources until we have less than 500K taken up
; 497  : 	while ( gSoundMemory > (500 * 1024) ) {

  00d59	81 3d 00 00 00
	00 00 d0 07 00	 cmp	 DWORD PTR ?gSoundMemory@@3HA, 512000 ; gSoundMemory, 0007d000H
  00d63	0f 8e 9f 00 00
	00		 jle	 $L64736

; 498  : 		for ( i=0; i<_MAX_SND_RES; i++ ) {

  00d69	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00d70	eb 09		 jmp	 SHORT $L64737
$L64738:
  00d72	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00d75	83 c2 01	 add	 edx, 1
  00d78	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$L64737:
  00d7b	81 7d fc 00 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 256	; 00000100H
  00d82	7d 74		 jge	 SHORT $L64739

; 499  : 			if ( (resources[i].data != NULL) && !resources[i].refCount ) {

  00d84	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00d87	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00d8a	8b 8d f4 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00d90	83 7c 01 18 00	 cmp	 DWORD PTR [ecx+eax+24], 0
  00d95	74 5c		 je	 SHORT $L64740
  00d97	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00d9a	6b d2 1c	 imul	 edx, 28			; 0000001cH
  00d9d	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00da3	83 7c 10 20 00	 cmp	 DWORD PTR [eax+edx+32], 0
  00da8	75 49		 jne	 SHORT $L64740

; 500  : 				AIL_mem_free_lock ( resources[i].data );

  00daa	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00dad	6b c9 1c	 imul	 ecx, 28			; 0000001cH
  00db0	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00db6	8b 44 0a 18	 mov	 eax, DWORD PTR [edx+ecx+24]
  00dba	50		 push	 eax
  00dbb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_mem_free_lock@4

; 501  : 				resources[i].data = NULL;

  00dc1	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00dc4	6b c9 1c	 imul	 ecx, 28			; 0000001cH
  00dc7	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00dcd	c7 44 0a 18 00
	00 00 00	 mov	 DWORD PTR [edx+ecx+24], 0

; 502  : 
; 503  : 				gSoundMemory -= resources[i].size;

  00dd5	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00dd8	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00ddb	8b 8d f4 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00de1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gSoundMemory@@3HA ; gSoundMemory
  00de7	2b 54 01 1c	 sub	 edx, DWORD PTR [ecx+eax+28]
  00deb	89 15 00 00 00
	00		 mov	 DWORD PTR ?gSoundMemory@@3HA, edx ; gSoundMemory

; 504  : 
; 505  : 				break;

  00df1	eb 05		 jmp	 SHORT $L64739
$L64740:

; 507  : 		}

  00df3	e9 7a ff ff ff	 jmp	 $L64738
$L64739:

; 508  : 
; 509  : 		if ( i >= _MAX_SND_RES )

  00df8	81 7d fc 00 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 256	; 00000100H
  00dff	7c 02		 jl	 SHORT $L64741

; 510  : 			break;

  00e01	eb 05		 jmp	 SHORT $L64736
$L64741:

; 511  : 	}

  00e03	e9 51 ff ff ff	 jmp	 $L64732
$L64736:

; 512  : 
; 513  : 	// look for a free space in the resource list
; 514  : 	for ( i=0; i<_MAX_SND_RES; i++ ) {

  00e08	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00e0f	eb 09		 jmp	 SHORT $L64742
$L64743:
  00e11	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00e14	83 c0 01	 add	 eax, 1
  00e17	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L64742:
  00e1a	81 7d fc 00 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 256	; 00000100H
  00e21	0f 8d ce 00 00
	00		 jge	 $L64744

; 515  : 		if ( resources[i].data == NULL ) {

  00e27	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00e2a	6b c9 1c	 imul	 ecx, 28			; 0000001cH
  00e2d	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00e33	83 7c 0a 18 00	 cmp	 DWORD PTR [edx+ecx+24], 0
  00e38	0f 85 b2 00 00
	00		 jne	 $L64745

; 516  : 			char filename[1024];
; 517  : 			sprintf ( filename, "%s\\%s", gSoundDir, name );

  00e3e	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  00e41	50		 push	 eax
  00e42	68 00 00 00 00	 push	 OFFSET FLAT:?gSoundDir@@3PADA ; gSoundDir
  00e47	68 00 00 00 00	 push	 OFFSET FLAT:$SG64747
  00e4c	8d 8d f8 fb ff
	ff		 lea	 ecx, DWORD PTR _filename$64746[ebp]
  00e52	51		 push	 ecx
  00e53	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  00e59	83 c4 10	 add	 esp, 16			; 00000010H

; 518  : 
; 519  : 			strcpy ( resources[i].name, name );

  00e5c	8b 55 08	 mov	 edx, DWORD PTR _name$[ebp]
  00e5f	52		 push	 edx
  00e60	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00e63	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00e66	8b 8d f4 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00e6c	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  00e70	52		 push	 edx
  00e71	e8 00 00 00 00	 call	 _strcpy
  00e76	83 c4 08	 add	 esp, 8

; 520  : 			resources[i].refCount = 1;

  00e79	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00e7c	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00e7f	8b 8d f4 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00e85	c7 44 01 20 01
	00 00 00	 mov	 DWORD PTR [ecx+eax+32], 1

; 521  : 			resources[i].data = (void far *)AIL_file_read ( filename, NULL );

  00e8d	6a 00		 push	 0
  00e8f	8d 95 f8 fb ff
	ff		 lea	 edx, DWORD PTR _filename$64746[ebp]
  00e95	52		 push	 edx
  00e96	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_file_read@8
  00e9c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00e9f	6b c9 1c	 imul	 ecx, 28			; 0000001cH
  00ea2	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00ea8	89 44 0a 18	 mov	 DWORD PTR [edx+ecx+24], eax

; 522  : 
; 523  : 			int size = AIL_file_size ( filename );

  00eac	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _filename$64746[ebp]
  00eb2	50		 push	 eax
  00eb3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AIL_file_size@4
  00eb9	89 45 f8	 mov	 DWORD PTR _size$64749[ebp], eax

; 524  : 			resources[i].size = size;

  00ebc	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00ebf	6b c9 1c	 imul	 ecx, 28			; 0000001cH
  00ec2	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00ec8	8b 45 f8	 mov	 eax, DWORD PTR _size$64749[ebp]
  00ecb	89 44 0a 1c	 mov	 DWORD PTR [edx+ecx+28], eax

; 525  : 			gSoundMemory += size;

  00ecf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gSoundMemory@@3HA ; gSoundMemory
  00ed5	03 4d f8	 add	 ecx, DWORD PTR _size$64749[ebp]
  00ed8	89 0d 00 00 00
	00		 mov	 DWORD PTR ?gSoundMemory@@3HA, ecx ; gSoundMemory

; 526  : 
; 527  : 			return resources[i].data;

  00ede	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00ee1	6b d2 1c	 imul	 edx, 28			; 0000001cH
  00ee4	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00eea	8b 44 10 18	 mov	 eax, DWORD PTR [eax+edx+24]
  00eee	eb 07		 jmp	 SHORT $L64728
$L64745:

; 529  : 	}

  00ef0	e9 1c ff ff ff	 jmp	 $L64743
$L64744:

; 530  : #endif
; 531  : 
; 532  : 	return NULL;

  00ef5	33 c0		 xor	 eax, eax
$L64728:

; 533  : }

  00ef7	8b e5		 mov	 esp, ebp
  00ef9	5d		 pop	 ebp
  00efa	c2 04 00	 ret	 4
?load@SoundResMgr@@QAEPAXPAD@Z ENDP			; SoundResMgr::load
_ptr$ = 8
_this$ = -8
_i$ = -4
?unload@SoundResMgr@@QAEXPAX@Z PROC NEAR		; SoundResMgr::unload

; 536  : {

  00efd	55		 push	 ebp
  00efe	8b ec		 mov	 ebp, esp
  00f00	83 ec 08	 sub	 esp, 8
  00f03	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 537  : 	for ( int i=0; i<_MAX_SND_RES; i++ ) {

  00f06	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00f0d	eb 09		 jmp	 SHORT $L64755
$L64756:
  00f0f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00f12	83 c0 01	 add	 eax, 1
  00f15	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L64755:
  00f18	81 7d fc 00 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 256	; 00000100H
  00f1f	7d 33		 jge	 SHORT $L64757

; 538  : 		if ( resources[i].data == ptr ) {

  00f21	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00f24	6b c9 1c	 imul	 ecx, 28			; 0000001cH
  00f27	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00f2a	8b 44 0a 18	 mov	 eax, DWORD PTR [edx+ecx+24]
  00f2e	3b 45 08	 cmp	 eax, DWORD PTR _ptr$[ebp]
  00f31	75 1f		 jne	 SHORT $L64758

; 539  : 			resources[i].refCount--;

  00f33	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00f36	6b c9 1c	 imul	 ecx, 28			; 0000001cH
  00f39	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00f3c	8b 44 0a 20	 mov	 eax, DWORD PTR [edx+ecx+32]
  00f40	83 e8 01	 sub	 eax, 1
  00f43	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00f46	6b c9 1c	 imul	 ecx, 28			; 0000001cH
  00f49	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00f4c	89 44 0a 20	 mov	 DWORD PTR [edx+ecx+32], eax

; 540  : 			break;

  00f50	eb 02		 jmp	 SHORT $L64757
$L64758:

; 542  : 	}

  00f52	eb bb		 jmp	 SHORT $L64756
$L64757:

; 543  : }

  00f54	8b e5		 mov	 esp, ebp
  00f56	5d		 pop	 ebp
  00f57	c2 04 00	 ret	 4
?unload@SoundResMgr@@QAEXPAX@Z ENDP			; SoundResMgr::unload
_TEXT	ENDS
PUBLIC	?KSound@@YAXPAF@Z				; KSound
PUBLIC	??0MemID@@QAE@ABV0@@Z				; MemID::MemID
PUBLIC	??0MemID@@QAE@G@Z				; MemID::MemID
PUBLIC	??DMemID@@QBEPAXXZ				; MemID::operator*
EXTRN	?pm@@3VPMachine@@A:BYTE				; pm
EXTRN	__imp__rand:NEAR
_DATA	SEGMENT
	ORG $+2
_?names@?BC@??KSound@@YAXPAF@Z@4PAPADA DD FLAT:$SG64803
	DD	FLAT:$SG64804
	DD	FLAT:$SG64805
$SG64803 DB	'step1.wav', 00H
	ORG $+2
$SG64804 DB	'step2.wav', 00H
	ORG $+2
$SG64805 DB	'step3.wav', 00H
	ORG $+2
$SG64808 DB	'trmove.wav', 00H
	ORG $+1
$SG64811 DB	'minom.wav', 00H
_DATA	ENDS
_TEXT	SEGMENT
_args$ = 8
_file$64777 = -4
_view$64787 = -16
_cel$64790 = -20
_x$64791 = -24
_scaleX$64792 = -12
_frontSize$64793 = -8
_name$64794 = -28
_id$64813 = -36
_nPan$64814 = -32
$T65138 = -40
?KSound@@YAXPAF@Z PROC NEAR				; KSound

; 546  : {

  00f5a	55		 push	 ebp
  00f5b	8b ec		 mov	 ebp, esp
  00f5d	83 ec 34	 sub	 esp, 52			; 00000034H

; 547  : 	enum {
; 548  : 		SPlay,
; 549  : 		SStop,
; 550  : 		SLock,
; 551  : 		SUnlock,
; 552  : 		SSetPan,
; 553  : 		SSetPanPosn,
; 554  : 		SSetLoopCount,
; 555  : 		SDoFootStep,
; 556  : 		SMax
; 557  : 	};
; 558  : 
; 559  : 	switch ( arg ( 1 ) ) {

  00f60	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00f63	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00f67	89 4d d4	 mov	 DWORD PTR -44+[ebp], ecx
  00f6a	83 7d d4 07	 cmp	 DWORD PTR -44+[ebp], 7
  00f6e	0f 87 83 02 00
	00		 ja	 $L64773
  00f74	8b 55 d4	 mov	 edx, DWORD PTR -44+[ebp]
  00f77	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L65142[edx*4]
$L64776:

; 561  : 			MemID file = (MemID)arg(2);

  00f7e	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00f81	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  00f85	51		 push	 ecx
  00f86	8d 4d d8	 lea	 ecx, DWORD PTR $T65138[ebp]
  00f89	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  00f8e	50		 push	 eax
  00f8f	8d 4d fc	 lea	 ecx, DWORD PTR _file$64777[ebp]
  00f92	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID

; 562  : 			pm.acc = soundMgr->play ( (char *)*file, (argCount > 2)? arg(3) : 1 );

  00f97	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00f9a	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00f9d	83 f8 02	 cmp	 eax, 2
  00fa0	7e 0c		 jle	 SHORT $L65139
  00fa2	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00fa5	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00fa9	89 55 d0	 mov	 DWORD PTR -48+[ebp], edx
  00fac	eb 07		 jmp	 SHORT $L65140
$L65139:
  00fae	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR -48+[ebp], 1
$L65140:
  00fb5	8b 45 d0	 mov	 eax, DWORD PTR -48+[ebp]
  00fb8	50		 push	 eax
  00fb9	8d 4d fc	 lea	 ecx, DWORD PTR _file$64777[ebp]
  00fbc	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  00fc1	50		 push	 eax
  00fc2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?soundMgr@@3PAVSoundMgr@@A ; soundMgr
  00fc8	e8 00 00 00 00	 call	 ?play@SoundMgr@@QAEHPADH@Z ; SoundMgr::play
  00fcd	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 564  : 
; 565  : 		break;

  00fd2	e9 20 02 00 00	 jmp	 $L64773
$L64781:

; 568  : 			pm.acc = soundMgr->stop ( arg(2) );

  00fd7	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00fda	0f bf 51 04	 movsx	 edx, WORD PTR [ecx+4]
  00fde	52		 push	 edx
  00fdf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?soundMgr@@3PAVSoundMgr@@A ; soundMgr
  00fe5	e8 00 00 00 00	 call	 ?stop@SoundMgr@@QAEHH@Z	; SoundMgr::stop
  00fea	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 570  : 
; 571  : 		break;

  00fef	e9 03 02 00 00	 jmp	 $L64773
$L64782:

; 574  : 			pm.acc = soundMgr->setPan ( arg(2), arg(3) );

  00ff4	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00ff7	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00ffb	51		 push	 ecx
  00ffc	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00fff	0f bf 42 04	 movsx	 eax, WORD PTR [edx+4]
  01003	50		 push	 eax
  01004	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?soundMgr@@3PAVSoundMgr@@A ; soundMgr
  0100a	e8 00 00 00 00	 call	 ?setPan@SoundMgr@@QAEHHH@Z ; SoundMgr::setPan
  0100f	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 576  : 
; 577  : 		break;

  01014	e9 de 01 00 00	 jmp	 $L64773
$L64783:

; 580  : 			pm.acc = soundMgr->setPan ( arg(2), (((arg(3) * 100) / 640) * 127) / 100 );

  01019	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  0101c	0f bf 41 06	 movsx	 eax, WORD PTR [ecx+6]
  01020	6b c0 64	 imul	 eax, 100		; 00000064H
  01023	99		 cdq
  01024	b9 80 02 00 00	 mov	 ecx, 640		; 00000280H
  01029	f7 f9		 idiv	 ecx
  0102b	6b c0 7f	 imul	 eax, 127		; 0000007fH
  0102e	99		 cdq
  0102f	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  01034	f7 f9		 idiv	 ecx
  01036	50		 push	 eax
  01037	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  0103a	0f bf 42 04	 movsx	 eax, WORD PTR [edx+4]
  0103e	50		 push	 eax
  0103f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?soundMgr@@3PAVSoundMgr@@A ; soundMgr
  01045	e8 00 00 00 00	 call	 ?setPan@SoundMgr@@QAEHHH@Z ; SoundMgr::setPan
  0104a	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 581  : 
; 582  : 			if ( arg(5) )

  0104f	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  01052	0f bf 51 0a	 movsx	 edx, WORD PTR [ecx+10]
  01056	85 d2		 test	 edx, edx
  01058	74 33		 je	 SHORT $L64784

; 583  : 				soundMgr->setVolume ( arg(2), (((arg(4) * 100) / arg(5)) * 127) / 100 );

  0105a	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  0105d	0f bf 40 08	 movsx	 eax, WORD PTR [eax+8]
  01061	6b c0 64	 imul	 eax, 100		; 00000064H
  01064	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  01067	0f bf 49 0a	 movsx	 ecx, WORD PTR [ecx+10]
  0106b	99		 cdq
  0106c	f7 f9		 idiv	 ecx
  0106e	6b c0 7f	 imul	 eax, 127		; 0000007fH
  01071	99		 cdq
  01072	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  01077	f7 f9		 idiv	 ecx
  01079	50		 push	 eax
  0107a	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  0107d	0f bf 42 04	 movsx	 eax, WORD PTR [edx+4]
  01081	50		 push	 eax
  01082	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?soundMgr@@3PAVSoundMgr@@A ; soundMgr
  01088	e8 00 00 00 00	 call	 ?setVolume@SoundMgr@@QAEHHH@Z ; SoundMgr::setVolume
$L64784:

; 585  : 
; 586  : 		break;

  0108d	e9 65 01 00 00	 jmp	 $L64773
$L64785:

; 589  : 			pm.acc = soundMgr->setLoopCount ( arg(2), arg(3) );

  01092	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  01095	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  01099	52		 push	 edx
  0109a	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  0109d	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  010a1	51		 push	 ecx
  010a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?soundMgr@@3PAVSoundMgr@@A ; soundMgr
  010a8	e8 00 00 00 00	 call	 ?setLoopCount@SoundMgr@@QAEHHH@Z ; SoundMgr::setLoopCount
  010ad	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 591  : 
; 592  : 		break;

  010b2	e9 40 01 00 00	 jmp	 $L64773
$L64786:

; 595  : 			int view = (int)((unsigned short)arg(2));

  010b7	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  010ba	33 c0		 xor	 eax, eax
  010bc	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  010c0	89 45 f0	 mov	 DWORD PTR _view$64787[ebp], eax

; 596  : 			int cel = arg(3);

  010c3	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  010c6	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  010ca	89 55 ec	 mov	 DWORD PTR _cel$64790[ebp], edx

; 597  : 			int x = arg(4);

  010cd	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  010d0	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  010d4	89 4d e8	 mov	 DWORD PTR _x$64791[ebp], ecx

; 598  : 			int scaleX = arg(5);

  010d7	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  010da	0f bf 42 0a	 movsx	 eax, WORD PTR [edx+10]
  010de	89 45 f4	 mov	 DWORD PTR _scaleX$64792[ebp], eax

; 599  : 			int frontSize = arg(6);

  010e1	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  010e4	0f bf 51 0c	 movsx	 edx, WORD PTR [ecx+12]
  010e8	89 55 f8	 mov	 DWORD PTR _frontSize$64793[ebp], edx

; 600  : 
; 601  : 			char *name = NULL;

  010eb	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _name$64794[ebp], 0

; 602  : 
; 603  : 			switch ( view ) {

  010f2	8b 45 f0	 mov	 eax, DWORD PTR _view$64787[ebp]
  010f5	89 45 cc	 mov	 DWORD PTR -52+[ebp], eax
  010f8	81 7d cc 08 9d
	00 00		 cmp	 DWORD PTR -52+[ebp], 40200 ; 00009d08H
  010ff	7f 1a		 jg	 SHORT $L65141
  01101	81 7d cc 08 9d
	00 00		 cmp	 DWORD PTR -52+[ebp], 40200 ; 00009d08H
  01108	74 4f		 je	 SHORT $L64806
  0110a	83 7d cc 64	 cmp	 DWORD PTR -52+[ebp], 100 ; 00000064H
  0110e	74 1f		 je	 SHORT $L64799
  01110	81 7d cc c8 00
	00 00		 cmp	 DWORD PTR -52+[ebp], 200 ; 000000c8H
  01117	74 16		 je	 SHORT $L64799
  01119	eb 6e		 jmp	 SHORT $L64796
$L65141:
  0111b	81 7d cc d8 a4
	00 00		 cmp	 DWORD PTR -52+[ebp], 42200 ; 0000a4d8H
  01122	74 4e		 je	 SHORT $L64809
  01124	81 7d cc 3c a5
	00 00		 cmp	 DWORD PTR -52+[ebp], 42300 ; 0000a53cH
  0112b	74 45		 je	 SHORT $L64809
  0112d	eb 5a		 jmp	 SHORT $L64796
$L64799:

; 606  : 					if ( (cel % 5) == 1 ) {

  0112f	8b 45 ec	 mov	 eax, DWORD PTR _cel$64790[ebp]
  01132	99		 cdq
  01133	b9 05 00 00 00	 mov	 ecx, 5
  01138	f7 f9		 idiv	 ecx
  0113a	83 fa 01	 cmp	 edx, 1
  0113d	75 18		 jne	 SHORT $L64800

; 607  : 						static char *names[] = { "step1.wav", "step2.wav", "step3.wav" };
; 608  : 						name = names[rand() % 3];

  0113f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  01145	99		 cdq
  01146	b9 03 00 00 00	 mov	 ecx, 3
  0114b	f7 f9		 idiv	 ecx
  0114d	8b 14 95 00 00
	00 00		 mov	 edx, DWORD PTR _?names@?BC@??KSound@@YAXPAF@Z@4PAPADA[edx*4]
  01154	89 55 e4	 mov	 DWORD PTR _name$64794[ebp], edx
$L64800:

; 611  : 
; 612  : 				break;

  01157	eb 30		 jmp	 SHORT $L64796
$L64806:

; 616  : 					if ( (cel % 6) == 3 ) 

  01159	8b 45 ec	 mov	 eax, DWORD PTR _cel$64790[ebp]
  0115c	99		 cdq
  0115d	b9 06 00 00 00	 mov	 ecx, 6
  01162	f7 f9		 idiv	 ecx
  01164	83 fa 03	 cmp	 edx, 3
  01167	75 07		 jne	 SHORT $L64807

; 617  : 						name = "trmove.wav";

  01169	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _name$64794[ebp], OFFSET FLAT:$SG64808
$L64807:

; 619  : 
; 620  : 				break;

  01170	eb 17		 jmp	 SHORT $L64796
$L64809:

; 621  : 
; 622  : 				// minotaur movement...
; 623  : 				case 42200: //minotaur warrior
; 624  : 				case 42300: //minotaur mage
; 625  : 					if ( (cel % 6) == 3 ) 

  01172	8b 45 ec	 mov	 eax, DWORD PTR _cel$64790[ebp]
  01175	99		 cdq
  01176	b9 06 00 00 00	 mov	 ecx, 6
  0117b	f7 f9		 idiv	 ecx
  0117d	83 fa 03	 cmp	 edx, 3
  01180	75 07		 jne	 SHORT $L64810

; 626  : 						name = "minom.wav";

  01182	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _name$64794[ebp], OFFSET FLAT:$SG64811
$L64810:
$L64796:

; 629  : 
; 630  : 			if ( name ) {

  01189	83 7d e4 00	 cmp	 DWORD PTR _name$64794[ebp], 0
  0118d	74 68		 je	 SHORT $L64812

; 631  : 				int id = soundMgr->play ( name, 1 );

  0118f	6a 01		 push	 1
  01191	8b 55 e4	 mov	 edx, DWORD PTR _name$64794[ebp]
  01194	52		 push	 edx
  01195	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?soundMgr@@3PAVSoundMgr@@A ; soundMgr
  0119b	e8 00 00 00 00	 call	 ?play@SoundMgr@@QAEHPADH@Z ; SoundMgr::play
  011a0	89 45 dc	 mov	 DWORD PTR _id$64813[ebp], eax

; 632  : 
; 633  : 				int nPan = (((x * 100) / 640) * 127) / 100;

  011a3	8b 45 e8	 mov	 eax, DWORD PTR _x$64791[ebp]
  011a6	6b c0 64	 imul	 eax, 100		; 00000064H
  011a9	99		 cdq
  011aa	b9 80 02 00 00	 mov	 ecx, 640		; 00000280H
  011af	f7 f9		 idiv	 ecx
  011b1	6b c0 7f	 imul	 eax, 127		; 0000007fH
  011b4	99		 cdq
  011b5	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  011ba	f7 f9		 idiv	 ecx
  011bc	89 45 e0	 mov	 DWORD PTR _nPan$64814[ebp], eax

; 634  : 				soundMgr->setPan ( id, nPan );

  011bf	8b 55 e0	 mov	 edx, DWORD PTR _nPan$64814[ebp]
  011c2	52		 push	 edx
  011c3	8b 45 dc	 mov	 eax, DWORD PTR _id$64813[ebp]
  011c6	50		 push	 eax
  011c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?soundMgr@@3PAVSoundMgr@@A ; soundMgr
  011cd	e8 00 00 00 00	 call	 ?setPan@SoundMgr@@QAEHHH@Z ; SoundMgr::setPan

; 635  : 				soundMgr->setVolume ( id, (((scaleX * 100) / frontSize) * 127) / 100 );

  011d2	8b 45 f4	 mov	 eax, DWORD PTR _scaleX$64792[ebp]
  011d5	6b c0 64	 imul	 eax, 100		; 00000064H
  011d8	99		 cdq
  011d9	f7 7d f8	 idiv	 DWORD PTR _frontSize$64793[ebp]
  011dc	6b c0 7f	 imul	 eax, 127		; 0000007fH
  011df	99		 cdq
  011e0	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  011e5	f7 f9		 idiv	 ecx
  011e7	50		 push	 eax
  011e8	8b 55 dc	 mov	 edx, DWORD PTR _id$64813[ebp]
  011eb	52		 push	 edx
  011ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?soundMgr@@3PAVSoundMgr@@A ; soundMgr
  011f2	e8 00 00 00 00	 call	 ?setVolume@SoundMgr@@QAEHHH@Z ; SoundMgr::setVolume
$L64812:
$L64773:

; 641  : }

  011f7	8b e5		 mov	 esp, ebp
  011f9	5d		 pop	 ebp
  011fa	c3		 ret	 0
$L65142:
  011fb	00 00 00 00	 DD	 $L64776
  011ff	00 00 00 00	 DD	 $L64781
  01203	00 00 00 00	 DD	 $L64773
  01207	00 00 00 00	 DD	 $L64773
  0120b	00 00 00 00	 DD	 $L64782
  0120f	00 00 00 00	 DD	 $L64783
  01213	00 00 00 00	 DD	 $L64785
  01217	00 00 00 00	 DD	 $L64786
?KSound@@YAXPAF@Z ENDP					; KSound
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0MemID@@QAE@ABV0@@Z PROC NEAR				; MemID::MemID, COMDAT

; 19   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  0000d	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00010	66 89 10	 mov	 WORD PTR [eax], dx

; 20   : 	}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0MemID@@QAE@ABV0@@Z ENDP				; MemID::MemID
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0MemID@@QAE@G@Z PROC NEAR				; MemID::MemID, COMDAT

; 23   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 4d 08	 mov	 cx, WORD PTR _h$[ebp]
  0000e	66 89 08	 mov	 WORD PTR [eax], cx

; 24   : 	}

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??0MemID@@QAE@G@Z ENDP					; MemID::MemID
_TEXT	ENDS
PUBLIC	?GetAddr@MemoryMgr@@QAEPAXG@Z			; MemoryMgr::GetAddr
EXTRN	_memMgr:DWORD
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT
_this$ = -4
??DMemID@@QBEPAXXZ PROC NEAR				; MemID::operator*, COMDAT

; 98   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 99   : 		return memMgr->GetAddr(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr

; 100  : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??DMemID@@QBEPAXXZ ENDP					; MemID::operator*
_TEXT	ENDS
EXTRN	__descPtrTable:BYTE
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -4
?GetAddr@MemoryMgr@@QAEPAXG@Z PROC NEAR			; MemoryMgr::GetAddr, COMDAT

; 462  : 	inline void* MemoryMgr::GetAddr(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : //		CheckValid(theID);
; 464  : 		return _descPtrTable[(unsigned int)((unsigned short)theID)];

  00007	8b 45 08	 mov	 eax, DWORD PTR _theID$[ebp]
  0000a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0000f	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR __descPtrTable[eax*4]

; 465  : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?GetAddr@MemoryMgr@@QAEPAXG@Z ENDP			; MemoryMgr::GetAddr
_TEXT	ENDS
END
