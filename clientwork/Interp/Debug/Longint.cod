	TITLE	C:\Documents and Settings\don\Desktop\sciw\Interp\Longint.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MemoryMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckValid@MemoryMgr@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GMemoryMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@V1@III@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AMemID@@QBEAADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8MemID@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??7MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeArrayID@@QBEPAUArrayHeader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ArrayID@@QAE@HW4ArrayType@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@ArrayID@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAE?AVMemID@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAEXVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_List@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@SOL_List@@QAEAAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeDispatchTblID@@QBEPAUDispatchTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeScriptEntryID@@QBEPAUScriptEntry@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntry@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeVariableID@@QBEPAUVariable@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Script@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Object@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGraphicsUpdate@Object@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?selectorDict@Object@@QAEPAVSelectorDict@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AObject@@QAEAAFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddr@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedPropAddr@Object@@QAEPBFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedProperty@Object@@QAEFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddrCheck@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@Object@@QAEFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropOffset@Object@@QAEIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetIndexedProperty@Object@@QAEXHF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetProperty@Object@@QAEXGF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssureValid@ObjectID@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsObject@ObjectID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedProperty@ObjectID@@QBEFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetIndexedProperty@ObjectID@@QBEXHF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeClassTblID@@QBEPAUClassTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DTextID@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TextID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7MemoryMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	??DTextID@@QAEPADXZ				; TextID::operator*
PUBLIC	??0TextID@@QAE@ABV0@@Z				; TextID::TextID
PUBLIC	?KLongInt@@YAXPAF@Z				; KLongInt
PUBLIC	??0ObjectID@@QAE@ABV0@@Z			; ObjectID::ObjectID
PUBLIC	??0ObjectID@@QAE@G@Z				; ObjectID::ObjectID
PUBLIC	?IsObject@ObjectID@@QBEHXZ			; ObjectID::IsObject
PUBLIC	?GetIndexedProperty@ObjectID@@QBEFH@Z		; ObjectID::GetIndexedProperty
PUBLIC	?SetIndexedProperty@ObjectID@@QBEXHF@Z		; ObjectID::SetIndexedProperty
EXTRN	?pm@@3VPMachine@@A:BYTE				; pm
EXTRN	??0TextID@@QAE@G@Z:NEAR				; TextID::TextID
EXTRN	?Add@TextID@@QAEXPBD@Z:NEAR			; TextID::Add
EXTRN	?gSerialNumber@@3IA:DWORD			; gSerialNumber
EXTRN	?gAllocSize@@3HA:DWORD				; gAllocSize
EXTRN	?Fatal@MsgMgr@@QAAXPADZZ:NEAR			; MsgMgr::Fatal
EXTRN	?msgMgr@@3PAVMsgMgr@@A:DWORD			; msgMgr
EXTRN	__imp__sprintf:NEAR
EXTRN	__imp__atoi:NEAR
EXTRN	_labs:NEAR
_DATA	SEGMENT
$SG58749 DB	'Less than two arguments passed to KLongInt', 00H
	ORG $+1
$SG58755 DB	'Invalid object passed to KLongInt (0x%x)', 00H
	ORG $+3
$SG58763 DB	'Less than three arguments passed to low/hi word expectin'
	DB	'g KLongInt call.', 00H
	ORG $+3
$SG58782 DB	'LongInt divide by goose egg.', 00H
	ORG $+3
$SG58811 DB	'%d', 00H
	ORG $+1
$SG58814 DB	'%u', 00H
	ORG $+1
$SG58825 DB	'Invalid function number in call to KLongInt (call == %d)'
	DB	00H
_DATA	ENDS
_TEXT	SEGMENT
_args$ = 8
_function$ = -16
_longID$ = -12
_objValue$ = -8
_origObjValue$ = -4
_argValue$ = -20
_tmp$58795 = -24
_temp$58809 = -60
_theID$58815 = -28
_theID$58819 = -64
$T58914 = -68
$T58915 = -72
$T58916 = -76
?KLongInt@@YAXPAF@Z PROC NEAR				; KLongInt

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	56		 push	 esi

; 27   : 	enum {
; 28   : 		LongSet,
; 29   : 		LongAdd,
; 30   : 		LongSub,
; 31   : 		LongMul,
; 32   : 		LongDiv,
; 33   : 		LongAnd,
; 34   : 		LongOr,
; 35   : 		LongXor,
; 36   : 		LongEqual,
; 37   : 		LongLess,
; 38   : 		LongLessEqual,
; 39   : 		LongGreater,
; 40   : 		LongGreaterEqual,
; 41   : 		LongNoArgs,
; 42   : 		LongNot = LongNoArgs,
; 43   : 		LongSetBit,
; 44   : 		LongResetBit,
; 45   : 		LongToggleBit,
; 46   : 		LongGetBit,
; 47   : 		LongShiftLeft,
; 48   : 		LongShiftRight,
; 49   : 		LongSwap,
; 50   : 		LongNeg,
; 51   : 		LongAbs,
; 52   : 		LongAsStr,
; 53   : 		LongFromStr,
; 54   : 		LongGetSerial,
; 55   : 		LongMemory
; 56   : 	};
; 57   : 
; 58   : 	// check to make sure that the minimum number of arguments are passed
; 59   : 	if ( argCount < 2 ) 

  00007	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  0000a	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0000d	83 f9 02	 cmp	 ecx, 2
  00010	7d 14		 jge	 SHORT $L58748

; 60   : 		msgMgr->Fatal ( "Less than two arguments passed to KLongInt" );

  00012	68 00 00 00 00	 push	 OFFSET FLAT:$SG58749
  00017	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00023	83 c4 08	 add	 esp, 8
$L58748:

; 61   : 
; 62   : 	// get the function index
; 63   : 	int function = arg ( 1 );

  00026	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00029	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  0002d	89 4d f0	 mov	 DWORD PTR _function$[ebp], ecx

; 64   : 
; 65   : 	// get the LongInt SCI object ID
; 66   : 	ObjectID longID = (ObjectID)arg ( 2 );

  00030	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00033	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  00037	50		 push	 eax
  00038	8d 4d bc	 lea	 ecx, DWORD PTR $T58914[ebp]
  0003b	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  00040	50		 push	 eax
  00041	8d 4d f4	 lea	 ecx, DWORD PTR _longID$[ebp]
  00044	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID

; 67   : 
; 68   : 	// validate the object
; 69   : 	if ( !longID.IsObject() )

  00049	8d 4d f4	 lea	 ecx, DWORD PTR _longID$[ebp]
  0004c	e8 00 00 00 00	 call	 ?IsObject@ObjectID@@QBEHXZ ; ObjectID::IsObject
  00051	85 c0		 test	 eax, eax
  00053	75 19		 jne	 SHORT $L58754

; 70   : 		msgMgr->Fatal ( "Invalid object passed to KLongInt (0x%x)", longID );

  00055	66 8b 4d f4	 mov	 cx, WORD PTR _longID$[ebp]
  00059	51		 push	 ecx
  0005a	68 00 00 00 00	 push	 OFFSET FLAT:$SG58755
  0005f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH
$L58754:

; 71   : 
; 72   : 	// get the 32 bit integer value from the low/hi word properties
; 73   : 	long objValue = (SCIUWord)longID.GetIndexedProperty ( longLowWord ) + ((SCIUWord)longID.GetIndexedProperty ( longHiWord ) << 16);

  0006e	6a 47		 push	 71			; 00000047H
  00070	8d 4d f4	 lea	 ecx, DWORD PTR _longID$[ebp]
  00073	e8 00 00 00 00	 call	 ?GetIndexedProperty@ObjectID@@QBEFH@Z ; ObjectID::GetIndexedProperty
  00078	66 8b f0	 mov	 si, ax
  0007b	81 e6 ff ff 00
	00		 and	 esi, 65535		; 0000ffffH
  00081	6a 48		 push	 72			; 00000048H
  00083	8d 4d f4	 lea	 ecx, DWORD PTR _longID$[ebp]
  00086	e8 00 00 00 00	 call	 ?GetIndexedProperty@ObjectID@@QBEFH@Z ; ObjectID::GetIndexedProperty
  0008b	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00090	c1 e0 10	 shl	 eax, 16			; 00000010H
  00093	03 f0		 add	 esi, eax
  00095	89 75 f8	 mov	 DWORD PTR _objValue$[ebp], esi

; 74   : 	long origObjValue = objValue;

  00098	8b 45 f8	 mov	 eax, DWORD PTR _objValue$[ebp]
  0009b	89 45 fc	 mov	 DWORD PTR _origObjValue$[ebp], eax

; 75   : 
; 76   : //	msgMgr->Mono ( "KLongInt objValue == %u\n", objValue );
; 77   : 
; 78   : 	// get the lowWord and highWord from the argument list, if needed
; 79   : 	long argValue = 0;

  0009e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _argValue$[ebp], 0

; 80   : 
; 81   : 	if ( function < LongNoArgs ) {

  000a5	83 7d f0 0d	 cmp	 DWORD PTR _function$[ebp], 13 ; 0000000dH
  000a9	7d 55		 jge	 SHORT $L58769

; 82   : 		// validate the number of arguments
; 83   : 		if ( argCount < 3 )

  000ab	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  000ae	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  000b1	83 fa 03	 cmp	 edx, 3
  000b4	7d 13		 jge	 SHORT $L58762

; 84   : 			msgMgr->Fatal ( "Less than three arguments passed to low/hi word expecting KLongInt call." );

  000b6	68 00 00 00 00	 push	 OFFSET FLAT:$SG58763
  000bb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  000c0	50		 push	 eax
  000c1	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  000c6	83 c4 08	 add	 esp, 8
$L58762:

; 85   : 
; 86   : 		if ( argCount > 3 ) {

  000c9	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  000cc	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  000cf	83 fa 03	 cmp	 edx, 3
  000d2	7e 22		 jle	 SHORT $L58764

; 87   : 			argValue = (long)(SCIUWord)arg ( 3 );

  000d4	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  000d7	33 c9		 xor	 ecx, ecx
  000d9	66 8b 48 06	 mov	 cx, WORD PTR [eax+6]
  000dd	89 4d ec	 mov	 DWORD PTR _argValue$[ebp], ecx

; 88   : 			argValue += (long)((SCIUWord)arg ( 4 )) << 16;

  000e0	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  000e3	33 c0		 xor	 eax, eax
  000e5	66 8b 42 08	 mov	 ax, WORD PTR [edx+8]
  000e9	c1 e0 10	 shl	 eax, 16			; 00000010H
  000ec	8b 4d ec	 mov	 ecx, DWORD PTR _argValue$[ebp]
  000ef	03 c8		 add	 ecx, eax
  000f1	89 4d ec	 mov	 DWORD PTR _argValue$[ebp], ecx

; 89   : 		} else {

  000f4	eb 0a		 jmp	 SHORT $L58769
$L58764:

; 90   : 			argValue = (long)(short)arg ( 3 );

  000f6	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  000f9	0f bf 42 06	 movsx	 eax, WORD PTR [edx+6]
  000fd	89 45 ec	 mov	 DWORD PTR _argValue$[ebp], eax
$L58769:

; 93   : 
; 94   : //	msgMgr->Mono ( "KLongInt argValue == %u\n", argValue );
; 95   : 
; 96   : 	switch ( function ) {

  00100	8b 4d f0	 mov	 ecx, DWORD PTR _function$[ebp]
  00103	89 4d b0	 mov	 DWORD PTR -80+[ebp], ecx
  00106	83 7d b0 1a	 cmp	 DWORD PTR -80+[ebp], 26	; 0000001aH
  0010a	0f 87 93 02 00
	00		 ja	 $L58824
  00110	8b 55 b0	 mov	 edx, DWORD PTR -80+[ebp]
  00113	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L58917[edx*4]
$L58776:

; 97   : 		// set the hi/low word values of a LongInt
; 98   : 		case LongSet:
; 99   : 			objValue = argValue;	

  0011a	8b 45 ec	 mov	 eax, DWORD PTR _argValue$[ebp]
  0011d	89 45 f8	 mov	 DWORD PTR _objValue$[ebp], eax

; 100  : 			break;

  00120	e9 9a 02 00 00	 jmp	 $L58773
$L58777:

; 101  : 
; 102  : 		// add argValue to objValue
; 103  : 		case LongAdd: 
; 104  : 			objValue += argValue;

  00125	8b 4d f8	 mov	 ecx, DWORD PTR _objValue$[ebp]
  00128	03 4d ec	 add	 ecx, DWORD PTR _argValue$[ebp]
  0012b	89 4d f8	 mov	 DWORD PTR _objValue$[ebp], ecx

; 105  : 			break;

  0012e	e9 8c 02 00 00	 jmp	 $L58773
$L58778:

; 106  : 
; 107  : 		// subtract argValue from objValue
; 108  : 		case LongSub:
; 109  : 			objValue -= argValue;

  00133	8b 55 f8	 mov	 edx, DWORD PTR _objValue$[ebp]
  00136	2b 55 ec	 sub	 edx, DWORD PTR _argValue$[ebp]
  00139	89 55 f8	 mov	 DWORD PTR _objValue$[ebp], edx

; 110  : 			break;

  0013c	e9 7e 02 00 00	 jmp	 $L58773
$L58779:

; 111  : 
; 112  : 		// multiply argValue and objValue
; 113  : 		case LongMul:
; 114  : 			objValue *= argValue;

  00141	8b 45 f8	 mov	 eax, DWORD PTR _objValue$[ebp]
  00144	0f af 45 ec	 imul	 eax, DWORD PTR _argValue$[ebp]
  00148	89 45 f8	 mov	 DWORD PTR _objValue$[ebp], eax

; 115  : 			break;

  0014b	e9 6f 02 00 00	 jmp	 $L58773
$L58780:

; 116  : 
; 117  : 		// divide objVal by argValue
; 118  : 		case LongDiv:
; 119  : 			if ( !argValue )

  00150	83 7d ec 00	 cmp	 DWORD PTR _argValue$[ebp], 0
  00154	75 14		 jne	 SHORT $L58781

; 120  : 				msgMgr->Fatal ( "LongInt divide by goose egg." );

  00156	68 00 00 00 00	 push	 OFFSET FLAT:$SG58782
  0015b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00161	51		 push	 ecx
  00162	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00167	83 c4 08	 add	 esp, 8
$L58781:

; 121  : 
; 122  : 			objValue /= argValue;

  0016a	8b 45 f8	 mov	 eax, DWORD PTR _objValue$[ebp]
  0016d	99		 cdq
  0016e	f7 7d ec	 idiv	 DWORD PTR _argValue$[ebp]
  00171	89 45 f8	 mov	 DWORD PTR _objValue$[ebp], eax

; 123  : 			break;

  00174	e9 46 02 00 00	 jmp	 $L58773
$L58783:

; 124  : 
; 125  : 		// perform a bitwise AND between objVal and argVal
; 126  : 		case LongAnd:
; 127  : 			objValue &= argValue;

  00179	8b 55 f8	 mov	 edx, DWORD PTR _objValue$[ebp]
  0017c	23 55 ec	 and	 edx, DWORD PTR _argValue$[ebp]
  0017f	89 55 f8	 mov	 DWORD PTR _objValue$[ebp], edx

; 128  : 			break;

  00182	e9 38 02 00 00	 jmp	 $L58773
$L58784:

; 129  : 
; 130  : 		// perform a bitwise OR between objVal and argVal
; 131  : 		case LongOr:
; 132  : 			objValue |= argValue;

  00187	8b 45 f8	 mov	 eax, DWORD PTR _objValue$[ebp]
  0018a	0b 45 ec	 or	 eax, DWORD PTR _argValue$[ebp]
  0018d	89 45 f8	 mov	 DWORD PTR _objValue$[ebp], eax

; 133  : 			break;

  00190	e9 2a 02 00 00	 jmp	 $L58773
$L58785:

; 134  : 
; 135  : 		// perform a bitwise XOR between objVal and argVal
; 136  : 		case LongXor:
; 137  : 			objValue ^= argValue;

  00195	8b 4d f8	 mov	 ecx, DWORD PTR _objValue$[ebp]
  00198	33 4d ec	 xor	 ecx, DWORD PTR _argValue$[ebp]
  0019b	89 4d f8	 mov	 DWORD PTR _objValue$[ebp], ecx

; 138  : 			break;

  0019e	e9 1c 02 00 00	 jmp	 $L58773
$L58786:

; 139  : 
; 140  : 		// perform a bitwise NOT on objValue
; 141  : 		case LongNot: 
; 142  : 			objValue = ~objValue;

  001a3	8b 55 f8	 mov	 edx, DWORD PTR _objValue$[ebp]
  001a6	f7 d2		 not	 edx
  001a8	89 55 f8	 mov	 DWORD PTR _objValue$[ebp], edx

; 143  : 			break;

  001ab	e9 0f 02 00 00	 jmp	 $L58773
$L58787:

; 144  : 
; 145  : 		// set a bit of objValue
; 146  : 		case LongSetBit:
; 147  : 			objValue |= 1 << arg(3);

  001b0	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  001b3	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  001b7	ba 01 00 00 00	 mov	 edx, 1
  001bc	d3 e2		 shl	 edx, cl
  001be	8b 45 f8	 mov	 eax, DWORD PTR _objValue$[ebp]
  001c1	0b c2		 or	 eax, edx
  001c3	89 45 f8	 mov	 DWORD PTR _objValue$[ebp], eax

; 148  : 			break;

  001c6	e9 f4 01 00 00	 jmp	 $L58773
$L58788:

; 149  : 
; 150  : 		// clear a bit of objValue
; 151  : 		case LongResetBit:
; 152  : 			objValue &= ~(1 << arg(3));

  001cb	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  001ce	0f bf 49 06	 movsx	 ecx, WORD PTR [ecx+6]
  001d2	ba 01 00 00 00	 mov	 edx, 1
  001d7	d3 e2		 shl	 edx, cl
  001d9	f7 d2		 not	 edx
  001db	8b 45 f8	 mov	 eax, DWORD PTR _objValue$[ebp]
  001de	23 c2		 and	 eax, edx
  001e0	89 45 f8	 mov	 DWORD PTR _objValue$[ebp], eax

; 153  : 			break;

  001e3	e9 d7 01 00 00	 jmp	 $L58773
$L58789:

; 154  : 
; 155  : 		// toggle a bit of objValue
; 156  : 		case LongToggleBit:
; 157  : 			objValue ^= 1 << arg(3);

  001e8	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  001eb	0f bf 49 06	 movsx	 ecx, WORD PTR [ecx+6]
  001ef	ba 01 00 00 00	 mov	 edx, 1
  001f4	d3 e2		 shl	 edx, cl
  001f6	8b 45 f8	 mov	 eax, DWORD PTR _objValue$[ebp]
  001f9	33 c2		 xor	 eax, edx
  001fb	89 45 f8	 mov	 DWORD PTR _objValue$[ebp], eax

; 158  : 			break;

  001fe	e9 bc 01 00 00	 jmp	 $L58773
$L58790:

; 159  : 
; 160  : 		// get the value of a bit of objValue
; 161  : 		case LongGetBit:
; 162  : 			pm.acc = (Acc)(objValue & (1 << arg(3)))? 1 : 0;

  00203	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00206	0f bf 49 06	 movsx	 ecx, WORD PTR [ecx+6]
  0020a	ba 01 00 00 00	 mov	 edx, 1
  0020f	d3 e2		 shl	 edx, cl
  00211	8b 45 f8	 mov	 eax, DWORD PTR _objValue$[ebp]
  00214	23 c2		 and	 eax, edx
  00216	f7 d8		 neg	 eax
  00218	1b c0		 sbb	 eax, eax
  0021a	f7 d8		 neg	 eax
  0021c	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 163  : 			break;

  00221	e9 99 01 00 00	 jmp	 $L58773
$L58792:

; 164  : 
; 165  : 		// shift objValue to the left by arg(3) bits
; 166  : 		case LongShiftLeft:
; 167  : 			objValue <<= arg(3);

  00226	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00229	0f bf 49 06	 movsx	 ecx, WORD PTR [ecx+6]
  0022d	8b 55 f8	 mov	 edx, DWORD PTR _objValue$[ebp]
  00230	d3 e2		 shl	 edx, cl
  00232	89 55 f8	 mov	 DWORD PTR _objValue$[ebp], edx

; 168  : 			break;

  00235	e9 85 01 00 00	 jmp	 $L58773
$L58793:

; 169  : 
; 170  : 		// shift objValue to the right by arg(3) bits
; 171  : 		case LongShiftRight:
; 172  : 			objValue >>= arg(3);

  0023a	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  0023d	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00241	8b 55 f8	 mov	 edx, DWORD PTR _objValue$[ebp]
  00244	d3 fa		 sar	 edx, cl
  00246	89 55 f8	 mov	 DWORD PTR _objValue$[ebp], edx

; 173  : 			break;

  00249	e9 71 01 00 00	 jmp	 $L58773
$L58794:

; 177  : 			long tmp = objValue;

  0024e	8b 45 f8	 mov	 eax, DWORD PTR _objValue$[ebp]
  00251	89 45 e8	 mov	 DWORD PTR _tmp$58795[ebp], eax

; 178  : 
; 179  : 			objValue >>= 16;

  00254	8b 4d f8	 mov	 ecx, DWORD PTR _objValue$[ebp]
  00257	c1 f9 10	 sar	 ecx, 16			; 00000010H
  0025a	89 4d f8	 mov	 DWORD PTR _objValue$[ebp], ecx

; 180  : 			objValue |= tmp << 16;

  0025d	8b 55 e8	 mov	 edx, DWORD PTR _tmp$58795[ebp]
  00260	c1 e2 10	 shl	 edx, 16			; 00000010H
  00263	8b 45 f8	 mov	 eax, DWORD PTR _objValue$[ebp]
  00266	0b c2		 or	 eax, edx
  00268	89 45 f8	 mov	 DWORD PTR _objValue$[ebp], eax

; 182  : 
; 183  : 		break;

  0026b	e9 4f 01 00 00	 jmp	 $L58773
$L58796:

; 184  : 
; 185  : 		// negate objValue
; 186  : 		case LongNeg:
; 187  : 			objValue *= -1;

  00270	8b 4d f8	 mov	 ecx, DWORD PTR _objValue$[ebp]
  00273	6b c9 ff	 imul	 ecx, -1
  00276	89 4d f8	 mov	 DWORD PTR _objValue$[ebp], ecx

; 188  : 			break;

  00279	e9 41 01 00 00	 jmp	 $L58773
$L58797:

; 189  : 
; 190  : 		// calc the absolute value of objValue
; 191  : 		case LongAbs:
; 192  : 			objValue = labs ( objValue );

  0027e	8b 55 f8	 mov	 edx, DWORD PTR _objValue$[ebp]
  00281	52		 push	 edx
  00282	e8 00 00 00 00	 call	 _labs
  00287	83 c4 04	 add	 esp, 4
  0028a	89 45 f8	 mov	 DWORD PTR _objValue$[ebp], eax

; 193  : 			break;

  0028d	e9 2d 01 00 00	 jmp	 $L58773
$L58798:

; 194  : 
; 195  : 		// objVal == argVal?
; 196  : 		case LongEqual:
; 197  : 			pm.acc = (Acc)objValue == argValue;

  00292	8b 45 f8	 mov	 eax, DWORD PTR _objValue$[ebp]
  00295	33 c9		 xor	 ecx, ecx
  00297	3b 45 ec	 cmp	 eax, DWORD PTR _argValue$[ebp]
  0029a	0f 94 c1	 sete	 cl
  0029d	89 0d 04 00 00
	00		 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, ecx

; 198  : 			break;

  002a3	e9 17 01 00 00	 jmp	 $L58773
$L58800:

; 199  : 
; 200  : 		// objVal < argVal?
; 201  : 		case LongLess:
; 202  : 			pm.acc = (Acc)objValue < argValue;

  002a8	8b 55 f8	 mov	 edx, DWORD PTR _objValue$[ebp]
  002ab	33 c0		 xor	 eax, eax
  002ad	3b 55 ec	 cmp	 edx, DWORD PTR _argValue$[ebp]
  002b0	0f 9c c0	 setl	 al
  002b3	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 203  : 			break;

  002b8	e9 02 01 00 00	 jmp	 $L58773
$L58802:

; 204  : 
; 205  : 		// objVal <= argVal?
; 206  : 		case LongLessEqual:
; 207  : 			pm.acc = (Acc)objValue <= argValue;

  002bd	8b 4d f8	 mov	 ecx, DWORD PTR _objValue$[ebp]
  002c0	33 d2		 xor	 edx, edx
  002c2	3b 4d ec	 cmp	 ecx, DWORD PTR _argValue$[ebp]
  002c5	0f 9e c2	 setle	 dl
  002c8	89 15 04 00 00
	00		 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, edx

; 208  : 			break;

  002ce	e9 ec 00 00 00	 jmp	 $L58773
$L58804:

; 209  : 
; 210  : 		// objVal > argVal?
; 211  : 		case LongGreater:
; 212  : 			pm.acc = (Acc)objValue > argValue;

  002d3	8b 45 f8	 mov	 eax, DWORD PTR _objValue$[ebp]
  002d6	33 c9		 xor	 ecx, ecx
  002d8	3b 45 ec	 cmp	 eax, DWORD PTR _argValue$[ebp]
  002db	0f 9f c1	 setg	 cl
  002de	89 0d 04 00 00
	00		 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, ecx

; 213  : 			break;

  002e4	e9 d6 00 00 00	 jmp	 $L58773
$L58806:

; 214  : 
; 215  : 		// objVal >= argVal?
; 216  : 		case LongGreaterEqual:
; 217  : 			pm.acc = (Acc)objValue >= argValue;

  002e9	8b 55 f8	 mov	 edx, DWORD PTR _objValue$[ebp]
  002ec	33 c0		 xor	 eax, eax
  002ee	3b 55 ec	 cmp	 edx, DWORD PTR _argValue$[ebp]
  002f1	0f 9d c0	 setge	 al
  002f4	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 218  : 			break;

  002f9	e9 c1 00 00 00	 jmp	 $L58773
$L58808:

; 221  : 			char temp[32];
; 222  : 
; 223  : 			if ( arg(4) ) {

  002fe	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00301	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  00305	85 d2		 test	 edx, edx
  00307	74 18		 je	 SHORT $L58810

; 224  : 				sprintf ( temp, "%d", objValue );

  00309	8b 45 f8	 mov	 eax, DWORD PTR _objValue$[ebp]
  0030c	50		 push	 eax
  0030d	68 00 00 00 00	 push	 OFFSET FLAT:$SG58811
  00312	8d 4d c4	 lea	 ecx, DWORD PTR _temp$58809[ebp]
  00315	51		 push	 ecx
  00316	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  0031c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 225  : 			} else {

  0031f	eb 16		 jmp	 SHORT $L58812
$L58810:

; 226  : 				sprintf ( temp, "%u", (unsigned int)objValue );

  00321	8b 55 f8	 mov	 edx, DWORD PTR _objValue$[ebp]
  00324	52		 push	 edx
  00325	68 00 00 00 00	 push	 OFFSET FLAT:$SG58814
  0032a	8d 45 c4	 lea	 eax, DWORD PTR _temp$58809[ebp]
  0032d	50		 push	 eax
  0032e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  00334	83 c4 0c	 add	 esp, 12			; 0000000cH
$L58812:

; 228  : 
; 229  : 			TextID theID = (TextID)arg(3);

  00337	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  0033a	66 8b 51 06	 mov	 dx, WORD PTR [ecx+6]
  0033e	52		 push	 edx
  0033f	8d 4d b8	 lea	 ecx, DWORD PTR $T58915[ebp]
  00342	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  00347	50		 push	 eax
  00348	8d 4d e4	 lea	 ecx, DWORD PTR _theID$58815[ebp]
  0034b	e8 00 00 00 00	 call	 ??0TextID@@QAE@ABV0@@Z	; TextID::TextID

; 230  : 			theID.Add ( temp );

  00350	8d 45 c4	 lea	 eax, DWORD PTR _temp$58809[ebp]
  00353	50		 push	 eax
  00354	8d 4d e4	 lea	 ecx, DWORD PTR _theID$58815[ebp]
  00357	e8 00 00 00 00	 call	 ?Add@TextID@@QAEXPBD@Z	; TextID::Add

; 232  : 
; 233  : 		break;

  0035c	eb 61		 jmp	 SHORT $L58773
$L58818:

; 236  : 			TextID theID = (TextID)arg(3);

  0035e	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00361	66 8b 51 06	 mov	 dx, WORD PTR [ecx+6]
  00365	52		 push	 edx
  00366	8d 4d b4	 lea	 ecx, DWORD PTR $T58916[ebp]
  00369	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  0036e	50		 push	 eax
  0036f	8d 4d c0	 lea	 ecx, DWORD PTR _theID$58819[ebp]
  00372	e8 00 00 00 00	 call	 ??0TextID@@QAE@ABV0@@Z	; TextID::TextID

; 237  : 			objValue = atoi ( *theID ); 

  00377	8d 4d c0	 lea	 ecx, DWORD PTR _theID$58819[ebp]
  0037a	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  0037f	50		 push	 eax
  00380	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00386	83 c4 04	 add	 esp, 4
  00389	89 45 f8	 mov	 DWORD PTR _objValue$[ebp], eax

; 239  : 
; 240  : 		break;

  0038c	eb 31		 jmp	 SHORT $L58773
$L58822:

; 243  : 			objValue = gSerialNumber; 

  0038e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gSerialNumber@@3IA ; gSerialNumber
  00393	89 45 f8	 mov	 DWORD PTR _objValue$[ebp], eax

; 245  : 
; 246  : 		break;

  00396	eb 27		 jmp	 SHORT $L58773
$L58823:

; 249  : 			objValue = gAllocSize; 

  00398	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gAllocSize@@3HA ; gAllocSize
  0039e	89 4d f8	 mov	 DWORD PTR _objValue$[ebp], ecx

; 251  : 
; 252  : 		break;

  003a1	eb 1c		 jmp	 SHORT $L58773
$L58824:

; 253  : 
; 254  : 		// fatal out because invalid kernel call indexed
; 255  : 		default:
; 256  : 			msgMgr->Fatal ( "Invalid function number in call to KLongInt (call == %d)", arg ( 1 ) );

  003a3	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  003a6	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  003aa	50		 push	 eax
  003ab	68 00 00 00 00	 push	 OFFSET FLAT:$SG58825
  003b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  003b6	51		 push	 ecx
  003b7	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  003bc	83 c4 0c	 add	 esp, 12			; 0000000cH
$L58773:

; 259  : 
; 260  : 	if ( origObjValue != objValue ) {

  003bf	8b 55 fc	 mov	 edx, DWORD PTR _origObjValue$[ebp]
  003c2	3b 55 f8	 cmp	 edx, DWORD PTR _objValue$[ebp]
  003c5	74 24		 je	 SHORT $L58826

; 261  : 		longID.SetIndexedProperty ( longLowWord, objValue & 0x0000ffff );

  003c7	8b 45 f8	 mov	 eax, DWORD PTR _objValue$[ebp]
  003ca	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  003cf	50		 push	 eax
  003d0	6a 47		 push	 71			; 00000047H
  003d2	8d 4d f4	 lea	 ecx, DWORD PTR _longID$[ebp]
  003d5	e8 00 00 00 00	 call	 ?SetIndexedProperty@ObjectID@@QBEXHF@Z ; ObjectID::SetIndexedProperty

; 262  : 		longID.SetIndexedProperty ( longHiWord, objValue >> 16 );

  003da	8b 4d f8	 mov	 ecx, DWORD PTR _objValue$[ebp]
  003dd	c1 f9 10	 sar	 ecx, 16			; 00000010H
  003e0	51		 push	 ecx
  003e1	6a 48		 push	 72			; 00000048H
  003e3	8d 4d f4	 lea	 ecx, DWORD PTR _longID$[ebp]
  003e6	e8 00 00 00 00	 call	 ?SetIndexedProperty@ObjectID@@QBEXHF@Z ; ObjectID::SetIndexedProperty
$L58826:

; 264  : }

  003eb	5e		 pop	 esi
  003ec	8b e5		 mov	 esp, ebp
  003ee	5d		 pop	 ebp
  003ef	c3		 ret	 0
$L58917:
  003f0	00 00 00 00	 DD	 $L58776
  003f4	00 00 00 00	 DD	 $L58777
  003f8	00 00 00 00	 DD	 $L58778
  003fc	00 00 00 00	 DD	 $L58779
  00400	00 00 00 00	 DD	 $L58780
  00404	00 00 00 00	 DD	 $L58783
  00408	00 00 00 00	 DD	 $L58784
  0040c	00 00 00 00	 DD	 $L58785
  00410	00 00 00 00	 DD	 $L58798
  00414	00 00 00 00	 DD	 $L58800
  00418	00 00 00 00	 DD	 $L58802
  0041c	00 00 00 00	 DD	 $L58804
  00420	00 00 00 00	 DD	 $L58806
  00424	00 00 00 00	 DD	 $L58786
  00428	00 00 00 00	 DD	 $L58787
  0042c	00 00 00 00	 DD	 $L58788
  00430	00 00 00 00	 DD	 $L58789
  00434	00 00 00 00	 DD	 $L58790
  00438	00 00 00 00	 DD	 $L58792
  0043c	00 00 00 00	 DD	 $L58793
  00440	00 00 00 00	 DD	 $L58794
  00444	00 00 00 00	 DD	 $L58796
  00448	00 00 00 00	 DD	 $L58797
  0044c	00 00 00 00	 DD	 $L58808
  00450	00 00 00 00	 DD	 $L58818
  00454	00 00 00 00	 DD	 $L58822
  00458	00 00 00 00	 DD	 $L58823
?KLongInt@@YAXPAF@Z ENDP				; KLongInt
_TEXT	ENDS
PUBLIC	??0MemID@@QAE@ABV0@@Z				; MemID::MemID
;	COMDAT ??0TextID@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0TextID@@QAE@ABV0@@Z PROC NEAR			; TextID::TextID, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0TextID@@QAE@ABV0@@Z ENDP				; TextID::TextID
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0MemID@@QAE@ABV0@@Z PROC NEAR				; MemID::MemID, COMDAT

; 19   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  0000d	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00010	66 89 10	 mov	 WORD PTR [eax], dx

; 20   : 	}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0MemID@@QAE@ABV0@@Z ENDP				; MemID::MemID
_TEXT	ENDS
PUBLIC	??0FakeObjectID@@QAE@ABVMemID@@@Z		; FakeObjectID::FakeObjectID
;	COMDAT ??0ObjectID@@QAE@ABV0@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0ObjectID@@QAE@ABV0@@Z PROC NEAR			; ObjectID::ObjectID, COMDAT

; 229  : 	ObjectID(const ObjectID& id) : FakeObjectID((MemID&) id) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0FakeObjectID@@QAE@ABVMemID@@@Z ; FakeObjectID::FakeObjectID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0ObjectID@@QAE@ABV0@@Z ENDP				; ObjectID::ObjectID
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0FakeObjectID@@QAE@ABVMemID@@@Z PROC NEAR		; FakeObjectID::FakeObjectID, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0FakeObjectID@@QAE@ABVMemID@@@Z ENDP			; FakeObjectID::FakeObjectID
_TEXT	ENDS
PUBLIC	??0FakeObjectID@@QAE@G@Z			; FakeObjectID::FakeObjectID
;	COMDAT ??0ObjectID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0ObjectID@@QAE@G@Z PROC NEAR				; ObjectID::ObjectID, COMDAT

; 230  : 	ObjectID(SOL_Handle h) : FakeObjectID(h) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	66 8b 45 08	 mov	 ax, WORD PTR _h$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0FakeObjectID@@QAE@G@Z ; FakeObjectID::FakeObjectID
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0ObjectID@@QAE@G@Z ENDP				; ObjectID::ObjectID
_TEXT	ENDS
PUBLIC	??0MemID@@QAE@G@Z				; MemID::MemID
;	COMDAT ??0FakeObjectID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0FakeObjectID@@QAE@G@Z PROC NEAR			; FakeObjectID::FakeObjectID, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	66 8b 45 08	 mov	 ax, WORD PTR _h$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0FakeObjectID@@QAE@G@Z ENDP				; FakeObjectID::FakeObjectID
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0MemID@@QAE@G@Z PROC NEAR				; MemID::MemID, COMDAT

; 23   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 4d 08	 mov	 cx, WORD PTR _h$[ebp]
  0000e	66 89 08	 mov	 WORD PTR [eax], cx

; 24   : 	}

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??0MemID@@QAE@G@Z ENDP					; MemID::MemID
_TEXT	ENDS
PUBLIC	?IsValid@MemID@@QBEHXZ				; MemID::IsValid
EXTRN	?GetMemType@MemID@@QBE?AW4MemType@@XZ:NEAR	; MemID::GetMemType
;	COMDAT ?IsObject@ObjectID@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsObject@ObjectID@@QBEHXZ PROC NEAR			; ObjectID::IsObject, COMDAT

; 247  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 248  : 		return IsValid() && GetMemType() == MemObject;

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  00011	85 c0		 test	 eax, eax
  00013	74 16		 je	 SHORT $L58926
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  0001d	83 f8 34	 cmp	 eax, 52			; 00000034H
  00020	75 09		 jne	 SHORT $L58926
  00022	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR -8+[ebp], 1
  00029	eb 07		 jmp	 SHORT $L58927
$L58926:
  0002b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], 0
$L58927:
  00032	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]

; 249  : 	}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?IsObject@ObjectID@@QBEHXZ ENDP				; ObjectID::IsObject
_TEXT	ENDS
PUBLIC	?IsValid@MemoryMgr@@QAEHG@Z			; MemoryMgr::IsValid
EXTRN	_memMgr:DWORD
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsValid@MemID@@QBEHXZ PROC NEAR			; MemID::IsValid, COMDAT

; 62   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 63   : 		return memMgr->IsValid(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?IsValid@MemoryMgr@@QAEHG@Z ; MemoryMgr::IsValid

; 64   : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?IsValid@MemID@@QBEHXZ ENDP				; MemID::IsValid
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -8
_tempID$ = -4
?IsValid@MemoryMgr@@QAEHG@Z PROC NEAR			; MemoryMgr::IsValid, COMDAT

; 475  : 	inline Bool MemoryMgr::IsValid(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 476  : 		unsigned short tempID = (unsigned short)theID;

  00009	66 8b 45 08	 mov	 ax, WORD PTR _theID$[ebp]
  0000d	66 89 45 fc	 mov	 WORD PTR _tempID$[ebp], ax

; 477  : 
; 478  : 		return(
; 479  : 				(tempID)															&&
; 480  : 				(tempID < maxDescriptors)									&&
; 481  : 				(desc[tempID].memInfo.bits.freeDescriptor == False)	&&
; 482  : 				(desc[tempID].memInfo.bits.freeMemory == False)
; 483  : 				);

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _tempID$[ebp]
  00014	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 58		 je	 SHORT $L58930
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _tempID$[ebp]
  00021	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  0002d	73 47		 jae	 SHORT $L58930
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _tempID$[ebp]
  00032	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00038	c1 e1 04	 shl	 ecx, 4
  0003b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00041	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00044	c1 e1 0e	 shl	 ecx, 14			; 0000000eH
  00047	c1 f9 1f	 sar	 ecx, 31			; 0000001fH
  0004a	85 c9		 test	 ecx, ecx
  0004c	75 28		 jne	 SHORT $L58930
  0004e	8b 55 fc	 mov	 edx, DWORD PTR _tempID$[ebp]
  00051	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00057	c1 e2 04	 shl	 edx, 4
  0005a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00060	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00063	c1 e2 14	 shl	 edx, 20			; 00000014H
  00066	c1 fa 1f	 sar	 edx, 31			; 0000001fH
  00069	85 d2		 test	 edx, edx
  0006b	75 09		 jne	 SHORT $L58930
  0006d	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR -12+[ebp], 1
  00074	eb 07		 jmp	 SHORT $L58931
$L58930:
  00076	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR -12+[ebp], 0
$L58931:
  0007d	8b 45 f4	 mov	 eax, DWORD PTR -12+[ebp]

; 484  : 	}

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 04 00	 ret	 4
?IsValid@MemoryMgr@@QAEHG@Z ENDP			; MemoryMgr::IsValid
_TEXT	ENDS
PUBLIC	?GetIndexedProperty@Object@@QAEFH@Z		; Object::GetIndexedProperty
PUBLIC	??CFakeObjectID@@QBEPAUObject@@XZ		; FakeObjectID::operator->
PUBLIC	?AssureValid@ObjectID@@QBEXXZ			; ObjectID::AssureValid
;	COMDAT ?GetIndexedProperty@ObjectID@@QBEFH@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
?GetIndexedProperty@ObjectID@@QBEFH@Z PROC NEAR		; ObjectID::GetIndexedProperty, COMDAT

; 266  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 267  : 		//	get a property given an index in the property offsets table
; 268  : 		AssureValid();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?AssureValid@ObjectID@@QBEXXZ ; ObjectID::AssureValid

; 269  : 		return (*this)->GetIndexedProperty(index);

  0000f	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00012	50		 push	 eax
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  0001b	8b c8		 mov	 ecx, eax
  0001d	e8 00 00 00 00	 call	 ?GetIndexedProperty@Object@@QAEFH@Z ; Object::GetIndexedProperty

; 270  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?GetIndexedProperty@ObjectID@@QBEFH@Z ENDP		; ObjectID::GetIndexedProperty
_TEXT	ENDS
PUBLIC	?GetIndexedPropAddr@Object@@QAEPBFH@Z		; Object::GetIndexedPropAddr
;	COMDAT ?GetIndexedProperty@Object@@QAEFH@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
?GetIndexedProperty@Object@@QAEFH@Z PROC NEAR		; Object::GetIndexedProperty, COMDAT

; 146  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 147  : 		//	get a property given an index in the property offsets table
; 148  : 		return *GetIndexedPropAddr(index);

  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?GetIndexedPropAddr@Object@@QAEPBFH@Z ; Object::GetIndexedPropAddr
  00013	66 8b 00	 mov	 ax, WORD PTR [eax]

; 149  : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?GetIndexedProperty@Object@@QAEFH@Z ENDP		; Object::GetIndexedProperty
_TEXT	ENDS
PUBLIC	??AObject@@QAEAAFH@Z				; Object::operator[]
EXTRN	?indexedPropertyOffsets@@3PAIA:BYTE		; indexedPropertyOffsets
;	COMDAT ?GetIndexedPropAddr@Object@@QAEPBFH@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
?GetIndexedPropAddr@Object@@QAEPBFH@Z PROC NEAR		; Object::GetIndexedPropAddr, COMDAT

; 138  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 139  : 		//	get a property address given an index into the property offsets table
; 140  : 		extern size_t indexedPropertyOffsets[];
; 141  : 		return &(*this)[indexedPropertyOffsets[index]];

  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?indexedPropertyOffsets@@3PAIA[eax*4]
  00011	51		 push	 ecx
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??AObject@@QAEAAFH@Z	; Object::operator[]

; 142  : 	}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?GetIndexedPropAddr@Object@@QAEPBFH@Z ENDP		; Object::GetIndexedPropAddr
_TEXT	ENDS
;	COMDAT ??AObject@@QAEAAFH@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
??AObject@@QAEAAFH@Z PROC NEAR				; Object::operator[], COMDAT

; 117  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 118  : 		//	get a reference to a property given the number of the property
; 119  : 		return ((Property*) this)[index];

  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]

; 120  : 	}

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??AObject@@QAEAAFH@Z ENDP				; Object::operator[]
_TEXT	ENDS
PUBLIC	??DMemID@@QBEPAXXZ				; MemID::operator*
;	COMDAT ??CFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT
_this$ = -4
??CFakeObjectID@@QBEPAUObject@@XZ PROC NEAR		; FakeObjectID::operator->, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??CFakeObjectID@@QBEPAUObject@@XZ ENDP			; FakeObjectID::operator->
_TEXT	ENDS
PUBLIC	?GetAddr@MemoryMgr@@QAEPAXG@Z			; MemoryMgr::GetAddr
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT
_this$ = -4
??DMemID@@QBEPAXXZ PROC NEAR				; MemID::operator*, COMDAT

; 98   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 99   : 		return memMgr->GetAddr(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr

; 100  : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??DMemID@@QBEPAXXZ ENDP					; MemID::operator*
_TEXT	ENDS
EXTRN	__descPtrTable:BYTE
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -4
?GetAddr@MemoryMgr@@QAEPAXG@Z PROC NEAR			; MemoryMgr::GetAddr, COMDAT

; 462  : 	inline void* MemoryMgr::GetAddr(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : //		CheckValid(theID);
; 464  : 		return _descPtrTable[(unsigned int)((unsigned short)theID)];

  00007	8b 45 08	 mov	 eax, DWORD PTR _theID$[ebp]
  0000a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0000f	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR __descPtrTable[eax*4]

; 465  : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?GetAddr@MemoryMgr@@QAEPAXG@Z ENDP			; MemoryMgr::GetAddr
_TEXT	ENDS
PUBLIC	??BMemID@@QBEGXZ				; MemID::operator unsigned short
EXTRN	?Fatal@MsgMgr@@QAAXHZZ:NEAR			; MsgMgr::Fatal
;	COMDAT ?AssureValid@ObjectID@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4
?AssureValid@ObjectID@@QBEXXZ PROC NEAR			; ObjectID::AssureValid, COMDAT

; 238  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 239  : 		if (!IsObject())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?IsObject@ObjectID@@QBEHXZ ; ObjectID::IsObject
  0000f	85 c0		 test	 eax, eax
  00011	75 1e		 jne	 SHORT $L58257

; 240  : 			msgMgr->Fatal(Msg_NotObject, (int) *this);

  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  0001b	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00020	50		 push	 eax
  00021	6a 2f		 push	 47			; 0000002fH
  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXHZZ	; MsgMgr::Fatal
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L58257:

; 241  : 	}

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?AssureValid@ObjectID@@QBEXXZ ENDP			; ObjectID::AssureValid
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4
??BMemID@@QBEGXZ PROC NEAR				; MemID::operator unsigned short, COMDAT

; 93   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   : 		return handle;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 00	 mov	 ax, WORD PTR [eax]

; 95   : 	}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??BMemID@@QBEGXZ ENDP					; MemID::operator unsigned short
_TEXT	ENDS
PUBLIC	?SetIndexedProperty@Object@@QAEXHF@Z		; Object::SetIndexedProperty
;	COMDAT ?SetIndexedProperty@ObjectID@@QBEXHF@Z
_TEXT	SEGMENT
_index$ = 8
_property$ = 12
_this$ = -4
?SetIndexedProperty@ObjectID@@QBEXHF@Z PROC NEAR	; ObjectID::SetIndexedProperty, COMDAT

; 324  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 325  : 		//	set a property given an index into property offsets table
; 326  : 		AssureValid();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?AssureValid@ObjectID@@QBEXXZ ; ObjectID::AssureValid

; 327  : 		(*this)->SetIndexedProperty(index, property);

  0000f	66 8b 45 0c	 mov	 ax, WORD PTR _property$[ebp]
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  00017	51		 push	 ecx
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 ?SetIndexedProperty@Object@@QAEXHF@Z ; Object::SetIndexedProperty

; 328  : 	}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
?SetIndexedProperty@ObjectID@@QBEXHF@Z ENDP		; ObjectID::SetIndexedProperty
_TEXT	ENDS
PUBLIC	?SetPropAtOffset@Object@@QAEAAFI@Z		; Object::SetPropAtOffset
EXTRN	?indexedPropertyOffsets@@3PAIA:BYTE		; indexedPropertyOffsets
;	COMDAT ?SetIndexedProperty@Object@@QAEXHF@Z
_TEXT	SEGMENT
_index$ = 8
_property$ = 12
_this$ = -4
?SetIndexedProperty@Object@@QAEXHF@Z PROC NEAR		; Object::SetIndexedProperty, COMDAT

; 188  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 189  : 		//	set a property given an index into property offsets table
; 190  : 		extern size_t indexedPropertyOffsets[];
; 191  : 		SetPropAtOffset(indexedPropertyOffsets[index] * sizeof(Property)) =
; 192  : 			property;

  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?indexedPropertyOffsets@@3PAIA[eax*4]
  00011	d1 e1		 shl	 ecx, 1
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?SetPropAtOffset@Object@@QAEAAFI@Z ; Object::SetPropAtOffset
  0001c	66 8b 55 0c	 mov	 dx, WORD PTR _property$[ebp]
  00020	66 89 10	 mov	 WORD PTR [eax], dx

; 193  : 	}

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
?SetIndexedProperty@Object@@QAEXHF@Z ENDP		; Object::SetIndexedProperty
_TEXT	ENDS
PUBLIC	?SetGraphicsUpdate@Object@@QAEXXZ		; Object::SetGraphicsUpdate
PUBLIC	?GetPropAtOffset@Object@@QAEAAFI@Z		; Object::GetPropAtOffset
;	COMDAT ?SetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT
_offset$ = 8
_this$ = -4
?SetPropAtOffset@Object@@QAEAAFI@Z PROC NEAR		; Object::SetPropAtOffset, COMDAT

; 197  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 198  : 		//	return reference to property that is about to be changed
; 199  : 		if (offset <= MaxGraphUpdateOffset && offset >= MinGraphUpdateOffset)

  00007	83 7d 08 56	 cmp	 DWORD PTR _offset$[ebp], 86 ; 00000056H
  0000b	77 0e		 ja	 SHORT $L58116
  0000d	83 7d 08 30	 cmp	 DWORD PTR _offset$[ebp], 48 ; 00000030H
  00011	72 08		 jb	 SHORT $L58116

; 200  : 			SetGraphicsUpdate();

  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?SetGraphicsUpdate@Object@@QAEXXZ ; Object::SetGraphicsUpdate
$L58116:

; 201  : 		return GetPropAtOffset(offset);

  0001b	8b 45 08	 mov	 eax, DWORD PTR _offset$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?GetPropAtOffset@Object@@QAEAAFI@Z ; Object::GetPropAtOffset

; 202  : 	}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?SetPropAtOffset@Object@@QAEAAFI@Z ENDP			; Object::SetPropAtOffset
_TEXT	ENDS
;	COMDAT ?SetGraphicsUpdate@Object@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?SetGraphicsUpdate@Object@@QAEXXZ PROC NEAR		; Object::SetGraphicsUpdate, COMDAT

; 97   : 	void		SetGraphicsUpdate()		{ info |= GRAPH_UPD; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 48 0e	 mov	 cx, WORD PTR [eax+14]
  0000e	80 c9 08	 or	 cl, 8
  00011	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00014	66 89 4a 0e	 mov	 WORD PTR [edx+14], cx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?SetGraphicsUpdate@Object@@QAEXXZ ENDP			; Object::SetGraphicsUpdate
_TEXT	ENDS
;	COMDAT ?GetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT
_offset$ = 8
_this$ = -4
?GetPropAtOffset@Object@@QAEAAFI@Z PROC NEAR		; Object::GetPropAtOffset, COMDAT

; 163  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 164  : 		//	get a property given an offset into the object
; 165  : 		return (Property&) ((char*) this)[offset];

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	03 45 08	 add	 eax, DWORD PTR _offset$[ebp]

; 166  : 	}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?GetPropAtOffset@Object@@QAEAAFI@Z ENDP			; Object::GetPropAtOffset
_TEXT	ENDS
PUBLIC	??_C@_00A@?$AA@					; `string'
;	COMDAT ??_C@_00A@?$AA@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\textid.hpp
_BSS	SEGMENT
??_C@_00A@?$AA@ DB 01H DUP (?)				; `string'
_BSS	ENDS
;	COMDAT ??DTextID@@QAEPADXZ
_TEXT	SEGMENT
_this$ = -4
??DTextID@@QAEPADXZ PROC NEAR				; TextID::operator*, COMDAT

; 24   : 	char	*operator *() { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 25   : 		return handle ? (char *)MemID::operator*() : ""; 

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	33 c9		 xor	 ecx, ecx
  0000e	66 8b 08	 mov	 cx, WORD PTR [eax]
  00011	85 c9		 test	 ecx, ecx
  00013	74 0d		 je	 SHORT $L58947
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0001d	89 45 f8	 mov	 DWORD PTR -8+[ebp], eax
  00020	eb 07		 jmp	 SHORT $L58948
$L58947:
  00022	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
$L58948:
  00029	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]

; 26   : 	}

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??DTextID@@QAEPADXZ ENDP				; TextID::operator*
_TEXT	ENDS
END
