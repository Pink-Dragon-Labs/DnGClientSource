	TITLE	C:\Documents and Settings\don\Desktop\sciw\Interp\Cursorw.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BM@LHED@Instructed?5to?5scale?5to?5zero?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07CCG@ResView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KCEF@?4v56?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06IAEF@ResPic?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04EODC@?4p56?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08OCKJ@ResChunk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PIPI@?4chk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07ICMB@ResHunk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GG@?4scr?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08BLBP@ResSound?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KPDA@?4snd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NNMB@ResVocab?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PGDD@?4voc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FLKK@ResPatch?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CEHK@?4pat?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07MKGC@ResFont?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04IDCK@?4fon?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06DEEM@ResPal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NJLC@?4pal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07HFNL@ResHeap?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GFFD@?4hep?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06HDCC@ResMsg?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JONM@?4msg?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NFDN@ResAudio?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MOHF@?4aud?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BKMJ@ResWave?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MPDF@?4wav?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@IMEI@ResAudio36?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BONB@ResSync?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KFFK@?4syn?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09CBJE@ResSync36?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06MIEL@ResMap?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CFLF@?4map?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@LIAH@ResMsgTranslation?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JFJA@?4trn?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08JLOL@ResRobot?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04LLKI@?4rbt?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06OEMP@ResVMD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04IOID@?4vmd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MemoryMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckValid@MemoryMgr@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GMemoryMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@V1@III@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AMemID@@QBEAADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8MemID@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@NN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SOL_Point@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Rgb24@@QAE@EEE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Rgb24@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Rgb24F@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Ratio@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@HHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@VMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Type@Bitmap@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCel@Bitmap@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLoop@Bitmap@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetView@Bitmap@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObj@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Width@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Height@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?XOrg@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?YOrg@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Skip@CelObj@@QBEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemapState@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Mirrored@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObj@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjView@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjView@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjView@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjView@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjMem@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjMem@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjMem@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjMem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjColor@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjColor@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjColor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjColor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1SOL_Cursor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GSOL_Cursor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@AAVSOL_Point@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Set@SOL_Rect@@QAEXHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEmpty@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeEmpty@SOL_Rect@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Xlen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ylen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8SOL_Rect@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clip@SOL_Rect@@QAEXABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Both@SOL_Rect@@QAEXABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveTo@SOL_Rect@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?XDim@Buffer@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?YDim@Buffer@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@CursorWin@@UAEAAVBitmap@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GonnaPaint@CursorWin@@UAEXVSOL_Rect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PaintStarting@CursorWin@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DonePainting@CursorWin@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetDevice@CursorWin@@UAEXAAVPointerDevice@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHideCount@CursorWin@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@CursorWinClr@@UAEAAVBitmap@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHideCount@CursorWinClr@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Info@CursorWinClr@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Draw@ScreenItem@@QAEXABVBuffer@@ABVSOL_Rect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SOL_Rect@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TopPlane@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TopSCIPlane@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Xdim@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ydim@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4Screen@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1PaletteMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GPaletteMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Current@PaletteMgrIndex@@UBEABVSOLPalette@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Source@PaletteMgrIndex@@UBEABVSOLPalette@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Next@PaletteMgrIndex@@UBEABVSOLPalette@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CycleMap@PaletteMgrIndex@@UBEPBEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VaryPercent@PaletteMgrIndex@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VaryPause@PaletteMgrIndex@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0PaletteMgrTrue@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GPaletteMgrTrue@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1PaletteMgrTrue@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1PaletteMgrIWin@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateHardware@PaletteMgrIWin@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GPaletteMgrIWin@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1PaletteMgrTWin@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateHardware@PaletteMgrTWin@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GPaletteMgrTWin@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1PointerDevice@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GPointerDevice@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1SOL_Mouse@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSwiftInfo@SOL_Mouse@@UBEHPAH000@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSwift@SOL_Mouse@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Vibrate@SOL_Mouse@@UBEXHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetHotRectangleStatus@SOL_Mouse@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GSOL_Mouse@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetExtension@SOL_ResType@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSupported@SOL_ResType@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAttrs@SOL_ResType@@UBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResView@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPic@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResChunk@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResScript@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSound@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResVocab@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPatch@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResFont@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPal@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResHeap@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMsg@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResAudio@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResWave@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResAudio36@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSync@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSync36@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMap@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMsgTranslation@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileType@ResMsgTranslation@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResRobot@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResVMD@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCursorWin@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Cursor@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCursorWinClr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7ResPic@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7PaletteMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResView@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResPal@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObj@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResHeap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResWave@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResRobot@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResPatch@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMsgTranslation@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7Buffer@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResScript@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CursorWin@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjColor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CursorWinClr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSync36@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMsg@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7SOL_Cursor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjView@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResAudio36@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7PaletteMgrTrue@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResAudio@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResFont@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7PointerDevice@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7SOL_Mouse@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7MemoryMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7PaletteMgrIWin@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResVMD@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResChunk@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSync@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjMem@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResVocab@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7PaletteMgrTWin@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?buffAND@@3PAEA					; buffAND
PUBLIC	?buffXOR@@3PAEA					; buffXOR
PUBLIC	?cursorBuffAddr@@3PAEA				; cursorBuffAddr
PUBLIC	?winCurBuff@@3PAEA				; winCurBuff
_BSS	SEGMENT
?buffAND@@3PAEA DB 080H DUP (?)				; buffAND
?buffXOR@@3PAEA DB 080H DUP (?)				; buffXOR
_restrictFlag DD 01H DUP (?)
?cursorBuffAddr@@3PAEA DD 01H DUP (?)			; cursorBuffAddr
?winCurBuff@@3PAEA DD 01H DUP (?)			; winCurBuff
_BSS	ENDS
PUBLIC	??0SOL_Point@@QAE@XZ				; SOL_Point::SOL_Point
PUBLIC	??1SOL_Cursor@@UAE@XZ				; SOL_Cursor::~SOL_Cursor
PUBLIC	??0SOL_Cursor@@QAE@XZ				; SOL_Cursor::SOL_Cursor
PUBLIC	??0SOL_Rect@@QAE@XZ				; SOL_Rect::SOL_Rect
PUBLIC	?MakeEmpty@SOL_Rect@@QAEXXZ			; SOL_Rect::MakeEmpty
PUBLIC	??0CursorWin@@QAE@XZ				; CursorWin::CursorWin
PUBLIC	?Hide@CursorWin@@UAEXXZ				; CursorWin::Hide
PUBLIC	?UnHide@CursorWin@@UAEXXZ			; CursorWin::UnHide
PUBLIC	?Show@CursorWin@@UAEXXZ				; CursorWin::Show
PUBLIC	?Set@CursorWin@@UAEXHHH@Z			; CursorWin::Set
PUBLIC	?Get@CursorWin@@UAEAAVBitmap@@XZ		; CursorWin::Get
PUBLIC	?DeviceMovedTo@CursorWin@@UAEXABVSOL_Point@@@Z	; CursorWin::DeviceMovedTo
PUBLIC	?ForcePos@CursorWin@@UAEXVSOL_Point@@@Z		; CursorWin::ForcePos
PUBLIC	?GonnaPaint@CursorWin@@UAEXVSOL_Rect@@@Z	; CursorWin::GonnaPaint
PUBLIC	?PaintStarting@CursorWin@@UAEXXZ		; CursorWin::PaintStarting
PUBLIC	?DonePainting@CursorWin@@UAEXXZ			; CursorWin::DonePainting
PUBLIC	?SetRestrictRect@CursorWin@@UAEXABVSOL_Rect@@@Z	; CursorWin::SetRestrictRect
PUBLIC	?ClearRestrictRect@CursorWin@@UAEXXZ		; CursorWin::ClearRestrictRect
PUBLIC	?SetDevice@CursorWin@@UAEXAAVPointerDevice@@@Z	; CursorWin::SetDevice
PUBLIC	?GetHideCount@CursorWin@@UAEHXZ			; CursorWin::GetHideCount
PUBLIC	??0Bitmap@@QAE@XZ				; Bitmap::Bitmap
PUBLIC	??_7CursorWin@@6B@				; CursorWin::`vftable'
PUBLIC	??_GCursorWin@@UAEPAXI@Z			; CursorWin::`scalar deleting destructor'
PUBLIC	??_ECursorWin@@UAEPAXI@Z			; CursorWin::`vector deleting destructor'
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT ??_7CursorWin@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\Cursorw.cpp
CONST	SEGMENT
??_7CursorWin@@6B@ DD FLAT:??_ECursorWin@@UAEPAXI@Z	; CursorWin::`vftable'
	DD	FLAT:?Hide@CursorWin@@UAEXXZ
	DD	FLAT:?UnHide@CursorWin@@UAEXXZ
	DD	FLAT:?Show@CursorWin@@UAEXXZ
	DD	FLAT:?Set@CursorWin@@UAEXHHH@Z
	DD	FLAT:?Get@CursorWin@@UAEAAVBitmap@@XZ
	DD	FLAT:?DeviceMovedTo@CursorWin@@UAEXABVSOL_Point@@@Z
	DD	FLAT:?ForcePos@CursorWin@@UAEXVSOL_Point@@@Z
	DD	FLAT:?GonnaPaint@CursorWin@@UAEXVSOL_Rect@@@Z
	DD	FLAT:?PaintStarting@CursorWin@@UAEXXZ
	DD	FLAT:?DonePainting@CursorWin@@UAEXXZ
	DD	FLAT:?SetRestrictRect@CursorWin@@UAEXABVSOL_Rect@@@Z
	DD	FLAT:?ClearRestrictRect@CursorWin@@UAEXXZ
	DD	FLAT:?SetDevice@CursorWin@@UAEXAAVPointerDevice@@@Z
	DD	FLAT:?GetHideCount@CursorWin@@UAEHXZ
CONST	ENDS
xdata$x	SEGMENT
$T57580	DD	019930520H
	DD	01H
	DD	FLAT:$T57583
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T57583	DD	0ffffffffH
	DD	FLAT:$L57576
xdata$x	ENDS
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -24
_p$ = -20
??0CursorWin@@QAE@XZ PROC NEAR				; CursorWin::CursorWin

; 37   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 $L57581
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0001b	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  0001e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ??0SOL_Cursor@@QAE@XZ	; SOL_Cursor::SOL_Cursor
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002d	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	83 c1 04	 add	 ecx, 4
  00033	e8 00 00 00 00	 call	 ??0Bitmap@@QAE@XZ	; Bitmap::Bitmap
  00038	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0003e	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@XZ	; SOL_Rect::SOL_Rect
  00043	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	83 c1 30	 add	 ecx, 48			; 00000030H
  00049	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@XZ	; SOL_Rect::SOL_Rect
  0004e	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CursorWin@@6B@ ; CursorWin::`vftable'

; 38   : SOL_Point	p;

  00057	8d 4d ec	 lea	 ecx, DWORD PTR _p$[ebp]
  0005a	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point

; 39   : 
; 40   : 	hideCount = 0;

  0005f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 41   : 	fullSize.MakeEmpty();

  00069	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0006f	e8 00 00 00 00	 call	 ?MakeEmpty@SOL_Rect@@QAEXXZ ; SOL_Rect::MakeEmpty

; 42   : 	restrictFlag = False;

  00074	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _restrictFlag, 0

; 43   : 	p.x = 0;

  0007e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], 0

; 44   : 	p.y = 0;

  00085	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+4], 0

; 45   : }

  0008c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00093	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00096	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00099	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L57576:
  00000	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e8 00 00 00 00	 call	 ??1SOL_Cursor@@UAE@XZ	; SOL_Cursor::~SOL_Cursor
  00008	c3		 ret	 0
$L57581:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T57580
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0CursorWin@@QAE@XZ ENDP				; CursorWin::CursorWin
PUBLIC	??1CursorWin@@UAE@XZ				; CursorWin::~CursorWin
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
;	COMDAT ??_GCursorWin@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GCursorWin@@UAEPAXI@Z PROC NEAR			; CursorWin::`scalar deleting destructor', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CursorWin@@UAE@XZ	; CursorWin::~CursorWin
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L57110
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L57110:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCursorWin@@UAEPAXI@Z ENDP				; CursorWin::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7SOL_Cursor@@6B@				; SOL_Cursor::`vftable'
PUBLIC	??_GSOL_Cursor@@UAEPAXI@Z			; SOL_Cursor::`scalar deleting destructor'
PUBLIC	??_ESOL_Cursor@@UAEPAXI@Z			; SOL_Cursor::`vector deleting destructor'
EXTRN	__purecall:NEAR
;	COMDAT ??_7SOL_Cursor@@6B@
CONST	SEGMENT
??_7SOL_Cursor@@6B@ DD FLAT:??_ESOL_Cursor@@UAEPAXI@Z	; SOL_Cursor::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??0SOL_Cursor@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0SOL_Cursor@@QAE@XZ PROC NEAR				; SOL_Cursor::SOL_Cursor, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7SOL_Cursor@@6B@ ; SOL_Cursor::`vftable'
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0SOL_Cursor@@QAE@XZ ENDP				; SOL_Cursor::SOL_Cursor
_TEXT	ENDS
EXTRN	__imp__ShowCursor@4:NEAR
_TEXT	SEGMENT
_this$ = -4
??1CursorWin@@UAE@XZ PROC NEAR				; CursorWin::~CursorWin

; 49   : {

  000a4	55		 push	 ebp
  000a5	8b ec		 mov	 ebp, esp
  000a7	51		 push	 ecx
  000a8	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  000ab	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CursorWin@@6B@ ; CursorWin::`vftable'

; 50   : 	ShowCursor (1);

  000b4	6a 01		 push	 1
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowCursor@4

; 51   : }

  000bc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000bf	e8 00 00 00 00	 call	 ??1SOL_Cursor@@UAE@XZ	; SOL_Cursor::~SOL_Cursor
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
??1CursorWin@@UAE@XZ ENDP				; CursorWin::~CursorWin
_this$ = -4
?Set@CursorWin@@UAEXHHH@Z PROC NEAR			; CursorWin::Set

; 57   : {

  000c8	55		 push	 ebp
  000c9	8b ec		 mov	 ebp, esp
  000cb	51		 push	 ecx
  000cc	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 58   : }

  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c2 0c 00	 ret	 12			; 0000000cH
?Set@CursorWin@@UAEXHHH@Z ENDP				; CursorWin::Set
_p$ = 8
_this$ = -4
?ForcePos@CursorWin@@UAEXVSOL_Point@@@Z PROC NEAR	; CursorWin::ForcePos

; 63   : {

  000d5	55		 push	 ebp
  000d6	8b ec		 mov	 ebp, esp
  000d8	51		 push	 ecx
  000d9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 64   : 	DeviceMovedTo(p);

  000dc	8d 45 08	 lea	 eax, DWORD PTR _p$[ebp]
  000df	50		 push	 eax
  000e0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e8	ff 52 18	 call	 DWORD PTR [edx+24]

; 65   : }

  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c2 08 00	 ret	 8
?ForcePos@CursorWin@@UAEXVSOL_Point@@@Z ENDP		; CursorWin::ForcePos
_this$ = -4
?DeviceMovedTo@CursorWin@@UAEXABVSOL_Point@@@Z PROC NEAR ; CursorWin::DeviceMovedTo

; 70   : {

  000f1	55		 push	 ebp
  000f2	8b ec		 mov	 ebp, esp
  000f4	51		 push	 ecx
  000f5	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 71   : }

  000f8	8b e5		 mov	 esp, ebp
  000fa	5d		 pop	 ebp
  000fb	c2 04 00	 ret	 4
?DeviceMovedTo@CursorWin@@UAEXABVSOL_Point@@@Z ENDP	; CursorWin::DeviceMovedTo
_this$ = -4
?Hide@CursorWin@@UAEXXZ PROC NEAR			; CursorWin::Hide

; 76   : {

  000fe	55		 push	 ebp
  000ff	8b ec		 mov	 ebp, esp
  00101	51		 push	 ecx
  00102	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 77   : }

  00105	8b e5		 mov	 esp, ebp
  00107	5d		 pop	 ebp
  00108	c3		 ret	 0
?Hide@CursorWin@@UAEXXZ ENDP				; CursorWin::Hide
_this$ = -4
?UnHide@CursorWin@@UAEXXZ PROC NEAR			; CursorWin::UnHide

; 82   : {

  00109	55		 push	 ebp
  0010a	8b ec		 mov	 ebp, esp
  0010c	51		 push	 ecx
  0010d	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 83   : }

  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	c3		 ret	 0
?UnHide@CursorWin@@UAEXXZ ENDP				; CursorWin::UnHide
_this$ = -4
?Show@CursorWin@@UAEXXZ PROC NEAR			; CursorWin::Show

; 87   : {

  00114	55		 push	 ebp
  00115	8b ec		 mov	 ebp, esp
  00117	51		 push	 ecx
  00118	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 88   : }

  0011b	8b e5		 mov	 esp, ebp
  0011d	5d		 pop	 ebp
  0011e	c3		 ret	 0
?Show@CursorWin@@UAEXXZ ENDP				; CursorWin::Show
_this$ = -4
?SetRestrictRect@CursorWin@@UAEXABVSOL_Rect@@@Z PROC NEAR ; CursorWin::SetRestrictRect

; 92   : {

  0011f	55		 push	 ebp
  00120	8b ec		 mov	 ebp, esp
  00122	51		 push	 ecx
  00123	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 93   : }

  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c2 04 00	 ret	 4
?SetRestrictRect@CursorWin@@UAEXABVSOL_Rect@@@Z ENDP	; CursorWin::SetRestrictRect
_this$ = -4
?ClearRestrictRect@CursorWin@@UAEXXZ PROC NEAR		; CursorWin::ClearRestrictRect

; 98   : {

  0012c	55		 push	 ebp
  0012d	8b ec		 mov	 ebp, esp
  0012f	51		 push	 ecx
  00130	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 99   : }

  00133	8b e5		 mov	 esp, ebp
  00135	5d		 pop	 ebp
  00136	c3		 ret	 0
?ClearRestrictRect@CursorWin@@UAEXXZ ENDP		; CursorWin::ClearRestrictRect
_TEXT	ENDS
PUBLIC	??_7CursorWinClr@@6B@				; CursorWinClr::`vftable'
PUBLIC	??_GCursorWinClr@@UAEPAXI@Z			; CursorWinClr::`scalar deleting destructor'
PUBLIC	??_ECursorWinClr@@UAEPAXI@Z			; CursorWinClr::`vector deleting destructor'
PUBLIC	??0SOL_Point@@QAE@HH@Z				; SOL_Point::SOL_Point
PUBLIC	??4SOL_Point@@QAEAAV0@ABV0@@Z			; SOL_Point::operator=
PUBLIC	?Set@SOL_Rect@@QAEXHHHH@Z			; SOL_Rect::Set
PUBLIC	??4SOL_Rect@@QAEAAV0@ABV0@@Z			; SOL_Rect::operator=
PUBLIC	?XDim@Buffer@@QBEHXZ				; Buffer::XDim
PUBLIC	?YDim@Buffer@@QBEHXZ				; Buffer::YDim
PUBLIC	??0Bitmap@@QAE@HHH@Z				; Bitmap::Bitmap
PUBLIC	??0CursorWinClr@@QAE@ABVBufferWin@@@Z		; CursorWinClr::CursorWinClr
PUBLIC	?Hide@CursorWinClr@@UAEXXZ			; CursorWinClr::Hide
PUBLIC	?UnHide@CursorWinClr@@UAEXXZ			; CursorWinClr::UnHide
PUBLIC	?Show@CursorWinClr@@UAEXXZ			; CursorWinClr::Show
PUBLIC	?Set@CursorWinClr@@UAEXHHH@Z			; CursorWinClr::Set
PUBLIC	?Get@CursorWinClr@@UAEAAVBitmap@@XZ		; CursorWinClr::Get
PUBLIC	?SetDevice@CursorWinClr@@UAEXAAVPointerDevice@@@Z ; CursorWinClr::SetDevice
PUBLIC	?DeviceMovedTo@CursorWinClr@@UAEXABVSOL_Point@@@Z ; CursorWinClr::DeviceMovedTo
PUBLIC	?ForcePos@CursorWinClr@@UAEXVSOL_Point@@@Z	; CursorWinClr::ForcePos
PUBLIC	?GonnaPaint@CursorWinClr@@UAEXVSOL_Rect@@@Z	; CursorWinClr::GonnaPaint
PUBLIC	?PaintStarting@CursorWinClr@@UAEXXZ		; CursorWinClr::PaintStarting
PUBLIC	?DonePainting@CursorWinClr@@UAEXXZ		; CursorWinClr::DonePainting
PUBLIC	?SetRestrictRect@CursorWinClr@@UAEXABVSOL_Rect@@@Z ; CursorWinClr::SetRestrictRect
PUBLIC	?ClearRestrictRect@CursorWinClr@@UAEXXZ		; CursorWinClr::ClearRestrictRect
PUBLIC	?GetHideCount@CursorWinClr@@UAEHXZ		; CursorWinClr::GetHideCount
PUBLIC	??0Info@CursorWinClr@@QAE@H@Z			; CursorWinClr::Info::Info
EXTRN	?maxCursorSize@@3HA:DWORD			; maxCursorSize
;	COMDAT ??_7CursorWinClr@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\Cursorw.cpp
CONST	SEGMENT
??_7CursorWinClr@@6B@ DD FLAT:??_ECursorWinClr@@UAEPAXI@Z ; CursorWinClr::`vftable'
	DD	FLAT:?Hide@CursorWinClr@@UAEXXZ
	DD	FLAT:?UnHide@CursorWinClr@@UAEXXZ
	DD	FLAT:?Show@CursorWinClr@@UAEXXZ
	DD	FLAT:?Set@CursorWinClr@@UAEXHHH@Z
	DD	FLAT:?Get@CursorWinClr@@UAEAAVBitmap@@XZ
	DD	FLAT:?DeviceMovedTo@CursorWinClr@@UAEXABVSOL_Point@@@Z
	DD	FLAT:?ForcePos@CursorWinClr@@UAEXVSOL_Point@@@Z
	DD	FLAT:?GonnaPaint@CursorWinClr@@UAEXVSOL_Rect@@@Z
	DD	FLAT:?PaintStarting@CursorWinClr@@UAEXXZ
	DD	FLAT:?DonePainting@CursorWinClr@@UAEXXZ
	DD	FLAT:?SetRestrictRect@CursorWinClr@@UAEXABVSOL_Rect@@@Z
	DD	FLAT:?ClearRestrictRect@CursorWinClr@@UAEXXZ
	DD	FLAT:?SetDevice@CursorWinClr@@UAEXAAVPointerDevice@@@Z
	DD	FLAT:?GetHideCount@CursorWinClr@@UAEHXZ
CONST	ENDS
xdata$x	SEGMENT
$T57601	DD	019930520H
	DD	01H
	DD	FLAT:$T57603
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T57603	DD	0ffffffffH
	DD	FLAT:$L57599
xdata$x	ENDS
_TEXT	SEGMENT
$T57598 = -20
__$EHRec$ = -12
_buffer$ = 8
_this$ = -24
??0CursorWinClr@@QAE@ABVBufferWin@@@Z PROC NEAR		; CursorWinClr::CursorWinClr

; 115  : {

  00137	55		 push	 ebp
  00138	8b ec		 mov	 ebp, esp
  0013a	6a ff		 push	 -1
  0013c	68 00 00 00 00	 push	 $L57602
  00141	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00147	50		 push	 eax
  00148	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0014f	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00152	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00155	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00158	e8 00 00 00 00	 call	 ??0SOL_Cursor@@QAE@XZ	; SOL_Cursor::SOL_Cursor
  0015d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00164	6a ff		 push	 -1
  00166	6a ff		 push	 -1
  00168	6a ff		 push	 -1
  0016a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0016d	83 c1 10	 add	 ecx, 16			; 00000010H
  00170	e8 00 00 00 00	 call	 ??0Bitmap@@QAE@HHH@Z	; Bitmap::Bitmap
  00175	6a 00		 push	 0
  00177	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0017a	83 c1 2c	 add	 ecx, 44			; 0000002cH
  0017d	e8 00 00 00 00	 call	 ??0Info@CursorWinClr@@QAE@H@Z ; CursorWinClr::Info::Info
  00182	6a 00		 push	 0
  00184	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00187	83 c1 48	 add	 ecx, 72			; 00000048H
  0018a	e8 00 00 00 00	 call	 ??0Info@CursorWinClr@@QAE@H@Z ; CursorWinClr::Info::Info
  0018f	6a 00		 push	 0
  00191	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00194	83 c1 64	 add	 ecx, 100		; 00000064H
  00197	e8 00 00 00 00	 call	 ??0Info@CursorWinClr@@QAE@H@Z ; CursorWinClr::Info::Info
  0019c	6a 01		 push	 1
  0019e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001a1	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  001a7	e8 00 00 00 00	 call	 ??0Info@CursorWinClr@@QAE@H@Z ; CursorWinClr::Info::Info
  001ac	6a 00		 push	 0
  001ae	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001b1	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  001b7	e8 00 00 00 00	 call	 ??0Info@CursorWinClr@@QAE@H@Z ; CursorWinClr::Info::Info
  001bc	6a 00		 push	 0
  001be	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001c1	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  001c7	e8 00 00 00 00	 call	 ??0Info@CursorWinClr@@QAE@H@Z ; CursorWinClr::Info::Info
  001cc	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001cf	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  001d5	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@XZ	; SOL_Rect::SOL_Rect
  001da	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001dd	81 c1 e4 00 00
	00		 add	 ecx, 228		; 000000e4H
  001e3	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point
  001e8	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001eb	81 c1 f8 00 00
	00		 add	 ecx, 248		; 000000f8H
  001f1	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@XZ	; SOL_Rect::SOL_Rect
  001f6	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  001f9	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CursorWinClr@@6B@ ; CursorWinClr::`vftable'

; 116  : 	putCursorInVMAP = False;

  001ff	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00202	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 117  : 	gonnaPaint = False;

  00209	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0020c	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 118  : 	hideCount = 0;

  00213	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00216	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 119  : 
; 120  : 	cursorBack.rect.MakeEmpty();

  0021d	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00220	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00223	e8 00 00 00 00	 call	 ?MakeEmpty@SOL_Rect@@QAEXXZ ; SOL_Rect::MakeEmpty

; 121  : 	cursorBack.buffer = NULL;

  00228	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0022b	c7 41 48 00 00
	00 00		 mov	 DWORD PTR [ecx+72], 0

; 122  : 
; 123  : 	cursorData.rect.MakeEmpty();

  00232	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00235	83 c1 30	 add	 ecx, 48			; 00000030H
  00238	e8 00 00 00 00	 call	 ?MakeEmpty@SOL_Rect@@QAEXXZ ; SOL_Rect::MakeEmpty

; 124  : 	cursorData.buffer = NULL;

  0023d	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00240	c7 42 2c 00 00
	00 00		 mov	 DWORD PTR [edx+44], 0

; 125  : 
; 126  : 	saveVmap.rect.MakeEmpty();

  00247	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0024a	83 c1 68	 add	 ecx, 104		; 00000068H
  0024d	e8 00 00 00 00	 call	 ?MakeEmpty@SOL_Rect@@QAEXXZ ; SOL_Rect::MakeEmpty

; 127  : 	saveVmap.buffer = NULL;

  00252	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00255	c7 40 64 00 00
	00 00		 mov	 DWORD PTR [eax+100], 0

; 128  : 
; 129  : 	drawBuff1.rect.MakeEmpty();

  0025c	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0025f	81 c1 a0 00 00
	00		 add	 ecx, 160		; 000000a0H
  00265	e8 00 00 00 00	 call	 ?MakeEmpty@SOL_Rect@@QAEXXZ ; SOL_Rect::MakeEmpty

; 130  : 	drawBuff1.buffer = NULL;

  0026a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0026d	c7 81 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+156], 0

; 131  : 
; 132  : 	drawBuff2.rect.MakeEmpty();

  00277	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0027a	81 c1 bc 00 00
	00		 add	 ecx, 188		; 000000bcH
  00280	e8 00 00 00 00	 call	 ?MakeEmpty@SOL_Rect@@QAEXXZ ; SOL_Rect::MakeEmpty

; 133  : 	drawBuff2.buffer = NULL;

  00285	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00288	c7 82 b8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+184], 0

; 134  : 
; 135  : 	vmapData.rect.Set(0, 0, buffer.XDim() - 1, buffer.YDim() - 1);

  00292	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00295	e8 00 00 00 00	 call	 ?YDim@Buffer@@QBEHXZ	; Buffer::YDim
  0029a	83 e8 01	 sub	 eax, 1
  0029d	50		 push	 eax
  0029e	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  002a1	e8 00 00 00 00	 call	 ?XDim@Buffer@@QBEHXZ	; Buffer::XDim
  002a6	83 e8 01	 sub	 eax, 1
  002a9	50		 push	 eax
  002aa	6a 00		 push	 0
  002ac	6a 00		 push	 0
  002ae	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  002b1	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  002b7	e8 00 00 00 00	 call	 ?Set@SOL_Rect@@QAEXHHHH@Z ; SOL_Rect::Set

; 136  : 	vmapData.buffer = buffer.start;

  002bc	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  002bf	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  002c2	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  002c5	89 90 80 00 00
	00		 mov	 DWORD PTR [eax+128], edx

; 137  : 
; 138  : 	nextPos = SOL_Point(0, 0);

  002cb	6a 00		 push	 0
  002cd	6a 00		 push	 0
  002cf	8d 4d ec	 lea	 ecx, DWORD PTR $T57598[ebp]
  002d2	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@HH@Z	; SOL_Point::SOL_Point
  002d7	50		 push	 eax
  002d8	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  002db	81 c1 e4 00 00
	00		 add	 ecx, 228		; 000000e4H
  002e1	e8 00 00 00 00	 call	 ??4SOL_Point@@QAEAAV0@ABV0@@Z ; SOL_Point::operator=

; 139  : 	disableCount = 0;

  002e6	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  002e9	c7 80 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+236], 0

; 140  : 	restrict = vmapData.rect;

  002f3	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  002f6	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  002fc	51		 push	 ecx
  002fd	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00300	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  00306	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 141  : 
; 142  : 	// set up work buffer pointers
; 143  : 	cursorData.buffer = cursorBuffAddr;

  0030b	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0030e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cursorBuffAddr@@3PAEA ; cursorBuffAddr
  00313	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 144  : 	cursorBack.buffer = cursorBuffAddr + maxCursorSize;

  00316	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cursorBuffAddr@@3PAEA ; cursorBuffAddr
  0031c	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?maxCursorSize@@3HA ; maxCursorSize
  00322	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00325	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 145  : 	drawBuff1.buffer =  cursorBuffAddr + 2 * maxCursorSize;

  00328	a1 00 00 00 00	 mov	 eax, DWORD PTR ?maxCursorSize@@3HA ; maxCursorSize
  0032d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cursorBuffAddr@@3PAEA ; cursorBuffAddr
  00333	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00336	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00339	89 90 9c 00 00
	00		 mov	 DWORD PTR [eax+156], edx

; 146  : 	saveVmap.buffer =   cursorBuffAddr + 3 * maxCursorSize;

  0033f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?maxCursorSize@@3HA ; maxCursorSize
  00345	6b c9 03	 imul	 ecx, 3
  00348	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?cursorBuffAddr@@3PAEA ; cursorBuffAddr
  0034e	03 d1		 add	 edx, ecx
  00350	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00353	89 50 64	 mov	 DWORD PTR [eax+100], edx

; 147  : 	drawBuff2.buffer =  cursorBuffAddr + 4 * maxCursorSize;

  00356	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?maxCursorSize@@3HA ; maxCursorSize
  0035c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?cursorBuffAddr@@3PAEA ; cursorBuffAddr
  00362	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00365	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00368	89 81 b8 00 00
	00		 mov	 DWORD PTR [ecx+184], eax

; 148  : 	winCurBuff =        cursorBuffAddr + 8 * maxCursorSize;

  0036e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?maxCursorSize@@3HA ; maxCursorSize
  00374	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cursorBuffAddr@@3PAEA ; cursorBuffAddr
  00379	8d 0c d0	 lea	 ecx, DWORD PTR [eax+edx*8]
  0037c	89 0d 00 00 00
	00		 mov	 DWORD PTR ?winCurBuff@@3PAEA, ecx ; winCurBuff

; 149  : 
; 150  : //	following line removed because it was causing "Invalid pointer" error
; 151  : // on mono monitor.  TM 10/27/95
; 152  : //	Set(-1, -1, -1);
; 153  : }

  00382	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00389	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0038c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0038f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00396	8b e5		 mov	 esp, ebp
  00398	5d		 pop	 ebp
  00399	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L57599:
  00013	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??1SOL_Cursor@@UAE@XZ	; SOL_Cursor::~SOL_Cursor
  0001b	c3		 ret	 0
$L57602:
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T57601
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0CursorWinClr@@QAE@ABVBufferWin@@@Z ENDP		; CursorWinClr::CursorWinClr
PUBLIC	??1CursorWinClr@@UAE@XZ				; CursorWinClr::~CursorWinClr
;	COMDAT ??_GCursorWinClr@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GCursorWinClr@@UAEPAXI@Z PROC NEAR			; CursorWinClr::`scalar deleting destructor', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CursorWinClr@@UAE@XZ	; CursorWinClr::~CursorWinClr
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L57156
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L57156:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCursorWinClr@@UAEPAXI@Z ENDP			; CursorWinClr::`scalar deleting destructor'
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4
??1CursorWinClr@@UAE@XZ PROC NEAR			; CursorWinClr::~CursorWinClr

; 157  : {

  0039c	55		 push	 ebp
  0039d	8b ec		 mov	 ebp, esp
  0039f	51		 push	 ecx
  003a0	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  003a3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003a6	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CursorWinClr@@6B@ ; CursorWinClr::`vftable'

; 158  : 	ShowCursor(1);

  003ac	6a 01		 push	 1
  003ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowCursor@4

; 159  : //	delete cursorBack.buffer;
; 160  : //	delete cursorData.buffer;
; 161  : //	delete drawBuff1.buffer;
; 162  : //	delete drawBuff2.buffer;
; 163  : //	delete saveVmap.buffer;
; 164  : }

  003b4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003b7	e8 00 00 00 00	 call	 ??1SOL_Cursor@@UAE@XZ	; SOL_Cursor::~SOL_Cursor
  003bc	8b e5		 mov	 esp, ebp
  003be	5d		 pop	 ebp
  003bf	c3		 ret	 0
??1CursorWinClr@@UAE@XZ ENDP				; CursorWinClr::~CursorWinClr
_TEXT	ENDS
PUBLIC	?Width@CelObj@@QBEHXZ				; CelObj::Width
PUBLIC	?Height@CelObj@@QBEHXZ				; CelObj::Height
PUBLIC	?XOrg@CelObj@@QBEHXZ				; CelObj::XOrg
PUBLIC	?YOrg@CelObj@@QBEHXZ				; CelObj::YOrg
PUBLIC	??0SOL_Point@@QAE@ABV0@@Z			; SOL_Point::SOL_Point
PUBLIC	?IsEmpty@SOL_Rect@@QBEHXZ			; SOL_Rect::IsEmpty
PUBLIC	?Clip@SOL_Rect@@QAEXABV1@@Z			; SOL_Rect::Clip
PUBLIC	?SetCel@Bitmap@@QAEXH@Z				; Bitmap::SetCel
PUBLIC	?SetLoop@Bitmap@@QAEXH@Z			; Bitmap::SetLoop
PUBLIC	?SetView@Bitmap@@QAEXH@Z			; Bitmap::SetView
PUBLIC	?ReadVideo@CursorWinClr@@IAEXABUInfo@1@@Z	; CursorWinClr::ReadVideo
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	__imp__exit:NEAR
EXTRN	??0CelObjView@@QAE@HHH@Z:NEAR			; CelObjView::CelObjView
EXTRN	_memset:NEAR
EXTRN	?resMgr@@3PAVResourceMgr@@A:DWORD		; resMgr
EXTRN	?mbuff@@3PADA:BYTE				; mbuff
EXTRN	?MBox@@YAXPAD0@Z:NEAR				; MBox
EXTRN	??0BufferStd@@QAE@HHPAE@Z:NEAR			; BufferStd::BufferStd
EXTRN	__imp__sprintf:NEAR
_BSS	SEGMENT
$SG57179 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG57178 DB	'Cursor too large for buffer (%d X %d).', 0aH, 'Set maxCu'
	DB	'rsorSize option to %d', 00H
_DATA	ENDS
xdata$x	SEGMENT
$T57621	DD	019930520H
	DD	01H
	DD	FLAT:$T57623
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T57623	DD	0ffffffffH
	DD	FLAT:$L57619
xdata$x	ENDS
_TEXT	SEGMENT
$T57608 = -48
$T57609 = -52
$T57612 = -56
$T57613 = -60
$T57614 = -68
$T57615 = -72
$T57616 = -76
__$EHRec$ = -12
_v$ = 8
_l$ = 12
_c$ = 16
_this$ = -80
_cursor$ = -16
_xDim$ = -20
_yDim$ = -24
_xDimMod4$ = -28
_dest$57182 = -44
?Set@CursorWinClr@@UAEXHHH@Z PROC NEAR			; CursorWinClr::Set

; 170  : {

  003c0	55		 push	 ebp
  003c1	8b ec		 mov	 ebp, esp
  003c3	6a ff		 push	 -1
  003c5	68 00 00 00 00	 push	 $L57622
  003ca	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  003d0	50		 push	 eax
  003d1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  003d8	83 ec 4c	 sub	 esp, 76			; 0000004cH
  003db	89 4d b0	 mov	 DWORD PTR _this$[ebp], ecx

; 171  : 
; 172  : 	//  Get resource, put information away for savegame
; 173  : 	gonnaPaint = True;

  003de	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  003e1	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [eax+4], 1

; 174  : 	CelObjView* cursor = NULL;

  003e8	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _cursor$[ebp], 0

; 175  : 	if (v != -1)

  003ef	83 7d 08 ff	 cmp	 DWORD PTR _v$[ebp], -1
  003f3	74 4d		 je	 SHORT $L57167

; 176  : 		cursor = New CelObjView(v, l, c);

  003f5	6a 50		 push	 80			; 00000050H
  003f7	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  003fc	83 c4 04	 add	 esp, 4
  003ff	89 45 cc	 mov	 DWORD PTR $T57609[ebp], eax
  00402	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00409	83 7d cc 00	 cmp	 DWORD PTR $T57609[ebp], 0
  0040d	74 19		 je	 SHORT $L57610
  0040f	8b 4d 10	 mov	 ecx, DWORD PTR _c$[ebp]
  00412	51		 push	 ecx
  00413	8b 55 0c	 mov	 edx, DWORD PTR _l$[ebp]
  00416	52		 push	 edx
  00417	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0041a	50		 push	 eax
  0041b	8b 4d cc	 mov	 ecx, DWORD PTR $T57609[ebp]
  0041e	e8 00 00 00 00	 call	 ??0CelObjView@@QAE@HHH@Z ; CelObjView::CelObjView
  00423	89 45 ac	 mov	 DWORD PTR -84+[ebp], eax
  00426	eb 07		 jmp	 SHORT $L57611
$L57610:
  00428	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR -84+[ebp], 0
$L57611:
  0042f	8b 4d ac	 mov	 ecx, DWORD PTR -84+[ebp]
  00432	89 4d d0	 mov	 DWORD PTR $T57608[ebp], ecx
  00435	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0043c	8b 55 d0	 mov	 edx, DWORD PTR $T57608[ebp]
  0043f	89 55 f0	 mov	 DWORD PTR _cursor$[ebp], edx
$L57167:

; 177  : 
; 178  : 	//  Stop interrupts, erase cursor if not already hidden
; 179  : //	PushAndDisableInterrupts();
; 180  : 	Hide();

  00442	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00445	8b 10		 mov	 edx, DWORD PTR [eax]
  00447	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  0044a	ff 52 04	 call	 DWORD PTR [edx+4]

; 181  : 
; 182  : 
; 183  : 	bitmap.SetView(v);

  0044d	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00450	50		 push	 eax
  00451	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00454	83 c1 10	 add	 ecx, 16			; 00000010H
  00457	e8 00 00 00 00	 call	 ?SetView@Bitmap@@QAEXH@Z ; Bitmap::SetView

; 184  : 	bitmap.SetLoop(l);

  0045c	8b 4d 0c	 mov	 ecx, DWORD PTR _l$[ebp]
  0045f	51		 push	 ecx
  00460	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00463	83 c1 10	 add	 ecx, 16			; 00000010H
  00466	e8 00 00 00 00	 call	 ?SetLoop@Bitmap@@QAEXH@Z ; Bitmap::SetLoop

; 185  : 	bitmap.SetCel(c);

  0046b	8b 55 10	 mov	 edx, DWORD PTR _c$[ebp]
  0046e	52		 push	 edx
  0046f	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00472	83 c1 10	 add	 ecx, 16			; 00000010H
  00475	e8 00 00 00 00	 call	 ?SetCel@Bitmap@@QAEXH@Z	; Bitmap::SetCel

; 186  : 
; 187  : 	int xDim, yDim;
; 188  : 
; 189  : 	if (cursor)  {

  0047a	83 7d f0 00	 cmp	 DWORD PTR _cursor$[ebp], 0
  0047e	74 34		 je	 SHORT $L57174

; 190  : 		xhot = cursor->XOrg();

  00480	8b 4d f0	 mov	 ecx, DWORD PTR _cursor$[ebp]
  00483	e8 00 00 00 00	 call	 ?XOrg@CelObj@@QBEHXZ	; CelObj::XOrg
  00488	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  0048b	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 191  : 		yhot = cursor->YOrg();

  0048e	8b 4d f0	 mov	 ecx, DWORD PTR _cursor$[ebp]
  00491	e8 00 00 00 00	 call	 ?YOrg@CelObj@@QBEHXZ	; CelObj::YOrg
  00496	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  00499	89 42 28	 mov	 DWORD PTR [edx+40], eax

; 192  : 		xDim = cursor->Width();

  0049c	8b 4d f0	 mov	 ecx, DWORD PTR _cursor$[ebp]
  0049f	e8 00 00 00 00	 call	 ?Width@CelObj@@QBEHXZ	; CelObj::Width
  004a4	89 45 ec	 mov	 DWORD PTR _xDim$[ebp], eax

; 193  : 		yDim = cursor->Height();

  004a7	8b 4d f0	 mov	 ecx, DWORD PTR _cursor$[ebp]
  004aa	e8 00 00 00 00	 call	 ?Height@CelObj@@QBEHXZ	; CelObj::Height
  004af	89 45 e8	 mov	 DWORD PTR _yDim$[ebp], eax

; 195  : 	else  {

  004b2	eb 21		 jmp	 SHORT $L57175
$L57174:

; 196  : 		xhot = yhot = 0;

  004b4	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  004b7	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0
  004be	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  004c1	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 197  : 		xDim = yDim = 1;

  004c8	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _yDim$[ebp], 1
  004cf	8b 55 e8	 mov	 edx, DWORD PTR _yDim$[ebp]
  004d2	89 55 ec	 mov	 DWORD PTR _xDim$[ebp], edx
$L57175:

; 199  : 
; 200  : 	int xDimMod4 = ((xDim + 3) >> 2) << 2;

  004d5	8b 45 ec	 mov	 eax, DWORD PTR _xDim$[ebp]
  004d8	83 c0 03	 add	 eax, 3
  004db	c1 f8 02	 sar	 eax, 2
  004de	c1 e0 02	 shl	 eax, 2
  004e1	89 45 e4	 mov	 DWORD PTR _xDimMod4$[ebp], eax

; 201  : 	if (xDimMod4 * yDim > maxCursorSize) {

  004e4	8b 4d e4	 mov	 ecx, DWORD PTR _xDimMod4$[ebp]
  004e7	0f af 4d e8	 imul	 ecx, DWORD PTR _yDim$[ebp]
  004eb	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?maxCursorSize@@3HA ; maxCursorSize
  004f1	7e 40		 jle	 SHORT $L57177

; 202  : 		sprintf(mbuff, "Cursor too large for buffer (%d X %d).\n"
; 203  : 							"Set maxCursorSize option to %d", xDimMod4, yDim, xDimMod4 * yDim);

  004f3	8b 55 e4	 mov	 edx, DWORD PTR _xDimMod4$[ebp]
  004f6	0f af 55 e8	 imul	 edx, DWORD PTR _yDim$[ebp]
  004fa	52		 push	 edx
  004fb	8b 45 e8	 mov	 eax, DWORD PTR _yDim$[ebp]
  004fe	50		 push	 eax
  004ff	8b 4d e4	 mov	 ecx, DWORD PTR _xDimMod4$[ebp]
  00502	51		 push	 ecx
  00503	68 00 00 00 00	 push	 OFFSET FLAT:$SG57178
  00508	68 00 00 00 00	 push	 OFFSET FLAT:?mbuff@@3PADA ; mbuff
  0050d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  00513	83 c4 14	 add	 esp, 20			; 00000014H

; 204  : 		MBox(mbuff,"");

  00516	68 00 00 00 00	 push	 OFFSET FLAT:$SG57179
  0051b	68 00 00 00 00	 push	 OFFSET FLAT:?mbuff@@3PADA ; mbuff
  00520	e8 00 00 00 00	 call	 ?MBox@@YAXPAD0@Z	; MBox
  00525	83 c4 08	 add	 esp, 8

; 205  : 		exit(255);

  00528	68 ff 00 00 00	 push	 255			; 000000ffH
  0052d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
$L57177:

; 207  : 
; 208  : 	//  Extract information, init variables
; 209  : //	delete cursorData.buffer;
; 210  : //	delete cursorBack.buffer;
; 211  : //	delete drawBuff1.buffer;
; 212  : //	delete drawBuff2.buffer;
; 213  : //	delete saveVmap.buffer;
; 214  : 
; 215  : //	cursorData.buffer = New uchar[xDim * yDim];
; 216  : //	cursorBack.buffer = New uchar[xDim * yDim];
; 217  : //	drawBuff1.buffer = New uchar[xDim * yDim];
; 218  : //	drawBuff2.buffer = New uchar[xDim * yDim * 4];
; 219  : //	saveVmap.buffer = New uchar[xDim * yDim];
; 220  : 
; 221  : 	cursorData.rect.Set(0, 0, xDim - 1, yDim - 1);

  00533	8b 55 e8	 mov	 edx, DWORD PTR _yDim$[ebp]
  00536	83 ea 01	 sub	 edx, 1
  00539	52		 push	 edx
  0053a	8b 45 ec	 mov	 eax, DWORD PTR _xDim$[ebp]
  0053d	83 e8 01	 sub	 eax, 1
  00540	50		 push	 eax
  00541	6a 00		 push	 0
  00543	6a 00		 push	 0
  00545	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00548	83 c1 30	 add	 ecx, 48			; 00000030H
  0054b	e8 00 00 00 00	 call	 ?Set@SOL_Rect@@QAEXHHHH@Z ; SOL_Rect::Set

; 222  : 	memset(cursorData.buffer, 255, xDim * yDim);

  00550	8b 4d ec	 mov	 ecx, DWORD PTR _xDim$[ebp]
  00553	0f af 4d e8	 imul	 ecx, DWORD PTR _yDim$[ebp]
  00557	51		 push	 ecx
  00558	68 ff 00 00 00	 push	 255			; 000000ffH
  0055d	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  00560	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00563	50		 push	 eax
  00564	e8 00 00 00 00	 call	 _memset
  00569	83 c4 0c	 add	 esp, 12			; 0000000cH

; 223  : 	cursorData.skip = 255;

  0056c	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  0056f	c6 41 40 ff	 mov	 BYTE PTR [ecx+64], 255	; 000000ffH

; 224  : 
; 225  : 	//  Convert to non-RLE image, display if it wasn't hidden
; 226  : 	if (cursor)  {

  00573	83 7d f0 00	 cmp	 DWORD PTR _cursor$[ebp], 0
  00577	74 69		 je	 SHORT $L57180

; 227  : 		resMgr->Get ( MemResView, v );

  00579	6a 00		 push	 0
  0057b	66 8b 55 08	 mov	 dx, WORD PTR _v$[ebp]
  0057f	52		 push	 edx
  00580	6a 00		 push	 0
  00582	8d 45 c8	 lea	 eax, DWORD PTR $T57612[ebp]
  00585	50		 push	 eax
  00586	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMgr@@3PAVResourceMgr@@A ; resMgr
  0058c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0058e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMgr@@3PAVResourceMgr@@A ; resMgr
  00594	ff 52 20	 call	 DWORD PTR [edx+32]

; 228  : 		BufferStd dest(xDim, yDim, cursorData.buffer);

  00597	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  0059a	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0059d	51		 push	 ecx
  0059e	8b 55 e8	 mov	 edx, DWORD PTR _yDim$[ebp]
  005a1	52		 push	 edx
  005a2	8b 45 ec	 mov	 eax, DWORD PTR _xDim$[ebp]
  005a5	50		 push	 eax
  005a6	8d 4d d4	 lea	 ecx, DWORD PTR _dest$57182[ebp]
  005a9	e8 00 00 00 00	 call	 ??0BufferStd@@QAE@HHPAE@Z ; BufferStd::BufferStd

; 229  : 		cursor->Draw(dest, cursorData.rect, SOL_Point(0, 0), False);

  005ae	6a 00		 push	 0
  005b0	6a 00		 push	 0
  005b2	6a 00		 push	 0
  005b4	8d 4d bc	 lea	 ecx, DWORD PTR $T57614[ebp]
  005b7	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@HH@Z	; SOL_Point::SOL_Point
  005bc	83 ec 08	 sub	 esp, 8
  005bf	8b cc		 mov	 ecx, esp
  005c1	89 65 c4	 mov	 DWORD PTR $T57613[ebp], esp
  005c4	50		 push	 eax
  005c5	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  005ca	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  005cd	83 c1 30	 add	 ecx, 48			; 00000030H
  005d0	51		 push	 ecx
  005d1	8d 55 d4	 lea	 edx, DWORD PTR _dest$57182[ebp]
  005d4	52		 push	 edx
  005d5	8b 45 f0	 mov	 eax, DWORD PTR _cursor$[ebp]
  005d8	8b 10		 mov	 edx, DWORD PTR [eax]
  005da	8b 4d f0	 mov	 ecx, DWORD PTR _cursor$[ebp]
  005dd	ff 52 08	 call	 DWORD PTR [edx+8]

; 231  : 	else  {

  005e0	eb 53		 jmp	 SHORT $L57186
$L57180:

; 232  : 		*cursorData.buffer = cursorData.skip;

  005e2	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  005e5	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  005e8	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  005eb	8a 42 40	 mov	 al, BYTE PTR [edx+64]
  005ee	88 01		 mov	 BYTE PTR [ecx], al

; 233  : 		cursorBack.rect = cursorData.rect;

  005f0	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  005f3	83 c1 30	 add	 ecx, 48			; 00000030H
  005f6	51		 push	 ecx
  005f7	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  005fa	83 c1 4c	 add	 ecx, 76			; 0000004cH
  005fd	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 234  : 		cursorBack.rect.Clip(vmapData.rect);

  00602	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  00605	81 c2 84 00 00
	00		 add	 edx, 132		; 00000084H
  0060b	52		 push	 edx
  0060c	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  0060f	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00612	e8 00 00 00 00	 call	 ?Clip@SOL_Rect@@QAEXABV1@@Z ; SOL_Rect::Clip

; 235  : 		if (!cursorBack.rect.IsEmpty())

  00617	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  0061a	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0061d	e8 00 00 00 00	 call	 ?IsEmpty@SOL_Rect@@QBEHXZ ; SOL_Rect::IsEmpty
  00622	85 c0		 test	 eax, eax
  00624	75 0f		 jne	 SHORT $L57186

; 236  : 			ReadVideo(cursorBack);

  00626	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00629	83 c0 48	 add	 eax, 72			; 00000048H
  0062c	50		 push	 eax
  0062d	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00630	e8 00 00 00 00	 call	 ?ReadVideo@CursorWinClr@@IAEXABUInfo@1@@Z ; CursorWinClr::ReadVideo
$L57186:

; 238  : 
; 239  : 	delete cursor;

  00635	8b 4d f0	 mov	 ecx, DWORD PTR _cursor$[ebp]
  00638	89 4d b4	 mov	 DWORD PTR $T57616[ebp], ecx
  0063b	8b 55 b4	 mov	 edx, DWORD PTR $T57616[ebp]
  0063e	89 55 b8	 mov	 DWORD PTR $T57615[ebp], edx
  00641	83 7d b8 00	 cmp	 DWORD PTR $T57615[ebp], 0
  00645	74 11		 je	 SHORT $L57617
  00647	6a 01		 push	 1
  00649	8b 45 b8	 mov	 eax, DWORD PTR $T57615[ebp]
  0064c	8b 10		 mov	 edx, DWORD PTR [eax]
  0064e	8b 4d b8	 mov	 ecx, DWORD PTR $T57615[ebp]
  00651	ff 12		 call	 DWORD PTR [edx]
  00653	89 45 a8	 mov	 DWORD PTR -88+[ebp], eax
  00656	eb 07		 jmp	 SHORT $L57618
$L57617:
  00658	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR -88+[ebp], 0
$L57618:

; 240  : 	UnHide();

  0065f	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00662	8b 10		 mov	 edx, DWORD PTR [eax]
  00664	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00667	ff 52 08	 call	 DWORD PTR [edx+8]

; 241  : //	PopInterrupts();
; 242  : 	gonnaPaint = False;

  0066a	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  0066d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$L57165:

; 243  : }

  00674	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00677	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0067e	8b e5		 mov	 esp, ebp
  00680	5d		 pop	 ebp
  00681	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
$L57619:
  00026	8b 45 cc	 mov	 eax, DWORD PTR $T57609[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	c3		 ret	 0
$L57622:
  00031	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T57621
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?Set@CursorWinClr@@UAEXHHH@Z ENDP			; CursorWinClr::Set
_TEXT	SEGMENT
_dev$ = 8
_this$ = -12
_p$ = -8
?SetDevice@CursorWinClr@@UAEXAAVPointerDevice@@@Z PROC NEAR ; CursorWinClr::SetDevice

; 250  : {

  00684	55		 push	 ebp
  00685	8b ec		 mov	 ebp, esp
  00687	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0068a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 251  : 	SOL_Point p;

  0068d	8d 4d f8	 lea	 ecx, DWORD PTR _p$[ebp]
  00690	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point

; 252  : 	posDevice = &dev;

  00695	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00698	8b 4d 08	 mov	 ecx, DWORD PTR _dev$[ebp]
  0069b	89 88 f0 00 00
	00		 mov	 DWORD PTR [eax+240], ecx

; 253  : 	posDevice->Setup(*this);

  006a1	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  006a4	52		 push	 edx
  006a5	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  006a8	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  006ae	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  006b1	8b 82 f0 00 00
	00		 mov	 eax, DWORD PTR [edx+240]
  006b7	8b 10		 mov	 edx, DWORD PTR [eax]
  006b9	ff 52 18	 call	 DWORD PTR [edx+24]

; 254  : 	posDevice->GlobalPos(&p);

  006bc	8d 45 f8	 lea	 eax, DWORD PTR _p$[ebp]
  006bf	50		 push	 eax
  006c0	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  006c3	8b 89 f0 00 00
	00		 mov	 ecx, DWORD PTR [ecx+240]
  006c9	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  006cc	8b 82 f0 00 00
	00		 mov	 eax, DWORD PTR [edx+240]
  006d2	8b 10		 mov	 edx, DWORD PTR [eax]
  006d4	ff 52 08	 call	 DWORD PTR [edx+8]

; 255  : 	DeviceMovedTo(p);

  006d7	8d 45 f8	 lea	 eax, DWORD PTR _p$[ebp]
  006da	50		 push	 eax
  006db	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  006de	8b 11		 mov	 edx, DWORD PTR [ecx]
  006e0	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  006e3	ff 52 18	 call	 DWORD PTR [edx+24]

; 256  : }

  006e6	8b e5		 mov	 esp, ebp
  006e8	5d		 pop	 ebp
  006e9	c2 04 00	 ret	 4
?SetDevice@CursorWinClr@@UAEXAAVPointerDevice@@@Z ENDP	; CursorWinClr::SetDevice
_TEXT	ENDS
EXTRN	?hMyWnd@@3PAUHWND__@@A:DWORD			; hMyWnd
EXTRN	?gameWidth@@3HA:DWORD				; gameWidth
EXTRN	?gameHeight@@3HA:DWORD				; gameHeight
EXTRN	?gameBorderX@@3HA:DWORD				; gameBorderX
EXTRN	?gameBorderY@@3HA:DWORD				; gameBorderY
EXTRN	__imp__ClientToScreen@8:NEAR
_TEXT	SEGMENT
_p$ = 8
_this$ = -12
_myPoint$ = -8
?ForcePos@CursorWinClr@@UAEXVSOL_Point@@@Z PROC NEAR	; CursorWinClr::ForcePos

; 263  : {

  006ec	55		 push	 ebp
  006ed	8b ec		 mov	 ebp, esp
  006ef	83 ec 0c	 sub	 esp, 12			; 0000000cH
  006f2	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 264  : POINT	myPoint;
; 265  : 
; 266  : 	myPoint.x = p.x;

  006f5	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  006f8	89 45 f8	 mov	 DWORD PTR _myPoint$[ebp], eax

; 267  : 	myPoint.y = p.y;

  006fb	8b 4d 0c	 mov	 ecx, DWORD PTR _p$[ebp+4]
  006fe	89 4d fc	 mov	 DWORD PTR _myPoint$[ebp+4], ecx

; 268  : 
; 269  : 	// scale to client coords
; 270  : 	myPoint.x = (((int)myPoint.x * gameWidth)  / SCIRESX) + gameBorderX;

  00701	8b 45 f8	 mov	 eax, DWORD PTR _myPoint$[ebp]
  00704	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR ?gameWidth@@3HA ; gameWidth
  0070b	99		 cdq
  0070c	b9 80 02 00 00	 mov	 ecx, 640		; 00000280H
  00711	f7 f9		 idiv	 ecx
  00713	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gameBorderX@@3HA ; gameBorderX
  00719	89 45 f8	 mov	 DWORD PTR _myPoint$[ebp], eax

; 271  : 	myPoint.y = (((int)myPoint.y * gameHeight) / SCIRESY) + gameBorderY;

  0071c	8b 45 fc	 mov	 eax, DWORD PTR _myPoint$[ebp+4]
  0071f	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR ?gameHeight@@3HA ; gameHeight
  00726	99		 cdq
  00727	b9 e0 01 00 00	 mov	 ecx, 480		; 000001e0H
  0072c	f7 f9		 idiv	 ecx
  0072e	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gameBorderY@@3HA ; gameBorderY
  00734	89 45 fc	 mov	 DWORD PTR _myPoint$[ebp+4], eax

; 272  : 
; 273  : 	ClientToScreen (hMyWnd, (LPPOINT)&myPoint);

  00737	8d 55 f8	 lea	 edx, DWORD PTR _myPoint$[ebp]
  0073a	52		 push	 edx
  0073b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hMyWnd@@3PAUHWND__@@A ; hMyWnd
  00740	50		 push	 eax
  00741	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ClientToScreen@8

; 274  : 
; 275  : //	SetCursorPos (myPoint.x, myPoint.y);
; 276  : }

  00747	8b e5		 mov	 esp, ebp
  00749	5d		 pop	 ebp
  0074a	c2 08 00	 ret	 8
?ForcePos@CursorWinClr@@UAEXVSOL_Point@@@Z ENDP		; CursorWinClr::ForcePos
_TEXT	ENDS
PUBLIC	?Intersect@SOL_Rect@@QBEHABV1@@Z		; SOL_Rect::Intersect
_TEXT	SEGMENT
_rect$ = 8
_this$ = -4
?GonnaPaint@CursorWinClr@@UAEXVSOL_Rect@@@Z PROC NEAR	; CursorWinClr::GonnaPaint

; 282  : {

  0074d	55		 push	 ebp
  0074e	8b ec		 mov	 ebp, esp
  00750	51		 push	 ecx
  00751	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 283  : 	if (!hideCount  &&  !putCursorInVMAP  &&  !cursorBack.rect.IsEmpty())  {

  00754	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00757	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0075b	75 49		 jne	 SHORT $L57207
  0075d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00760	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00764	75 40		 jne	 SHORT $L57207
  00766	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00769	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0076c	e8 00 00 00 00	 call	 ?IsEmpty@SOL_Rect@@QBEHXZ ; SOL_Rect::IsEmpty
  00771	85 c0		 test	 eax, eax
  00773	75 31		 jne	 SHORT $L57207

; 284  : 		rect.A.x &= 0x7FFC;

  00775	8b 55 08	 mov	 edx, DWORD PTR _rect$[ebp]
  00778	81 e2 fc 7f 00
	00		 and	 edx, 32764		; 00007ffcH
  0077e	89 55 08	 mov	 DWORD PTR _rect$[ebp], edx

; 285  : 		rect.B.x |= 3;

  00781	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp+8]
  00784	0c 03		 or	 al, 3
  00786	89 45 10	 mov	 DWORD PTR _rect$[ebp+8], eax

; 286  : 		if (cursorBack.rect.Intersect(rect)) {

  00789	8d 4d 08	 lea	 ecx, DWORD PTR _rect$[ebp]
  0078c	51		 push	 ecx
  0078d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00790	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00793	e8 00 00 00 00	 call	 ?Intersect@SOL_Rect@@QBEHABV1@@Z ; SOL_Rect::Intersect
  00798	85 c0		 test	 eax, eax
  0079a	74 0a		 je	 SHORT $L57207

; 287  : 			putCursorInVMAP = True;

  0079c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0079f	c7 42 08 01 00
	00 00		 mov	 DWORD PTR [edx+8], 1
$L57207:

; 290  : 	gonnaPaint = True;

  007a6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  007a9	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [eax+4], 1

; 291  : }

  007b0	8b e5		 mov	 esp, ebp
  007b2	5d		 pop	 ebp
  007b3	c2 10 00	 ret	 16			; 00000010H
?GonnaPaint@CursorWinClr@@UAEXVSOL_Rect@@@Z ENDP	; CursorWinClr::GonnaPaint
_TEXT	ENDS
PUBLIC	?Paint@CursorWinClr@@IAEXABUInfo@1@0@Z		; CursorWinClr::Paint
PUBLIC	?Copy@CursorWinClr@@IAEXABUInfo@1@0@Z		; CursorWinClr::Copy
_TEXT	SEGMENT
_this$ = -4
?PaintStarting@CursorWinClr@@UAEXXZ PROC NEAR		; CursorWinClr::PaintStarting

; 296  : {

  007b6	55		 push	 ebp
  007b7	8b ec		 mov	 ebp, esp
  007b9	51		 push	 ecx
  007ba	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 297  : 	if (putCursorInVMAP)  {

  007bd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  007c0	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  007c4	74 57		 je	 SHORT $L57211

; 298  : 		//  Save Vmap, put cursor in vmap
; 299  : 		saveVmap.rect = cursorData.rect;

  007c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  007c9	83 c1 30	 add	 ecx, 48			; 00000030H
  007cc	51		 push	 ecx
  007cd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  007d0	83 c1 68	 add	 ecx, 104		; 00000068H
  007d3	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 300  : 		// clip it in case we are partly off the vmap
; 301  : 		saveVmap.rect.Clip(vmapData.rect);

  007d8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  007db	81 c2 84 00 00
	00		 add	 edx, 132		; 00000084H
  007e1	52		 push	 edx
  007e2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  007e5	83 c1 68	 add	 ecx, 104		; 00000068H
  007e8	e8 00 00 00 00	 call	 ?Clip@SOL_Rect@@QAEXABV1@@Z ; SOL_Rect::Clip

; 302  : 		Copy(saveVmap, vmapData);

  007ed	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  007f0	05 80 00 00 00	 add	 eax, 128		; 00000080H
  007f5	50		 push	 eax
  007f6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  007f9	83 c1 64	 add	 ecx, 100		; 00000064H
  007fc	51		 push	 ecx
  007fd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00800	e8 00 00 00 00	 call	 ?Copy@CursorWinClr@@IAEXABUInfo@1@0@Z ; CursorWinClr::Copy

; 303  : 		Paint(vmapData, cursorData);

  00805	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00808	83 c2 2c	 add	 edx, 44			; 0000002cH
  0080b	52		 push	 edx
  0080c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0080f	05 80 00 00 00	 add	 eax, 128		; 00000080H
  00814	50		 push	 eax
  00815	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00818	e8 00 00 00 00	 call	 ?Paint@CursorWinClr@@IAEXABUInfo@1@0@Z ; CursorWinClr::Paint
$L57211:

; 305  : }

  0081d	8b e5		 mov	 esp, ebp
  0081f	5d		 pop	 ebp
  00820	c3		 ret	 0
?PaintStarting@CursorWinClr@@UAEXXZ ENDP		; CursorWinClr::PaintStarting
_TEXT	ENDS
EXTRN	?Fatal@MsgMgr@@QAAXDPADHHZZ:NEAR		; MsgMgr::Fatal
EXTRN	?msgMgr@@3PAVMsgMgr@@A:DWORD			; msgMgr
_DATA	SEGMENT
	ORG $+2
$SG57219 DB	'C:\Documents and Settings\don\Desktop\sciw\Interp\Cursor'
	DB	'w.cpp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_this$ = -4
?DonePainting@CursorWinClr@@UAEXXZ PROC NEAR		; CursorWinClr::DonePainting

; 309  : {

  00821	55		 push	 ebp
  00822	8b ec		 mov	 ebp, esp
  00824	51		 push	 ecx
  00825	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 310  : 	if (gonnaPaint)  {

  00828	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0082b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0082f	74 72		 je	 SHORT $L57215

; 311  : 
; 312  : 		//  If cursor was put in vmap, take it out now
; 313  : 		if (putCursorInVMAP)  {

  00831	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00834	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00838	74 2d		 je	 SHORT $L57216

; 314  : 			Copy(vmapData, saveVmap);

  0083a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0083d	83 c2 64	 add	 edx, 100		; 00000064H
  00840	52		 push	 edx
  00841	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00844	05 80 00 00 00	 add	 eax, 128		; 00000080H
  00849	50		 push	 eax
  0084a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0084d	e8 00 00 00 00	 call	 ?Copy@CursorWinClr@@IAEXABUInfo@1@0@Z ; CursorWinClr::Copy

; 315  : 			saveVmap.rect.MakeEmpty();

  00852	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00855	83 c1 68	 add	 ecx, 104		; 00000068H
  00858	e8 00 00 00 00	 call	 ?MakeEmpty@SOL_Rect@@QAEXXZ ; SOL_Rect::MakeEmpty

; 316  : 			putCursorInVMAP = False;

  0085d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00860	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
$L57216:

; 318  : 
; 319  : 		//  Update cursor background
; 320  : 		if (!hideCount  &&  !cursorBack.rect.IsEmpty())

  00867	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0086a	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  0086e	75 27		 jne	 SHORT $L57217
  00870	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00873	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00876	e8 00 00 00 00	 call	 ?IsEmpty@SOL_Rect@@QBEHXZ ; SOL_Rect::IsEmpty
  0087b	85 c0		 test	 eax, eax
  0087d	75 18		 jne	 SHORT $L57217

; 321  : 			Copy(cursorBack, vmapData);

  0087f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00882	05 80 00 00 00	 add	 eax, 128		; 00000080H
  00887	50		 push	 eax
  00888	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0088b	83 c1 48	 add	 ecx, 72			; 00000048H
  0088e	51		 push	 ecx
  0088f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00892	e8 00 00 00 00	 call	 ?Copy@CursorWinClr@@IAEXABUInfo@1@0@Z ; CursorWinClr::Copy
$L57217:

; 322  : 
; 323  : 		gonnaPaint = False;

  00897	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0089a	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 325  : 	else

  008a1	eb 1c		 jmp	 SHORT $L57218
$L57215:

; 326  : 		msgMgr->Fatal(SrcLoc, Msg_DonePainting);

  008a3	6a 57		 push	 87			; 00000057H
  008a5	68 46 01 00 00	 push	 326			; 00000146H
  008aa	68 00 00 00 00	 push	 OFFSET FLAT:$SG57219
  008af	6a 61		 push	 97			; 00000061H
  008b1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  008b6	50		 push	 eax
  008b7	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXDPADHHZZ ; MsgMgr::Fatal
  008bc	83 c4 14	 add	 esp, 20			; 00000014H
$L57218:

; 327  : }

  008bf	8b e5		 mov	 esp, ebp
  008c1	5d		 pop	 ebp
  008c2	c3		 ret	 0
?DonePainting@CursorWinClr@@UAEXXZ ENDP			; CursorWinClr::DonePainting
_TEXT	ENDS
PUBLIC	?Move@CursorWinClr@@IAEXXZ			; CursorWinClr::Move
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
?DeviceMovedTo@CursorWinClr@@UAEXABVSOL_Point@@@Z PROC NEAR ; CursorWinClr::DeviceMovedTo

; 339  : {

  008c3	55		 push	 ebp
  008c4	8b ec		 mov	 ebp, esp
  008c6	51		 push	 ecx
  008c7	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 340  : 	if (!gonnaPaint)  {

  008ca	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  008cd	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  008d1	75 25		 jne	 SHORT $L57224

; 341  : //		PushAndDisableInterrupts();
; 342  : 		nextPos.x = p.x;

  008d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  008d6	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  008d9	8b 02		 mov	 eax, DWORD PTR [edx]
  008db	89 81 e4 00 00
	00		 mov	 DWORD PTR [ecx+228], eax

; 343  : 		nextPos.y = p.y;

  008e1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  008e4	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  008e7	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  008ea	89 81 e8 00 00
	00		 mov	 DWORD PTR [ecx+232], eax

; 344  : 		Move();

  008f0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  008f3	e8 00 00 00 00	 call	 ?Move@CursorWinClr@@IAEXXZ ; CursorWinClr::Move
$L57224:

; 347  : }

  008f8	8b e5		 mov	 esp, ebp
  008fa	5d		 pop	 ebp
  008fb	c2 04 00	 ret	 4
?DeviceMovedTo@CursorWinClr@@UAEXABVSOL_Point@@@Z ENDP	; CursorWinClr::DeviceMovedTo
_TEXT	ENDS
PUBLIC	?DrawToHardware@CursorWinClr@@IAEXABUInfo@1@@Z	; CursorWinClr::DrawToHardware
_TEXT	SEGMENT
_this$ = -4
?Hide@CursorWinClr@@UAEXXZ PROC NEAR			; CursorWinClr::Hide

; 359  : {

  008fe	55		 push	 ebp
  008ff	8b ec		 mov	 ebp, esp
  00901	51		 push	 ecx
  00902	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 360  : //	PushAndDisableInterrupts();
; 361  : 
; 362  : 	if (!hideCount)  {

  00905	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00908	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0090c	75 1e		 jne	 SHORT $L57229

; 363  : 		if (!cursorBack.rect.IsEmpty())  {

  0090e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00911	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00914	e8 00 00 00 00	 call	 ?IsEmpty@SOL_Rect@@QBEHXZ ; SOL_Rect::IsEmpty
  00919	85 c0		 test	 eax, eax
  0091b	75 0f		 jne	 SHORT $L57229

; 364  : 			DrawToHardware(cursorBack);

  0091d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00920	83 c1 48	 add	 ecx, 72			; 00000048H
  00923	51		 push	 ecx
  00924	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00927	e8 00 00 00 00	 call	 ?DrawToHardware@CursorWinClr@@IAEXABUInfo@1@@Z ; CursorWinClr::DrawToHardware
$L57229:

; 367  : 	hideCount++;

  0092c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0092f	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00932	83 c0 01	 add	 eax, 1
  00935	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00938	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 368  : 
; 369  : //	PopInterrupts();
; 370  : }

  0093b	8b e5		 mov	 esp, ebp
  0093d	5d		 pop	 ebp
  0093e	c3		 ret	 0
?Hide@CursorWinClr@@UAEXXZ ENDP				; CursorWinClr::Hide
_TEXT	ENDS
PUBLIC	?MoveTo@SOL_Rect@@QAEXHH@Z			; SOL_Rect::MoveTo
PUBLIC	?RevealCursor@CursorWinClr@@IAEXXZ		; CursorWinClr::RevealCursor
_TEXT	SEGMENT
_this$ = -4
?UnHide@CursorWinClr@@UAEXXZ PROC NEAR			; CursorWinClr::UnHide

; 381  : {

  0093f	55		 push	 ebp
  00940	8b ec		 mov	 ebp, esp
  00942	51		 push	 ecx
  00943	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 382  : 	//  Disable further interrrupts
; 383  : //	PushAndDisableInterrupts();
; 384  : 
; 385  : 	if (hideCount)  {

  00946	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00949	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0094d	74 4b		 je	 SHORT $L57234

; 386  : 		hideCount--;

  0094f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00952	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00955	83 ea 01	 sub	 edx, 1
  00958	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0095b	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 387  : 
; 388  : 		//  If it became visible, calc draw area, save bkg, paint
; 389  : 		if (!hideCount)  {

  0095e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00961	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00965	75 33		 jne	 SHORT $L57234

; 390  : 			cursorData.rect.MoveTo(nextPos.x - xhot, nextPos.y - yhot);

  00967	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0096a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0096d	8b 8a e8 00 00
	00		 mov	 ecx, DWORD PTR [edx+232]
  00973	2b 48 28	 sub	 ecx, DWORD PTR [eax+40]
  00976	51		 push	 ecx
  00977	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0097a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0097d	8b 8a e4 00 00
	00		 mov	 ecx, DWORD PTR [edx+228]
  00983	2b 48 24	 sub	 ecx, DWORD PTR [eax+36]
  00986	51		 push	 ecx
  00987	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0098a	83 c1 30	 add	 ecx, 48			; 00000030H
  0098d	e8 00 00 00 00	 call	 ?MoveTo@SOL_Rect@@QAEXHH@Z ; SOL_Rect::MoveTo

; 391  : 			RevealCursor();

  00992	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00995	e8 00 00 00 00	 call	 ?RevealCursor@CursorWinClr@@IAEXXZ ; CursorWinClr::RevealCursor
$L57234:

; 394  : //	else
; 395  : //		msgMgr->Fatal(SrcLoc, Msg_CursorUnHide);
; 396  : 
; 397  : //	PopInterrupts();
; 398  : }

  0099a	8b e5		 mov	 esp, ebp
  0099c	5d		 pop	 ebp
  0099d	c3		 ret	 0
?UnHide@CursorWinClr@@UAEXXZ ENDP			; CursorWinClr::UnHide
_this$ = -4
?Show@CursorWinClr@@UAEXXZ PROC NEAR			; CursorWinClr::Show

; 408  : {

  0099e	55		 push	 ebp
  0099f	8b ec		 mov	 ebp, esp
  009a1	51		 push	 ecx
  009a2	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 409  : 	//  Disable further interrrupts
; 410  : //	PushAndDisableInterrupts();
; 411  : 
; 412  : 	if (hideCount)  {

  009a5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  009a8	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  009ac	74 3d		 je	 SHORT $L57238

; 413  : 		hideCount = 0;

  009ae	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  009b1	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 414  : 
; 415  : 		//  If it became visible, calc draw area, save bkg, paint
; 416  : 		cursorData.rect.MoveTo(nextPos.x - xhot, nextPos.y - yhot);

  009b8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  009bb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  009be	8b 8a e8 00 00
	00		 mov	 ecx, DWORD PTR [edx+232]
  009c4	2b 48 28	 sub	 ecx, DWORD PTR [eax+40]
  009c7	51		 push	 ecx
  009c8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  009cb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  009ce	8b 8a e4 00 00
	00		 mov	 ecx, DWORD PTR [edx+228]
  009d4	2b 48 24	 sub	 ecx, DWORD PTR [eax+36]
  009d7	51		 push	 ecx
  009d8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  009db	83 c1 30	 add	 ecx, 48			; 00000030H
  009de	e8 00 00 00 00	 call	 ?MoveTo@SOL_Rect@@QAEXHH@Z ; SOL_Rect::MoveTo

; 417  : 		RevealCursor();

  009e3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  009e6	e8 00 00 00 00	 call	 ?RevealCursor@CursorWinClr@@IAEXXZ ; CursorWinClr::RevealCursor
$L57238:

; 419  : 
; 420  : //	PopInterrupts();
; 421  : }

  009eb	8b e5		 mov	 esp, ebp
  009ed	5d		 pop	 ebp
  009ee	c3		 ret	 0
?Show@CursorWinClr@@UAEXXZ ENDP				; CursorWinClr::Show
_this$ = -4
?RevealCursor@CursorWinClr@@IAEXXZ PROC NEAR		; CursorWinClr::RevealCursor

; 427  : {

  009ef	55		 push	 ebp
  009f0	8b ec		 mov	 ebp, esp
  009f2	51		 push	 ecx
  009f3	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 428  : 	cursorBack.rect = cursorData.rect;

  009f6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  009f9	83 c0 30	 add	 eax, 48			; 00000030H
  009fc	50		 push	 eax
  009fd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a00	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00a03	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 429  : 	cursorBack.rect.Clip(vmapData.rect);

  00a08	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a0b	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  00a11	51		 push	 ecx
  00a12	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a15	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00a18	e8 00 00 00 00	 call	 ?Clip@SOL_Rect@@QAEXABV1@@Z ; SOL_Rect::Clip

; 430  : 	if (cursorBack.rect.IsEmpty())

  00a1d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a20	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00a23	e8 00 00 00 00	 call	 ?IsEmpty@SOL_Rect@@QBEHXZ ; SOL_Rect::IsEmpty
  00a28	85 c0		 test	 eax, eax
  00a2a	74 02		 je	 SHORT $L57242

; 431  : 		return;

  00a2c	eb 7e		 jmp	 SHORT $L57241
$L57242:

; 432  : 
; 433  : 	ReadVideo(cursorBack);

  00a2e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00a31	83 c2 48	 add	 edx, 72			; 00000048H
  00a34	52		 push	 edx
  00a35	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a38	e8 00 00 00 00	 call	 ?ReadVideo@CursorWinClr@@IAEXABUInfo@1@@Z ; CursorWinClr::ReadVideo

; 434  : 	drawBuff1.rect = cursorData.rect;

  00a3d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a40	83 c0 30	 add	 eax, 48			; 00000030H
  00a43	50		 push	 eax
  00a44	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a47	81 c1 a0 00 00
	00		 add	 ecx, 160		; 000000a0H
  00a4d	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 435  : 	// clip it in case we are partly off the vmap
; 436  : 	drawBuff1.rect.Clip(vmapData.rect);

  00a52	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a55	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  00a5b	51		 push	 ecx
  00a5c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a5f	81 c1 a0 00 00
	00		 add	 ecx, 160		; 000000a0H
  00a65	e8 00 00 00 00	 call	 ?Clip@SOL_Rect@@QAEXABV1@@Z ; SOL_Rect::Clip

; 437  : 	Copy(drawBuff1, cursorBack);

  00a6a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00a6d	83 c2 48	 add	 edx, 72			; 00000048H
  00a70	52		 push	 edx
  00a71	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a74	05 9c 00 00 00	 add	 eax, 156		; 0000009cH
  00a79	50		 push	 eax
  00a7a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a7d	e8 00 00 00 00	 call	 ?Copy@CursorWinClr@@IAEXABUInfo@1@0@Z ; CursorWinClr::Copy

; 438  : 
; 439  : 	Paint(drawBuff1, cursorData);

  00a82	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a85	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00a88	51		 push	 ecx
  00a89	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00a8c	81 c2 9c 00 00
	00		 add	 edx, 156		; 0000009cH
  00a92	52		 push	 edx
  00a93	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a96	e8 00 00 00 00	 call	 ?Paint@CursorWinClr@@IAEXABUInfo@1@0@Z ; CursorWinClr::Paint

; 440  : 	DrawToHardware(drawBuff1);

  00a9b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a9e	05 9c 00 00 00	 add	 eax, 156		; 0000009cH
  00aa3	50		 push	 eax
  00aa4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00aa7	e8 00 00 00 00	 call	 ?DrawToHardware@CursorWinClr@@IAEXABUInfo@1@@Z ; CursorWinClr::DrawToHardware
$L57241:

; 441  : }

  00aac	8b e5		 mov	 esp, ebp
  00aae	5d		 pop	 ebp
  00aaf	c3		 ret	 0
?RevealCursor@CursorWinClr@@IAEXXZ ENDP			; CursorWinClr::RevealCursor
_TEXT	ENDS
PUBLIC	?Both@SOL_Rect@@QAEXABV1@@Z			; SOL_Rect::Both
PUBLIC	??0SOL_Rect@@QAE@ABV0@@Z			; SOL_Rect::SOL_Rect
_TEXT	SEGMENT
_this$ = -20
_mergedRect$57251 = -16
?Move@CursorWinClr@@IAEXXZ PROC NEAR			; CursorWinClr::Move

; 453  : {

  00ab0	55		 push	 ebp
  00ab1	8b ec		 mov	 ebp, esp
  00ab3	83 ec 14	 sub	 esp, 20			; 00000014H
  00ab6	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 454  : 	if (!hideCount)  {

  00ab9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00abc	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00ac0	0f 85 3a 02 00
	00		 jne	 $L57250

; 455  : 
; 456  : 		//  If it was off the screen, just show it and return
; 457  : 		cursorData.rect.MoveTo(nextPos.x - xhot, nextPos.y - yhot);

  00ac6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00ac9	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00acc	8b 81 e8 00 00
	00		 mov	 eax, DWORD PTR [ecx+232]
  00ad2	2b 42 28	 sub	 eax, DWORD PTR [edx+40]
  00ad5	50		 push	 eax
  00ad6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00ad9	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00adc	8b 81 e4 00 00
	00		 mov	 eax, DWORD PTR [ecx+228]
  00ae2	2b 42 24	 sub	 eax, DWORD PTR [edx+36]
  00ae5	50		 push	 eax
  00ae6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00ae9	83 c1 30	 add	 ecx, 48			; 00000030H
  00aec	e8 00 00 00 00	 call	 ?MoveTo@SOL_Rect@@QAEXHH@Z ; SOL_Rect::MoveTo

; 458  : 		if (cursorBack.rect.IsEmpty())  {

  00af1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00af4	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00af7	e8 00 00 00 00	 call	 ?IsEmpty@SOL_Rect@@QBEHXZ ; SOL_Rect::IsEmpty
  00afc	85 c0		 test	 eax, eax
  00afe	74 0d		 je	 SHORT $L57247

; 459  : 			RevealCursor();

  00b00	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00b03	e8 00 00 00 00	 call	 ?RevealCursor@CursorWinClr@@IAEXXZ ; CursorWinClr::RevealCursor

; 460  : 			return;

  00b08	e9 f3 01 00 00	 jmp	 $L57245
$L57247:

; 462  : 
; 463  : 		//  If we just moved entirely off screen, remove background & return
; 464  : 		if (!cursorData.rect.Intersect(vmapData.rect))  {

  00b0d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00b10	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  00b16	51		 push	 ecx
  00b17	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00b1a	83 c1 30	 add	 ecx, 48			; 00000030H
  00b1d	e8 00 00 00 00	 call	 ?Intersect@SOL_Rect@@QBEHABV1@@Z ; SOL_Rect::Intersect
  00b22	85 c0		 test	 eax, eax
  00b24	75 14		 jne	 SHORT $L57248

; 465  : 			DrawToHardware(cursorBack);

  00b26	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00b29	83 c2 48	 add	 edx, 72			; 00000048H
  00b2c	52		 push	 edx
  00b2d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00b30	e8 00 00 00 00	 call	 ?DrawToHardware@CursorWinClr@@IAEXABUInfo@1@@Z ; CursorWinClr::DrawToHardware

; 466  : 			return;

  00b35	e9 c6 01 00 00	 jmp	 $L57245
$L57248:

; 468  : 
; 469  : 
; 470  : 		if (!cursorData.rect.Intersect(cursorBack.rect))  {

  00b3a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00b3d	83 c0 4c	 add	 eax, 76			; 0000004cH
  00b40	50		 push	 eax
  00b41	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00b44	83 c1 30	 add	 ecx, 48			; 00000030H
  00b47	e8 00 00 00 00	 call	 ?Intersect@SOL_Rect@@QBEHABV1@@Z ; SOL_Rect::Intersect
  00b4c	85 c0		 test	 eax, eax
  00b4e	0f 85 ee 00 00
	00		 jne	 $L57249

; 471  : 			//  Do two rectangles
; 472  : 
; 473  : 			//  Read new rectangles background
; 474  : 			drawBuff1.rect = cursorData.rect;

  00b54	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00b57	83 c1 30	 add	 ecx, 48			; 00000030H
  00b5a	51		 push	 ecx
  00b5b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00b5e	81 c1 a0 00 00
	00		 add	 ecx, 160		; 000000a0H
  00b64	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 475  : 			drawBuff1.rect.Clip(vmapData.rect);

  00b69	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00b6c	81 c2 84 00 00
	00		 add	 edx, 132		; 00000084H
  00b72	52		 push	 edx
  00b73	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00b76	81 c1 a0 00 00
	00		 add	 ecx, 160		; 000000a0H
  00b7c	e8 00 00 00 00	 call	 ?Clip@SOL_Rect@@QAEXABV1@@Z ; SOL_Rect::Clip

; 476  : 			ReadVideo(drawBuff1);

  00b81	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00b84	05 9c 00 00 00	 add	 eax, 156		; 0000009cH
  00b89	50		 push	 eax
  00b8a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00b8d	e8 00 00 00 00	 call	 ?ReadVideo@CursorWinClr@@IAEXABUInfo@1@@Z ; CursorWinClr::ReadVideo

; 477  : 
; 478  : 			//  Ensure that data from there has been erased
; 479  : 
; 480  : 			//  Make duplicate to 2nd buffer
; 481  : 			drawBuff2.rect = drawBuff1.rect;

  00b92	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00b95	81 c1 a0 00 00
	00		 add	 ecx, 160		; 000000a0H
  00b9b	51		 push	 ecx
  00b9c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00b9f	81 c1 bc 00 00
	00		 add	 ecx, 188		; 000000bcH
  00ba5	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 482  : 			Copy(drawBuff2, drawBuff1);

  00baa	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00bad	81 c2 9c 00 00
	00		 add	 edx, 156		; 0000009cH
  00bb3	52		 push	 edx
  00bb4	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00bb7	05 b8 00 00 00	 add	 eax, 184		; 000000b8H
  00bbc	50		 push	 eax
  00bbd	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00bc0	e8 00 00 00 00	 call	 ?Copy@CursorWinClr@@IAEXABUInfo@1@0@Z ; CursorWinClr::Copy

; 483  : 
; 484  : 			//  Drawing cursor to buffer 1, display on hardware
; 485  : 			Paint(drawBuff1, cursorData);

  00bc5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00bc8	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00bcb	51		 push	 ecx
  00bcc	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00bcf	81 c2 9c 00 00
	00		 add	 edx, 156		; 0000009cH
  00bd5	52		 push	 edx
  00bd6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00bd9	e8 00 00 00 00	 call	 ?Paint@CursorWinClr@@IAEXABUInfo@1@0@Z ; CursorWinClr::Paint

; 486  : 			DrawToHardware(drawBuff1);

  00bde	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00be1	05 9c 00 00 00	 add	 eax, 156		; 0000009cH
  00be6	50		 push	 eax
  00be7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00bea	e8 00 00 00 00	 call	 ?DrawToHardware@CursorWinClr@@IAEXABUInfo@1@@Z ; CursorWinClr::DrawToHardware

; 487  : 
; 488  : 			//  Display old background to hardware (erase)
; 489  : 			DrawToHardware(cursorBack);

  00bef	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00bf2	83 c1 48	 add	 ecx, 72			; 00000048H
  00bf5	51		 push	 ecx
  00bf6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00bf9	e8 00 00 00 00	 call	 ?DrawToHardware@CursorWinClr@@IAEXABUInfo@1@@Z ; CursorWinClr::DrawToHardware

; 490  : 
; 491  : 			//  Copy buffer 2 to background
; 492  : 			cursorBack.rect = cursorData.rect;

  00bfe	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00c01	83 c2 30	 add	 edx, 48			; 00000030H
  00c04	52		 push	 edx
  00c05	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00c08	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00c0b	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 493  : 			cursorBack.rect.Clip(vmapData.rect);

  00c10	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00c13	05 84 00 00 00	 add	 eax, 132		; 00000084H
  00c18	50		 push	 eax
  00c19	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00c1c	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00c1f	e8 00 00 00 00	 call	 ?Clip@SOL_Rect@@QAEXABV1@@Z ; SOL_Rect::Clip

; 494  : 			Copy(cursorBack, drawBuff2);

  00c24	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00c27	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  00c2d	51		 push	 ecx
  00c2e	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00c31	83 c2 48	 add	 edx, 72			; 00000048H
  00c34	52		 push	 edx
  00c35	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00c38	e8 00 00 00 00	 call	 ?Copy@CursorWinClr@@IAEXABUInfo@1@0@Z ; CursorWinClr::Copy

; 496  : 		else  {

  00c3d	e9 be 00 00 00	 jmp	 $L57250
$L57249:

; 497  : 			//  Do one rectangle
; 498  : 
; 499  : 			SOL_Rect mergedRect = cursorBack.rect;

  00c42	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00c45	83 c0 4c	 add	 eax, 76			; 0000004cH
  00c48	50		 push	 eax
  00c49	8d 4d f0	 lea	 ecx, DWORD PTR _mergedRect$57251[ebp]
  00c4c	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@ABV0@@Z ; SOL_Rect::SOL_Rect

; 500  : 			mergedRect.Both(cursorData.rect);

  00c51	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00c54	83 c1 30	 add	 ecx, 48			; 00000030H
  00c57	51		 push	 ecx
  00c58	8d 4d f0	 lea	 ecx, DWORD PTR _mergedRect$57251[ebp]
  00c5b	e8 00 00 00 00	 call	 ?Both@SOL_Rect@@QAEXABV1@@Z ; SOL_Rect::Both

; 501  : 			mergedRect.Clip(vmapData.rect);

  00c60	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00c63	81 c2 84 00 00
	00		 add	 edx, 132		; 00000084H
  00c69	52		 push	 edx
  00c6a	8d 4d f0	 lea	 ecx, DWORD PTR _mergedRect$57251[ebp]
  00c6d	e8 00 00 00 00	 call	 ?Clip@SOL_Rect@@QAEXABV1@@Z ; SOL_Rect::Clip

; 502  : 
; 503  : 			//  Set up overlapping rectangle, read background from video
; 504  : 			drawBuff2.rect = mergedRect;

  00c72	8d 45 f0	 lea	 eax, DWORD PTR _mergedRect$57251[ebp]
  00c75	50		 push	 eax
  00c76	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00c79	81 c1 bc 00 00
	00		 add	 ecx, 188		; 000000bcH
  00c7f	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 505  : 			ReadVideo(drawBuff2);

  00c84	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00c87	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  00c8d	51		 push	 ecx
  00c8e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00c91	e8 00 00 00 00	 call	 ?ReadVideo@CursorWinClr@@IAEXABUInfo@1@@Z ; CursorWinClr::ReadVideo

; 506  : 
; 507  : 			//  Erase old cursor from new background rect
; 508  : //			Copy(drawBuff2, cursorBack);
; 509  : 
; 510  : 			//  Update current cursor background
; 511  : 			cursorBack.rect = cursorData.rect;

  00c96	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00c99	83 c2 30	 add	 edx, 48			; 00000030H
  00c9c	52		 push	 edx
  00c9d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00ca0	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00ca3	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 512  : 			cursorBack.rect.Clip(vmapData.rect);

  00ca8	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00cab	05 84 00 00 00	 add	 eax, 132		; 00000084H
  00cb0	50		 push	 eax
  00cb1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00cb4	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00cb7	e8 00 00 00 00	 call	 ?Clip@SOL_Rect@@QAEXABV1@@Z ; SOL_Rect::Clip

; 513  : 			Copy(cursorBack, drawBuff2);

  00cbc	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00cbf	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  00cc5	51		 push	 ecx
  00cc6	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00cc9	83 c2 48	 add	 edx, 72			; 00000048H
  00ccc	52		 push	 edx
  00ccd	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00cd0	e8 00 00 00 00	 call	 ?Copy@CursorWinClr@@IAEXABUInfo@1@0@Z ; CursorWinClr::Copy

; 514  : 
; 515  : 			//  Draw cursor in background buffer, update hardware
; 516  : 			Paint(drawBuff2, cursorData);

  00cd5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00cd8	83 c0 2c	 add	 eax, 44			; 0000002cH
  00cdb	50		 push	 eax
  00cdc	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00cdf	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  00ce5	51		 push	 ecx
  00ce6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00ce9	e8 00 00 00 00	 call	 ?Paint@CursorWinClr@@IAEXABUInfo@1@0@Z ; CursorWinClr::Paint

; 517  : 			DrawToHardware(drawBuff2);

  00cee	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00cf1	81 c2 b8 00 00
	00		 add	 edx, 184		; 000000b8H
  00cf7	52		 push	 edx
  00cf8	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00cfb	e8 00 00 00 00	 call	 ?DrawToHardware@CursorWinClr@@IAEXABUInfo@1@@Z ; CursorWinClr::DrawToHardware
$L57250:
$L57245:

; 520  : }

  00d00	8b e5		 mov	 esp, ebp
  00d02	5d		 pop	 ebp
  00d03	c3		 ret	 0
?Move@CursorWinClr@@IAEXXZ ENDP				; CursorWinClr::Move
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0SOL_Point@@QAE@XZ PROC NEAR				; SOL_Point::SOL_Point, COMDAT

; 20   : 	SOL_Point() : x(DefaultCoord), y(DefaultCoord) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 ef cd ab
	89		 mov	 DWORD PTR [eax], -1985229329 ; 89abcdefH
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 ef cd
	ab 89		 mov	 DWORD PTR [ecx+4], -1985229329 ; 89abcdefH
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0SOL_Point@@QAE@XZ ENDP				; SOL_Point::SOL_Point
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@HH@Z
_TEXT	SEGMENT
_x$ = 8
_y$ = 12
_this$ = -4
??0SOL_Point@@QAE@HH@Z PROC NEAR			; SOL_Point::SOL_Point, COMDAT

; 21   : 	SOL_Point(Coord x, Coord y) : x(x), y(y) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0SOL_Point@@QAE@HH@Z ENDP				; SOL_Point::SOL_Point
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@ABV0@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
??0SOL_Point@@QAE@ABV0@@Z PROC NEAR			; SOL_Point::SOL_Point, COMDAT

; 22   : 	SOL_Point(const SOL_Point& p) : x(p.x), y(p.y) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00017	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001a	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??0SOL_Point@@QAE@ABV0@@Z ENDP				; SOL_Point::SOL_Point
_TEXT	ENDS
PUBLIC	?Xlen@SOL_Rect@@QBEHXZ				; SOL_Rect::Xlen
PUBLIC	?Ylen@SOL_Rect@@QBEHXZ				; SOL_Rect::Ylen
_TEXT	SEGMENT
_dest$ = 8
_src$ = 12
_this$ = -64
_srcRect$ = -36
_sxo$ = -56
_syo$ = -16
_xsize$ = -44
_ysize$ = -4
_destPtr$ = -12
_srcPtr$ = -52
_skip$ = -40
_srcNextLine$ = -20
_destNextLine$ = -8
_y$ = -48
_x$57274 = -60
?Paint@CursorWinClr@@IAEXABUInfo@1@0@Z PROC NEAR	; CursorWinClr::Paint

; 533  : {

  00d04	55		 push	 ebp
  00d05	8b ec		 mov	 ebp, esp
  00d07	83 ec 40	 sub	 esp, 64			; 00000040H
  00d0a	56		 push	 esi
  00d0b	89 4d c0	 mov	 DWORD PTR _this$[ebp], ecx

; 534  : 	if (src.rect.IsEmpty())

  00d0e	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00d11	83 c1 04	 add	 ecx, 4
  00d14	e8 00 00 00 00	 call	 ?IsEmpty@SOL_Rect@@QBEHXZ ; SOL_Rect::IsEmpty
  00d19	85 c0		 test	 eax, eax
  00d1b	74 05		 je	 SHORT $L57257

; 535  : 		return;

  00d1d	e9 94 01 00 00	 jmp	 $L57256
$L57257:

; 536  : 
; 537  : 	SOL_Rect srcRect = src.rect;

  00d22	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00d25	83 c0 04	 add	 eax, 4
  00d28	50		 push	 eax
  00d29	8d 4d dc	 lea	 ecx, DWORD PTR _srcRect$[ebp]
  00d2c	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@ABV0@@Z ; SOL_Rect::SOL_Rect

; 538  : 	srcRect.Clip(dest.rect);

  00d31	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00d34	83 c1 04	 add	 ecx, 4
  00d37	51		 push	 ecx
  00d38	8d 4d dc	 lea	 ecx, DWORD PTR _srcRect$[ebp]
  00d3b	e8 00 00 00 00	 call	 ?Clip@SOL_Rect@@QAEXABV1@@Z ; SOL_Rect::Clip

; 539  : 	if (srcRect.IsEmpty())

  00d40	8d 4d dc	 lea	 ecx, DWORD PTR _srcRect$[ebp]
  00d43	e8 00 00 00 00	 call	 ?IsEmpty@SOL_Rect@@QBEHXZ ; SOL_Rect::IsEmpty
  00d48	85 c0		 test	 eax, eax
  00d4a	74 05		 je	 SHORT $L57259

; 540  : 		return;

  00d4c	e9 65 01 00 00	 jmp	 $L57256
$L57259:

; 541  : 
; 542  : 	int sxo = srcRect.A.x - src.rect.A.x;

  00d51	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00d54	8b 45 dc	 mov	 eax, DWORD PTR _srcRect$[ebp]
  00d57	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00d5a	89 45 c8	 mov	 DWORD PTR _sxo$[ebp], eax

; 543  : 	int syo = srcRect.A.y - src.rect.A.y;

  00d5d	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00d60	8b 55 e0	 mov	 edx, DWORD PTR _srcRect$[ebp+4]
  00d63	2b 51 08	 sub	 edx, DWORD PTR [ecx+8]
  00d66	89 55 f0	 mov	 DWORD PTR _syo$[ebp], edx

; 544  : 	int xsize = srcRect.Xlen();

  00d69	8d 4d dc	 lea	 ecx, DWORD PTR _srcRect$[ebp]
  00d6c	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  00d71	89 45 d4	 mov	 DWORD PTR _xsize$[ebp], eax

; 545  : 	int ysize = srcRect.Ylen();

  00d74	8d 4d dc	 lea	 ecx, DWORD PTR _srcRect$[ebp]
  00d77	e8 00 00 00 00	 call	 ?Ylen@SOL_Rect@@QBEHXZ	; SOL_Rect::Ylen
  00d7c	89 45 fc	 mov	 DWORD PTR _ysize$[ebp], eax

; 546  : 
; 547  : 	uchar* destPtr = dest.buffer + ((srcRect.A.y - dest.rect.A.y) * dest.rect.Xlen()) + (srcRect.A.x - dest.rect.A.x);

  00d7f	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00d82	8b 75 e0	 mov	 esi, DWORD PTR _srcRect$[ebp+4]
  00d85	2b 70 08	 sub	 esi, DWORD PTR [eax+8]
  00d88	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00d8b	83 c1 04	 add	 ecx, 4
  00d8e	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  00d93	0f af f0	 imul	 esi, eax
  00d96	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00d99	8b 11		 mov	 edx, DWORD PTR [ecx]
  00d9b	03 d6		 add	 edx, esi
  00d9d	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00da0	8b 4d dc	 mov	 ecx, DWORD PTR _srcRect$[ebp]
  00da3	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00da6	03 d1		 add	 edx, ecx
  00da8	89 55 f4	 mov	 DWORD PTR _destPtr$[ebp], edx

; 548  : 	const uchar* srcPtr = src.buffer + (syo * src.rect.Xlen()) + sxo;

  00dab	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00dae	83 c1 04	 add	 ecx, 4
  00db1	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  00db6	8b 55 f0	 mov	 edx, DWORD PTR _syo$[ebp]
  00db9	0f af d0	 imul	 edx, eax
  00dbc	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00dbf	8b 08		 mov	 ecx, DWORD PTR [eax]
  00dc1	03 ca		 add	 ecx, edx
  00dc3	03 4d c8	 add	 ecx, DWORD PTR _sxo$[ebp]
  00dc6	89 4d cc	 mov	 DWORD PTR _srcPtr$[ebp], ecx

; 549  : 	uchar skip = src.skip;

  00dc9	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00dcc	8a 42 14	 mov	 al, BYTE PTR [edx+20]
  00dcf	88 45 d8	 mov	 BYTE PTR _skip$[ebp], al

; 550  : 
; 551  : 	int srcNextLine = src.rect.Xlen() - xsize;

  00dd2	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00dd5	83 c1 04	 add	 ecx, 4
  00dd8	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  00ddd	2b 45 d4	 sub	 eax, DWORD PTR _xsize$[ebp]
  00de0	89 45 ec	 mov	 DWORD PTR _srcNextLine$[ebp], eax

; 552  : 	int destNextLine = dest.rect.Xlen() - xsize;

  00de3	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00de6	83 c1 04	 add	 ecx, 4
  00de9	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  00dee	2b 45 d4	 sub	 eax, DWORD PTR _xsize$[ebp]
  00df1	89 45 f8	 mov	 DWORD PTR _destNextLine$[ebp], eax

; 553  : 
; 554  : 	if (dest.invertedFlag) {

  00df4	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00df7	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  00dfb	74 3f		 je	 SHORT $L57269

; 555  : 		destPtr = dest.buffer + ((dest.rect.B.y - srcRect.A.y) * dest.rect.Xlen()) + (srcRect.A.x - dest.rect.A.x);

  00dfd	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  00e00	8b 72 10	 mov	 esi, DWORD PTR [edx+16]
  00e03	2b 75 e0	 sub	 esi, DWORD PTR _srcRect$[ebp+4]
  00e06	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00e09	83 c1 04	 add	 ecx, 4
  00e0c	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  00e11	0f af f0	 imul	 esi, eax
  00e14	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00e17	8b 08		 mov	 ecx, DWORD PTR [eax]
  00e19	03 ce		 add	 ecx, esi
  00e1b	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  00e1e	8b 45 dc	 mov	 eax, DWORD PTR _srcRect$[ebp]
  00e21	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00e24	03 c8		 add	 ecx, eax
  00e26	89 4d f4	 mov	 DWORD PTR _destPtr$[ebp], ecx

; 556  : 		destNextLine = - dest.rect.Xlen() - xsize;

  00e29	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00e2c	83 c1 04	 add	 ecx, 4
  00e2f	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  00e34	f7 d8		 neg	 eax
  00e36	2b 45 d4	 sub	 eax, DWORD PTR _xsize$[ebp]
  00e39	89 45 f8	 mov	 DWORD PTR _destNextLine$[ebp], eax
$L57269:

; 558  : 
; 559  : 	for (int y = 0; y < ysize; y++)

  00e3c	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  00e43	eb 09		 jmp	 SHORT $L57271
$L57272:
  00e45	8b 4d d0	 mov	 ecx, DWORD PTR _y$[ebp]
  00e48	83 c1 01	 add	 ecx, 1
  00e4b	89 4d d0	 mov	 DWORD PTR _y$[ebp], ecx
$L57271:
  00e4e	8b 55 d0	 mov	 edx, DWORD PTR _y$[ebp]
  00e51	3b 55 fc	 cmp	 edx, DWORD PTR _ysize$[ebp]
  00e54	7d 60		 jge	 SHORT $L57273

; 561  : 		for (int x = 0; x < xsize; x++)

  00e56	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _x$57274[ebp], 0
  00e5d	eb 09		 jmp	 SHORT $L57275
$L57276:
  00e5f	8b 45 c4	 mov	 eax, DWORD PTR _x$57274[ebp]
  00e62	83 c0 01	 add	 eax, 1
  00e65	89 45 c4	 mov	 DWORD PTR _x$57274[ebp], eax
$L57275:
  00e68	8b 4d c4	 mov	 ecx, DWORD PTR _x$57274[ebp]
  00e6b	3b 4d d4	 cmp	 ecx, DWORD PTR _xsize$[ebp]
  00e6e	7d 32		 jge	 SHORT $L57277

; 563  : 			if (*srcPtr != skip)

  00e70	8b 55 cc	 mov	 edx, DWORD PTR _srcPtr$[ebp]
  00e73	33 c0		 xor	 eax, eax
  00e75	8a 02		 mov	 al, BYTE PTR [edx]
  00e77	8b 4d d8	 mov	 ecx, DWORD PTR _skip$[ebp]
  00e7a	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00e80	3b c1		 cmp	 eax, ecx
  00e82	74 0a		 je	 SHORT $L57278

; 564  : 				*destPtr = *srcPtr;

  00e84	8b 55 f4	 mov	 edx, DWORD PTR _destPtr$[ebp]
  00e87	8b 45 cc	 mov	 eax, DWORD PTR _srcPtr$[ebp]
  00e8a	8a 08		 mov	 cl, BYTE PTR [eax]
  00e8c	88 0a		 mov	 BYTE PTR [edx], cl
$L57278:

; 565  : 			destPtr++;

  00e8e	8b 55 f4	 mov	 edx, DWORD PTR _destPtr$[ebp]
  00e91	83 c2 01	 add	 edx, 1
  00e94	89 55 f4	 mov	 DWORD PTR _destPtr$[ebp], edx

; 566  : 			srcPtr++;

  00e97	8b 45 cc	 mov	 eax, DWORD PTR _srcPtr$[ebp]
  00e9a	83 c0 01	 add	 eax, 1
  00e9d	89 45 cc	 mov	 DWORD PTR _srcPtr$[ebp], eax

; 567  : 		}

  00ea0	eb bd		 jmp	 SHORT $L57276
$L57277:

; 568  : 		srcPtr += srcNextLine;

  00ea2	8b 4d cc	 mov	 ecx, DWORD PTR _srcPtr$[ebp]
  00ea5	03 4d ec	 add	 ecx, DWORD PTR _srcNextLine$[ebp]
  00ea8	89 4d cc	 mov	 DWORD PTR _srcPtr$[ebp], ecx

; 569  : 		destPtr += destNextLine;

  00eab	8b 55 f4	 mov	 edx, DWORD PTR _destPtr$[ebp]
  00eae	03 55 f8	 add	 edx, DWORD PTR _destNextLine$[ebp]
  00eb1	89 55 f4	 mov	 DWORD PTR _destPtr$[ebp], edx

; 570  : 	}

  00eb4	eb 8f		 jmp	 SHORT $L57272
$L57273:
$L57256:

; 571  : }

  00eb6	5e		 pop	 esi
  00eb7	8b e5		 mov	 esp, ebp
  00eb9	5d		 pop	 ebp
  00eba	c2 08 00	 ret	 8
?Paint@CursorWinClr@@IAEXABUInfo@1@0@Z ENDP		; CursorWinClr::Paint
_TEXT	ENDS
;	COMDAT ??4SOL_Point@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
??4SOL_Point@@QAEAAV0@ABV0@@Z PROC NEAR			; SOL_Point::operator=, COMDAT

; 117  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 118  : 	x = p.x;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx

; 119  : 	y = p.y;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00017	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001a	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 120  : 	return *this;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 121  : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??4SOL_Point@@QAEAAV0@ABV0@@Z ENDP			; SOL_Point::operator=
_TEXT	ENDS
EXTRN	_memcpy:NEAR
_TEXT	SEGMENT
_dest$ = 8
_src$ = 12
_this$ = -56
_srcRect$ = -36
_sxo$ = -52
_syo$ = -16
_xsize$ = -40
_ysize$ = -4
_destPtr$ = -12
_srcPtr$ = -48
_srcNextLine$ = -20
_destNextLine$ = -8
_y$ = -44
?Copy@CursorWinClr@@IAEXABUInfo@1@0@Z PROC NEAR		; CursorWinClr::Copy

; 581  : {

  00ebd	55		 push	 ebp
  00ebe	8b ec		 mov	 ebp, esp
  00ec0	83 ec 38	 sub	 esp, 56			; 00000038H
  00ec3	56		 push	 esi
  00ec4	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx

; 582  : 	if (src.rect.IsEmpty())

  00ec7	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00eca	83 c1 04	 add	 ecx, 4
  00ecd	e8 00 00 00 00	 call	 ?IsEmpty@SOL_Rect@@QBEHXZ ; SOL_Rect::IsEmpty
  00ed2	85 c0		 test	 eax, eax
  00ed4	74 05		 je	 SHORT $L57284

; 583  : 		return;

  00ed6	e9 aa 01 00 00	 jmp	 $L57283
$L57284:

; 584  : 
; 585  : 	SOL_Rect srcRect = src.rect;

  00edb	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00ede	83 c0 04	 add	 eax, 4
  00ee1	50		 push	 eax
  00ee2	8d 4d dc	 lea	 ecx, DWORD PTR _srcRect$[ebp]
  00ee5	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@ABV0@@Z ; SOL_Rect::SOL_Rect

; 586  : 	srcRect.Clip(dest.rect);

  00eea	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00eed	83 c1 04	 add	 ecx, 4
  00ef0	51		 push	 ecx
  00ef1	8d 4d dc	 lea	 ecx, DWORD PTR _srcRect$[ebp]
  00ef4	e8 00 00 00 00	 call	 ?Clip@SOL_Rect@@QAEXABV1@@Z ; SOL_Rect::Clip

; 587  : 	if (srcRect.IsEmpty())

  00ef9	8d 4d dc	 lea	 ecx, DWORD PTR _srcRect$[ebp]
  00efc	e8 00 00 00 00	 call	 ?IsEmpty@SOL_Rect@@QBEHXZ ; SOL_Rect::IsEmpty
  00f01	85 c0		 test	 eax, eax
  00f03	74 05		 je	 SHORT $L57286

; 588  : 		return;

  00f05	e9 7b 01 00 00	 jmp	 $L57283
$L57286:

; 589  : 
; 590  : 
; 591  : 	int sxo = srcRect.A.x - src.rect.A.x;

  00f0a	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00f0d	8b 45 dc	 mov	 eax, DWORD PTR _srcRect$[ebp]
  00f10	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00f13	89 45 cc	 mov	 DWORD PTR _sxo$[ebp], eax

; 592  : 	int syo = srcRect.A.y - src.rect.A.y;

  00f16	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00f19	8b 55 e0	 mov	 edx, DWORD PTR _srcRect$[ebp+4]
  00f1c	2b 51 08	 sub	 edx, DWORD PTR [ecx+8]
  00f1f	89 55 f0	 mov	 DWORD PTR _syo$[ebp], edx

; 593  : 	int xsize = srcRect.Xlen();

  00f22	8d 4d dc	 lea	 ecx, DWORD PTR _srcRect$[ebp]
  00f25	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  00f2a	89 45 d8	 mov	 DWORD PTR _xsize$[ebp], eax

; 594  : 	int ysize = srcRect.Ylen();

  00f2d	8d 4d dc	 lea	 ecx, DWORD PTR _srcRect$[ebp]
  00f30	e8 00 00 00 00	 call	 ?Ylen@SOL_Rect@@QBEHXZ	; SOL_Rect::Ylen
  00f35	89 45 fc	 mov	 DWORD PTR _ysize$[ebp], eax

; 595  : 
; 596  : 	uchar* destPtr = dest.buffer + ((srcRect.A.y - dest.rect.A.y) * dest.rect.Xlen()) + (srcRect.A.x - dest.rect.A.x);

  00f38	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00f3b	8b 75 e0	 mov	 esi, DWORD PTR _srcRect$[ebp+4]
  00f3e	2b 70 08	 sub	 esi, DWORD PTR [eax+8]
  00f41	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00f44	83 c1 04	 add	 ecx, 4
  00f47	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  00f4c	0f af f0	 imul	 esi, eax
  00f4f	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00f52	8b 11		 mov	 edx, DWORD PTR [ecx]
  00f54	03 d6		 add	 edx, esi
  00f56	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00f59	8b 4d dc	 mov	 ecx, DWORD PTR _srcRect$[ebp]
  00f5c	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00f5f	03 d1		 add	 edx, ecx
  00f61	89 55 f4	 mov	 DWORD PTR _destPtr$[ebp], edx

; 597  : 	const uchar* srcPtr = src.buffer + (syo * src.rect.Xlen()) + sxo;

  00f64	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00f67	83 c1 04	 add	 ecx, 4
  00f6a	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  00f6f	8b 55 f0	 mov	 edx, DWORD PTR _syo$[ebp]
  00f72	0f af d0	 imul	 edx, eax
  00f75	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00f78	8b 08		 mov	 ecx, DWORD PTR [eax]
  00f7a	03 ca		 add	 ecx, edx
  00f7c	03 4d cc	 add	 ecx, DWORD PTR _sxo$[ebp]
  00f7f	89 4d d0	 mov	 DWORD PTR _srcPtr$[ebp], ecx

; 598  : 
; 599  : 	int srcNextLine = src.rect.Xlen();

  00f82	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00f85	83 c1 04	 add	 ecx, 4
  00f88	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  00f8d	89 45 ec	 mov	 DWORD PTR _srcNextLine$[ebp], eax

; 600  : 	int destNextLine = dest.rect.Xlen();

  00f90	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00f93	83 c1 04	 add	 ecx, 4
  00f96	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  00f9b	89 45 f8	 mov	 DWORD PTR _destNextLine$[ebp], eax

; 601  : 
; 602  : 	if (src.invertedFlag) {

  00f9e	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00fa1	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  00fa5	74 57		 je	 SHORT $L57295

; 603  : 		syo = src.rect.A.y + src.rect.B.y - srcRect.A.y - dest.rect.Ylen() + srcRect.Ylen();

  00fa7	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00faa	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00fad	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00fb0	03 71 10	 add	 esi, DWORD PTR [ecx+16]
  00fb3	2b 75 e0	 sub	 esi, DWORD PTR _srcRect$[ebp+4]
  00fb6	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00fb9	83 c1 04	 add	 ecx, 4
  00fbc	e8 00 00 00 00	 call	 ?Ylen@SOL_Rect@@QBEHXZ	; SOL_Rect::Ylen
  00fc1	2b f0		 sub	 esi, eax
  00fc3	8d 4d dc	 lea	 ecx, DWORD PTR _srcRect$[ebp]
  00fc6	e8 00 00 00 00	 call	 ?Ylen@SOL_Rect@@QBEHXZ	; SOL_Rect::Ylen
  00fcb	03 f0		 add	 esi, eax
  00fcd	89 75 f0	 mov	 DWORD PTR _syo$[ebp], esi

; 604  : 		srcPtr = src.buffer + (syo * src.rect.Xlen()) + sxo;

  00fd0	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00fd3	83 c1 04	 add	 ecx, 4
  00fd6	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  00fdb	8b 55 f0	 mov	 edx, DWORD PTR _syo$[ebp]
  00fde	0f af d0	 imul	 edx, eax
  00fe1	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00fe4	8b 08		 mov	 ecx, DWORD PTR [eax]
  00fe6	03 ca		 add	 ecx, edx
  00fe8	03 4d cc	 add	 ecx, DWORD PTR _sxo$[ebp]
  00feb	89 4d d0	 mov	 DWORD PTR _srcPtr$[ebp], ecx

; 605  :   		srcNextLine = -src.rect.Xlen();

  00fee	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00ff1	83 c1 04	 add	 ecx, 4
  00ff4	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  00ff9	f7 d8		 neg	 eax
  00ffb	89 45 ec	 mov	 DWORD PTR _srcNextLine$[ebp], eax
$L57295:

; 607  : 	if (dest.invertedFlag) {

  00ffe	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  01001	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  01005	74 3c		 je	 SHORT $L57296

; 608  : 		destPtr = dest.buffer + ((dest.rect.B.y - srcRect.A.y) * dest.rect.Xlen()) + (srcRect.A.x - dest.rect.A.x);

  01007	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0100a	8b 70 10	 mov	 esi, DWORD PTR [eax+16]
  0100d	2b 75 e0	 sub	 esi, DWORD PTR _srcRect$[ebp+4]
  01010	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  01013	83 c1 04	 add	 ecx, 4
  01016	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  0101b	0f af f0	 imul	 esi, eax
  0101e	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  01021	8b 11		 mov	 edx, DWORD PTR [ecx]
  01023	03 d6		 add	 edx, esi
  01025	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  01028	8b 4d dc	 mov	 ecx, DWORD PTR _srcRect$[ebp]
  0102b	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  0102e	03 d1		 add	 edx, ecx
  01030	89 55 f4	 mov	 DWORD PTR _destPtr$[ebp], edx

; 609  : 		destNextLine = -dest.rect.Xlen();

  01033	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  01036	83 c1 04	 add	 ecx, 4
  01039	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  0103e	f7 d8		 neg	 eax
  01040	89 45 f8	 mov	 DWORD PTR _destNextLine$[ebp], eax
$L57296:

; 611  : 
; 612  : 	for (int y = 0; y < ysize; y++)  {

  01043	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  0104a	eb 09		 jmp	 SHORT $L57298
$L57299:
  0104c	8b 55 d4	 mov	 edx, DWORD PTR _y$[ebp]
  0104f	83 c2 01	 add	 edx, 1
  01052	89 55 d4	 mov	 DWORD PTR _y$[ebp], edx
$L57298:
  01055	8b 45 d4	 mov	 eax, DWORD PTR _y$[ebp]
  01058	3b 45 fc	 cmp	 eax, DWORD PTR _ysize$[ebp]
  0105b	7d 28		 jge	 SHORT $L57300

; 613  : 		memcpy(destPtr, srcPtr, xsize);

  0105d	8b 4d d8	 mov	 ecx, DWORD PTR _xsize$[ebp]
  01060	51		 push	 ecx
  01061	8b 55 d0	 mov	 edx, DWORD PTR _srcPtr$[ebp]
  01064	52		 push	 edx
  01065	8b 45 f4	 mov	 eax, DWORD PTR _destPtr$[ebp]
  01068	50		 push	 eax
  01069	e8 00 00 00 00	 call	 _memcpy
  0106e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 614  : 		destPtr += destNextLine;

  01071	8b 4d f4	 mov	 ecx, DWORD PTR _destPtr$[ebp]
  01074	03 4d f8	 add	 ecx, DWORD PTR _destNextLine$[ebp]
  01077	89 4d f4	 mov	 DWORD PTR _destPtr$[ebp], ecx

; 615  : 		srcPtr += srcNextLine;

  0107a	8b 55 d0	 mov	 edx, DWORD PTR _srcPtr$[ebp]
  0107d	03 55 ec	 add	 edx, DWORD PTR _srcNextLine$[ebp]
  01080	89 55 d0	 mov	 DWORD PTR _srcPtr$[ebp], edx

; 616  : 	}

  01083	eb c7		 jmp	 SHORT $L57299
$L57300:
$L57283:

; 617  : }

  01085	5e		 pop	 esi
  01086	8b e5		 mov	 esp, ebp
  01088	5d		 pop	 ebp
  01089	c2 08 00	 ret	 8
?Copy@CursorWinClr@@IAEXABUInfo@1@0@Z ENDP		; CursorWinClr::Copy
_TEXT	ENDS
EXTRN	?bmiHdr@@3UBMI@@A:BYTE				; bmiHdr
EXTRN	?colorUse@@3IA:DWORD				; colorUse
EXTRN	?hMyDC@@3PAUHDC__@@A:DWORD			; hMyDC
EXTRN	__imp__SetDIBitsToDevice@48:NEAR
_BSS	SEGMENT
	ALIGN	4

$SG57319 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
	ORG $+2
$SG57318 DB	'xCursor too large for buffer.', 0aH, 'Set maxCursorSize '
	DB	'option to %d', 00H
_DATA	ENDS
_TEXT	SEGMENT
_info$ = 8
_this$ = -84
_top$ = -60
_left$ = -80
_bottom$ = -76
_right$ = -44
_width$ = -24
_widthMod4$ = -72
_height$ = -64
_rect$ = -16
_sxo$ = -68
_syo$ = -32
_src$ = -56
_srcXOff$ = -40
_srcPtr$ = -52
_srcNextLine$ = -36
_destPtr$ = -28
_destNextLine$ = -20
_y$ = -48
?DrawToHardware@CursorWinClr@@IAEXABUInfo@1@@Z PROC NEAR ; CursorWinClr::DrawToHardware

; 658  : {

  0108c	55		 push	 ebp
  0108d	8b ec		 mov	 ebp, esp
  0108f	83 ec 54	 sub	 esp, 84			; 00000054H
  01092	56		 push	 esi
  01093	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 659  : WORD top, left, bottom, right, width, widthMod4, height;
; 660  : 
; 661  : 	SOL_Rect rect = info.rect;

  01096	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  01099	83 c0 04	 add	 eax, 4
  0109c	50		 push	 eax
  0109d	8d 4d f0	 lea	 ecx, DWORD PTR _rect$[ebp]
  010a0	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@ABV0@@Z ; SOL_Rect::SOL_Rect

; 662  : 	rect.Clip(vmapData.rect);

  010a5	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  010a8	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  010ae	51		 push	 ecx
  010af	8d 4d f0	 lea	 ecx, DWORD PTR _rect$[ebp]
  010b2	e8 00 00 00 00	 call	 ?Clip@SOL_Rect@@QAEXABV1@@Z ; SOL_Rect::Clip

; 663  : 	int sxo = rect.A.x - info.rect.A.x;

  010b7	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  010ba	8b 45 f0	 mov	 eax, DWORD PTR _rect$[ebp]
  010bd	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  010c0	89 45 bc	 mov	 DWORD PTR _sxo$[ebp], eax

; 664  : 	int syo = rect.A.y - info.rect.A.y;

  010c3	8b 4d 08	 mov	 ecx, DWORD PTR _info$[ebp]
  010c6	8b 55 f4	 mov	 edx, DWORD PTR _rect$[ebp+4]
  010c9	2b 51 08	 sub	 edx, DWORD PTR [ecx+8]
  010cc	89 55 e0	 mov	 DWORD PTR _syo$[ebp], edx

; 665  : 	uchar* src = info.buffer + (syo * info.rect.Xlen()) + sxo;

  010cf	8b 4d 08	 mov	 ecx, DWORD PTR _info$[ebp]
  010d2	83 c1 04	 add	 ecx, 4
  010d5	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  010da	8b 4d e0	 mov	 ecx, DWORD PTR _syo$[ebp]
  010dd	0f af c8	 imul	 ecx, eax
  010e0	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  010e3	8b 02		 mov	 eax, DWORD PTR [edx]
  010e5	03 c1		 add	 eax, ecx
  010e7	03 45 bc	 add	 eax, DWORD PTR _sxo$[ebp]
  010ea	89 45 c8	 mov	 DWORD PTR _src$[ebp], eax

; 666  : 
; 667  : 	// need both srcXOff and srcYOff because we don't know here
; 668  : 	// what video mdeo we're in and which we'll need
; 669  : 	int srcXOff = info.rect.Xlen() - rect.Xlen();

  010ed	8b 4d 08	 mov	 ecx, DWORD PTR _info$[ebp]
  010f0	83 c1 04	 add	 ecx, 4
  010f3	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  010f8	8b f0		 mov	 esi, eax
  010fa	8d 4d f0	 lea	 ecx, DWORD PTR _rect$[ebp]
  010fd	e8 00 00 00 00	 call	 ?Xlen@SOL_Rect@@QBEHXZ	; SOL_Rect::Xlen
  01102	2b f0		 sub	 esi, eax
  01104	89 75 d8	 mov	 DWORD PTR _srcXOff$[ebp], esi

; 670  : 
; 671  : 	left =	rect.A.x;

  01107	66 8b 4d f0	 mov	 cx, WORD PTR _rect$[ebp]
  0110b	66 89 4d b0	 mov	 WORD PTR _left$[ebp], cx

; 672  : 	top =		rect.A.y;

  0110f	66 8b 55 f4	 mov	 dx, WORD PTR _rect$[ebp+4]
  01113	66 89 55 c4	 mov	 WORD PTR _top$[ebp], dx

; 673  : 	right =	rect.B.x;

  01117	66 8b 45 f8	 mov	 ax, WORD PTR _rect$[ebp+8]
  0111b	66 89 45 d4	 mov	 WORD PTR _right$[ebp], ax

; 674  : 	bottom =	rect.B.y;

  0111f	66 8b 4d fc	 mov	 cx, WORD PTR _rect$[ebp+12]
  01123	66 89 4d b4	 mov	 WORD PTR _bottom$[ebp], cx

; 675  : 	width =	right - left + 1;

  01127	8b 55 d4	 mov	 edx, DWORD PTR _right$[ebp]
  0112a	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  01130	8b 45 b0	 mov	 eax, DWORD PTR _left$[ebp]
  01133	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  01138	2b d0		 sub	 edx, eax
  0113a	83 c2 01	 add	 edx, 1
  0113d	66 89 55 e8	 mov	 WORD PTR _width$[ebp], dx

; 676  : 	height =	bottom - top + 1;

  01141	8b 4d b4	 mov	 ecx, DWORD PTR _bottom$[ebp]
  01144	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0114a	8b 55 c4	 mov	 edx, DWORD PTR _top$[ebp]
  0114d	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  01153	2b ca		 sub	 ecx, edx
  01155	83 c1 01	 add	 ecx, 1
  01158	66 89 4d c0	 mov	 WORD PTR _height$[ebp], cx

; 677  : 	widthMod4 = (((width + 3) >> 2) << 2);

  0115c	8b 45 e8	 mov	 eax, DWORD PTR _width$[ebp]
  0115f	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  01164	83 c0 03	 add	 eax, 3
  01167	c1 f8 02	 sar	 eax, 2
  0116a	c1 e0 02	 shl	 eax, 2
  0116d	66 89 45 b8	 mov	 WORD PTR _widthMod4$[ebp], ax

; 678  : 
; 679  : 	if (widthMod4 * height > 4 * maxCursorSize) {

  01171	8b 4d b8	 mov	 ecx, DWORD PTR _widthMod4$[ebp]
  01174	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0117a	8b 55 c0	 mov	 edx, DWORD PTR _height$[ebp]
  0117d	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  01183	0f af ca	 imul	 ecx, edx
  01186	a1 00 00 00 00	 mov	 eax, DWORD PTR ?maxCursorSize@@3HA ; maxCursorSize
  0118b	c1 e0 02	 shl	 eax, 2
  0118e	3b c8		 cmp	 ecx, eax
  01190	7e 4e		 jle	 SHORT $L57317

; 680  : 		sprintf(mbuff, "xCursor too large for buffer.\n"
; 681  : 							"Set maxCursorSize option to %d", (widthMod4 * height) / 4);

  01192	8b 45 b8	 mov	 eax, DWORD PTR _widthMod4$[ebp]
  01195	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0119a	8b 4d c0	 mov	 ecx, DWORD PTR _height$[ebp]
  0119d	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  011a3	0f af c1	 imul	 eax, ecx
  011a6	99		 cdq
  011a7	83 e2 03	 and	 edx, 3
  011aa	03 c2		 add	 eax, edx
  011ac	c1 f8 02	 sar	 eax, 2
  011af	50		 push	 eax
  011b0	68 00 00 00 00	 push	 OFFSET FLAT:$SG57318
  011b5	68 00 00 00 00	 push	 OFFSET FLAT:?mbuff@@3PADA ; mbuff
  011ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  011c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 682  : 		MBox(mbuff,"");

  011c3	68 00 00 00 00	 push	 OFFSET FLAT:$SG57319
  011c8	68 00 00 00 00	 push	 OFFSET FLAT:?mbuff@@3PADA ; mbuff
  011cd	e8 00 00 00 00	 call	 ?MBox@@YAXPAD0@Z	; MBox
  011d2	83 c4 08	 add	 esp, 8

; 683  : 		exit(255);

  011d5	68 ff 00 00 00	 push	 255			; 000000ffH
  011da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
$L57317:

; 685  : 
; 686  : 	// write it to the windows buffer
; 687  : 	uchar* srcPtr = src;

  011e0	8b 55 c8	 mov	 edx, DWORD PTR _src$[ebp]
  011e3	89 55 cc	 mov	 DWORD PTR _srcPtr$[ebp], edx

; 688  : 	int srcNextLine = width;

  011e6	8b 45 e8	 mov	 eax, DWORD PTR _width$[ebp]
  011e9	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  011ee	89 45 dc	 mov	 DWORD PTR _srcNextLine$[ebp], eax

; 689  : 
; 690  : 	uchar* destPtr = winCurBuff + (height - 1) * widthMod4;

  011f1	8b 4d c0	 mov	 ecx, DWORD PTR _height$[ebp]
  011f4	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  011fa	83 e9 01	 sub	 ecx, 1
  011fd	8b 55 b8	 mov	 edx, DWORD PTR _widthMod4$[ebp]
  01200	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  01206	0f af ca	 imul	 ecx, edx
  01209	a1 00 00 00 00	 mov	 eax, DWORD PTR ?winCurBuff@@3PAEA ; winCurBuff
  0120e	03 c1		 add	 eax, ecx
  01210	89 45 e4	 mov	 DWORD PTR _destPtr$[ebp], eax

; 691  : 	int destNextLine = widthMod4;

  01213	8b 4d b8	 mov	 ecx, DWORD PTR _widthMod4$[ebp]
  01216	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0121c	89 4d ec	 mov	 DWORD PTR _destNextLine$[ebp], ecx

; 692  : 
; 693  : 	for (int y = 0; y < height; y++) {

  0121f	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  01226	eb 09		 jmp	 SHORT $L57325
$L57326:
  01228	8b 55 d0	 mov	 edx, DWORD PTR _y$[ebp]
  0122b	83 c2 01	 add	 edx, 1
  0122e	89 55 d0	 mov	 DWORD PTR _y$[ebp], edx
$L57325:
  01231	8b 45 c0	 mov	 eax, DWORD PTR _height$[ebp]
  01234	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  01239	39 45 d0	 cmp	 DWORD PTR _y$[ebp], eax
  0123c	7d 2e		 jge	 SHORT $L57327

; 694  : 		memcpy(destPtr, srcPtr, width);

  0123e	8b 4d e8	 mov	 ecx, DWORD PTR _width$[ebp]
  01241	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  01247	51		 push	 ecx
  01248	8b 55 cc	 mov	 edx, DWORD PTR _srcPtr$[ebp]
  0124b	52		 push	 edx
  0124c	8b 45 e4	 mov	 eax, DWORD PTR _destPtr$[ebp]
  0124f	50		 push	 eax
  01250	e8 00 00 00 00	 call	 _memcpy
  01255	83 c4 0c	 add	 esp, 12			; 0000000cH

; 695  : 		destPtr -= destNextLine;

  01258	8b 4d e4	 mov	 ecx, DWORD PTR _destPtr$[ebp]
  0125b	2b 4d ec	 sub	 ecx, DWORD PTR _destNextLine$[ebp]
  0125e	89 4d e4	 mov	 DWORD PTR _destPtr$[ebp], ecx

; 696  : 		srcPtr += srcNextLine;

  01261	8b 55 cc	 mov	 edx, DWORD PTR _srcPtr$[ebp]
  01264	03 55 dc	 add	 edx, DWORD PTR _srcNextLine$[ebp]
  01267	89 55 cc	 mov	 DWORD PTR _srcPtr$[ebp], edx

; 697  : 	}

  0126a	eb bc		 jmp	 SHORT $L57326
$L57327:

; 698  : 
; 699  : 	bmiHdr.bmih.biWidth =			(DWORD)widthMod4;

  0126c	8b 45 b8	 mov	 eax, DWORD PTR _widthMod4$[ebp]
  0126f	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  01274	a3 04 00 00 00	 mov	 DWORD PTR ?bmiHdr@@3UBMI@@A+4, eax

; 700  : 	bmiHdr.bmih.biHeight =			(DWORD)height;

  01279	8b 4d c0	 mov	 ecx, DWORD PTR _height$[ebp]
  0127c	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  01282	89 0d 08 00 00
	00		 mov	 DWORD PTR ?bmiHdr@@3UBMI@@A+8, ecx

; 701  : 
; 702  : 	SetDIBitsToDevice (hMyDC,						//device context
; 703  : 							left + gameBorderX,		//destination X
; 704  : 							top + gameBorderY,		//destination Y
; 705  : 							width,						//X-extent
; 706  : 							height,						//Y-extent
; 707  : 							0,								//source X
; 708  : 							0,								//source Y
; 709  : 							0,								//first scan-line number
; 710  : 							height,						//number of scan lines
; 711  : 							(LPSTR)winCurBuff, 		//pointer to DIB
; 712  : 							(LPBITMAPINFO)&bmiHdr.bmih, //pointer to header
; 713  : 							colorUse);					//indexed color table

  01288	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?colorUse@@3IA ; colorUse
  0128e	52		 push	 edx
  0128f	68 00 00 00 00	 push	 OFFSET FLAT:?bmiHdr@@3UBMI@@A ; bmiHdr
  01294	a1 00 00 00 00	 mov	 eax, DWORD PTR ?winCurBuff@@3PAEA ; winCurBuff
  01299	50		 push	 eax
  0129a	8b 4d c0	 mov	 ecx, DWORD PTR _height$[ebp]
  0129d	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  012a3	51		 push	 ecx
  012a4	6a 00		 push	 0
  012a6	6a 00		 push	 0
  012a8	6a 00		 push	 0
  012aa	8b 55 c0	 mov	 edx, DWORD PTR _height$[ebp]
  012ad	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  012b3	52		 push	 edx
  012b4	8b 45 e8	 mov	 eax, DWORD PTR _width$[ebp]
  012b7	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  012bc	50		 push	 eax
  012bd	8b 4d c4	 mov	 ecx, DWORD PTR _top$[ebp]
  012c0	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  012c6	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gameBorderY@@3HA ; gameBorderY
  012cc	51		 push	 ecx
  012cd	8b 55 b0	 mov	 edx, DWORD PTR _left$[ebp]
  012d0	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  012d6	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gameBorderX@@3HA ; gameBorderX
  012dc	52		 push	 edx
  012dd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hMyDC@@3PAUHDC__@@A ; hMyDC
  012e2	50		 push	 eax
  012e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetDIBitsToDevice@48
$L57304:

; 714  : }

  012e9	5e		 pop	 esi
  012ea	8b e5		 mov	 esp, ebp
  012ec	5d		 pop	 ebp
  012ed	c2 04 00	 ret	 4
?DrawToHardware@CursorWinClr@@IAEXABUInfo@1@@Z ENDP	; CursorWinClr::DrawToHardware
_TEXT	ENDS
PUBLIC	?ReadVideoFromVMAP@CursorWinClr@@IAEXABUInfo@1@@Z ; CursorWinClr::ReadVideoFromVMAP
_TEXT	SEGMENT
_info$ = 8
_this$ = -4
?ReadVideo@CursorWinClr@@IAEXABUInfo@1@@Z PROC NEAR	; CursorWinClr::ReadVideo

; 719  : {

  012f0	55		 push	 ebp
  012f1	8b ec		 mov	 ebp, esp
  012f3	51		 push	 ecx
  012f4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 720  : //	if (graphMgr->vmapValid)
; 721  : 		ReadVideoFromVMAP(info);

  012f7	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  012fa	50		 push	 eax
  012fb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  012fe	e8 00 00 00 00	 call	 ?ReadVideoFromVMAP@CursorWinClr@@IAEXABUInfo@1@@Z ; CursorWinClr::ReadVideoFromVMAP

; 722  : //	else
; 723  : //		SciDisplay("not valid");
; 724  : //		ReadVideoFromHardware(info);
; 725  : }

  01303	8b e5		 mov	 esp, ebp
  01305	5d		 pop	 ebp
  01306	c2 04 00	 ret	 4
?ReadVideo@CursorWinClr@@IAEXABUInfo@1@@Z ENDP		; CursorWinClr::ReadVideo
_info$ = 8
_this$ = -4
?ReadVideoFromVMAP@CursorWinClr@@IAEXABUInfo@1@@Z PROC NEAR ; CursorWinClr::ReadVideoFromVMAP

; 736  : {

  01309	55		 push	 ebp
  0130a	8b ec		 mov	 ebp, esp
  0130c	51		 push	 ecx
  0130d	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 737  : 	Copy(info, vmapData);

  01310	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01313	05 80 00 00 00	 add	 eax, 128		; 00000080H
  01318	50		 push	 eax
  01319	8b 4d 08	 mov	 ecx, DWORD PTR _info$[ebp]
  0131c	51		 push	 ecx
  0131d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01320	e8 00 00 00 00	 call	 ?Copy@CursorWinClr@@IAEXABUInfo@1@0@Z ; CursorWinClr::Copy

; 738  : }

  01325	8b e5		 mov	 esp, ebp
  01327	5d		 pop	 ebp
  01328	c2 04 00	 ret	 4
?ReadVideoFromVMAP@CursorWinClr@@IAEXABUInfo@1@@Z ENDP	; CursorWinClr::ReadVideoFromVMAP
_r$ = 8
_this$ = -8
?SetRestrictRect@CursorWinClr@@UAEXABVSOL_Rect@@@Z PROC NEAR ; CursorWinClr::SetRestrictRect

; 744  : {

  0132b	55		 push	 ebp
  0132c	8b ec		 mov	 ebp, esp
  0132e	83 ec 08	 sub	 esp, 8
  01331	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 745  : 	restrict = r;

  01334	8b 45 08	 mov	 eax, DWORD PTR _r$[ebp]
  01337	50		 push	 eax
  01338	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0133b	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  01341	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 746  : 	restrict.Clip(vmapData.rect);

  01346	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01349	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  0134f	51		 push	 ecx
  01350	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01353	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  01359	e8 00 00 00 00	 call	 ?Clip@SOL_Rect@@QAEXABV1@@Z ; SOL_Rect::Clip

; 747  : 	posDevice->SetRestrictRect(restrict);

  0135e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  01361	81 c2 d4 00 00
	00		 add	 edx, 212		; 000000d4H
  01367	52		 push	 edx
  01368	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0136b	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  01371	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  01374	8b 82 f0 00 00
	00		 mov	 eax, DWORD PTR [edx+240]
  0137a	8b 10		 mov	 edx, DWORD PTR [eax]
  0137c	ff 52 0c	 call	 DWORD PTR [edx+12]

; 748  : 	ForcePos(nextPos);

  0137f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01382	05 e4 00 00 00	 add	 eax, 228		; 000000e4H
  01387	83 ec 08	 sub	 esp, 8
  0138a	8b cc		 mov	 ecx, esp
  0138c	50		 push	 eax
  0138d	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  01392	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01395	8b 11		 mov	 edx, DWORD PTR [ecx]
  01397	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0139a	ff 52 1c	 call	 DWORD PTR [edx+28]

; 749  : }

  0139d	8b e5		 mov	 esp, ebp
  0139f	5d		 pop	 ebp
  013a0	c2 04 00	 ret	 4
?SetRestrictRect@CursorWinClr@@UAEXABVSOL_Rect@@@Z ENDP	; CursorWinClr::SetRestrictRect
_this$ = -4
?ClearRestrictRect@CursorWinClr@@UAEXXZ PROC NEAR	; CursorWinClr::ClearRestrictRect

; 754  : {

  013a3	55		 push	 ebp
  013a4	8b ec		 mov	 ebp, esp
  013a6	51		 push	 ecx
  013a7	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 755  : 	restrict = vmapData.rect;

  013aa	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  013ad	05 84 00 00 00	 add	 eax, 132		; 00000084H
  013b2	50		 push	 eax
  013b3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  013b6	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  013bc	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 756  : 	posDevice->ClearRestrictRect();

  013c1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  013c4	8b 89 f0 00 00
	00		 mov	 ecx, DWORD PTR [ecx+240]
  013ca	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  013cd	8b 82 f0 00 00
	00		 mov	 eax, DWORD PTR [edx+240]
  013d3	8b 10		 mov	 edx, DWORD PTR [eax]
  013d5	ff 52 10	 call	 DWORD PTR [edx+16]

; 757  : }

  013d8	8b e5		 mov	 esp, ebp
  013da	5d		 pop	 ebp
  013db	c3		 ret	 0
?ClearRestrictRect@CursorWinClr@@UAEXXZ ENDP		; CursorWinClr::ClearRestrictRect
_TEXT	ENDS
PUBLIC	??0MemID@@QAE@XZ				; MemID::MemID
;	COMDAT ??0Bitmap@@QAE@HHH@Z
_TEXT	SEGMENT
_v$ = 8
_l$ = 12
_c$ = 16
_this$ = -4
??0Bitmap@@QAE@HHH@Z PROC NEAR				; Bitmap::Bitmap, COMDAT

; 126  : 	Bitmap(const int v, const int l, const int c)	{view = v; loop = l; cel = c; type = tView;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 10	 add	 ecx, 16			; 00000010H
  0000d	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00018	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	8b 45 0c	 mov	 eax, DWORD PTR _l$[ebp]
  00021	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	8b 55 10	 mov	 edx, DWORD PTR _c$[ebp]
  0002a	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 0c 00	 ret	 12			; 0000000cH
??0Bitmap@@QAE@HHH@Z ENDP				; Bitmap::Bitmap
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0MemID@@QAE@XZ PROC NEAR				; MemID::MemID, COMDAT

; 15   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 16   : 	}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0MemID@@QAE@XZ ENDP					; MemID::MemID
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Bitmap@@QAE@XZ PROC NEAR				; Bitmap::Bitmap, COMDAT

; 130  : 	Bitmap() 													{view = loop = cel = 0; type = tMem;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 10	 add	 ecx, 16			; 00000010H
  0000d	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2
  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??0Bitmap@@QAE@XZ ENDP					; Bitmap::Bitmap
_TEXT	ENDS
;	COMDAT ?SetCel@Bitmap@@QAEXH@Z
_TEXT	SEGMENT
_c$ = 8
_this$ = -4
?SetCel@Bitmap@@QAEXH@Z PROC NEAR			; Bitmap::SetCel, COMDAT

; 146  : 	void	SetCel(int c)			{cel = c;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  0000d	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetCel@Bitmap@@QAEXH@Z ENDP				; Bitmap::SetCel
_TEXT	ENDS
;	COMDAT ?SetLoop@Bitmap@@QAEXH@Z
_TEXT	SEGMENT
_l$ = 8
_this$ = -4
?SetLoop@Bitmap@@QAEXH@Z PROC NEAR			; Bitmap::SetLoop, COMDAT

; 147  : 	void	SetLoop(int l)			{loop = l;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _l$[ebp]
  0000d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetLoop@Bitmap@@QAEXH@Z ENDP				; Bitmap::SetLoop
_TEXT	ENDS
;	COMDAT ?SetView@Bitmap@@QAEXH@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
?SetView@Bitmap@@QAEXH@Z PROC NEAR			; Bitmap::SetView, COMDAT

; 148  : 	void	SetView(int v)			{view = v; type = tView;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00013	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?SetView@Bitmap@@QAEXH@Z ENDP				; Bitmap::SetView
_TEXT	ENDS
;	COMDAT ?Width@CelObj@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Width@CelObj@@QBEHXZ PROC NEAR				; CelObj::Width, COMDAT

; 177  : 	int	Width() const			{return width;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Width@CelObj@@QBEHXZ ENDP				; CelObj::Width
_TEXT	ENDS
;	COMDAT ?Height@CelObj@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Height@CelObj@@QBEHXZ PROC NEAR			; CelObj::Height, COMDAT

; 178  : 	int	Height() const			{return height;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Height@CelObj@@QBEHXZ ENDP				; CelObj::Height
_TEXT	ENDS
;	COMDAT ?XOrg@CelObj@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?XOrg@CelObj@@QBEHXZ PROC NEAR				; CelObj::XOrg, COMDAT

; 179  : 	int	XOrg() const			{return xorg;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?XOrg@CelObj@@QBEHXZ ENDP				; CelObj::XOrg
_TEXT	ENDS
;	COMDAT ?YOrg@CelObj@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?YOrg@CelObj@@QBEHXZ PROC NEAR				; CelObj::YOrg, COMDAT

; 180  : 	int	YOrg() const			{return yorg;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?YOrg@CelObj@@QBEHXZ ENDP				; CelObj::YOrg
_TEXT	ENDS
;	COMDAT ??1SOL_Cursor@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1SOL_Cursor@@UAE@XZ PROC NEAR				; SOL_Cursor::~SOL_Cursor, COMDAT

; 20   : 	virtual	~SOL_Cursor() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7SOL_Cursor@@6B@ ; SOL_Cursor::`vftable'
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1SOL_Cursor@@UAE@XZ ENDP				; SOL_Cursor::~SOL_Cursor
_TEXT	ENDS
;	COMDAT ??_GSOL_Cursor@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GSOL_Cursor@@UAEPAXI@Z PROC NEAR			; SOL_Cursor::`scalar deleting destructor', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1SOL_Cursor@@UAE@XZ	; SOL_Cursor::~SOL_Cursor
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L53805
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L53805:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GSOL_Cursor@@UAEPAXI@Z ENDP				; SOL_Cursor::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0SOL_Rect@@QAE@XZ PROC NEAR				; SOL_Rect::SOL_Rect, COMDAT

; 13   : 	SOL_Rect()  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 08	 add	 ecx, 8
  00015	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0SOL_Rect@@QAE@XZ ENDP				; SOL_Rect::SOL_Rect
_TEXT	ENDS
;	COMDAT ?Set@SOL_Rect@@QAEXHHHH@Z
_TEXT	SEGMENT
_xa$ = 8
_ya$ = 12
_xb$ = 16
_yb$ = 20
_this$ = -4
?Set@SOL_Rect@@QAEXHHHH@Z PROC NEAR			; SOL_Rect::Set, COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 	A.x = xa;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _xa$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 75   : 	A.y = ya;

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _ya$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 76   : 	B.x = xb;

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 55 10	 mov	 edx, DWORD PTR _xb$[ebp]
  0001e	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 77   : 	B.y = yb;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 4d 14	 mov	 ecx, DWORD PTR _yb$[ebp]
  00027	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 78   : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 10 00	 ret	 16			; 00000010H
?Set@SOL_Rect@@QAEXHHHH@Z ENDP				; SOL_Rect::Set
_TEXT	ENDS
;	COMDAT ?IsEmpty@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsEmpty@SOL_Rect@@QBEHXZ PROC NEAR			; SOL_Rect::IsEmpty, COMDAT

; 116  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 117  : 	if (B.x < A.x  ||  B.y < A.y)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00010	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00012	7c 0e		 jl	 SHORT $L53934
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0001d	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00020	7d 07		 jge	 SHORT $L53933
$L53934:

; 118  : 		return True;

  00022	b8 01 00 00 00	 mov	 eax, 1
  00027	eb 02		 jmp	 SHORT $L53932
$L53933:

; 119  : 	return False;

  00029	33 c0		 xor	 eax, eax
$L53932:

; 120  : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?IsEmpty@SOL_Rect@@QBEHXZ ENDP				; SOL_Rect::IsEmpty
_TEXT	ENDS
;	COMDAT ?MakeEmpty@SOL_Rect@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?MakeEmpty@SOL_Rect@@QAEXXZ PROC NEAR			; SOL_Rect::MakeEmpty, COMDAT

; 142  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 143  : 	B.x = -1;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 08 ff ff
	ff ff		 mov	 DWORD PTR [eax+8], -1

; 144  : 	B.y = -1;

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 0c ff ff
	ff ff		 mov	 DWORD PTR [ecx+12], -1

; 145  : 	A.x = 0;

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 146  : 	A.y = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 147  : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?MakeEmpty@SOL_Rect@@QAEXXZ ENDP			; SOL_Rect::MakeEmpty
_TEXT	ENDS
;	COMDAT ?Xlen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Xlen@SOL_Rect@@QBEHXZ PROC NEAR			; SOL_Rect::Xlen, COMDAT

; 153  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 154  : 	return B.x - A.x + 1;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00010	2b 01		 sub	 eax, DWORD PTR [ecx]
  00012	83 c0 01	 add	 eax, 1

; 155  : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?Xlen@SOL_Rect@@QBEHXZ ENDP				; SOL_Rect::Xlen
_TEXT	ENDS
;	COMDAT ?Ylen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Ylen@SOL_Rect@@QBEHXZ PROC NEAR			; SOL_Rect::Ylen, COMDAT

; 161  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 	return B.y - A.y + 1;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00010	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00013	83 c0 01	 add	 eax, 1

; 163  : }

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?Ylen@SOL_Rect@@QBEHXZ ENDP				; SOL_Rect::Ylen
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHABV1@@Z
_TEXT	SEGMENT
_r$ = 8
_this$ = -4
?Intersect@SOL_Rect@@QBEHABV1@@Z PROC NEAR		; SOL_Rect::Intersect, COMDAT

; 189  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 190  : 	if (B.x < r.A.x)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  0000d	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00010	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00012	7d 04		 jge	 SHORT $L53970

; 191  : 		return False;

  00014	33 c0		 xor	 eax, eax
  00016	eb 3a		 jmp	 SHORT $L53969
$L53970:

; 192  : 	if (B.y < r.A.y)

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  0001e	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00021	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00024	7d 04		 jge	 SHORT $L53971

; 193  : 		return False;

  00026	33 c0		 xor	 eax, eax
  00028	eb 28		 jmp	 SHORT $L53969
$L53971:

; 194  : 	if (A.x > r.B.x)

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00030	8b 10		 mov	 edx, DWORD PTR [eax]
  00032	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00035	7e 04		 jle	 SHORT $L53972

; 195  : 		return False;

  00037	33 c0		 xor	 eax, eax
  00039	eb 17		 jmp	 SHORT $L53969
$L53972:

; 196  : 	if (A.y > r.B.y)

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00041	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00044	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00047	7e 04		 jle	 SHORT $L53973

; 197  : 		return False;

  00049	33 c0		 xor	 eax, eax
  0004b	eb 05		 jmp	 SHORT $L53969
$L53973:

; 198  : 	return True;

  0004d	b8 01 00 00 00	 mov	 eax, 1
$L53969:

; 199  : }

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?Intersect@SOL_Rect@@QBEHABV1@@Z ENDP			; SOL_Rect::Intersect
_TEXT	ENDS
;	COMDAT ?Clip@SOL_Rect@@QAEXABV1@@Z
_TEXT	SEGMENT
_r$ = 8
_this$ = -4
?Clip@SOL_Rect@@QAEXABV1@@Z PROC NEAR			; SOL_Rect::Clip, COMDAT

; 224  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 225  : 	if (Intersect(r))  {

  00007	8b 45 08	 mov	 eax, DWORD PTR _r$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?Intersect@SOL_Rect@@QBEHABV1@@Z ; SOL_Rect::Intersect
  00013	85 c0		 test	 eax, eax
  00015	74 66		 je	 SHORT $L53987

; 226  : 		if (A.x < r.A.x)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  0001d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001f	3b 02		 cmp	 eax, DWORD PTR [edx]
  00021	7d 0a		 jge	 SHORT $L53988

; 227  : 			A.x = r.A.x;

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00029	8b 02		 mov	 eax, DWORD PTR [edx]
  0002b	89 01		 mov	 DWORD PTR [ecx], eax
$L53988:

; 228  : 		if (A.y < r.A.y)

  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00033	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00036	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00039	7d 0c		 jge	 SHORT $L53989

; 229  : 			A.y = r.A.y;

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00041	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00044	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$L53989:

; 230  : 		if (B.x > r.B.x)

  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  0004d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00050	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00053	7e 0c		 jle	 SHORT $L53990

; 231  : 			B.x = r.B.x;

  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  0005b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0005e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L53990:

; 232  : 		if (B.y > r.B.y)

  00061	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00067	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0006a	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  0006d	7e 0c		 jle	 SHORT $L53991

; 233  : 			B.y = r.B.y;

  0006f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00075	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00078	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$L53991:

; 235  : 	else

  0007b	eb 08		 jmp	 SHORT $L53992
$L53987:

; 236  : 		MakeEmpty();

  0007d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	e8 00 00 00 00	 call	 ?MakeEmpty@SOL_Rect@@QAEXXZ ; SOL_Rect::MakeEmpty
$L53992:

; 237  : }

  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
?Clip@SOL_Rect@@QAEXABV1@@Z ENDP			; SOL_Rect::Clip
_TEXT	ENDS
;	COMDAT ?Both@SOL_Rect@@QAEXABV1@@Z
_TEXT	SEGMENT
_r$ = 8
_this$ = -4
?Both@SOL_Rect@@QAEXABV1@@Z PROC NEAR			; SOL_Rect::Both, COMDAT

; 244  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 245  : 	if (A.x > r.A.x)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  0000d	8b 10		 mov	 edx, DWORD PTR [eax]
  0000f	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00011	7e 0a		 jle	 SHORT $L53997

; 246  : 		A.x = r.A.x;

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00019	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001b	89 10		 mov	 DWORD PTR [eax], edx
$L53997:

; 247  : 	if (A.y > r.A.y)

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00023	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00026	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00029	7e 0c		 jle	 SHORT $L53998

; 248  : 		A.y = r.A.y;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00031	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00034	89 50 04	 mov	 DWORD PTR [eax+4], edx
$L53998:

; 249  : 	if (B.x < r.B.x)

  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  0003d	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00040	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00043	7d 0c		 jge	 SHORT $L53999

; 250  : 		B.x = r.B.x;

  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  0004b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0004e	89 50 08	 mov	 DWORD PTR [eax+8], edx
$L53999:

; 251  : 	if (B.y < r.B.y)

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00057	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0005a	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  0005d	7d 0c		 jge	 SHORT $L54000

; 252  : 		B.y = r.B.y;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00065	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00068	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$L54000:

; 253  : }

  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 04 00	 ret	 4
?Both@SOL_Rect@@QAEXABV1@@Z ENDP			; SOL_Rect::Both
_TEXT	ENDS
;	COMDAT ?MoveTo@SOL_Rect@@QAEXHH@Z
_TEXT	SEGMENT
_xa$ = 8
_ya$ = 12
_this$ = -4
?MoveTo@SOL_Rect@@QAEXHH@Z PROC NEAR			; SOL_Rect::MoveTo, COMDAT

; 295  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 296  : 	B.x += xa - A.x;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _xa$[ebp]
  0000d	2b 08		 sub	 ecx, DWORD PTR [eax]
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00015	03 c1		 add	 eax, ecx
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 297  : 	B.y += ya - A.y;

  0001d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00020	8b 45 0c	 mov	 eax, DWORD PTR _ya$[ebp]
  00023	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0002c	03 d0		 add	 edx, eax
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 298  : 	A.x = xa;

  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 55 08	 mov	 edx, DWORD PTR _xa$[ebp]
  0003a	89 11		 mov	 DWORD PTR [ecx], edx

; 299  : 	A.y = ya;

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	8b 4d 0c	 mov	 ecx, DWORD PTR _ya$[ebp]
  00042	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 300  : }

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 08 00	 ret	 8
?MoveTo@SOL_Rect@@QAEXHH@Z ENDP				; SOL_Rect::MoveTo
_TEXT	ENDS
;	COMDAT ?XDim@Buffer@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?XDim@Buffer@@QBEHXZ PROC NEAR				; Buffer::XDim, COMDAT

; 12   : 	int		XDim() const							{return xDim;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?XDim@Buffer@@QBEHXZ ENDP				; Buffer::XDim
_TEXT	ENDS
;	COMDAT ?YDim@Buffer@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?YDim@Buffer@@QBEHXZ PROC NEAR				; Buffer::YDim, COMDAT

; 13   : 	int		YDim() const							{return yDim;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?YDim@Buffer@@QBEHXZ ENDP				; Buffer::YDim
_TEXT	ENDS
;	COMDAT ?Get@CursorWin@@UAEAAVBitmap@@XZ
_TEXT	SEGMENT
_this$ = -4
?Get@CursorWin@@UAEAAVBitmap@@XZ PROC NEAR		; CursorWin::Get, COMDAT

; 33   : 	Bitmap&	Get() {return bitmap;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Get@CursorWin@@UAEAAVBitmap@@XZ ENDP			; CursorWin::Get
_TEXT	ENDS
;	COMDAT ?GonnaPaint@CursorWin@@UAEXVSOL_Rect@@@Z
_TEXT	SEGMENT
_this$ = -4
?GonnaPaint@CursorWin@@UAEXVSOL_Rect@@@Z PROC NEAR	; CursorWin::GonnaPaint, COMDAT

; 36   : 	void		GonnaPaint(SOL_Rect) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 10 00	 ret	 16			; 00000010H
?GonnaPaint@CursorWin@@UAEXVSOL_Rect@@@Z ENDP		; CursorWin::GonnaPaint
_TEXT	ENDS
;	COMDAT ?PaintStarting@CursorWin@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?PaintStarting@CursorWin@@UAEXXZ PROC NEAR		; CursorWin::PaintStarting, COMDAT

; 37   : 	void		PaintStarting() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?PaintStarting@CursorWin@@UAEXXZ ENDP			; CursorWin::PaintStarting
_TEXT	ENDS
;	COMDAT ?DonePainting@CursorWin@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?DonePainting@CursorWin@@UAEXXZ PROC NEAR		; CursorWin::DonePainting, COMDAT

; 38   : 	void		DonePainting() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?DonePainting@CursorWin@@UAEXXZ ENDP			; CursorWin::DonePainting
_TEXT	ENDS
;	COMDAT ?SetDevice@CursorWin@@UAEXAAVPointerDevice@@@Z
_TEXT	SEGMENT
_this$ = -4
?SetDevice@CursorWin@@UAEXAAVPointerDevice@@@Z PROC NEAR ; CursorWin::SetDevice, COMDAT

; 41   : 	void		SetDevice(PointerDevice&) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetDevice@CursorWin@@UAEXAAVPointerDevice@@@Z ENDP	; CursorWin::SetDevice
_TEXT	ENDS
;	COMDAT ?GetHideCount@CursorWin@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?GetHideCount@CursorWin@@UAEHXZ PROC NEAR		; CursorWin::GetHideCount, COMDAT

; 42   : 	int		GetHideCount() {return hideCount;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetHideCount@CursorWin@@UAEHXZ ENDP			; CursorWin::GetHideCount
_TEXT	ENDS
;	COMDAT ?Get@CursorWinClr@@UAEAAVBitmap@@XZ
_TEXT	SEGMENT
_this$ = -4
?Get@CursorWinClr@@UAEAAVBitmap@@XZ PROC NEAR		; CursorWinClr::Get, COMDAT

; 65   : 	Bitmap&	Get() {return bitmap;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 10	 add	 eax, 16			; 00000010H
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Get@CursorWinClr@@UAEAAVBitmap@@XZ ENDP		; CursorWinClr::Get
_TEXT	ENDS
;	COMDAT ?GetHideCount@CursorWinClr@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?GetHideCount@CursorWinClr@@UAEHXZ PROC NEAR		; CursorWinClr::GetHideCount, COMDAT

; 74   : 	int		GetHideCount() {return hideCount;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetHideCount@CursorWinClr@@UAEHXZ ENDP			; CursorWinClr::GetHideCount
_TEXT	ENDS
;	COMDAT ??0Info@CursorWinClr@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -4
_invertedFlag$ = 8
??0Info@CursorWinClr@@QAE@H@Z PROC NEAR			; CursorWinClr::Info::Info, COMDAT

; 79   : 		Info(Bool invertedFlag) : invertedFlag(invertedFlag) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 04	 add	 ecx, 4
  0000d	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@XZ	; SOL_Rect::SOL_Rect
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _invertedFlag$[ebp]
  00018	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??0Info@CursorWinClr@@QAE@H@Z ENDP			; CursorWinClr::Info::Info
_TEXT	ENDS
;	COMDAT ??4SOL_Rect@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??4SOL_Rect@@QAEAAV0@ABV0@@Z PROC NEAR			; SOL_Rect::operator=, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??4SOL_Point@@QAEAAV0@ABV0@@Z ; SOL_Point::operator=
  00013	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00016	83 c1 08	 add	 ecx, 8
  00019	51		 push	 ecx
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 08	 add	 ecx, 8
  00020	e8 00 00 00 00	 call	 ??4SOL_Point@@QAEAAV0@ABV0@@Z ; SOL_Point::operator=
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??4SOL_Rect@@QAEAAV0@ABV0@@Z ENDP			; SOL_Rect::operator=
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0SOL_Rect@@QAE@ABV0@@Z PROC NEAR			; SOL_Rect::SOL_Rect, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  00013	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00016	83 c1 08	 add	 ecx, 8
  00019	51		 push	 ecx
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 08	 add	 ecx, 8
  00020	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??0SOL_Rect@@QAE@ABV0@@Z ENDP				; SOL_Rect::SOL_Rect
_TEXT	ENDS
END
