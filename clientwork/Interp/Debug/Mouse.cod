	TITLE	C:\Documents and Settings\don\Desktop\sciw\Interp\Mouse.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BM@LHED@Instructed?5to?5scale?5to?5zero?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MemoryMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckValid@MemoryMgr@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GMemoryMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@V1@III@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AMemID@@QBEAADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8MemID@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??7MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@NN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SOL_Point@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Rgb24@@QAE@EEE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Rgb24@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Rgb24F@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Ratio@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@HHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@VMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Type@Bitmap@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObj@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Skip@CelObj@@QBEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemapState@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Mirrored@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObj@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjView@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjView@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjView@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjView@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjMem@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjMem@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjMem@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjMem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjColor@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjColor@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjColor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjColor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1SOL_Cursor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GSOL_Cursor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@HHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@AAVSOL_Point@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Set@SOL_Rect@@QAEXHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeEmpty@SOL_Rect@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Xlen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ylen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8SOL_Rect@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Draw@ScreenItem@@QAEXABVBuffer@@ABVSOL_Rect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SOL_Rect@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TopPlane@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TopSCIPlane@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Xdim@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ydim@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1KbdMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GKbdMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1PointerDevice@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GPointerDevice@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1SOL_Mouse@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSwiftInfo@SOL_Mouse@@UBEHPAH000@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSwift@SOL_Mouse@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Vibrate@SOL_Mouse@@UBEXHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetHotRectangleStatus@SOL_Mouse@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GSOL_Mouse@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeArrayID@@QBEPAUArrayHeader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ArrayID@@QAE@HW4ArrayType@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@ArrayID@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAE?AVMemID@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAEXVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_List@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@SOL_List@@QAEAAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeDispatchTblID@@QBEPAUDispatchTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeScriptEntryID@@QBEPAUScriptEntry@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntry@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeVariableID@@QBEPAUVariable@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Script@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Object@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGraphicsUpdate@Object@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?selectorDict@Object@@QAEPAVSelectorDict@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AObject@@QAEAAFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddr@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedPropAddr@Object@@QAEPBFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedProperty@Object@@QAEFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddrCheck@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@Object@@QAEFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropOffset@Object@@QAEIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetIndexedProperty@Object@@QAEXHF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetProperty@Object@@QAEXGF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssureValid@ObjectID@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsObject@ObjectID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeClassTblID@@QBEPAUClassTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CelObj@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7Buffer@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjColor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7SOL_Cursor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjView@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7PointerDevice@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7SOL_Mouse@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7MemoryMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjMem@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7KbdMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?hotRectangles@SOL_Mouse@@1PAUSCI_Rect@@A	; SOL_Mouse::hotRectangles
PUBLIC	?hotRectangleCount@SOL_Mouse@@1HA		; SOL_Mouse::hotRectangleCount
PUBLIC	?inRect@SOL_Mouse@@1HA				; SOL_Mouse::inRect
PUBLIC	?hotOn@SOL_Mouse@@1HA				; SOL_Mouse::hotOn
PUBLIC	?mouse@@3PAVSOL_Mouse@@A			; mouse
_BSS	SEGMENT
?hotRectangles@SOL_Mouse@@1PAUSCI_Rect@@A DD 01H DUP (?) ; SOL_Mouse::hotRectangles
?hotRectangleCount@SOL_Mouse@@1HA DD 01H DUP (?)	; SOL_Mouse::hotRectangleCount
?hotOn@SOL_Mouse@@1HA DD 01H DUP (?)			; SOL_Mouse::hotOn
?mouse@@3PAVSOL_Mouse@@A DD 01H DUP (?)			; mouse
_BSS	ENDS
CRT$XCU	SEGMENT
_$S24	DD	FLAT:_$E23
CRT$XCU	ENDS
_DATA	SEGMENT
?inRect@SOL_Mouse@@1HA DD 0ffffffffH			; SOL_Mouse::inRect
_DATA	ENDS
_TEXT	SEGMENT
_$E23	PROC NEAR
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	e8 00 00 00 00	 call	 _$E22
  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
_$E23	ENDP
_TEXT	ENDS
EXTRN	??0SOL_Event@@QAE@XZ:NEAR			; SOL_Event::SOL_Event
_BSS	SEGMENT
_event	DB	028H DUP (?)
_BSS	ENDS
_TEXT	SEGMENT
_$E22	PROC NEAR

; 17   : static SOL_Event event;	// kk - can't create it on the stack!

  0000a	55		 push	 ebp
  0000b	8b ec		 mov	 ebp, esp
  0000d	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_event
  00012	e8 00 00 00 00	 call	 ??0SOL_Event@@QAE@XZ	; SOL_Event::SOL_Event
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
_$E22	ENDP
_TEXT	ENDS
PUBLIC	?KHaveMouse@@YAXPAF@Z				; KHaveMouse
EXTRN	?pm@@3VPMachine@@A:BYTE				; pm
_TEXT	SEGMENT
?KHaveMouse@@YAXPAF@Z PROC NEAR				; KHaveMouse

; 26   : {

  00019	55		 push	 ebp
  0001a	8b ec		 mov	 ebp, esp

; 27   : 	if (mouse)

  0001c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?mouse@@3PAVSOL_Mouse@@A, 0 ; mouse
  00023	74 17		 je	 SHORT $L62075

; 28   : 		pm.acc = mouse->Exists();		//  Really means exists, irregardless if

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ?mouse@@3PAVSOL_Mouse@@A ; mouse
  0002a	8b 10		 mov	 edx, DWORD PTR [eax]
  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?mouse@@3PAVSOL_Mouse@@A ; mouse
  00032	ff 52 04	 call	 DWORD PTR [edx+4]
  00035	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 29   : 	else									//  user wants it or not

  0003a	eb 0a		 jmp	 SHORT $L62076
$L62075:

; 30   : 		pm.acc = False;

  0003c	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, 0
$L62076:

; 31   : }

  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?KHaveMouse@@YAXPAF@Z ENDP				; KHaveMouse
_TEXT	ENDS
PUBLIC	??0SOL_Point@@QAE@HH@Z				; SOL_Point::SOL_Point
PUBLIC	??0SOL_Point@@QAE@ABV0@@Z			; SOL_Point::SOL_Point
PUBLIC	??0SOL_Rect@@QAE@HHHH@Z				; SOL_Rect::SOL_Rect
PUBLIC	?KSetCursor@@YAXPAF@Z				; KSetCursor
EXTRN	?graphMgr@@3PAVGraphicsMgr@@A:DWORD		; graphMgr
_TEXT	SEGMENT
_args$ = 8
$T62290 = -12
$T62291 = -28
?KSetCursor@@YAXPAF@Z PROC NEAR				; KSetCursor

; 36   : {

  00048	55		 push	 ebp
  00049	8b ec		 mov	 ebp, esp
  0004b	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 37   : 	switch (argCount) {

  0004e	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00051	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00054	89 4d e0	 mov	 DWORD PTR -32+[ebp], ecx
  00057	8b 55 e0	 mov	 edx, DWORD PTR -32+[ebp]
  0005a	83 ea 01	 sub	 edx, 1
  0005d	89 55 e0	 mov	 DWORD PTR -32+[ebp], edx
  00060	83 7d e0 03	 cmp	 DWORD PTR -32+[ebp], 3
  00064	0f 87 5a 01 00
	00		 ja	 $L62081
  0006a	8b 45 e0	 mov	 eax, DWORD PTR -32+[ebp]
  0006d	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L62292[eax*4]
$L62084:

; 38   : 		case 1:
; 39   :          // show or hide cursor 
; 40   :          // disable special effects cursor
; 41   :          // restrict cursor to port
; 42   : 			switch (arg(1)) {

  00074	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00077	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  0007b	89 55 dc	 mov	 DWORD PTR -36+[ebp], edx
  0007e	83 7d dc fe	 cmp	 DWORD PTR -36+[ebp], -2	; fffffffeH
  00082	74 0a		 je	 SHORT $L62090
  00084	83 7d dc ff	 cmp	 DWORD PTR -36+[ebp], -1
  00088	74 02		 je	 SHORT $L62089
  0008a	eb 22		 jmp	 SHORT $L62091
$L62089:

; 43   : 				case -1:
; 44   : 					break;

  0008c	eb 6a		 jmp	 SHORT $L62086
$L62090:

; 45   : 
; 46   : 				case -2:
; 47   : 					graphMgr->GCursor().ClearRestrictRect();

  0008e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  00093	8b 10		 mov	 edx, DWORD PTR [eax]
  00095	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  0009b	ff 52 18	 call	 DWORD PTR [edx+24]
  0009e	89 45 d8	 mov	 DWORD PTR -40+[ebp], eax
  000a1	8b 45 d8	 mov	 eax, DWORD PTR -40+[ebp]
  000a4	8b 10		 mov	 edx, DWORD PTR [eax]
  000a6	8b 4d d8	 mov	 ecx, DWORD PTR -40+[ebp]
  000a9	ff 52 30	 call	 DWORD PTR [edx+48]

; 48   : 					break;

  000ac	eb 4a		 jmp	 SHORT $L62086
$L62091:

; 49   : 
; 50   : 				default:
; 51   : 			  		if (arg(1))

  000ae	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  000b1	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  000b5	85 c9		 test	 ecx, ecx
  000b7	74 21		 je	 SHORT $L62092

; 52   : 						graphMgr->GCursor().Show();

  000b9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  000bf	8b 02		 mov	 eax, DWORD PTR [edx]
  000c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  000c7	ff 50 18	 call	 DWORD PTR [eax+24]
  000ca	89 45 d4	 mov	 DWORD PTR -44+[ebp], eax
  000cd	8b 4d d4	 mov	 ecx, DWORD PTR -44+[ebp]
  000d0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d2	8b 4d d4	 mov	 ecx, DWORD PTR -44+[ebp]
  000d5	ff 52 0c	 call	 DWORD PTR [edx+12]

; 53   : 				   else

  000d8	eb 1e		 jmp	 SHORT $L62093
$L62092:

; 54   : 						graphMgr->GCursor().Hide();

  000da	a1 00 00 00 00	 mov	 eax, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  000df	8b 10		 mov	 edx, DWORD PTR [eax]
  000e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  000e7	ff 52 18	 call	 DWORD PTR [edx+24]
  000ea	89 45 d0	 mov	 DWORD PTR -48+[ebp], eax
  000ed	8b 45 d0	 mov	 eax, DWORD PTR -48+[ebp]
  000f0	8b 10		 mov	 edx, DWORD PTR [eax]
  000f2	8b 4d d0	 mov	 ecx, DWORD PTR -48+[ebp]
  000f5	ff 52 04	 call	 DWORD PTR [edx+4]
$L62093:
$L62086:

; 57   : 			break;

  000f8	e9 c7 00 00 00	 jmp	 $L62081
$L62094:

; 58   : 
; 59   : 		case 2:
; 60   :          // move cursor
; 61   :          graphMgr->GCursor().ForcePos(SOL_Point(arg(1), arg(2)));

  000fd	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00100	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  00104	51		 push	 ecx
  00105	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00108	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  0010c	50		 push	 eax
  0010d	8d 4d f4	 lea	 ecx, DWORD PTR $T62290[ebp]
  00110	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@HH@Z	; SOL_Point::SOL_Point
  00115	83 ec 08	 sub	 esp, 8
  00118	8b cc		 mov	 ecx, esp
  0011a	50		 push	 eax
  0011b	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  00120	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  00126	8b 11		 mov	 edx, DWORD PTR [ecx]
  00128	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  0012e	ff 52 18	 call	 DWORD PTR [edx+24]
  00131	89 45 cc	 mov	 DWORD PTR -52+[ebp], eax
  00134	8b 45 cc	 mov	 eax, DWORD PTR -52+[ebp]
  00137	8b 10		 mov	 edx, DWORD PTR [eax]
  00139	8b 4d cc	 mov	 ecx, DWORD PTR -52+[ebp]
  0013c	ff 52 1c	 call	 DWORD PTR [edx+28]

; 62   : 			break;

  0013f	e9 80 00 00 00	 jmp	 $L62081
$L62097:

; 63   : 
; 64   : 		case 3:
; 65   :          // set cursor
; 66   : 			graphMgr->GCursor().Set(arg(1), arg(2), arg(3));

  00144	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00147	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0014b	51		 push	 ecx
  0014c	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  0014f	0f bf 42 04	 movsx	 eax, WORD PTR [edx+4]
  00153	50		 push	 eax
  00154	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00157	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  0015b	52		 push	 edx
  0015c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  00161	8b 10		 mov	 edx, DWORD PTR [eax]
  00163	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  00169	ff 52 18	 call	 DWORD PTR [edx+24]
  0016c	89 45 c8	 mov	 DWORD PTR -56+[ebp], eax
  0016f	8b 45 c8	 mov	 eax, DWORD PTR -56+[ebp]
  00172	8b 10		 mov	 edx, DWORD PTR [eax]
  00174	8b 4d c8	 mov	 ecx, DWORD PTR -56+[ebp]
  00177	ff 52 10	 call	 DWORD PTR [edx+16]

; 67   : 			break;

  0017a	eb 48		 jmp	 SHORT $L62081
$L62098:

; 68   : 
; 69   : 		case 4:
; 70   : 			//  restrict mouse to a given rectangle
; 71   : 			//  Top left bottom right
; 72   : 			graphMgr->GCursor().SetRestrictRect(SOL_Rect(arg(1), arg(2), arg(3), arg(4)));

  0017c	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  0017f	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00183	51		 push	 ecx
  00184	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00187	0f bf 42 06	 movsx	 eax, WORD PTR [edx+6]
  0018b	50		 push	 eax
  0018c	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  0018f	0f bf 51 04	 movsx	 edx, WORD PTR [ecx+4]
  00193	52		 push	 edx
  00194	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00197	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  0019b	51		 push	 ecx
  0019c	8d 4d e4	 lea	 ecx, DWORD PTR $T62291[ebp]
  0019f	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@HHHH@Z	; SOL_Rect::SOL_Rect
  001a4	50		 push	 eax
  001a5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  001ab	8b 02		 mov	 eax, DWORD PTR [edx]
  001ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  001b3	ff 50 18	 call	 DWORD PTR [eax+24]
  001b6	89 45 c4	 mov	 DWORD PTR -60+[ebp], eax
  001b9	8b 4d c4	 mov	 ecx, DWORD PTR -60+[ebp]
  001bc	8b 11		 mov	 edx, DWORD PTR [ecx]
  001be	8b 4d c4	 mov	 ecx, DWORD PTR -60+[ebp]
  001c1	ff 52 2c	 call	 DWORD PTR [edx+44]
$L62081:

; 79   : }

  001c4	8b e5		 mov	 esp, ebp
  001c6	5d		 pop	 ebp
  001c7	c3		 ret	 0
$L62292:
  001c8	00 00 00 00	 DD	 $L62084
  001cc	00 00 00 00	 DD	 $L62094
  001d0	00 00 00 00	 DD	 $L62097
  001d4	00 00 00 00	 DD	 $L62098
?KSetCursor@@YAXPAF@Z ENDP				; KSetCursor
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@HH@Z
_TEXT	SEGMENT
_x$ = 8
_y$ = 12
_this$ = -4
??0SOL_Point@@QAE@HH@Z PROC NEAR			; SOL_Point::SOL_Point, COMDAT

; 21   : 	SOL_Point(Coord x, Coord y) : x(x), y(y) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0SOL_Point@@QAE@HH@Z ENDP				; SOL_Point::SOL_Point
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@ABV0@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
??0SOL_Point@@QAE@ABV0@@Z PROC NEAR			; SOL_Point::SOL_Point, COMDAT

; 22   : 	SOL_Point(const SOL_Point& p) : x(p.x), y(p.y) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00017	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001a	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??0SOL_Point@@QAE@ABV0@@Z ENDP				; SOL_Point::SOL_Point
_TEXT	ENDS
PUBLIC	??0SOL_Point@@QAE@XZ				; SOL_Point::SOL_Point
;	COMDAT ??0SOL_Rect@@QAE@HHHH@Z
_TEXT	SEGMENT
_xa$ = 8
_ya$ = 12
_xb$ = 16
_yb$ = 20
_this$ = -4
??0SOL_Rect@@QAE@HHHH@Z PROC NEAR			; SOL_Rect::SOL_Rect, COMDAT

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 08	 add	 ecx, 8
  00015	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point

; 56   : 	A.x = xa;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _xa$[ebp]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 57   : 	A.y = ya;

  00022	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00025	8b 45 0c	 mov	 eax, DWORD PTR _ya$[ebp]
  00028	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 58   : 	B.x = xb;

  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8b 55 10	 mov	 edx, DWORD PTR _xb$[ebp]
  00031	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 59   : 	B.y = yb;

  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 4d 14	 mov	 ecx, DWORD PTR _yb$[ebp]
  0003a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 60   : }

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 10 00	 ret	 16			; 00000010H
??0SOL_Rect@@QAE@HHHH@Z ENDP				; SOL_Rect::SOL_Rect
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0SOL_Point@@QAE@XZ PROC NEAR				; SOL_Point::SOL_Point, COMDAT

; 20   : 	SOL_Point() : x(DefaultCoord), y(DefaultCoord) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 ef cd ab
	89		 mov	 DWORD PTR [eax], -1985229329 ; 89abcdefH
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 ef cd
	ab 89		 mov	 DWORD PTR [ecx+4], -1985229329 ; 89abcdefH
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0SOL_Point@@QAE@XZ ENDP				; SOL_Point::SOL_Point
_TEXT	ENDS
PUBLIC	?KVibrateMouse@@YAXPAF@Z			; KVibrateMouse
_TEXT	SEGMENT
_args$ = 8
?KVibrateMouse@@YAXPAF@Z PROC NEAR			; KVibrateMouse

; 84   : {

  001d8	55		 push	 ebp
  001d9	8b ec		 mov	 ebp, esp

; 85   : 	if(argCount < 3)

  001db	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  001de	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  001e1	83 f9 03	 cmp	 ecx, 3
  001e4	7d 1f		 jge	 SHORT $L62104

; 86   : 		mouse->Vibrate(arg(1));

  001e6	6a 01		 push	 1
  001e8	6a 01		 push	 1
  001ea	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  001ed	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  001f1	50		 push	 eax
  001f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?mouse@@3PAVSOL_Mouse@@A ; mouse
  001f8	8b 11		 mov	 edx, DWORD PTR [ecx]
  001fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?mouse@@3PAVSOL_Mouse@@A ; mouse
  00200	ff 52 28	 call	 DWORD PTR [edx+40]

; 87   : 	else

  00203	eb 28		 jmp	 SHORT $L62105
$L62104:

; 88   : 		mouse->Vibrate(arg(1), arg(2), arg(3));

  00205	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00208	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0020c	51		 push	 ecx
  0020d	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00210	0f bf 42 04	 movsx	 eax, WORD PTR [edx+4]
  00214	50		 push	 eax
  00215	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00218	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  0021c	52		 push	 edx
  0021d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?mouse@@3PAVSOL_Mouse@@A ; mouse
  00222	8b 10		 mov	 edx, DWORD PTR [eax]
  00224	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?mouse@@3PAVSOL_Mouse@@A ; mouse
  0022a	ff 52 28	 call	 DWORD PTR [edx+40]
$L62105:

; 89   : }

  0022d	5d		 pop	 ebp
  0022e	c3		 ret	 0
?KVibrateMouse@@YAXPAF@Z ENDP				; KVibrateMouse
_TEXT	ENDS
PUBLIC	?KSetHotRectangles@@YAXPAF@Z			; KSetHotRectangles
PUBLIC	??0MemID@@QAE@G@Z				; MemID::MemID
_TEXT	SEGMENT
_args$ = 8
?KSetHotRectangles@@YAXPAF@Z PROC NEAR			; KSetHotRectangles

; 93   : {

  0022f	55		 push	 ebp
  00230	8b ec		 mov	 ebp, esp
  00232	83 ec 08	 sub	 esp, 8

; 94   : 	switch(arg(0)) {		// switch on count 

  00235	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00238	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0023b	89 4d f8	 mov	 DWORD PTR -8+[ebp], ecx
  0023e	83 7d f8 01	 cmp	 DWORD PTR -8+[ebp], 1
  00242	74 08		 je	 SHORT $L62113
  00244	83 7d f8 02	 cmp	 DWORD PTR -8+[ebp], 2
  00248	74 36		 je	 SHORT $L62116
  0024a	eb 6f		 jmp	 SHORT $L62110
$L62113:

; 95   : 
; 96   : 		case 1:	// Turn on or off
; 97   : 			if(arg(1))

  0024c	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  0024f	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  00253	85 c0		 test	 eax, eax
  00255	74 15		 je	 SHORT $L62114

; 98   : 				mouse->SetHotRectangleStatus(True);

  00257	6a 01		 push	 1
  00259	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?mouse@@3PAVSOL_Mouse@@A ; mouse
  0025f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00261	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?mouse@@3PAVSOL_Mouse@@A ; mouse
  00267	ff 52 2c	 call	 DWORD PTR [edx+44]

; 99   : 			else

  0026a	eb 12		 jmp	 SHORT $L62115
$L62114:

; 100  : 				mouse->SetHotRectangleStatus(False);

  0026c	6a 00		 push	 0
  0026e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?mouse@@3PAVSOL_Mouse@@A ; mouse
  00273	8b 10		 mov	 edx, DWORD PTR [eax]
  00275	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?mouse@@3PAVSOL_Mouse@@A ; mouse
  0027b	ff 52 2c	 call	 DWORD PTR [edx+44]
$L62115:

; 101  : 
; 102  : 			break;

  0027e	eb 3b		 jmp	 SHORT $L62110
$L62116:

; 103  : 
; 104  : 		case 2:	// setup rectangles
; 105  : 
; 106  : 			mouse->SetHotRectangleStatus(True);

  00280	6a 01		 push	 1
  00282	a1 00 00 00 00	 mov	 eax, DWORD PTR ?mouse@@3PAVSOL_Mouse@@A ; mouse
  00287	8b 10		 mov	 edx, DWORD PTR [eax]
  00289	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?mouse@@3PAVSOL_Mouse@@A ; mouse
  0028f	ff 52 2c	 call	 DWORD PTR [edx+44]

; 107  : 			mouse->SetupHotRectangles(arg(1),arg(2));

  00292	51		 push	 ecx
  00293	8b cc		 mov	 ecx, esp
  00295	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00298	66 8b 50 04	 mov	 dx, WORD PTR [eax+4]
  0029c	52		 push	 edx
  0029d	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  002a2	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  002a5	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  002a9	51		 push	 ecx
  002aa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?mouse@@3PAVSOL_Mouse@@A ; mouse
  002b0	8b 02		 mov	 eax, DWORD PTR [edx]
  002b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?mouse@@3PAVSOL_Mouse@@A ; mouse
  002b8	ff 50 30	 call	 DWORD PTR [eax+48]
$L62110:

; 109  : 
; 110  : }

  002bb	8b e5		 mov	 esp, ebp
  002bd	5d		 pop	 ebp
  002be	c3		 ret	 0
?KSetHotRectangles@@YAXPAF@Z ENDP			; KSetHotRectangles
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0MemID@@QAE@G@Z PROC NEAR				; MemID::MemID, COMDAT

; 23   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 4d 08	 mov	 cx, WORD PTR _h$[ebp]
  0000e	66 89 08	 mov	 WORD PTR [eax], cx

; 24   : 	}

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??0MemID@@QAE@G@Z ENDP					; MemID::MemID
_TEXT	ENDS
PUBLIC	?SetupHotRectangles@SOL_Mouse@@UAEXHVMemID@@@Z	; SOL_Mouse::SetupHotRectangles
PUBLIC	??DMemID@@QBEPAXXZ				; MemID::operator*
EXTRN	?Lock@MemID@@QBEPAXXZ:NEAR			; MemID::Lock
_TEXT	SEGMENT
_count$ = 8
_handle$ = 12
_this$ = -4
?SetupHotRectangles@SOL_Mouse@@UAEXHVMemID@@@Z PROC NEAR ; SOL_Mouse::SetupHotRectangles

; 114  : {

  002bf	55		 push	 ebp
  002c0	8b ec		 mov	 ebp, esp
  002c2	51		 push	 ecx
  002c3	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 115  : 	hotRectangleCount = count;

  002c6	8b 45 08	 mov	 eax, DWORD PTR _count$[ebp]
  002c9	a3 00 00 00 00	 mov	 DWORD PTR ?hotRectangleCount@SOL_Mouse@@1HA, eax ; SOL_Mouse::hotRectangleCount

; 116  : 	handle.Lock();

  002ce	8d 4d 0c	 lea	 ecx, DWORD PTR _handle$[ebp]
  002d1	e8 00 00 00 00	 call	 ?Lock@MemID@@QBEPAXXZ	; MemID::Lock

; 117  : 	hotRectangles = (SCI_Rect *) ((char *) (*handle) + 4);	// dereference once - locked memory

  002d6	8d 4d 0c	 lea	 ecx, DWORD PTR _handle$[ebp]
  002d9	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  002de	83 c0 04	 add	 eax, 4
  002e1	a3 00 00 00 00	 mov	 DWORD PTR ?hotRectangles@SOL_Mouse@@1PAUSCI_Rect@@A, eax ; SOL_Mouse::hotRectangles

; 118  : 	inRect = -1;

  002e6	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?inRect@SOL_Mouse@@1HA, -1 ; SOL_Mouse::inRect

; 119  : }

  002f0	8b e5		 mov	 esp, ebp
  002f2	5d		 pop	 ebp
  002f3	c2 08 00	 ret	 8
?SetupHotRectangles@SOL_Mouse@@UAEXHVMemID@@@Z ENDP	; SOL_Mouse::SetupHotRectangles
_TEXT	ENDS
PUBLIC	?GetAddr@MemoryMgr@@QAEPAXG@Z			; MemoryMgr::GetAddr
EXTRN	_memMgr:DWORD
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT
_this$ = -4
??DMemID@@QBEPAXXZ PROC NEAR				; MemID::operator*, COMDAT

; 98   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 99   : 		return memMgr->GetAddr(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr

; 100  : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??DMemID@@QBEPAXXZ ENDP					; MemID::operator*
_TEXT	ENDS
EXTRN	__descPtrTable:BYTE
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -4
?GetAddr@MemoryMgr@@QAEPAXG@Z PROC NEAR			; MemoryMgr::GetAddr, COMDAT

; 462  : 	inline void* MemoryMgr::GetAddr(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : //		CheckValid(theID);
; 464  : 		return _descPtrTable[(unsigned int)((unsigned short)theID)];

  00007	8b 45 08	 mov	 eax, DWORD PTR _theID$[ebp]
  0000a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0000f	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR __descPtrTable[eax*4]

; 465  : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?GetAddr@MemoryMgr@@QAEPAXG@Z ENDP			; MemoryMgr::GetAddr
_TEXT	ENDS
PUBLIC	?CheckHotRectangles@SOL_Mouse@@UAEXAAVSOL_Point@@@Z ; SOL_Mouse::CheckHotRectangles
EXTRN	?eventMgr@@3PAUEventMgr@@A:DWORD		; eventMgr
_TEXT	SEGMENT
_pos$ = 8
_this$ = -12
_lastRect$ = -8
_i$ = -4
?CheckHotRectangles@SOL_Mouse@@UAEXAAVSOL_Point@@@Z PROC NEAR ; SOL_Mouse::CheckHotRectangles

; 124  : {

  002f6	55		 push	 ebp
  002f7	8b ec		 mov	 ebp, esp
  002f9	83 ec 0c	 sub	 esp, 12			; 0000000cH
  002fc	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 125  : 	int lastRect = inRect;

  002ff	a1 00 00 00 00	 mov	 eax, DWORD PTR ?inRect@SOL_Mouse@@1HA ; SOL_Mouse::inRect
  00304	89 45 f8	 mov	 DWORD PTR _lastRect$[ebp], eax

; 126  : 	inRect = -1;

  00307	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?inRect@SOL_Mouse@@1HA, -1 ; SOL_Mouse::inRect

; 127  : 
; 128  : 	for(int i = 0; i < hotRectangleCount;i++) {

  00311	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00318	eb 09		 jmp	 SHORT $L62131
$L62132:
  0031a	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0031d	83 c1 01	 add	 ecx, 1
  00320	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L62131:
  00323	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00326	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?hotRectangleCount@SOL_Mouse@@1HA ; SOL_Mouse::hotRectangleCount
  0032c	0f 8d 9f 00 00
	00		 jge	 $L62133

; 130  : 			pos.x <= hotRectangles[i].lr.x &&
; 131  : 			pos.y >= hotRectangles[i].ul.y &&
; 132  : 			pos.y <= hotRectangles[i].lr.y) {

  00332	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00335	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hotRectangles@SOL_Mouse@@1PAUSCI_Rect@@A ; SOL_Mouse::hotRectangles
  0033b	0f bf 14 c1	 movsx	 edx, WORD PTR [ecx+eax*8]
  0033f	8b 45 08	 mov	 eax, DWORD PTR _pos$[ebp]
  00342	39 10		 cmp	 DWORD PTR [eax], edx
  00344	0f 8c 82 00 00
	00		 jl	 $L62134
  0034a	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0034d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hotRectangles@SOL_Mouse@@1PAUSCI_Rect@@A ; SOL_Mouse::hotRectangles
  00353	0f bf 44 ca 04	 movsx	 eax, WORD PTR [edx+ecx*8+4]
  00358	8b 4d 08	 mov	 ecx, DWORD PTR _pos$[ebp]
  0035b	39 01		 cmp	 DWORD PTR [ecx], eax
  0035d	7f 6d		 jg	 SHORT $L62134
  0035f	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00362	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hotRectangles@SOL_Mouse@@1PAUSCI_Rect@@A ; SOL_Mouse::hotRectangles
  00367	0f bf 4c d0 02	 movsx	 ecx, WORD PTR [eax+edx*8+2]
  0036c	8b 55 08	 mov	 edx, DWORD PTR _pos$[ebp]
  0036f	39 4a 04	 cmp	 DWORD PTR [edx+4], ecx
  00372	7c 58		 jl	 SHORT $L62134
  00374	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00377	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hotRectangles@SOL_Mouse@@1PAUSCI_Rect@@A ; SOL_Mouse::hotRectangles
  0037d	0f bf 54 c1 06	 movsx	 edx, WORD PTR [ecx+eax*8+6]
  00382	8b 45 08	 mov	 eax, DWORD PTR _pos$[ebp]
  00385	39 50 04	 cmp	 DWORD PTR [eax+4], edx
  00388	7f 42		 jg	 SHORT $L62134

; 133  : 
; 134  : 			inRect = i;

  0038a	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0038d	89 0d 00 00 00
	00		 mov	 DWORD PTR ?inRect@SOL_Mouse@@1HA, ecx ; SOL_Mouse::inRect

; 135  : 			if(i != lastRect) {

  00393	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00396	3b 55 f8	 cmp	 edx, DWORD PTR _lastRect$[ebp]
  00399	74 29		 je	 SHORT $L62135

; 136  : 				// it's in a rectangle, create an event
; 137  : 				event.type = SOL_Event::HotRectangle;

  0039b	66 c7 05 00 00
	00 00 00 04	 mov	 WORD PTR _event, 1024	; 00000400H

; 138  : 				event.message = i;

  003a4	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  003a7	a3 04 00 00 00	 mov	 DWORD PTR _event+4, eax

; 139  : 				eventMgr->Post(&event);

  003ac	68 00 00 00 00	 push	 OFFSET FLAT:_event
  003b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?eventMgr@@3PAUEventMgr@@A ; eventMgr
  003b7	8b 11		 mov	 edx, DWORD PTR [ecx]
  003b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?eventMgr@@3PAUEventMgr@@A ; eventMgr
  003bf	ff 52 18	 call	 DWORD PTR [edx+24]

; 140  : 				break;	// no need to continue once hit

  003c2	eb 0d		 jmp	 SHORT $L62133
$L62135:

; 142  : 
; 143  : 			lastRect = inRect;

  003c4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?inRect@SOL_Mouse@@1HA ; SOL_Mouse::inRect
  003c9	89 45 f8	 mov	 DWORD PTR _lastRect$[ebp], eax
$L62134:

; 146  : 	}

  003cc	e9 49 ff ff ff	 jmp	 $L62132
$L62133:

; 147  : 
; 148  : 	// it WAS in a rect, but not now - need to send a message too
; 149  : 	if(lastRect != inRect && lastRect != -1) {	

  003d1	8b 4d f8	 mov	 ecx, DWORD PTR _lastRect$[ebp]
  003d4	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?inRect@SOL_Mouse@@1HA ; SOL_Mouse::inRect
  003da	74 39		 je	 SHORT $L62136
  003dc	83 7d f8 ff	 cmp	 DWORD PTR _lastRect$[ebp], -1
  003e0	74 33		 je	 SHORT $L62136

; 150  : 		inRect = -1;

  003e2	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?inRect@SOL_Mouse@@1HA, -1 ; SOL_Mouse::inRect

; 151  : 		event.type = SOL_Event::HotRectangle;

  003ec	66 c7 05 00 00
	00 00 00 04	 mov	 WORD PTR _event, 1024	; 00000400H

; 152  : 		event.message = -1;

  003f5	c7 05 04 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _event+4, -1

; 153  : 		eventMgr->Post(&event);

  003ff	68 00 00 00 00	 push	 OFFSET FLAT:_event
  00404	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?eventMgr@@3PAUEventMgr@@A ; eventMgr
  0040a	8b 02		 mov	 eax, DWORD PTR [edx]
  0040c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?eventMgr@@3PAUEventMgr@@A ; eventMgr
  00412	ff 50 18	 call	 DWORD PTR [eax+24]
$L62136:

; 155  : }

  00415	8b e5		 mov	 esp, ebp
  00417	5d		 pop	 ebp
  00418	c2 04 00	 ret	 4
?CheckHotRectangles@SOL_Mouse@@UAEXAAVSOL_Point@@@Z ENDP ; SOL_Mouse::CheckHotRectangles
_TEXT	ENDS
END
