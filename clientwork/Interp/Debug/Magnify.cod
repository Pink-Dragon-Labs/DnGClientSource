	TITLE	C:\Documents and Settings\don\Desktop\sciw\Interp\Magnify.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BM@LHED@Instructed?5to?5scale?5to?5zero?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MemoryMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckValid@MemoryMgr@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GMemoryMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@MemID@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@V1@III@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AMemID@@QBEAADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8MemID@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??7MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@NN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SOL_Point@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Rgb24@@QAE@EEE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Rgb24@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Rgb24F@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Ratio@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@HHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@VMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Type@Bitmap@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Cel@Bitmap@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Handle@Bitmap@@QBE?AVMemID@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObj@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Width@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Height@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?XOrg@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?YOrg@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResX@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResY@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Skip@CelObj@@QBEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemapState@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Mirrored@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObj@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjView@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjView@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjView@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjView@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjMem@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjMem@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjMem@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjMem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjColor@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjColor@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjColor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjColor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@HHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@AAVSOL_Point@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Set@SOL_Rect@@QAEXHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeEmpty@SOL_Rect@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Xlen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ylen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8SOL_Rect@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScaleInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Id@ScreenItem@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Draw@ScreenItem@@QAEXABVBuffer@@ABVSOL_Rect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCel@ScreenItem@@QAEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCel@ScreenItem@@QAEXPAVCelObj@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetInsetRect@ScreenItem@@QAEXABVSOL_Rect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SOL_Rect@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TopPlane@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TopSCIPlane@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Xdim@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ydim@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddScreenItem@GraphicsMgr@@QAEXPAVScreenItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeArrayID@@QBEPAUArrayHeader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ArrayID@@QAE@HW4ArrayType@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@ArrayID@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAE?AVMemID@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAEXVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_List@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@SOL_List@@QAEAAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildHeader@@YAXVMemID@@HHHHHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeDispatchTblID@@QBEPAUDispatchTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeScriptEntryID@@QBEPAUScriptEntry@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntry@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeVariableID@@QBEPAUVariable@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Script@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Object@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGraphicsUpdate@Object@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?selectorDict@Object@@QAEPAVSelectorDict@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AObject@@QAEAAFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddr@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedPropAddr@Object@@QAEPBFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedProperty@Object@@QAEFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddrCheck@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@Object@@QAEFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropOffset@Object@@QAEIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetIndexedProperty@Object@@QAEXHF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetProperty@Object@@QAEXGF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssureValid@ObjectID@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsObject@ObjectID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedProperty@ObjectID@@QBEFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@ObjectID@@QBEFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeClassTblID@@QBEPAUClassTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CelObj@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7Buffer@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjColor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjView@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7MemoryMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjMem@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?Id@ScreenItem@@QBEJXZ				; ScreenItem::Id
PUBLIC	?GetCel@ScreenItem@@QAEPAVCelObj@@XZ		; ScreenItem::GetCel
PUBLIC	?SetCel@ScreenItem@@QAEXPAVCelObj@@@Z		; ScreenItem::SetCel
PUBLIC	??0Bitmap@@QAE@VMemID@@@Z			; Bitmap::Bitmap
PUBLIC	?Cel@Bitmap@@QBEHXZ				; Bitmap::Cel
PUBLIC	?Handle@Bitmap@@QBE?AVMemID@@XZ			; Bitmap::Handle
PUBLIC	??0MemID@@QAE@XZ				; MemID::MemID
PUBLIC	??0MemID@@QAE@ABV0@@Z				; MemID::MemID
PUBLIC	?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get
PUBLIC	?Width@CelObj@@QBEHXZ				; CelObj::Width
PUBLIC	?Height@CelObj@@QBEHXZ				; CelObj::Height
PUBLIC	?XOrg@CelObj@@QBEHXZ				; CelObj::XOrg
PUBLIC	?YOrg@CelObj@@QBEHXZ				; CelObj::YOrg
PUBLIC	?ResX@CelObj@@QBEHXZ				; CelObj::ResX
PUBLIC	?ResY@CelObj@@QBEHXZ				; CelObj::ResY
PUBLIC	?Skip@CelObj@@QBEEXZ				; CelObj::Skip
PUBLIC	??BMemID@@QBEGXZ				; MemID::operator unsigned short
PUBLIC	??DMemID@@QBEPAXXZ				; MemID::operator*
PUBLIC	??0SOL_Point@@QAE@XZ				; SOL_Point::SOL_Point
PUBLIC	??0SOL_Point@@QAE@HH@Z				; SOL_Point::SOL_Point
PUBLIC	??0SOL_Point@@QAE@ABV0@@Z			; SOL_Point::SOL_Point
PUBLIC	?AddScreenItem@GraphicsMgr@@QAEXPAVScreenItem@@@Z ; GraphicsMgr::AddScreenItem
PUBLIC	?Duplicate@CelObjView@@UBEPAVCelObj@@XZ		; CelObjView::Duplicate
PUBLIC	??0ObjectID@@QAE@ABV0@@Z			; ObjectID::ObjectID
PUBLIC	??0ObjectID@@QAE@G@Z				; ObjectID::ObjectID
PUBLIC	??1CelObjView@@UAE@XZ				; CelObjView::~CelObjView
PUBLIC	?GetIndexedProperty@ObjectID@@QBEFH@Z		; ObjectID::GetIndexedProperty
PUBLIC	?GetProperty@ObjectID@@QBEFG@Z			; ObjectID::GetProperty
PUBLIC	??0SOL_Rect@@QAE@XZ				; SOL_Rect::SOL_Rect
PUBLIC	??0MagnifyView@@QAE@VObjectID@@PAV0@@Z		; MagnifyView::MagnifyView
PUBLIC	??0SOL_Rect@@QAE@HHHH@Z				; SOL_Rect::SOL_Rect
PUBLIC	?FillData@MagnifyView@@QAEXVSOL_Point@@@Z	; MagnifyView::FillData
PUBLIC	??0ScaleInfo@@QAE@XZ				; ScaleInfo::ScaleInfo
PUBLIC	?BuildHeader@@YAXVMemID@@HHHHHHHHH@Z		; BuildHeader
EXTRN	??0ScreenItem@@QAE@JABVBitmap@@VSOL_Point@@UScaleInfo@@H@Z:NEAR ; ScreenItem::ScreenItem
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	_memset:NEAR
EXTRN	??0CelObjView@@QAE@HHH@Z:NEAR			; CelObjView::CelObjView
EXTRN	?Draw@CelObjView@@UAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@H@Z:NEAR ; CelObjView::Draw
EXTRN	?graphMgr@@3PAVGraphicsMgr@@A:DWORD		; graphMgr
EXTRN	??0BufferStd@@QAE@HHPAE@Z:NEAR			; BufferStd::BufferStd
EXTRN	?AddPalShift@@YAHH@Z:NEAR			; AddPalShift
xdata$x	SEGMENT
$T61519	DD	019930520H
	DD	03H
	DD	FLAT:$T61522
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T61522	DD	0ffffffffH
	DD	FLAT:$L61513
	DD	00H
	DD	FLAT:$L61514
	DD	01H
	DD	FLAT:$L61515
xdata$x	ENDS
_TEXT	SEGMENT
$T61501 = -320
$T61502 = -324
$T61503 = -328
$T61504 = -332
$T61505 = -336
$T61506 = -340
$T61507 = -344
$T61508 = -348
$T61509 = -352
$T61510 = -356
__$EHRec$ = -12
_ID$ = 8
_theNext$ = 12
_this$ = -360
_v$ = -180
_l$ = -312
_c$ = -168
_forground$ = -284
_background$ = -164
_resx$ = -176
_resy$ = -204
_rect$ = -64
_pt$ = -308
_buffer$ = -300
_bufferFG$ = -48
_bufferBG$ = -32
_bitmap$ = -84
_scaleInfo$ = -200
_m$ = -316
_w$ = -184
_a$ = -16
_d$ = -172
??0MagnifyView@@QAE@VObjectID@@PAV0@@Z PROC NEAR	; MagnifyView::MagnifyView

; 31   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 $L61520
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	81 ec 60 01 00
	00		 sub	 esp, 352		; 00000160H
  0001e	89 8d 98 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  00024	6a 36		 push	 54			; 00000036H
  00026	8d 4d 08	 lea	 ecx, DWORD PTR _ID$[ebp]
  00029	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  0002e	50		 push	 eax
  0002f	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  0003a	8d 45 08	 lea	 eax, DWORD PTR _ID$[ebp]
  0003d	50		 push	 eax
  0003e	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00044	83 c1 02	 add	 ecx, 2
  00047	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID
  0004c	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00052	83 c1 04	 add	 ecx, 4
  00055	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  0005a	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00060	83 c1 06	 add	 ecx, 6
  00063	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  00068	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	83 c1 08	 add	 ecx, 8
  00071	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  00076	6a 0e		 push	 14			; 0000000eH
  00078	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  00083	0f bf c8	 movsx	 ecx, ax
  00086	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0008c	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx
  0008f	6a 0f		 push	 15			; 0000000fH
  00091	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00097	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  0009c	0f bf c0	 movsx	 eax, ax
  0009f	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  000a8	6a 10		 push	 16			; 00000010H
  000aa	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  000b5	0f bf d0	 movsx	 edx, ax
  000b8	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000be	89 50 24	 mov	 DWORD PTR [eax+36], edx
  000c1	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	83 c1 28	 add	 ecx, 40			; 00000028H
  000ca	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point
  000cf	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	83 c1 30	 add	 ecx, 48			; 00000030H
  000d8	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@XZ	; SOL_Rect::SOL_Rect

; 32   : 	int v(magID.GetProperty(s_view));

  000dd	6a 0e		 push	 14			; 0000000eH
  000df	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000e5	83 c1 02	 add	 ecx, 2
  000e8	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  000ed	0f bf c8	 movsx	 ecx, ax
  000f0	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _v$[ebp], ecx

; 33   : 	int l(magID.GetProperty(s_loop));

  000f6	6a 0f		 push	 15			; 0000000fH
  000f8	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	83 c1 02	 add	 ecx, 2
  00101	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  00106	0f bf d0	 movsx	 edx, ax
  00109	89 95 c8 fe ff
	ff		 mov	 DWORD PTR _l$[ebp], edx

; 34   : 	int c(magID.GetProperty(s_cel));

  0010f	6a 10		 push	 16			; 00000010H
  00111	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00117	83 c1 02	 add	 ecx, 2
  0011a	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  0011f	0f bf c0	 movsx	 eax, ax
  00122	89 85 58 ff ff
	ff		 mov	 DWORD PTR _c$[ebp], eax

; 35   : 
; 36   :    // prepare forground and background info
; 37   : 	CelObjView forground(view, loop, cel);

  00128	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00131	52		 push	 edx
  00132	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00138	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0013b	51		 push	 ecx
  0013c	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00142	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00145	50		 push	 eax
  00146	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _forground$[ebp]
  0014c	e8 00 00 00 00	 call	 ??0CelObjView@@QAE@HHH@Z ; CelObjView::CelObjView
  00151	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 38   : 	CelObjView background(	magID.GetProperty(s_view),
; 39   : 									magID.GetProperty(s_loop),
; 40   : 									magID.GetProperty(s_cel)
; 41   : 				 				);

  00158	6a 10		 push	 16			; 00000010H
  0015a	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00160	83 c1 02	 add	 ecx, 2
  00163	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  00168	0f bf c8	 movsx	 ecx, ax
  0016b	51		 push	 ecx
  0016c	6a 0f		 push	 15			; 0000000fH
  0016e	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00174	83 c1 02	 add	 ecx, 2
  00177	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  0017c	0f bf d0	 movsx	 edx, ax
  0017f	52		 push	 edx
  00180	6a 0e		 push	 14			; 0000000eH
  00182	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00188	83 c1 02	 add	 ecx, 2
  0018b	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  00190	0f bf c0	 movsx	 eax, ax
  00193	50		 push	 eax
  00194	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _background$[ebp]
  0019a	e8 00 00 00 00	 call	 ??0CelObjView@@QAE@HHH@Z ; CelObjView::CelObjView
  0019f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 42   : 
; 43   :    // calculate boundy rectangle on screen
; 44   : 	boundry.A.x = magID.GetProperty(s_x);

  001a3	6a 01		 push	 1
  001a5	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001ab	83 c1 02	 add	 ecx, 2
  001ae	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  001b3	0f bf c8	 movsx	 ecx, ax
  001b6	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001bc	89 4a 30	 mov	 DWORD PTR [edx+48], ecx

; 45   : 	boundry.A.y = magID.GetProperty(s_y);

  001bf	6a 02		 push	 2
  001c1	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001c7	83 c1 02	 add	 ecx, 2
  001ca	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  001cf	0f bf c0	 movsx	 eax, ax
  001d2	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001d8	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 46   : 
; 47   : 	power = magID.GetProperty(s_power);

  001db	68 b6 01 00 00	 push	 438			; 000001b6H
  001e0	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001e6	83 c1 02	 add	 ecx, 2
  001e9	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  001ee	0f bf d0	 movsx	 edx, ax
  001f1	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001f7	89 50 44	 mov	 DWORD PTR [eax+68], edx

; 48   : 	boundry.B.x = boundry.A.x + (background.Width() - 1) / power;

  001fa	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _background$[ebp]
  00200	e8 00 00 00 00	 call	 ?Width@CelObj@@QBEHXZ	; CelObj::Width
  00205	83 e8 01	 sub	 eax, 1
  00208	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0020e	99		 cdq
  0020f	f7 79 44	 idiv	 DWORD PTR [ecx+68]
  00212	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00218	8b 4a 30	 mov	 ecx, DWORD PTR [edx+48]
  0021b	03 c8		 add	 ecx, eax
  0021d	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00223	89 4a 38	 mov	 DWORD PTR [edx+56], ecx

; 49   : 	boundry.B.y = boundry.A.y + (background.Height() - 1) / power;

  00226	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _background$[ebp]
  0022c	e8 00 00 00 00	 call	 ?Height@CelObj@@QBEHXZ	; CelObj::Height
  00231	83 e8 01	 sub	 eax, 1
  00234	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0023a	99		 cdq
  0023b	f7 79 44	 idiv	 DWORD PTR [ecx+68]
  0023e	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00244	8b 4a 34	 mov	 ecx, DWORD PTR [edx+52]
  00247	03 c8		 add	 ecx, eax
  00249	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0024f	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx

; 50   : 
; 51   : 
; 52   :    // store skip and remap colors
; 53   : #ifndef WIN32S
; 54   : 	remapColor = magID.GetProperty(s_skip);
; 55   : #else
; 56   : 	remapColor = (uchar)AddPalShift((int)magID.GetProperty(s_skip));

  00252	6a 72		 push	 114			; 00000072H
  00254	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0025a	83 c1 02	 add	 ecx, 2
  0025d	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  00262	0f bf c0	 movsx	 eax, ax
  00265	50		 push	 eax
  00266	e8 00 00 00 00	 call	 ?AddPalShift@@YAHH@Z	; AddPalShift
  0026b	83 c4 04	 add	 esp, 4
  0026e	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00274	88 41 40	 mov	 BYTE PTR [ecx+64], al

; 57   : #endif
; 58   : 	skip = forground.Skip();

  00277	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _forground$[ebp]
  0027d	e8 00 00 00 00	 call	 ?Skip@CelObj@@QBEEXZ	; CelObj::Skip
  00282	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00288	88 42 41	 mov	 BYTE PTR [edx+65], al

; 59   : 
; 60   :    // set next node value
; 61   :    next = theNext;

  0028b	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00291	8b 4d 0c	 mov	 ecx, DWORD PTR _theNext$[ebp]
  00294	89 48 48	 mov	 DWORD PTR [eax+72], ecx

; 62   : 
; 63   : 	// store width and height of forground(BM) and background(BG) cels
; 64   : 	BMWidth = forground.Width();

  00297	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _forground$[ebp]
  0029d	e8 00 00 00 00	 call	 ?Width@CelObj@@QBEHXZ	; CelObj::Width
  002a2	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  002a8	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 65   : 	BMHeight = forground.Height();

  002ab	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _forground$[ebp]
  002b1	e8 00 00 00 00	 call	 ?Height@CelObj@@QBEHXZ	; CelObj::Height
  002b6	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002bc	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 66   : 	BGWidth = background.Width();

  002bf	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _background$[ebp]
  002c5	e8 00 00 00 00	 call	 ?Width@CelObj@@QBEHXZ	; CelObj::Width
  002ca	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  002d0	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 67   : 	BGHeight = background.Height();

  002d3	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _background$[ebp]
  002d9	e8 00 00 00 00	 call	 ?Height@CelObj@@QBEHXZ	; CelObj::Height
  002de	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002e4	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 68   : 
; 69   : 	// allocate memory for the bitmaps
; 70   : 	BMData.Get(MemBitmap, BMWidth*BMHeight+CELHEADERSIZE);

  002e7	6a 00		 push	 0
  002e9	6a 00		 push	 0
  002eb	6a 00		 push	 0
  002ed	6a 00		 push	 0
  002ef	68 00 02 00 00	 push	 512			; 00000200H
  002f4	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  002fa	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00300	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00303	0f af 48 10	 imul	 ecx, DWORD PTR [eax+16]
  00307	83 c1 2e	 add	 ecx, 46			; 0000002eH
  0030a	51		 push	 ecx
  0030b	6a 4b		 push	 75			; 0000004bH
  0030d	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00313	83 c1 04	 add	 ecx, 4
  00316	e8 00 00 00 00	 call	 ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get

; 71   : 	FGData.Get(MemBitmap, BMWidth*BMHeight);

  0031b	6a 00		 push	 0
  0031d	6a 00		 push	 0
  0031f	6a 00		 push	 0
  00321	6a 00		 push	 0
  00323	68 00 02 00 00	 push	 512			; 00000200H
  00328	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0032e	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00334	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00337	0f af 48 10	 imul	 ecx, DWORD PTR [eax+16]
  0033b	51		 push	 ecx
  0033c	6a 4b		 push	 75			; 0000004bH
  0033e	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00344	83 c1 06	 add	 ecx, 6
  00347	e8 00 00 00 00	 call	 ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get

; 72   : 	BGData.Get(MemBitmap, BGWidth*BGHeight);

  0034c	6a 00		 push	 0
  0034e	6a 00		 push	 0
  00350	6a 00		 push	 0
  00352	6a 00		 push	 0
  00354	68 00 02 00 00	 push	 512			; 00000200H
  00359	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0035f	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00365	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  00368	0f af 48 18	 imul	 ecx, DWORD PTR [eax+24]
  0036c	51		 push	 ecx
  0036d	6a 4b		 push	 75			; 0000004bH
  0036f	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00375	83 c1 08	 add	 ecx, 8
  00378	e8 00 00 00 00	 call	 ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get

; 73   : 
; 74   :    // store origen point of forground cel
; 75   :    org.x = forground.XOrg();

  0037d	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _forground$[ebp]
  00383	e8 00 00 00 00	 call	 ?XOrg@CelObj@@QBEHXZ	; CelObj::XOrg
  00388	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0038e	89 42 28	 mov	 DWORD PTR [edx+40], eax

; 76   :    org.y = forground.YOrg();

  00391	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _forground$[ebp]
  00397	e8 00 00 00 00	 call	 ?YOrg@CelObj@@QBEHXZ	; CelObj::YOrg
  0039c	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003a2	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 77   : 
; 78   : 	int resx = forground.ResX();

  003a5	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _forground$[ebp]
  003ab	e8 00 00 00 00	 call	 ?ResX@CelObj@@QBEHXZ	; CelObj::ResX
  003b0	89 85 50 ff ff
	ff		 mov	 DWORD PTR _resx$[ebp], eax

; 79   : 	int resy = background.ResX();

  003b6	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _background$[ebp]
  003bc	e8 00 00 00 00	 call	 ?ResX@CelObj@@QBEHXZ	; CelObj::ResX
  003c1	89 85 34 ff ff
	ff		 mov	 DWORD PTR _resy$[ebp], eax

; 80   : 	// build the header for the BMData
; 81   : 	BuildHeader(BMData,BMWidth,BMHeight,skip,org.x,org.y,forground.ResX(),background.ResY()); 

  003c7	6a 00		 push	 0
  003c9	6a 00		 push	 0
  003cb	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _background$[ebp]
  003d1	e8 00 00 00 00	 call	 ?ResY@CelObj@@QBEHXZ	; CelObj::ResY
  003d6	50		 push	 eax
  003d7	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _forground$[ebp]
  003dd	e8 00 00 00 00	 call	 ?ResX@CelObj@@QBEHXZ	; CelObj::ResX
  003e2	50		 push	 eax
  003e3	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  003e9	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  003ec	50		 push	 eax
  003ed	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003f3	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  003f6	52		 push	 edx
  003f7	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  003fd	33 c9		 xor	 ecx, ecx
  003ff	8a 48 41	 mov	 cl, BYTE PTR [eax+65]
  00402	51		 push	 ecx
  00403	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00409	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0040c	50		 push	 eax
  0040d	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00413	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00416	52		 push	 edx
  00417	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0041d	83 c0 04	 add	 eax, 4
  00420	51		 push	 ecx
  00421	8b cc		 mov	 ecx, esp
  00423	89 a5 c0 fe ff
	ff		 mov	 DWORD PTR $T61501[ebp], esp
  00429	50		 push	 eax
  0042a	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  0042f	e8 00 00 00 00	 call	 ?BuildHeader@@YAXVMemID@@HHHHHHHHH@Z ; BuildHeader
  00434	83 c4 28	 add	 esp, 40			; 00000028H

; 82   : 
; 83   : 	// inset is size of data
; 84   : 	SOL_Rect rect(0,0,BMWidth - 1,BMHeight - 1);

  00437	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0043d	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00440	83 ea 01	 sub	 edx, 1
  00443	52		 push	 edx
  00444	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0044a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0044d	83 e9 01	 sub	 ecx, 1
  00450	51		 push	 ecx
  00451	6a 00		 push	 0
  00453	6a 00		 push	 0
  00455	8d 4d c0	 lea	 ecx, DWORD PTR _rect$[ebp]
  00458	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@HHHH@Z	; SOL_Rect::SOL_Rect

; 85   : 
; 86   : 	// draw the cel into the bitmap
; 87   : 	SOL_Point pt(0,0);

  0045d	6a 00		 push	 0
  0045f	6a 00		 push	 0
  00461	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR _pt$[ebp]
  00467	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@HH@Z	; SOL_Point::SOL_Point

; 88   : 
; 89   :    // fill background with skip of mem cels
; 90   :    memset((uchar *)*BMData + CELHEADERSIZE, skip, BMWidth*BMHeight);

  0046c	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00472	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00478	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0047b	0f af 48 10	 imul	 ecx, DWORD PTR [eax+16]
  0047f	51		 push	 ecx
  00480	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00486	33 c0		 xor	 eax, eax
  00488	8a 42 41	 mov	 al, BYTE PTR [edx+65]
  0048b	50		 push	 eax
  0048c	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00492	83 c1 04	 add	 ecx, 4
  00495	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0049a	83 c0 2e	 add	 eax, 46			; 0000002eH
  0049d	50		 push	 eax
  0049e	e8 00 00 00 00	 call	 _memset
  004a3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 91   :    memset((uchar *)*FGData, skip, BMWidth*BMHeight);

  004a6	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004ac	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  004b2	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  004b5	0f af 42 10	 imul	 eax, DWORD PTR [edx+16]
  004b9	50		 push	 eax
  004ba	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004c0	33 d2		 xor	 edx, edx
  004c2	8a 51 41	 mov	 dl, BYTE PTR [ecx+65]
  004c5	52		 push	 edx
  004c6	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004cc	83 c1 06	 add	 ecx, 6
  004cf	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  004d4	50		 push	 eax
  004d5	e8 00 00 00 00	 call	 _memset
  004da	83 c4 0c	 add	 esp, 12			; 0000000cH

; 92   : 
; 93   :    // actual screen cel space, background added later
; 94   : 	BufferStd buffer(BMWidth, BMHeight, (uchar *)*BMData + CELHEADERSIZE);

  004dd	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004e3	83 c1 04	 add	 ecx, 4
  004e6	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  004eb	83 c0 2e	 add	 eax, 46			; 0000002eH
  004ee	50		 push	 eax
  004ef	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  004f5	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  004f8	51		 push	 ecx
  004f9	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  004ff	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00502	50		 push	 eax
  00503	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _buffer$[ebp]
  00509	e8 00 00 00 00	 call	 ??0BufferStd@@QAE@HHPAE@Z ; BufferStd::BufferStd

; 95   : 	forground.Draw(buffer,rect,pt,False);

  0050e	6a 00		 push	 0
  00510	83 ec 08	 sub	 esp, 8
  00513	8b cc		 mov	 ecx, esp
  00515	89 a5 bc fe ff
	ff		 mov	 DWORD PTR $T61502[ebp], esp
  0051b	8d 95 cc fe ff
	ff		 lea	 edx, DWORD PTR _pt$[ebp]
  00521	52		 push	 edx
  00522	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  00527	8d 45 c0	 lea	 eax, DWORD PTR _rect$[ebp]
  0052a	50		 push	 eax
  0052b	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _buffer$[ebp]
  00531	51		 push	 ecx
  00532	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _forground$[ebp]
  00538	e8 00 00 00 00	 call	 ?Draw@CelObjView@@UAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@H@Z ; CelObjView::Draw

; 96   : 
; 97   :    // load forground pixel information						
; 98   : 	BufferStd bufferFG(BMWidth, BMHeight, (uchar *)*FGData);

  0053d	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00543	83 c1 06	 add	 ecx, 6
  00546	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0054b	50		 push	 eax
  0054c	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00552	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00555	50		 push	 eax
  00556	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0055c	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0055f	52		 push	 edx
  00560	8d 4d d0	 lea	 ecx, DWORD PTR _bufferFG$[ebp]
  00563	e8 00 00 00 00	 call	 ??0BufferStd@@QAE@HHPAE@Z ; BufferStd::BufferStd

; 99   : 	forground.Draw(bufferFG,rect,pt,False);

  00568	6a 00		 push	 0
  0056a	83 ec 08	 sub	 esp, 8
  0056d	8b cc		 mov	 ecx, esp
  0056f	89 a5 b8 fe ff
	ff		 mov	 DWORD PTR $T61503[ebp], esp
  00575	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR _pt$[ebp]
  0057b	50		 push	 eax
  0057c	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  00581	8d 4d c0	 lea	 ecx, DWORD PTR _rect$[ebp]
  00584	51		 push	 ecx
  00585	8d 55 d0	 lea	 edx, DWORD PTR _bufferFG$[ebp]
  00588	52		 push	 edx
  00589	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _forground$[ebp]
  0058f	e8 00 00 00 00	 call	 ?Draw@CelObjView@@UAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@H@Z ; CelObjView::Draw

; 100  : 
; 101  :    // fill background with skip of background mem cel
; 102  :    memset((uchar *)*BGData, background.Skip(), BGWidth*BGHeight);

  00594	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0059a	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  005a0	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  005a3	0f af 51 18	 imul	 edx, DWORD PTR [ecx+24]
  005a7	52		 push	 edx
  005a8	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _background$[ebp]
  005ae	e8 00 00 00 00	 call	 ?Skip@CelObj@@QBEEXZ	; CelObj::Skip
  005b3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  005b8	50		 push	 eax
  005b9	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  005bf	83 c1 08	 add	 ecx, 8
  005c2	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  005c7	50		 push	 eax
  005c8	e8 00 00 00 00	 call	 _memset
  005cd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 103  : 
; 104  :    // load background pixel information
; 105  : 	rect.B.x = BGWidth - 1;

  005d0	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  005d6	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  005d9	83 e9 01	 sub	 ecx, 1
  005dc	89 4d c8	 mov	 DWORD PTR _rect$[ebp+8], ecx

; 106  : 	rect.B.y = BGHeight - 1;

  005df	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  005e5	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  005e8	83 e8 01	 sub	 eax, 1
  005eb	89 45 cc	 mov	 DWORD PTR _rect$[ebp+12], eax

; 107  : 	BufferStd bufferBG(BGWidth, BGHeight, (uchar *)*BGData);

  005ee	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  005f4	83 c1 08	 add	 ecx, 8
  005f7	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  005fc	50		 push	 eax
  005fd	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00603	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00606	52		 push	 edx
  00607	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0060d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00610	51		 push	 ecx
  00611	8d 4d e0	 lea	 ecx, DWORD PTR _bufferBG$[ebp]
  00614	e8 00 00 00 00	 call	 ??0BufferStd@@QAE@HHPAE@Z ; BufferStd::BufferStd

; 108  : 	background.Draw(bufferBG,rect,pt,False);

  00619	6a 00		 push	 0
  0061b	83 ec 08	 sub	 esp, 8
  0061e	8b cc		 mov	 ecx, esp
  00620	89 a5 b4 fe ff
	ff		 mov	 DWORD PTR $T61504[ebp], esp
  00626	8d 95 cc fe ff
	ff		 lea	 edx, DWORD PTR _pt$[ebp]
  0062c	52		 push	 edx
  0062d	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  00632	8d 45 c0	 lea	 eax, DWORD PTR _rect$[ebp]
  00635	50		 push	 eax
  00636	8d 4d e0	 lea	 ecx, DWORD PTR _bufferBG$[ebp]
  00639	51		 push	 ecx
  0063a	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _background$[ebp]
  00640	e8 00 00 00 00	 call	 ?Draw@CelObjView@@UAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@H@Z ; CelObjView::Draw

; 109  : 
; 110  :    // where does this get drawn
; 111  : 	pt.x = (signed short)id.GetIndexedProperty(actX);

  00645	6a 00		 push	 0
  00647	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0064d	e8 00 00 00 00	 call	 ?GetIndexedProperty@ObjectID@@QBEFH@Z ; ObjectID::GetIndexedProperty
  00652	0f bf d0	 movsx	 edx, ax
  00655	89 95 cc fe ff
	ff		 mov	 DWORD PTR _pt$[ebp], edx

; 112  : 	pt.y = (signed short)id.GetIndexedProperty(actY);

  0065b	6a 01		 push	 1
  0065d	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00663	e8 00 00 00 00	 call	 ?GetIndexedProperty@ObjectID@@QBEFH@Z ; ObjectID::GetIndexedProperty
  00668	0f bf c0	 movsx	 eax, ax
  0066b	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _pt$[ebp+4], eax

; 113  : 
; 114  :    // created cel to be displayed
; 115  : 	FillData(pt);

  00671	83 ec 08	 sub	 esp, 8
  00674	8b cc		 mov	 ecx, esp
  00676	89 a5 b0 fe ff
	ff		 mov	 DWORD PTR $T61505[ebp], esp
  0067c	8d 95 cc fe ff
	ff		 lea	 edx, DWORD PTR _pt$[ebp]
  00682	52		 push	 edx
  00683	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  00688	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0068e	e8 00 00 00 00	 call	 ?FillData@MagnifyView@@QAEXVSOL_Point@@@Z ; MagnifyView::FillData

; 116  : 
; 117  : 	// make bitmap for created cel
; 118  : 	Bitmap bitmap(BMData);

  00693	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00699	83 c0 04	 add	 eax, 4
  0069c	51		 push	 ecx
  0069d	8b cc		 mov	 ecx, esp
  0069f	89 a5 ac fe ff
	ff		 mov	 DWORD PTR $T61506[ebp], esp
  006a5	50		 push	 eax
  006a6	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  006ab	8d 4d ac	 lea	 ecx, DWORD PTR _bitmap$[ebp]
  006ae	e8 00 00 00 00	 call	 ??0Bitmap@@QAE@VMemID@@@Z ; Bitmap::Bitmap

; 119  : 	ScaleInfo scaleInfo;

  006b3	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _scaleInfo$[ebp]
  006b9	e8 00 00 00 00	 call	 ??0ScaleInfo@@QAE@XZ	; ScaleInfo::ScaleInfo

; 120  : 
; 121  : 	MemID  m = bitmap.Handle();

  006be	8d 8d a8 fe ff
	ff		 lea	 ecx, DWORD PTR $T61507[ebp]
  006c4	51		 push	 ecx
  006c5	8d 4d ac	 lea	 ecx, DWORD PTR _bitmap$[ebp]
  006c8	e8 00 00 00 00	 call	 ?Handle@Bitmap@@QBE?AVMemID@@XZ ; Bitmap::Handle
  006cd	50		 push	 eax
  006ce	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR _m$[ebp]
  006d4	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID

; 122  :    // created screen item
; 123  : 	si = New ScreenItem(id.GetProperty(s_plane),bitmap,pt,scaleInfo,magID);

  006d9	68 98 00 00 00	 push	 152			; 00000098H
  006de	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  006e3	83 c4 04	 add	 esp, 4
  006e6	89 85 a0 fe ff
	ff		 mov	 DWORD PTR $T61509[ebp], eax
  006ec	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  006f0	83 bd a0 fe ff
	ff 00		 cmp	 DWORD PTR $T61509[ebp], 0
  006f7	74 7b		 je	 SHORT $L61511
  006f9	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  006ff	83 c1 02	 add	 ecx, 2
  00702	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00707	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0070c	50		 push	 eax
  0070d	83 ec 10	 sub	 esp, 16			; 00000010H
  00710	8b d4		 mov	 edx, esp
  00712	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _scaleInfo$[ebp]
  00718	89 02		 mov	 DWORD PTR [edx], eax
  0071a	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _scaleInfo$[ebp+4]
  00720	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00723	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _scaleInfo$[ebp+8]
  00729	89 42 08	 mov	 DWORD PTR [edx+8], eax
  0072c	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _scaleInfo$[ebp+12]
  00732	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00735	83 ec 08	 sub	 esp, 8
  00738	8b cc		 mov	 ecx, esp
  0073a	89 a5 9c fe ff
	ff		 mov	 DWORD PTR $T61510[ebp], esp
  00740	8d 95 cc fe ff
	ff		 lea	 edx, DWORD PTR _pt$[ebp]
  00746	52		 push	 edx
  00747	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  0074c	8d 45 ac	 lea	 eax, DWORD PTR _bitmap$[ebp]
  0074f	50		 push	 eax
  00750	6a 00		 push	 0
  00752	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00758	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  0075d	0f bf c8	 movsx	 ecx, ax
  00760	51		 push	 ecx
  00761	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR $T61509[ebp]
  00767	e8 00 00 00 00	 call	 ??0ScreenItem@@QAE@JABVBitmap@@VSOL_Point@@UScaleInfo@@H@Z ; ScreenItem::ScreenItem
  0076c	89 85 94 fe ff
	ff		 mov	 DWORD PTR -364+[ebp], eax
  00772	eb 0a		 jmp	 SHORT $L61512
$L61511:
  00774	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR -364+[ebp], 0
$L61512:
  0077e	8b 95 94 fe ff
	ff		 mov	 edx, DWORD PTR -364+[ebp]
  00784	89 95 a4 fe ff
	ff		 mov	 DWORD PTR $T61508[ebp], edx
  0078a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0078e	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00794	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR $T61508[ebp]
  0079a	89 48 4c	 mov	 DWORD PTR [eax+76], ecx

; 124  : 	int w = si->GetCel()->ResX();

  0079d	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  007a3	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  007a6	e8 00 00 00 00	 call	 ?GetCel@ScreenItem@@QAEPAVCelObj@@XZ ; ScreenItem::GetCel
  007ab	8b c8		 mov	 ecx, eax
  007ad	e8 00 00 00 00	 call	 ?ResX@CelObj@@QBEHXZ	; CelObj::ResX
  007b2	89 85 48 ff ff
	ff		 mov	 DWORD PTR _w$[ebp], eax

; 125  : 	Bool a;
; 126  : 	long	d;
; 127  : 	d = si->Id();

  007b8	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  007be	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  007c1	e8 00 00 00 00	 call	 ?Id@ScreenItem@@QBEJXZ	; ScreenItem::Id
  007c6	89 85 54 ff ff
	ff		 mov	 DWORD PTR _d$[ebp], eax

; 128  : 	a = bitmap.Cel();

  007cc	8d 4d ac	 lea	 ecx, DWORD PTR _bitmap$[ebp]
  007cf	e8 00 00 00 00	 call	 ?Cel@Bitmap@@QBEHXZ	; Bitmap::Cel
  007d4	89 45 f0	 mov	 DWORD PTR _a$[ebp], eax

; 129  :    // add to picture
; 130  : 	graphMgr->AddScreenItem(si);

  007d7	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  007dd	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  007e0	52		 push	 edx
  007e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  007e7	e8 00 00 00 00	 call	 ?AddScreenItem@GraphicsMgr@@QAEXPAVScreenItem@@@Z ; GraphicsMgr::AddScreenItem

; 131  :    si->SetCel(background.Duplicate());

  007ec	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _background$[ebp]
  007f2	e8 00 00 00 00	 call	 ?Duplicate@CelObjView@@UBEPAVCelObj@@XZ ; CelObjView::Duplicate
  007f7	50		 push	 eax
  007f8	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  007fe	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00801	e8 00 00 00 00	 call	 ?SetCel@ScreenItem@@QAEXPAVCelObj@@@Z ; ScreenItem::SetCel

; 132  : 	w = si->GetCel()->ResX();

  00806	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0080c	8b 49 4c	 mov	 ecx, DWORD PTR [ecx+76]
  0080f	e8 00 00 00 00	 call	 ?GetCel@ScreenItem@@QAEPAVCelObj@@XZ ; ScreenItem::GetCel
  00814	8b c8		 mov	 ecx, eax
  00816	e8 00 00 00 00	 call	 ?ResX@CelObj@@QBEHXZ	; CelObj::ResX
  0081b	89 85 48 ff ff
	ff		 mov	 DWORD PTR _w$[ebp], eax

; 133  : 	w = si->GetCel()->ResX();

  00821	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00827	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  0082a	e8 00 00 00 00	 call	 ?GetCel@ScreenItem@@QAEPAVCelObj@@XZ ; ScreenItem::GetCel
  0082f	8b c8		 mov	 ecx, eax
  00831	e8 00 00 00 00	 call	 ?ResX@CelObj@@QBEHXZ	; CelObj::ResX
  00836	89 85 48 ff ff
	ff		 mov	 DWORD PTR _w$[ebp], eax

; 134  : }

  0083c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00840	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _background$[ebp]
  00846	e8 00 00 00 00	 call	 ??1CelObjView@@UAE@XZ	; CelObjView::~CelObjView
  0084b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00852	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _forground$[ebp]
  00858	e8 00 00 00 00	 call	 ??1CelObjView@@UAE@XZ	; CelObjView::~CelObjView
  0085d	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00863	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00866	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0086d	8b e5		 mov	 esp, ebp
  0086f	5d		 pop	 ebp
  00870	c2 08 00	 ret	 8
_TEXT	ENDS
text$x	SEGMENT
$L61513:
  00000	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _forground$[ebp]
  00006	e8 00 00 00 00	 call	 ??1CelObjView@@UAE@XZ	; CelObjView::~CelObjView
  0000b	c3		 ret	 0
$L61514:
  0000c	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _background$[ebp]
  00012	e8 00 00 00 00	 call	 ??1CelObjView@@UAE@XZ	; CelObjView::~CelObjView
  00017	c3		 ret	 0
$L61515:
  00018	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR $T61509[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00024	59		 pop	 ecx
  00025	c3		 ret	 0
$L61520:
  00026	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T61519
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0MagnifyView@@QAE@VObjectID@@PAV0@@Z ENDP		; MagnifyView::MagnifyView
PUBLIC	?Free@MemID@@QAEXXZ				; MemID::Free
PUBLIC	??1MagnifyView@@QAE@XZ				; MagnifyView::~MagnifyView
_TEXT	SEGMENT
_this$ = -4
??1MagnifyView@@QAE@XZ PROC NEAR			; MagnifyView::~MagnifyView

; 137  : {

  00873	55		 push	 ebp
  00874	8b ec		 mov	 ebp, esp
  00876	51		 push	 ecx
  00877	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 138  : 	BGData.Free();

  0087a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0087d	83 c1 08	 add	 ecx, 8
  00880	e8 00 00 00 00	 call	 ?Free@MemID@@QAEXXZ	; MemID::Free

; 139  : 	BMData.Free();

  00885	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00888	83 c1 04	 add	 ecx, 4
  0088b	e8 00 00 00 00	 call	 ?Free@MemID@@QAEXXZ	; MemID::Free

; 140  : 	FGData.Free();

  00890	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00893	83 c1 06	 add	 ecx, 6
  00896	e8 00 00 00 00	 call	 ?Free@MemID@@QAEXXZ	; MemID::Free

; 141  : }

  0089b	8b e5		 mov	 esp, ebp
  0089d	5d		 pop	 ebp
  0089e	c3		 ret	 0
??1MagnifyView@@QAE@XZ ENDP				; MagnifyView::~MagnifyView
_TEXT	ENDS
PUBLIC	__real@8@40009999999999999800
PUBLIC	?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z		; SOL_Rect::Intersect
EXTRN	__ftol:NEAR
EXTRN	__fltused:NEAR
;	COMDAT __real@8@40009999999999999800
; File C:\Documents and Settings\don\Desktop\sciw\Interp\Magnify.cpp
CONST	SEGMENT
__real@8@40009999999999999800 DQ 04003333333333333r ; 2.4
CONST	ENDS
_TEXT	SEGMENT
_pt$ = 8
_this$ = -52
_focus$61284 = -8
_ptrBM$61285 = -12
_ptrFG$61287 = -24
_ptrBG$61289 = -20
_y$61290 = -16
_x$61297 = -28
_ptrBM$61306 = -32
_ptrFG$61308 = -40
_y$61310 = -36
_x$61314 = -44
?FillData@MagnifyView@@QAEXVSOL_Point@@@Z PROC NEAR	; MagnifyView::FillData

; 151  : {

  0089f	55		 push	 ebp
  008a0	8b ec		 mov	 ebp, esp
  008a2	83 ec 38	 sub	 esp, 56			; 00000038H
  008a5	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  :    // if pt in rect then fill background in
; 153  :    // else just fil remapColor with skip
; 154  : 	if(boundry.Intersect(pt)) {

  008a8	83 ec 08	 sub	 esp, 8
  008ab	8b cc		 mov	 ecx, esp
  008ad	8d 45 08	 lea	 eax, DWORD PTR _pt$[ebp]
  008b0	50		 push	 eax
  008b1	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  008b6	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  008b9	83 c1 30	 add	 ecx, 48			; 00000030H
  008bc	e8 00 00 00 00	 call	 ?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z ; SOL_Rect::Intersect
  008c1	85 c0		 test	 eax, eax
  008c3	0f 84 54 01 00
	00		 je	 $L61283

; 155  : 
; 156  : 		SOL_Point focus;

  008c9	8d 4d f8	 lea	 ecx, DWORD PTR _focus$61284[ebp]
  008cc	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point

; 157  :       // focus in upper left corner of forground compared to background.
; 158  :       // calculate the point location of a screen coordinate in the 
; 159  :       // background cel.
; 160  :       //  +--------+  
; 161  :       //  |        |  point in rect
; 162  :       //  |        |  +---+
; 163  :       //  |   *    |  | * |
; 164  :       //  |        |  |   |
; 165  :       //  |        |  |   |
; 166  :       //  |        |  +---+
; 167  :       //  |        |
; 168  :       //  |        |
; 169  :       //  +--------+
; 170  :       // then correct the location be the offset of the origin of the
; 171  :       // forground.
; 172  : //		focus.x = ( pt.x - boundry.A.x) * power - org.x;
; 173  : //		focus.y = ( pt.y - boundry.A.y) * power - org.y;
; 174  : 		focus.x = 2*( pt.x - boundry.A.x) * power - org.x;

  008d1	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  008d4	8b 55 08	 mov	 edx, DWORD PTR _pt$[ebp]
  008d7	2b 51 30	 sub	 edx, DWORD PTR [ecx+48]
  008da	d1 e2		 shl	 edx, 1
  008dc	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  008df	0f af 50 44	 imul	 edx, DWORD PTR [eax+68]
  008e3	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  008e6	2b 51 28	 sub	 edx, DWORD PTR [ecx+40]
  008e9	89 55 f8	 mov	 DWORD PTR _focus$61284[ebp], edx

; 175  : 		focus.y = 2.4*( pt.y - boundry.A.y) * power - org.y;

  008ec	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  008ef	8b 45 0c	 mov	 eax, DWORD PTR _pt$[ebp+4]
  008f2	2b 42 34	 sub	 eax, DWORD PTR [edx+52]
  008f5	89 45 c8	 mov	 DWORD PTR -56+[ebp], eax
  008f8	db 45 c8	 fild	 DWORD PTR -56+[ebp]
  008fb	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@8@40009999999999999800
  00901	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00904	da 49 44	 fimul	 DWORD PTR [ecx+68]
  00907	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  0090a	da 62 2c	 fisub	 DWORD PTR [edx+44]
  0090d	e8 00 00 00 00	 call	 __ftol
  00912	89 45 fc	 mov	 DWORD PTR _focus$61284[ebp+4], eax

; 176  : 		// change the above lines when hi-res coordinates are added
; 177  : 
; 178  :       // intialize forground and virtual cel
; 179  : 		uchar* ptrBM = (uchar *)*BMData + CELHEADERSIZE;

  00915	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00918	83 c1 04	 add	 ecx, 4
  0091b	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  00920	83 c0 2e	 add	 eax, 46			; 0000002eH
  00923	89 45 f4	 mov	 DWORD PTR _ptrBM$61285[ebp], eax

; 180  : 		uchar* ptrFG = (uchar *)*FGData;

  00926	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00929	83 c1 06	 add	 ecx, 6
  0092c	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  00931	89 45 e8	 mov	 DWORD PTR _ptrFG$61287[ebp], eax

; 181  : 		uchar* ptrBG;
; 182  : 
; 183  :       // for exery line in the forgroung
; 184  : 		for(int y = 0; y < BMHeight; y++) {

  00934	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _y$61290[ebp], 0
  0093b	eb 09		 jmp	 SHORT $L61291
$L61292:
  0093d	8b 45 f0	 mov	 eax, DWORD PTR _y$61290[ebp]
  00940	83 c0 01	 add	 eax, 1
  00943	89 45 f0	 mov	 DWORD PTR _y$61290[ebp], eax
$L61291:
  00946	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00949	8b 55 f0	 mov	 edx, DWORD PTR _y$61290[ebp]
  0094c	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  0094f	0f 8d c3 00 00
	00		 jge	 $L61293

; 185  :          // if this y location is in the background get the start of that 
; 186  :          // line.
; 187  : 			if (y + focus.y >= 0 && y + focus.y < BGHeight)

  00955	8b 45 f0	 mov	 eax, DWORD PTR _y$61290[ebp]
  00958	03 45 fc	 add	 eax, DWORD PTR _focus$61284[ebp+4]
  0095b	85 c0		 test	 eax, eax
  0095d	7c 2d		 jl	 SHORT $L61294
  0095f	8b 4d f0	 mov	 ecx, DWORD PTR _y$61290[ebp]
  00962	03 4d fc	 add	 ecx, DWORD PTR _focus$61284[ebp+4]
  00965	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00968	3b 4a 18	 cmp	 ecx, DWORD PTR [edx+24]
  0096b	7d 1f		 jge	 SHORT $L61294

; 188  : 				ptrBG = (uchar *)*BGData +  (y + focus.y ) * BGWidth;

  0096d	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00970	83 c1 08	 add	 ecx, 8
  00973	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  00978	8b 4d f0	 mov	 ecx, DWORD PTR _y$61290[ebp]
  0097b	03 4d fc	 add	 ecx, DWORD PTR _focus$61284[ebp+4]
  0097e	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00981	0f af 4a 14	 imul	 ecx, DWORD PTR [edx+20]
  00985	03 c1		 add	 eax, ecx
  00987	89 45 ec	 mov	 DWORD PTR _ptrBG$61289[ebp], eax

; 189  : 			else

  0098a	eb 07		 jmp	 SHORT $L61296
$L61294:

; 190  :          	ptrBG = NULL;

  0098c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _ptrBG$61289[ebp], 0
$L61296:

; 191  :          // for every pizel in this forground line
; 192  : 			for(int x = 0; x < BMWidth; x++) {

  00993	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _x$61297[ebp], 0
  0099a	eb 09		 jmp	 SHORT $L61298
$L61299:
  0099c	8b 45 e4	 mov	 eax, DWORD PTR _x$61297[ebp]
  0099f	83 c0 01	 add	 eax, 1
  009a2	89 45 e4	 mov	 DWORD PTR _x$61297[ebp], eax
$L61298:
  009a5	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  009a8	8b 55 e4	 mov	 edx, DWORD PTR _x$61297[ebp]
  009ab	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  009ae	7d 63		 jge	 SHORT $L61300

; 193  :             // if this is remap color better change it to something
; 194  : 				if (*ptrFG == remapColor) {

  009b0	8b 45 e8	 mov	 eax, DWORD PTR _ptrFG$61287[ebp]
  009b3	33 c9		 xor	 ecx, ecx
  009b5	8a 08		 mov	 cl, BYTE PTR [eax]
  009b7	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  009ba	33 c0		 xor	 eax, eax
  009bc	8a 42 40	 mov	 al, BYTE PTR [edx+64]
  009bf	3b c8		 cmp	 ecx, eax
  009c1	75 3c		 jne	 SHORT $L61304

; 195  :                // if there is a current background line and our x location
; 196  :                // is within the bound of that line get the background color
; 197  :                // else it is skip.
; 198  : 					if (ptrBG && x + focus.x >= 0 && x + focus.x < BGWidth) 

  009c3	83 7d ec 00	 cmp	 DWORD PTR _ptrBG$61289[ebp], 0
  009c7	74 2b		 je	 SHORT $L61302
  009c9	8b 4d e4	 mov	 ecx, DWORD PTR _x$61297[ebp]
  009cc	03 4d f8	 add	 ecx, DWORD PTR _focus$61284[ebp]
  009cf	85 c9		 test	 ecx, ecx
  009d1	7c 21		 jl	 SHORT $L61302
  009d3	8b 55 e4	 mov	 edx, DWORD PTR _x$61297[ebp]
  009d6	03 55 f8	 add	 edx, DWORD PTR _focus$61284[ebp]
  009d9	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  009dc	3b 50 14	 cmp	 edx, DWORD PTR [eax+20]
  009df	7d 13		 jge	 SHORT $L61302

; 199  : 						*ptrBM = *((uchar*)(ptrBG + x + focus.x));

  009e1	8b 4d ec	 mov	 ecx, DWORD PTR _ptrBG$61289[ebp]
  009e4	03 4d e4	 add	 ecx, DWORD PTR _x$61297[ebp]
  009e7	8b 55 f4	 mov	 edx, DWORD PTR _ptrBM$61285[ebp]
  009ea	8b 45 f8	 mov	 eax, DWORD PTR _focus$61284[ebp]
  009ed	8a 0c 01	 mov	 cl, BYTE PTR [ecx+eax]
  009f0	88 0a		 mov	 BYTE PTR [edx], cl

; 200  : 					else

  009f2	eb 0b		 jmp	 SHORT $L61304
$L61302:

; 201  : 						*ptrBM = skip;

  009f4	8b 55 f4	 mov	 edx, DWORD PTR _ptrBM$61285[ebp]
  009f7	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  009fa	8a 48 41	 mov	 cl, BYTE PTR [eax+65]
  009fd	88 0a		 mov	 BYTE PTR [edx], cl
$L61304:

; 204  : 				ptrBM++;

  009ff	8b 55 f4	 mov	 edx, DWORD PTR _ptrBM$61285[ebp]
  00a02	83 c2 01	 add	 edx, 1
  00a05	89 55 f4	 mov	 DWORD PTR _ptrBM$61285[ebp], edx

; 205  : 				ptrFG++;

  00a08	8b 45 e8	 mov	 eax, DWORD PTR _ptrFG$61287[ebp]
  00a0b	83 c0 01	 add	 eax, 1
  00a0e	89 45 e8	 mov	 DWORD PTR _ptrFG$61287[ebp], eax

; 206  : 			}

  00a11	eb 89		 jmp	 SHORT $L61299
$L61300:

; 207  : 		}

  00a13	e9 25 ff ff ff	 jmp	 $L61292
$L61293:

; 208  : 	} else {

  00a18	e9 8d 00 00 00	 jmp	 $L61313
$L61283:

; 209  :       // fill all remap colors with skip
; 210  : 		uchar* ptrBM = (uchar *)*BMData + CELHEADERSIZE;

  00a1d	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a20	83 c1 04	 add	 ecx, 4
  00a23	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  00a28	83 c0 2e	 add	 eax, 46			; 0000002eH
  00a2b	89 45 e0	 mov	 DWORD PTR _ptrBM$61306[ebp], eax

; 211  : 		uchar* ptrFG = (uchar *)*FGData;

  00a2e	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a31	83 c1 06	 add	 ecx, 6
  00a34	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  00a39	89 45 d8	 mov	 DWORD PTR _ptrFG$61308[ebp], eax

; 212  : 		for(int y = 0; y < BMHeight; y++) {

  00a3c	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _y$61310[ebp], 0
  00a43	eb 09		 jmp	 SHORT $L61311
$L61312:
  00a45	8b 4d dc	 mov	 ecx, DWORD PTR _y$61310[ebp]
  00a48	83 c1 01	 add	 ecx, 1
  00a4b	89 4d dc	 mov	 DWORD PTR _y$61310[ebp], ecx
$L61311:
  00a4e	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00a51	8b 45 dc	 mov	 eax, DWORD PTR _y$61310[ebp]
  00a54	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  00a57	7d 51		 jge	 SHORT $L61313

; 213  : 			for(int x = 0; x < BMWidth; x++) {

  00a59	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _x$61314[ebp], 0
  00a60	eb 09		 jmp	 SHORT $L61315
$L61316:
  00a62	8b 4d d4	 mov	 ecx, DWORD PTR _x$61314[ebp]
  00a65	83 c1 01	 add	 ecx, 1
  00a68	89 4d d4	 mov	 DWORD PTR _x$61314[ebp], ecx
$L61315:
  00a6b	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00a6e	8b 45 d4	 mov	 eax, DWORD PTR _x$61314[ebp]
  00a71	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  00a74	7d 32		 jge	 SHORT $L61317

; 214  : 				if (*ptrFG == remapColor) {

  00a76	8b 4d d8	 mov	 ecx, DWORD PTR _ptrFG$61308[ebp]
  00a79	33 d2		 xor	 edx, edx
  00a7b	8a 11		 mov	 dl, BYTE PTR [ecx]
  00a7d	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00a80	33 c9		 xor	 ecx, ecx
  00a82	8a 48 40	 mov	 cl, BYTE PTR [eax+64]
  00a85	3b d1		 cmp	 edx, ecx
  00a87	75 0b		 jne	 SHORT $L61318

; 215  : 					*ptrBM = skip;

  00a89	8b 55 e0	 mov	 edx, DWORD PTR _ptrBM$61306[ebp]
  00a8c	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00a8f	8a 48 41	 mov	 cl, BYTE PTR [eax+65]
  00a92	88 0a		 mov	 BYTE PTR [edx], cl
$L61318:

; 217  : 				ptrBM++;

  00a94	8b 55 e0	 mov	 edx, DWORD PTR _ptrBM$61306[ebp]
  00a97	83 c2 01	 add	 edx, 1
  00a9a	89 55 e0	 mov	 DWORD PTR _ptrBM$61306[ebp], edx

; 218  : 				ptrFG++;

  00a9d	8b 45 d8	 mov	 eax, DWORD PTR _ptrFG$61308[ebp]
  00aa0	83 c0 01	 add	 eax, 1
  00aa3	89 45 d8	 mov	 DWORD PTR _ptrFG$61308[ebp], eax

; 219  : 			}

  00aa6	eb ba		 jmp	 SHORT $L61316
$L61317:

; 220  : 		}

  00aa8	eb 9b		 jmp	 SHORT $L61312
$L61313:

; 222  : }

  00aaa	8b e5		 mov	 esp, ebp
  00aac	5d		 pop	 ebp
  00aad	c2 08 00	 ret	 8
?FillData@MagnifyView@@QAEXVSOL_Point@@@Z ENDP		; MagnifyView::FillData
_TEXT	ENDS
PUBLIC	?SetInsetRect@ScreenItem@@QAEXABVSOL_Rect@@@Z	; ScreenItem::SetInsetRect
PUBLIC	?Update@MagnifyView@@QAEXXZ			; MagnifyView::Update
EXTRN	?Realloc@MemID@@QBEPAXI@Z:NEAR			; MemID::Realloc
EXTRN	?UpdateScreenItem@GraphicsMgr@@QAEXPAVScreenItem@@@Z:NEAR ; GraphicsMgr::UpdateScreenItem
xdata$x	SEGMENT
$T61539	DD	019930520H
	DD	01H
	DD	FLAT:$T61541
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T61541	DD	0ffffffffH
	DD	FLAT:$L61537
xdata$x	ENDS
_TEXT	SEGMENT
$T61532 = -164
$T61533 = -168
$T61534 = -172
$T61535 = -188
$T61536 = -192
__$EHRec$ = -12
_this$ = -196
_update$ = -16
_holder$ = -20
_forground$61328 = -136
_oldSize$61329 = -56
_rect$61332 = -52
_pt$61333 = -160
_buffer$61337 = -152
_bufferFG$61340 = -36
?Update@MagnifyView@@QAEXXZ PROC NEAR			; MagnifyView::Update

; 226  : {

  00ab0	55		 push	 ebp
  00ab1	8b ec		 mov	 ebp, esp
  00ab3	6a ff		 push	 -1
  00ab5	68 00 00 00 00	 push	 $L61540
  00aba	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00ac0	50		 push	 eax
  00ac1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00ac8	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00ace	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 227  : 	Bool update = False;

  00ad4	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _update$[ebp], 0

; 228  : 
; 229  :    // if the view loop or cel has changed record the change and flag that 
; 230  : 	// work must be done
; 231  : 	int holder;
; 232  : 
; 233  : 	if((holder = id.GetIndexedProperty(actView)) != view){

  00adb	6a 03		 push	 3
  00add	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00ae3	e8 00 00 00 00	 call	 ?GetIndexedProperty@ObjectID@@QBEFH@Z ; ObjectID::GetIndexedProperty
  00ae8	0f bf c0	 movsx	 eax, ax
  00aeb	89 45 ec	 mov	 DWORD PTR _holder$[ebp], eax
  00aee	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00af4	8b 55 ec	 mov	 edx, DWORD PTR _holder$[ebp]
  00af7	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  00afa	74 13		 je	 SHORT $L61324

; 234  : 		view = holder;

  00afc	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00b02	8b 4d ec	 mov	 ecx, DWORD PTR _holder$[ebp]
  00b05	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 235  : 		update = True;

  00b08	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _update$[ebp], 1
$L61324:

; 237  : 
; 238  : 	if((holder = id.GetIndexedProperty(actLoop)) != loop){

  00b0f	6a 04		 push	 4
  00b11	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b17	e8 00 00 00 00	 call	 ?GetIndexedProperty@ObjectID@@QBEFH@Z ; ObjectID::GetIndexedProperty
  00b1c	0f bf d0	 movsx	 edx, ax
  00b1f	89 55 ec	 mov	 DWORD PTR _holder$[ebp], edx
  00b22	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00b28	8b 4d ec	 mov	 ecx, DWORD PTR _holder$[ebp]
  00b2b	3b 48 20	 cmp	 ecx, DWORD PTR [eax+32]
  00b2e	74 13		 je	 SHORT $L61325

; 239  : 		loop = holder;

  00b30	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00b36	8b 45 ec	 mov	 eax, DWORD PTR _holder$[ebp]
  00b39	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 240  : 		update = True;

  00b3c	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _update$[ebp], 1
$L61325:

; 242  : 
; 243  : 	if((holder = id.GetIndexedProperty(actCel)) != cel){

  00b43	6a 05		 push	 5
  00b45	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b4b	e8 00 00 00 00	 call	 ?GetIndexedProperty@ObjectID@@QBEFH@Z ; ObjectID::GetIndexedProperty
  00b50	0f bf c8	 movsx	 ecx, ax
  00b53	89 4d ec	 mov	 DWORD PTR _holder$[ebp], ecx
  00b56	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00b5c	8b 45 ec	 mov	 eax, DWORD PTR _holder$[ebp]
  00b5f	3b 42 24	 cmp	 eax, DWORD PTR [edx+36]
  00b62	74 13		 je	 SHORT $L61326

; 244  : 		cel = holder;

  00b64	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b6a	8b 55 ec	 mov	 edx, DWORD PTR _holder$[ebp]
  00b6d	89 51 24	 mov	 DWORD PTR [ecx+36], edx

; 245  : 		update = True;

  00b70	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _update$[ebp], 1
$L61326:

; 247  : 	 
; 248  : 	if(update) { 

  00b77	83 7d f0 00	 cmp	 DWORD PTR _update$[ebp], 0
  00b7b	0f 84 4b 03 00
	00		 je	 $L61327

; 249  :       // get the new forground
; 250  : 	   CelObjView forground(view, loop, cel);

  00b81	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00b87	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00b8a	51		 push	 ecx
  00b8b	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00b91	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00b94	50		 push	 eax
  00b95	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b9b	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00b9e	52		 push	 edx
  00b9f	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _forground$61328[ebp]
  00ba5	e8 00 00 00 00	 call	 ??0CelObjView@@QAE@HHH@Z ; CelObjView::CelObjView
  00baa	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 251  : 
; 252  :       // record old bitmap size
; 253  :       long oldSize = BMWidth * BMHeight;

  00bb1	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00bb7	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00bbd	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00bc0	0f af 51 10	 imul	 edx, DWORD PTR [ecx+16]
  00bc4	89 55 c8	 mov	 DWORD PTR _oldSize$61329[ebp], edx

; 254  : 
; 255  :       // get new cel info
; 256  : 		BMWidth = forground.Width();

  00bc7	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _forground$61328[ebp]
  00bcd	e8 00 00 00 00	 call	 ?Width@CelObj@@QBEHXZ	; CelObj::Width
  00bd2	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00bd8	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 257  : 		BMHeight = forground.Height();

  00bdb	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _forground$61328[ebp]
  00be1	e8 00 00 00 00	 call	 ?Height@CelObj@@QBEHXZ	; CelObj::Height
  00be6	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00bec	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 258  :       skip = forground.Skip();

  00bef	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _forground$61328[ebp]
  00bf5	e8 00 00 00 00	 call	 ?Skip@CelObj@@QBEEXZ	; CelObj::Skip
  00bfa	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00c00	88 41 41	 mov	 BYTE PTR [ecx+65], al

; 259  :       org.x = forground.XOrg();

  00c03	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _forground$61328[ebp]
  00c09	e8 00 00 00 00	 call	 ?XOrg@CelObj@@QBEHXZ	; CelObj::XOrg
  00c0e	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00c14	89 42 28	 mov	 DWORD PTR [edx+40], eax

; 260  :       org.y = forground.YOrg();

  00c17	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _forground$61328[ebp]
  00c1d	e8 00 00 00 00	 call	 ?YOrg@CelObj@@QBEHXZ	; CelObj::YOrg
  00c22	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00c28	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 261  : 
; 262  :       // if the data size changed get new buffers after release of old.
; 263  : 		if (oldSize != BMWidth * BMHeight) {

  00c2b	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00c31	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00c37	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00c3a	0f af 48 10	 imul	 ecx, DWORD PTR [eax+16]
  00c3e	39 4d c8	 cmp	 DWORD PTR _oldSize$61329[ebp], ecx
  00c41	74 47		 je	 SHORT $L61330

; 264  : 			// Resize the memory allocations
; 265  : 		   BMData.Realloc(BMWidth*BMHeight+CELHEADERSIZE);

  00c43	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00c49	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00c4f	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00c52	0f af 48 10	 imul	 ecx, DWORD PTR [eax+16]
  00c56	83 c1 2e	 add	 ecx, 46			; 0000002eH
  00c59	51		 push	 ecx
  00c5a	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00c60	83 c1 04	 add	 ecx, 4
  00c63	e8 00 00 00 00	 call	 ?Realloc@MemID@@QBEPAXI@Z ; MemID::Realloc

; 266  : 		   FGData.Realloc(BMWidth*BMHeight);

  00c68	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00c6e	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00c74	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00c77	0f af 48 10	 imul	 ecx, DWORD PTR [eax+16]
  00c7b	51		 push	 ecx
  00c7c	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00c82	83 c1 06	 add	 ecx, 6
  00c85	e8 00 00 00 00	 call	 ?Realloc@MemID@@QBEPAXI@Z ; MemID::Realloc
$L61330:

; 268  : 
; 269  :       // build the header
; 270  : 		BuildHeader(BMData,BMWidth,BMHeight,skip,org.x,org.y); 

  00c8a	6a 00		 push	 0
  00c8c	6a 00		 push	 0
  00c8e	68 e0 01 00 00	 push	 480			; 000001e0H
  00c93	68 80 02 00 00	 push	 640			; 00000280H
  00c98	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00c9e	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00ca1	50		 push	 eax
  00ca2	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00ca8	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00cab	52		 push	 edx
  00cac	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00cb2	33 c9		 xor	 ecx, ecx
  00cb4	8a 48 41	 mov	 cl, BYTE PTR [eax+65]
  00cb7	51		 push	 ecx
  00cb8	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00cbe	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00cc1	50		 push	 eax
  00cc2	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00cc8	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00ccb	52		 push	 edx
  00ccc	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00cd2	83 c0 04	 add	 eax, 4
  00cd5	51		 push	 ecx
  00cd6	8b cc		 mov	 ecx, esp
  00cd8	89 a5 5c ff ff
	ff		 mov	 DWORD PTR $T61532[ebp], esp
  00cde	50		 push	 eax
  00cdf	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00ce4	e8 00 00 00 00	 call	 ?BuildHeader@@YAXVMemID@@HHHHHHHHH@Z ; BuildHeader
  00ce9	83 c4 28	 add	 esp, 40			; 00000028H

; 271  : 
; 272  : 		// inset is size of data
; 273  : 		SOL_Rect rect(0,0,BMWidth - 1,BMHeight - 1);

  00cec	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00cf2	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00cf5	83 ea 01	 sub	 edx, 1
  00cf8	52		 push	 edx
  00cf9	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00cff	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00d02	83 e9 01	 sub	 ecx, 1
  00d05	51		 push	 ecx
  00d06	6a 00		 push	 0
  00d08	6a 00		 push	 0
  00d0a	8d 4d cc	 lea	 ecx, DWORD PTR _rect$61332[ebp]
  00d0d	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@HHHH@Z	; SOL_Rect::SOL_Rect

; 274  : 
; 275  : 		// draw the cel into the bitmap
; 276  : 		SOL_Point pt(0,0);

  00d12	6a 00		 push	 0
  00d14	6a 00		 push	 0
  00d16	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _pt$61333[ebp]
  00d1c	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@HH@Z	; SOL_Point::SOL_Point

; 277  : 
; 278  :       // fill background with skip of mem cels
; 279  :       memset((uchar *)*BMData + CELHEADERSIZE, skip, BMWidth*BMHeight);

  00d21	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00d27	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00d2d	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00d30	0f af 48 10	 imul	 ecx, DWORD PTR [eax+16]
  00d34	51		 push	 ecx
  00d35	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00d3b	33 c0		 xor	 eax, eax
  00d3d	8a 42 41	 mov	 al, BYTE PTR [edx+65]
  00d40	50		 push	 eax
  00d41	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00d47	83 c1 04	 add	 ecx, 4
  00d4a	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  00d4f	83 c0 2e	 add	 eax, 46			; 0000002eH
  00d52	50		 push	 eax
  00d53	e8 00 00 00 00	 call	 _memset
  00d58	83 c4 0c	 add	 esp, 12			; 0000000cH

; 280  :       memset((uchar *)*FGData, skip, BMWidth*BMHeight);

  00d5b	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00d61	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00d67	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00d6a	0f af 42 10	 imul	 eax, DWORD PTR [edx+16]
  00d6e	50		 push	 eax
  00d6f	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00d75	33 d2		 xor	 edx, edx
  00d77	8a 51 41	 mov	 dl, BYTE PTR [ecx+65]
  00d7a	52		 push	 edx
  00d7b	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00d81	83 c1 06	 add	 ecx, 6
  00d84	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  00d89	50		 push	 eax
  00d8a	e8 00 00 00 00	 call	 _memset
  00d8f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 281  : 
; 282  :       // read in new forground information to both virtual cel and forground 
; 283  :       // cel.
; 284  : 		BufferStd buffer(BMWidth, BMHeight, (uchar *)*BMData + CELHEADERSIZE);

  00d92	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00d98	83 c1 04	 add	 ecx, 4
  00d9b	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  00da0	83 c0 2e	 add	 eax, 46			; 0000002eH
  00da3	50		 push	 eax
  00da4	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00daa	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00dad	51		 push	 ecx
  00dae	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00db4	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00db7	50		 push	 eax
  00db8	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _buffer$61337[ebp]
  00dbe	e8 00 00 00 00	 call	 ??0BufferStd@@QAE@HHPAE@Z ; BufferStd::BufferStd

; 285  : 		forground.Draw(buffer,rect,pt,False);

  00dc3	6a 00		 push	 0
  00dc5	83 ec 08	 sub	 esp, 8
  00dc8	8b cc		 mov	 ecx, esp
  00dca	89 a5 58 ff ff
	ff		 mov	 DWORD PTR $T61533[ebp], esp
  00dd0	8d 95 60 ff ff
	ff		 lea	 edx, DWORD PTR _pt$61333[ebp]
  00dd6	52		 push	 edx
  00dd7	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  00ddc	8d 45 cc	 lea	 eax, DWORD PTR _rect$61332[ebp]
  00ddf	50		 push	 eax
  00de0	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _buffer$61337[ebp]
  00de6	51		 push	 ecx
  00de7	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _forground$61328[ebp]
  00ded	e8 00 00 00 00	 call	 ?Draw@CelObjView@@UAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@H@Z ; CelObjView::Draw

; 286  : 											
; 287  : 		BufferStd bufferFG(BMWidth, BMHeight, (uchar *)*FGData);

  00df2	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00df8	83 c1 06	 add	 ecx, 6
  00dfb	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  00e00	50		 push	 eax
  00e01	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00e07	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00e0a	50		 push	 eax
  00e0b	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00e11	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00e14	52		 push	 edx
  00e15	8d 4d dc	 lea	 ecx, DWORD PTR _bufferFG$61340[ebp]
  00e18	e8 00 00 00 00	 call	 ??0BufferStd@@QAE@HHPAE@Z ; BufferStd::BufferStd

; 288  : 		forground.Draw(bufferFG,rect,pt,False);

  00e1d	6a 00		 push	 0
  00e1f	83 ec 08	 sub	 esp, 8
  00e22	8b cc		 mov	 ecx, esp
  00e24	89 a5 54 ff ff
	ff		 mov	 DWORD PTR $T61534[ebp], esp
  00e2a	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _pt$61333[ebp]
  00e30	50		 push	 eax
  00e31	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  00e36	8d 4d cc	 lea	 ecx, DWORD PTR _rect$61332[ebp]
  00e39	51		 push	 ecx
  00e3a	8d 55 dc	 lea	 edx, DWORD PTR _bufferFG$61340[ebp]
  00e3d	52		 push	 edx
  00e3e	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _forground$61328[ebp]
  00e44	e8 00 00 00 00	 call	 ?Draw@CelObjView@@UAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@H@Z ; CelObjView::Draw

; 289  : 
; 290  : 		si->SetInsetRect(SOL_Rect(0,0,BMWidth - 1,BMHeight - 1));

  00e49	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00e4f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00e52	83 e9 01	 sub	 ecx, 1
  00e55	51		 push	 ecx
  00e56	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00e5c	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00e5f	83 e8 01	 sub	 eax, 1
  00e62	50		 push	 eax
  00e63	6a 00		 push	 0
  00e65	6a 00		 push	 0
  00e67	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR $T61535[ebp]
  00e6d	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@HHHH@Z	; SOL_Rect::SOL_Rect
  00e72	50		 push	 eax
  00e73	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00e79	8b 49 4c	 mov	 ecx, DWORD PTR [ecx+76]
  00e7c	e8 00 00 00 00	 call	 ?SetInsetRect@ScreenItem@@QAEXABVSOL_Rect@@@Z ; ScreenItem::SetInsetRect

; 291  : 
; 292  : 		si->pos.x =	(signed short)id.GetIndexedProperty(actX);

  00e81	6a 00		 push	 0
  00e83	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00e89	e8 00 00 00 00	 call	 ?GetIndexedProperty@ObjectID@@QBEFH@Z ; ObjectID::GetIndexedProperty
  00e8e	0f bf d0	 movsx	 edx, ax
  00e91	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00e97	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00e9a	89 11		 mov	 DWORD PTR [ecx], edx

; 293  : 		si->pos.y =	(signed short)id.GetIndexedProperty(actY);

  00e9c	6a 01		 push	 1
  00e9e	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00ea4	e8 00 00 00 00	 call	 ?GetIndexedProperty@ObjectID@@QBEFH@Z ; ObjectID::GetIndexedProperty
  00ea9	0f bf d0	 movsx	 edx, ax
  00eac	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00eb2	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00eb5	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 294  : 
; 295  : 	} else {

  00eb8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00ebf	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _forground$61328[ebp]
  00ec5	e8 00 00 00 00	 call	 ??1CelObjView@@UAE@XZ	; CelObjView::~CelObjView
  00eca	eb 37		 jmp	 SHORT $L61345
$L61327:

; 296  :       // location must be different
; 297  : 		si->pos.x = (signed short)id.GetIndexedProperty(actX);

  00ecc	6a 00		 push	 0
  00ece	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00ed4	e8 00 00 00 00	 call	 ?GetIndexedProperty@ObjectID@@QBEFH@Z ; ObjectID::GetIndexedProperty
  00ed9	0f bf d0	 movsx	 edx, ax
  00edc	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00ee2	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00ee5	89 11		 mov	 DWORD PTR [ecx], edx

; 298  : 		si->pos.y = (signed short)id.GetIndexedProperty(actY);

  00ee7	6a 01		 push	 1
  00ee9	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00eef	e8 00 00 00 00	 call	 ?GetIndexedProperty@ObjectID@@QBEFH@Z ; ObjectID::GetIndexedProperty
  00ef4	0f bf d0	 movsx	 edx, ax
  00ef7	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00efd	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00f00	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$L61345:

; 300  : 
; 301  :    // calculate new virtual cel
; 302  : 	FillData(si->pos);

  00f03	83 ec 08	 sub	 esp, 8
  00f06	8b cc		 mov	 ecx, esp
  00f08	89 a5 40 ff ff
	ff		 mov	 DWORD PTR $T61536[ebp], esp
  00f0e	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00f14	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  00f17	50		 push	 eax
  00f18	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  00f1d	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00f23	e8 00 00 00 00	 call	 ?FillData@MagnifyView@@QAEXVSOL_Point@@@Z ; MagnifyView::FillData

; 303  : 	
; 304  :    // update it
; 305  : 	graphMgr->UpdateScreenItem(si);

  00f28	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00f2e	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00f31	52		 push	 edx
  00f32	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  00f38	e8 00 00 00 00	 call	 ?UpdateScreenItem@GraphicsMgr@@QAEXPAVScreenItem@@@Z ; GraphicsMgr::UpdateScreenItem

; 306  : 
; 307  : }

  00f3d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00f40	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00f47	8b e5		 mov	 esp, ebp
  00f49	5d		 pop	 ebp
  00f4a	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L61537:
  00030	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _forground$61328[ebp]
  00036	e8 00 00 00 00	 call	 ??1CelObjView@@UAE@XZ	; CelObjView::~CelObjView
  0003b	c3		 ret	 0
$L61540:
  0003c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T61539
  00041	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?Update@MagnifyView@@QAEXXZ ENDP			; MagnifyView::Update
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0MemID@@QAE@XZ PROC NEAR				; MemID::MemID, COMDAT

; 15   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 16   : 	}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0MemID@@QAE@XZ ENDP					; MemID::MemID
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0MemID@@QAE@ABV0@@Z PROC NEAR				; MemID::MemID, COMDAT

; 19   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  0000d	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00010	66 89 10	 mov	 WORD PTR [eax], dx

; 20   : 	}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0MemID@@QAE@ABV0@@Z ENDP				; MemID::MemID
_TEXT	ENDS
EXTRN	?Free@MemoryMgr@@QAEXG@Z:NEAR			; MemoryMgr::Free
EXTRN	_memMgr:DWORD
;	COMDAT ?Free@MemID@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Free@MemID@@QAEXXZ PROC NEAR				; MemID::Free, COMDAT

; 32   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 33   : 		if (handle) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000f	85 c9		 test	 ecx, ecx
  00011	74 1a		 je	 SHORT $L54564

; 34   : 			memMgr->Free(handle);

  00013	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00016	66 8b 02	 mov	 ax, WORD PTR [edx]
  00019	50		 push	 eax
  0001a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00020	e8 00 00 00 00	 call	 ?Free@MemoryMgr@@QAEXG@Z ; MemoryMgr::Free

; 35   : 			handle = 0;

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	66 c7 01 00 00	 mov	 WORD PTR [ecx], 0
$L54564:

; 37   : 	}

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?Free@MemID@@QAEXXZ ENDP				; MemID::Free
_TEXT	ENDS
EXTRN	?Alloc@MemoryMgr@@QAEGIIIPAUMemClient@@DW4ReservedHandle@@@Z:NEAR ; MemoryMgr::Alloc
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT
_type$ = 8
_size$ = 12
_a$ = 16
_num$ = 20
_client$ = 24
_initChar$ = 28
_h$ = 32
_this$ = -4
?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z PROC NEAR ; MemID::Get, COMDAT

; 42   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 43   : 		handle = memMgr->Alloc(type | a, size, num, client, initChar, h);

  00007	8b 45 20	 mov	 eax, DWORD PTR _h$[ebp]
  0000a	50		 push	 eax
  0000b	8a 4d 1c	 mov	 cl, BYTE PTR _initChar$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 18	 mov	 edx, DWORD PTR _client$[ebp]
  00012	52		 push	 edx
  00013	8b 45 14	 mov	 eax, DWORD PTR _num$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 55 08	 mov	 edx, DWORD PTR _type$[ebp]
  0001e	0b 55 10	 or	 edx, DWORD PTR _a$[ebp]
  00021	52		 push	 edx
  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00028	e8 00 00 00 00	 call	 ?Alloc@MemoryMgr@@QAEGIIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemoryMgr::Alloc
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	66 89 01	 mov	 WORD PTR [ecx], ax

; 44   : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 1c 00	 ret	 28			; 0000001cH
?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ENDP ; MemID::Get
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4
??BMemID@@QBEGXZ PROC NEAR				; MemID::operator unsigned short, COMDAT

; 93   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   : 		return handle;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 00	 mov	 ax, WORD PTR [eax]

; 95   : 	}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??BMemID@@QBEGXZ ENDP					; MemID::operator unsigned short
_TEXT	ENDS
PUBLIC	?GetAddr@MemoryMgr@@QAEPAXG@Z			; MemoryMgr::GetAddr
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT
_this$ = -4
??DMemID@@QBEPAXXZ PROC NEAR				; MemID::operator*, COMDAT

; 98   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 99   : 		return memMgr->GetAddr(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr

; 100  : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??DMemID@@QBEPAXXZ ENDP					; MemID::operator*
_TEXT	ENDS
EXTRN	__descPtrTable:BYTE
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -4
?GetAddr@MemoryMgr@@QAEPAXG@Z PROC NEAR			; MemoryMgr::GetAddr, COMDAT

; 462  : 	inline void* MemoryMgr::GetAddr(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : //		CheckValid(theID);
; 464  : 		return _descPtrTable[(unsigned int)((unsigned short)theID)];

  00007	8b 45 08	 mov	 eax, DWORD PTR _theID$[ebp]
  0000a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0000f	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR __descPtrTable[eax*4]

; 465  : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?GetAddr@MemoryMgr@@QAEPAXG@Z ENDP			; MemoryMgr::GetAddr
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0SOL_Point@@QAE@XZ PROC NEAR				; SOL_Point::SOL_Point, COMDAT

; 20   : 	SOL_Point() : x(DefaultCoord), y(DefaultCoord) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 ef cd ab
	89		 mov	 DWORD PTR [eax], -1985229329 ; 89abcdefH
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 ef cd
	ab 89		 mov	 DWORD PTR [ecx+4], -1985229329 ; 89abcdefH
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0SOL_Point@@QAE@XZ ENDP				; SOL_Point::SOL_Point
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@HH@Z
_TEXT	SEGMENT
_x$ = 8
_y$ = 12
_this$ = -4
??0SOL_Point@@QAE@HH@Z PROC NEAR			; SOL_Point::SOL_Point, COMDAT

; 21   : 	SOL_Point(Coord x, Coord y) : x(x), y(y) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0SOL_Point@@QAE@HH@Z ENDP				; SOL_Point::SOL_Point
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@ABV0@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
??0SOL_Point@@QAE@ABV0@@Z PROC NEAR			; SOL_Point::SOL_Point, COMDAT

; 22   : 	SOL_Point(const SOL_Point& p) : x(p.x), y(p.y) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00017	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001a	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??0SOL_Point@@QAE@ABV0@@Z ENDP				; SOL_Point::SOL_Point
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@VMemID@@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0Bitmap@@QAE@VMemID@@@Z PROC NEAR			; Bitmap::Bitmap, COMDAT

; 128  : 	Bitmap(const MemID id)									{view = loop = cel = 0; type = tMem; memid = id;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 10	 add	 ecx, 16			; 00000010H
  0000d	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2
  00039	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	66 8b 55 08	 mov	 dx, WORD PTR _id$[ebp]
  00040	66 89 51 10	 mov	 WORD PTR [ecx+16], dx
  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??0Bitmap@@QAE@VMemID@@@Z ENDP				; Bitmap::Bitmap
_TEXT	ENDS
;	COMDAT ?Cel@Bitmap@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Cel@Bitmap@@QBEHXZ PROC NEAR				; Bitmap::Cel, COMDAT

; 139  : 	int	Cel() const				{return cel;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Cel@Bitmap@@QBEHXZ ENDP				; Bitmap::Cel
_TEXT	ENDS
;	COMDAT ?Handle@Bitmap@@QBE?AVMemID@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
?Handle@Bitmap@@QBE?AVMemID@@XZ PROC NEAR		; Bitmap::Handle, COMDAT

; 142  : 	MemID	Handle() const			{return memid;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 10	 add	 eax, 16			; 00000010H
  0000d	50		 push	 eax
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?Handle@Bitmap@@QBE?AVMemID@@XZ ENDP			; Bitmap::Handle
_TEXT	ENDS
;	COMDAT ?Width@CelObj@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Width@CelObj@@QBEHXZ PROC NEAR				; CelObj::Width, COMDAT

; 177  : 	int	Width() const			{return width;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Width@CelObj@@QBEHXZ ENDP				; CelObj::Width
_TEXT	ENDS
;	COMDAT ?Height@CelObj@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Height@CelObj@@QBEHXZ PROC NEAR			; CelObj::Height, COMDAT

; 178  : 	int	Height() const			{return height;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Height@CelObj@@QBEHXZ ENDP				; CelObj::Height
_TEXT	ENDS
;	COMDAT ?XOrg@CelObj@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?XOrg@CelObj@@QBEHXZ PROC NEAR				; CelObj::XOrg, COMDAT

; 179  : 	int	XOrg() const			{return xorg;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?XOrg@CelObj@@QBEHXZ ENDP				; CelObj::XOrg
_TEXT	ENDS
;	COMDAT ?YOrg@CelObj@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?YOrg@CelObj@@QBEHXZ PROC NEAR				; CelObj::YOrg, COMDAT

; 180  : 	int	YOrg() const			{return yorg;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?YOrg@CelObj@@QBEHXZ ENDP				; CelObj::YOrg
_TEXT	ENDS
;	COMDAT ?ResX@CelObj@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?ResX@CelObj@@QBEHXZ PROC NEAR				; CelObj::ResX, COMDAT

; 181  : 	int	ResX() const			{return resx;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?ResX@CelObj@@QBEHXZ ENDP				; CelObj::ResX
_TEXT	ENDS
;	COMDAT ?ResY@CelObj@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?ResY@CelObj@@QBEHXZ PROC NEAR				; CelObj::ResY, COMDAT

; 182  : 	int	ResY() const			{return resy;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?ResY@CelObj@@QBEHXZ ENDP				; CelObj::ResY
_TEXT	ENDS
;	COMDAT ?Skip@CelObj@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4
?Skip@CelObj@@QBEEXZ PROC NEAR				; CelObj::Skip, COMDAT

; 184  : 	uchar	Skip() const			{return skip;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 38	 mov	 al, BYTE PTR [eax+56]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Skip@CelObj@@QBEEXZ ENDP				; CelObj::Skip
_TEXT	ENDS
PUBLIC	??0CelObjView@@QAE@ABV0@@Z			; CelObjView::CelObjView
;	COMDAT xdata$x
; File C:\Documents and Settings\don\Desktop\sciw\Interp\celobj.hpp
xdata$x	SEGMENT
$T61569	DD	019930520H
	DD	01H
	DD	FLAT:$T61571
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T61571	DD	0ffffffffH
	DD	FLAT:$L61567
xdata$x	ENDS
;	COMDAT ?Duplicate@CelObjView@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT
$T61563 = -16
$T61564 = -20
__$EHRec$ = -12
_this$ = -24
?Duplicate@CelObjView@@UBEPAVCelObj@@XZ PROC NEAR	; CelObjView::Duplicate, COMDAT

; 294  : 	CelObj*	Duplicate() const			{return New CelObjView(*this);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 $L61570
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 10	 sub	 esp, 16			; 00000010H
  0001b	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  0001e	6a 50		 push	 80			; 00000050H
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	83 c4 04	 add	 esp, 4
  00028	89 45 ec	 mov	 DWORD PTR $T61564[ebp], eax
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	83 7d ec 00	 cmp	 DWORD PTR $T61564[ebp], 0
  00036	74 11		 je	 SHORT $L61565
  00038	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d ec	 mov	 ecx, DWORD PTR $T61564[ebp]
  0003f	e8 00 00 00 00	 call	 ??0CelObjView@@QAE@ABV0@@Z ; CelObjView::CelObjView
  00044	89 45 e4	 mov	 DWORD PTR -28+[ebp], eax
  00047	eb 07		 jmp	 SHORT $L61566
$L61565:
  00049	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR -28+[ebp], 0
$L61566:
  00050	8b 4d e4	 mov	 ecx, DWORD PTR -28+[ebp]
  00053	89 4d f0	 mov	 DWORD PTR $T61563[ebp], ecx
  00056	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0005d	8b 45 f0	 mov	 eax, DWORD PTR $T61563[ebp]
  00060	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00063	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L61567:
  00000	8b 45 ec	 mov	 eax, DWORD PTR $T61564[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
$L61570:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T61569
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?Duplicate@CelObjView@@UBEPAVCelObj@@XZ ENDP		; CelObjView::Duplicate
PUBLIC	??_7CelObjView@@6B@				; CelObjView::`vftable'
PUBLIC	??_GCelObjView@@UAEPAXI@Z			; CelObjView::`scalar deleting destructor'
PUBLIC	??_ECelObjView@@UAEPAXI@Z			; CelObjView::`vector deleting destructor'
EXTRN	??0CelObj@@QAE@ABV0@@Z:NEAR			; CelObj::CelObj
EXTRN	?ReadPix@CelObj@@UAEEHHH@Z:NEAR			; CelObj::ReadPix
EXTRN	?Draw@CelObjView@@UAEXABVBuffer@@ABVScreenItem@@ABVSOL_Rect@@H@Z:NEAR ; CelObjView::Draw
EXTRN	?ResPointer@CelObjView@@UAEPAEXZ:NEAR		; CelObjView::ResPointer
;	COMDAT ??_7CelObjView@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\celobj.hpp
CONST	SEGMENT
??_7CelObjView@@6B@ DD FLAT:??_ECelObjView@@UAEPAXI@Z	; CelObjView::`vftable'
	DD	FLAT:?Duplicate@CelObjView@@UBEPAVCelObj@@XZ
	DD	FLAT:?Draw@CelObjView@@UAEXABVBuffer@@ABVSOL_Rect@@VSOL_Point@@H@Z
	DD	FLAT:?Draw@CelObjView@@UAEXABVBuffer@@ABVScreenItem@@ABVSOL_Rect@@H@Z
	DD	FLAT:?ReadPix@CelObj@@UAEEHHH@Z
	DD	FLAT:?ResPointer@CelObjView@@UAEPAEXZ
CONST	ENDS
;	COMDAT ??0CelObjView@@QAE@ABV0@@Z
_TEXT	SEGMENT
_src$ = 8
_this$ = -4
??0CelObjView@@QAE@ABV0@@Z PROC NEAR			; CelObjView::CelObjView, COMDAT

; 293  : 	CelObjView(const CelObjView& src) : CelObj(src) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0CelObj@@QAE@ABV0@@Z	; CelObj::CelObj
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7CelObjView@@6B@ ; CelObjView::`vftable'
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0CelObjView@@QAE@ABV0@@Z ENDP				; CelObjView::CelObjView
_TEXT	ENDS
;	COMDAT ??_GCelObjView@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GCelObjView@@UAEPAXI@Z PROC NEAR			; CelObjView::`scalar deleting destructor', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CelObjView@@UAE@XZ	; CelObjView::~CelObjView
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L55878
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L55878:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCelObjView@@UAEPAXI@Z ENDP				; CelObjView::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1CelObj@@UAE@XZ				; CelObj::~CelObj
;	COMDAT ??1CelObjView@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CelObjView@@UAE@XZ PROC NEAR				; CelObjView::~CelObjView, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CelObj@@UAE@XZ	; CelObj::~CelObj
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1CelObjView@@UAE@XZ ENDP				; CelObjView::~CelObjView
_TEXT	ENDS
PUBLIC	??_7CelObj@@6B@					; CelObj::`vftable'
PUBLIC	??_GCelObj@@UAEPAXI@Z				; CelObj::`scalar deleting destructor'
PUBLIC	??_ECelObj@@UAEPAXI@Z				; CelObj::`vector deleting destructor'
EXTRN	__purecall:NEAR
;	COMDAT ??_7CelObj@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\celobj.hpp
CONST	SEGMENT
??_7CelObj@@6B@ DD FLAT:??_ECelObj@@UAEPAXI@Z		; CelObj::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?ReadPix@CelObj@@UAEEHHH@Z
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??1CelObj@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CelObj@@UAE@XZ PROC NEAR				; CelObj::~CelObj, COMDAT

; 173  : 	virtual	~CelObj()  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CelObj@@6B@ ; CelObj::`vftable'
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1CelObj@@UAE@XZ ENDP					; CelObj::~CelObj
_TEXT	ENDS
;	COMDAT ??_GCelObj@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GCelObj@@UAEPAXI@Z PROC NEAR				; CelObj::`scalar deleting destructor', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CelObj@@UAE@XZ	; CelObj::~CelObj
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L55826
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L55826:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCelObj@@UAEPAXI@Z ENDP				; CelObj::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0SOL_Rect@@QAE@XZ PROC NEAR				; SOL_Rect::SOL_Rect, COMDAT

; 13   : 	SOL_Rect()  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 08	 add	 ecx, 8
  00015	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0SOL_Rect@@QAE@XZ ENDP				; SOL_Rect::SOL_Rect
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@HHHH@Z
_TEXT	SEGMENT
_xa$ = 8
_ya$ = 12
_xb$ = 16
_yb$ = 20
_this$ = -4
??0SOL_Rect@@QAE@HHHH@Z PROC NEAR			; SOL_Rect::SOL_Rect, COMDAT

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 08	 add	 ecx, 8
  00015	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point

; 56   : 	A.x = xa;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _xa$[ebp]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 57   : 	A.y = ya;

  00022	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00025	8b 45 0c	 mov	 eax, DWORD PTR _ya$[ebp]
  00028	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 58   : 	B.x = xb;

  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8b 55 10	 mov	 edx, DWORD PTR _xb$[ebp]
  00031	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 59   : 	B.y = yb;

  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 4d 14	 mov	 ecx, DWORD PTR _yb$[ebp]
  0003a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 60   : }

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 10 00	 ret	 16			; 00000010H
??0SOL_Rect@@QAE@HHHH@Z ENDP				; SOL_Rect::SOL_Rect
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z
_TEXT	SEGMENT
_P$ = 8
_this$ = -4
?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z PROC NEAR	; SOL_Rect::Intersect, COMDAT

; 177  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 178  : 	if (P.x < A.x  ||  P.x > B.x)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _P$[ebp]
  0000d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000f	7c 0b		 jl	 SHORT $L56208
  00011	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00014	8b 45 08	 mov	 eax, DWORD PTR _P$[ebp]
  00017	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  0001a	7e 04		 jle	 SHORT $L56207
$L56208:

; 179  : 		return False;

  0001c	33 c0		 xor	 eax, eax
  0001e	eb 1f		 jmp	 SHORT $L56206
$L56207:

; 180  : 	if (P.y < A.y  ||  P.y > B.y)

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 55 0c	 mov	 edx, DWORD PTR _P$[ebp+4]
  00026	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00029	7c 0b		 jl	 SHORT $L56210
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _P$[ebp+4]
  00031	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00034	7e 04		 jle	 SHORT $L56209
$L56210:

; 181  : 		return False;

  00036	33 c0		 xor	 eax, eax
  00038	eb 05		 jmp	 SHORT $L56206
$L56209:

; 182  : 	return True;

  0003a	b8 01 00 00 00	 mov	 eax, 1
$L56206:

; 183  : }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z ENDP		; SOL_Rect::Intersect
_TEXT	ENDS
;	COMDAT ??0ScaleInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0ScaleInfo@@QAE@XZ PROC NEAR				; ScaleInfo::ScaleInfo, COMDAT

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 41   : 	scaleX = 128;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 80 00 00
	00		 mov	 DWORD PTR [eax], 128	; 00000080H

; 42   : 	scaleY = 128;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 80 00
	00 00		 mov	 DWORD PTR [ecx+4], 128	; 00000080H

; 43   : 	maxScale = 100;

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 64 00
	00 00		 mov	 DWORD PTR [edx+8], 100	; 00000064H

; 44   : 	scaleType = SCALE_OFF;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 45   : }

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??0ScaleInfo@@QAE@XZ ENDP				; ScaleInfo::ScaleInfo
_TEXT	ENDS
;	COMDAT ?Id@ScreenItem@@QBEJXZ
_TEXT	SEGMENT
_this$ = -4
?Id@ScreenItem@@QBEJXZ PROC NEAR			; ScreenItem::Id, COMDAT

; 61   : 	long			Id() const					{return id;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Id@ScreenItem@@QBEJXZ ENDP				; ScreenItem::Id
_TEXT	ENDS
;	COMDAT ?GetCel@ScreenItem@@QAEPAVCelObj@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetCel@ScreenItem@@QAEPAVCelObj@@XZ PROC NEAR		; ScreenItem::GetCel, COMDAT

; 88   : 	CelObj*		GetCel()						{return cel;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 54	 mov	 eax, DWORD PTR [eax+84]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetCel@ScreenItem@@QAEPAVCelObj@@XZ ENDP		; ScreenItem::GetCel
_TEXT	ENDS
;	COMDAT ?SetCel@ScreenItem@@QAEXPAVCelObj@@@Z
_TEXT	SEGMENT
_theCel$ = 8
$T61588 = -4
$T61589 = -8
_this$ = -12
?SetCel@ScreenItem@@QAEXPAVCelObj@@@Z PROC NEAR		; ScreenItem::SetCel, COMDAT

; 93   : 	void			SetCel(CelObj* theCel)  {delete cel; cel = theCel;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  0000f	89 4d f8	 mov	 DWORD PTR $T61589[ebp], ecx
  00012	8b 55 f8	 mov	 edx, DWORD PTR $T61589[ebp]
  00015	89 55 fc	 mov	 DWORD PTR $T61588[ebp], edx
  00018	83 7d fc 00	 cmp	 DWORD PTR $T61588[ebp], 0
  0001c	74 11		 je	 SHORT $L61590
  0001e	6a 01		 push	 1
  00020	8b 45 fc	 mov	 eax, DWORD PTR $T61588[ebp]
  00023	8b 10		 mov	 edx, DWORD PTR [eax]
  00025	8b 4d fc	 mov	 ecx, DWORD PTR $T61588[ebp]
  00028	ff 12		 call	 DWORD PTR [edx]
  0002a	89 45 f0	 mov	 DWORD PTR -16+[ebp], eax
  0002d	eb 07		 jmp	 SHORT $L61591
$L61590:
  0002f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR -16+[ebp], 0
$L61591:
  00036	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 4d 08	 mov	 ecx, DWORD PTR _theCel$[ebp]
  0003c	89 48 54	 mov	 DWORD PTR [eax+84], ecx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?SetCel@ScreenItem@@QAEXPAVCelObj@@@Z ENDP		; ScreenItem::SetCel
_TEXT	ENDS
PUBLIC	??4SOL_Rect@@QAEAAV0@ABV0@@Z			; SOL_Rect::operator=
;	COMDAT ?SetInsetRect@ScreenItem@@QAEXABVSOL_Rect@@@Z
_TEXT	SEGMENT
_r$ = 8
_this$ = -4
?SetInsetRect@ScreenItem@@QAEXABVSOL_Rect@@@Z PROC NEAR	; ScreenItem::SetInsetRect, COMDAT

; 97   : 	void			SetInsetRect(const SOL_Rect& r)		{insetRect = r; useInsetRect = True;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _r$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	81 c1 88 00 00
	00		 add	 ecx, 136		; 00000088H
  00014	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	c7 41 58 01 00
	00 00		 mov	 DWORD PTR [ecx+88], 1
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?SetInsetRect@ScreenItem@@QAEXABVSOL_Rect@@@Z ENDP	; ScreenItem::SetInsetRect
_TEXT	ENDS
PUBLIC	??4SOL_Point@@QAEAAV0@ABV0@@Z			; SOL_Point::operator=
;	COMDAT ??4SOL_Rect@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??4SOL_Rect@@QAEAAV0@ABV0@@Z PROC NEAR			; SOL_Rect::operator=, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??4SOL_Point@@QAEAAV0@ABV0@@Z ; SOL_Point::operator=
  00013	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00016	83 c1 08	 add	 ecx, 8
  00019	51		 push	 ecx
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 08	 add	 ecx, 8
  00020	e8 00 00 00 00	 call	 ??4SOL_Point@@QAEAAV0@ABV0@@Z ; SOL_Point::operator=
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??4SOL_Rect@@QAEAAV0@ABV0@@Z ENDP			; SOL_Rect::operator=
_TEXT	ENDS
;	COMDAT ??4SOL_Point@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
??4SOL_Point@@QAEAAV0@ABV0@@Z PROC NEAR			; SOL_Point::operator=, COMDAT

; 117  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 118  : 	x = p.x;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx

; 119  : 	y = p.y;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00017	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001a	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 120  : 	return *this;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 121  : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??4SOL_Point@@QAEAAV0@ABV0@@Z ENDP			; SOL_Point::operator=
_TEXT	ENDS
EXTRN	?AddScreenItem@Screen@@QAEXPAVScreenItem@@@Z:NEAR ; Screen::AddScreenItem
;	COMDAT ?AddScreenItem@GraphicsMgr@@QAEXPAVScreenItem@@@Z
_TEXT	SEGMENT
_si$ = 8
_this$ = -4
?AddScreenItem@GraphicsMgr@@QAEXPAVScreenItem@@@Z PROC NEAR ; GraphicsMgr::AddScreenItem, COMDAT

; 60   : 	void		AddScreenItem(ScreenItem* si)		{next.AddScreenItem(si);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _si$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 14	 add	 ecx, 20			; 00000014H
  00011	e8 00 00 00 00	 call	 ?AddScreenItem@Screen@@QAEXPAVScreenItem@@@Z ; Screen::AddScreenItem
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?AddScreenItem@GraphicsMgr@@QAEXPAVScreenItem@@@Z ENDP	; GraphicsMgr::AddScreenItem
_TEXT	ENDS
EXTRN	?BuildHeader@@YAXPAEHHHHHHHHH@Z:NEAR		; BuildHeader
;	COMDAT ?BuildHeader@@YAXVMemID@@HHHHHHHHH@Z
_TEXT	SEGMENT
_bm$ = 8
_width$ = 12
_height$ = 16
_skip$ = 20
_xHot$ = 24
_yHot$ = 28
_xRes$ = 32
_yRes$ = 36
_palFlag$ = 40
_remap$ = 44
?BuildHeader@@YAXVMemID@@HHHHHHHHH@Z PROC NEAR		; BuildHeader, COMDAT

; 41   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 42   : 	BuildHeader((uchar*) *bm, width, height, skip, xHot, yHot, xRes, yRes, palFlag, remap);

  00003	8b 45 2c	 mov	 eax, DWORD PTR _remap$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 28	 mov	 ecx, DWORD PTR _palFlag$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 24	 mov	 edx, DWORD PTR _yRes$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 20	 mov	 eax, DWORD PTR _xRes$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 1c	 mov	 ecx, DWORD PTR _yHot$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 18	 mov	 edx, DWORD PTR _xHot$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 14	 mov	 eax, DWORD PTR _skip$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR _height$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR _width$[ebp]
  00026	52		 push	 edx
  00027	8d 4d 08	 lea	 ecx, DWORD PTR _bm$[ebp]
  0002a	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ?BuildHeader@@YAXPAEHHHHHHHHH@Z ; BuildHeader
  00035	83 c4 28	 add	 esp, 40			; 00000028H

; 43   : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?BuildHeader@@YAXVMemID@@HHHHHHHHH@Z ENDP		; BuildHeader
_TEXT	ENDS
PUBLIC	??0FakeObjectID@@QAE@ABVMemID@@@Z		; FakeObjectID::FakeObjectID
;	COMDAT ??0ObjectID@@QAE@ABV0@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0ObjectID@@QAE@ABV0@@Z PROC NEAR			; ObjectID::ObjectID, COMDAT

; 229  : 	ObjectID(const ObjectID& id) : FakeObjectID((MemID&) id) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0FakeObjectID@@QAE@ABVMemID@@@Z ; FakeObjectID::FakeObjectID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0ObjectID@@QAE@ABV0@@Z ENDP				; ObjectID::ObjectID
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0FakeObjectID@@QAE@ABVMemID@@@Z PROC NEAR		; FakeObjectID::FakeObjectID, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0FakeObjectID@@QAE@ABVMemID@@@Z ENDP			; FakeObjectID::FakeObjectID
_TEXT	ENDS
PUBLIC	??0FakeObjectID@@QAE@G@Z			; FakeObjectID::FakeObjectID
;	COMDAT ??0ObjectID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0ObjectID@@QAE@G@Z PROC NEAR				; ObjectID::ObjectID, COMDAT

; 230  : 	ObjectID(SOL_Handle h) : FakeObjectID(h) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	66 8b 45 08	 mov	 ax, WORD PTR _h$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0FakeObjectID@@QAE@G@Z ; FakeObjectID::FakeObjectID
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0ObjectID@@QAE@G@Z ENDP				; ObjectID::ObjectID
_TEXT	ENDS
PUBLIC	??0MemID@@QAE@G@Z				; MemID::MemID
;	COMDAT ??0FakeObjectID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0FakeObjectID@@QAE@G@Z PROC NEAR			; FakeObjectID::FakeObjectID, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	66 8b 45 08	 mov	 ax, WORD PTR _h$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0FakeObjectID@@QAE@G@Z ENDP				; FakeObjectID::FakeObjectID
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0MemID@@QAE@G@Z PROC NEAR				; MemID::MemID, COMDAT

; 23   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 4d 08	 mov	 cx, WORD PTR _h$[ebp]
  0000e	66 89 08	 mov	 WORD PTR [eax], cx

; 24   : 	}

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??0MemID@@QAE@G@Z ENDP					; MemID::MemID
_TEXT	ENDS
PUBLIC	?GetIndexedProperty@Object@@QAEFH@Z		; Object::GetIndexedProperty
PUBLIC	??CFakeObjectID@@QBEPAUObject@@XZ		; FakeObjectID::operator->
PUBLIC	?AssureValid@ObjectID@@QBEXXZ			; ObjectID::AssureValid
;	COMDAT ?GetIndexedProperty@ObjectID@@QBEFH@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
?GetIndexedProperty@ObjectID@@QBEFH@Z PROC NEAR		; ObjectID::GetIndexedProperty, COMDAT

; 266  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 267  : 		//	get a property given an index in the property offsets table
; 268  : 		AssureValid();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?AssureValid@ObjectID@@QBEXXZ ; ObjectID::AssureValid

; 269  : 		return (*this)->GetIndexedProperty(index);

  0000f	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00012	50		 push	 eax
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  0001b	8b c8		 mov	 ecx, eax
  0001d	e8 00 00 00 00	 call	 ?GetIndexedProperty@Object@@QAEFH@Z ; Object::GetIndexedProperty

; 270  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?GetIndexedProperty@ObjectID@@QBEFH@Z ENDP		; ObjectID::GetIndexedProperty
_TEXT	ENDS
PUBLIC	?GetIndexedPropAddr@Object@@QAEPBFH@Z		; Object::GetIndexedPropAddr
;	COMDAT ?GetIndexedProperty@Object@@QAEFH@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
?GetIndexedProperty@Object@@QAEFH@Z PROC NEAR		; Object::GetIndexedProperty, COMDAT

; 146  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 147  : 		//	get a property given an index in the property offsets table
; 148  : 		return *GetIndexedPropAddr(index);

  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?GetIndexedPropAddr@Object@@QAEPBFH@Z ; Object::GetIndexedPropAddr
  00013	66 8b 00	 mov	 ax, WORD PTR [eax]

; 149  : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?GetIndexedProperty@Object@@QAEFH@Z ENDP		; Object::GetIndexedProperty
_TEXT	ENDS
PUBLIC	??AObject@@QAEAAFH@Z				; Object::operator[]
EXTRN	?indexedPropertyOffsets@@3PAIA:BYTE		; indexedPropertyOffsets
;	COMDAT ?GetIndexedPropAddr@Object@@QAEPBFH@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
?GetIndexedPropAddr@Object@@QAEPBFH@Z PROC NEAR		; Object::GetIndexedPropAddr, COMDAT

; 138  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 139  : 		//	get a property address given an index into the property offsets table
; 140  : 		extern size_t indexedPropertyOffsets[];
; 141  : 		return &(*this)[indexedPropertyOffsets[index]];

  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?indexedPropertyOffsets@@3PAIA[eax*4]
  00011	51		 push	 ecx
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??AObject@@QAEAAFH@Z	; Object::operator[]

; 142  : 	}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?GetIndexedPropAddr@Object@@QAEPBFH@Z ENDP		; Object::GetIndexedPropAddr
_TEXT	ENDS
;	COMDAT ??AObject@@QAEAAFH@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
??AObject@@QAEAAFH@Z PROC NEAR				; Object::operator[], COMDAT

; 117  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 118  : 		//	get a reference to a property given the number of the property
; 119  : 		return ((Property*) this)[index];

  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]

; 120  : 	}

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??AObject@@QAEAAFH@Z ENDP				; Object::operator[]
_TEXT	ENDS
;	COMDAT ??CFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT
_this$ = -4
??CFakeObjectID@@QBEPAUObject@@XZ PROC NEAR		; FakeObjectID::operator->, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??CFakeObjectID@@QBEPAUObject@@XZ ENDP			; FakeObjectID::operator->
_TEXT	ENDS
PUBLIC	?IsObject@ObjectID@@QBEHXZ			; ObjectID::IsObject
EXTRN	?Fatal@MsgMgr@@QAAXHZZ:NEAR			; MsgMgr::Fatal
EXTRN	?msgMgr@@3PAVMsgMgr@@A:DWORD			; msgMgr
;	COMDAT ?AssureValid@ObjectID@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4
?AssureValid@ObjectID@@QBEXXZ PROC NEAR			; ObjectID::AssureValid, COMDAT

; 238  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 239  : 		if (!IsObject())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?IsObject@ObjectID@@QBEHXZ ; ObjectID::IsObject
  0000f	85 c0		 test	 eax, eax
  00011	75 1e		 jne	 SHORT $L61022

; 240  : 			msgMgr->Fatal(Msg_NotObject, (int) *this);

  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  0001b	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00020	50		 push	 eax
  00021	6a 2f		 push	 47			; 0000002fH
  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXHZZ	; MsgMgr::Fatal
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L61022:

; 241  : 	}

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?AssureValid@ObjectID@@QBEXXZ ENDP			; ObjectID::AssureValid
_TEXT	ENDS
PUBLIC	?IsValid@MemID@@QBEHXZ				; MemID::IsValid
EXTRN	?GetMemType@MemID@@QBE?AW4MemType@@XZ:NEAR	; MemID::GetMemType
;	COMDAT ?IsObject@ObjectID@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsObject@ObjectID@@QBEHXZ PROC NEAR			; ObjectID::IsObject, COMDAT

; 247  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 248  : 		return IsValid() && GetMemType() == MemObject;

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  00011	85 c0		 test	 eax, eax
  00013	74 16		 je	 SHORT $L61609
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  0001d	83 f8 34	 cmp	 eax, 52			; 00000034H
  00020	75 09		 jne	 SHORT $L61609
  00022	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR -8+[ebp], 1
  00029	eb 07		 jmp	 SHORT $L61610
$L61609:
  0002b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], 0
$L61610:
  00032	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]

; 249  : 	}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?IsObject@ObjectID@@QBEHXZ ENDP				; ObjectID::IsObject
_TEXT	ENDS
PUBLIC	?IsValid@MemoryMgr@@QAEHG@Z			; MemoryMgr::IsValid
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsValid@MemID@@QBEHXZ PROC NEAR			; MemID::IsValid, COMDAT

; 62   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 63   : 		return memMgr->IsValid(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?IsValid@MemoryMgr@@QAEHG@Z ; MemoryMgr::IsValid

; 64   : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?IsValid@MemID@@QBEHXZ ENDP				; MemID::IsValid
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -8
_tempID$ = -4
?IsValid@MemoryMgr@@QAEHG@Z PROC NEAR			; MemoryMgr::IsValid, COMDAT

; 475  : 	inline Bool MemoryMgr::IsValid(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 476  : 		unsigned short tempID = (unsigned short)theID;

  00009	66 8b 45 08	 mov	 ax, WORD PTR _theID$[ebp]
  0000d	66 89 45 fc	 mov	 WORD PTR _tempID$[ebp], ax

; 477  : 
; 478  : 		return(
; 479  : 				(tempID)															&&
; 480  : 				(tempID < maxDescriptors)									&&
; 481  : 				(desc[tempID].memInfo.bits.freeDescriptor == False)	&&
; 482  : 				(desc[tempID].memInfo.bits.freeMemory == False)
; 483  : 				);

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _tempID$[ebp]
  00014	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 58		 je	 SHORT $L61613
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _tempID$[ebp]
  00021	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  0002d	73 47		 jae	 SHORT $L61613
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _tempID$[ebp]
  00032	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00038	c1 e1 04	 shl	 ecx, 4
  0003b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00041	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00044	c1 e1 0e	 shl	 ecx, 14			; 0000000eH
  00047	c1 f9 1f	 sar	 ecx, 31			; 0000001fH
  0004a	85 c9		 test	 ecx, ecx
  0004c	75 28		 jne	 SHORT $L61613
  0004e	8b 55 fc	 mov	 edx, DWORD PTR _tempID$[ebp]
  00051	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00057	c1 e2 04	 shl	 edx, 4
  0005a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00060	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00063	c1 e2 14	 shl	 edx, 20			; 00000014H
  00066	c1 fa 1f	 sar	 edx, 31			; 0000001fH
  00069	85 d2		 test	 edx, edx
  0006b	75 09		 jne	 SHORT $L61613
  0006d	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR -12+[ebp], 1
  00074	eb 07		 jmp	 SHORT $L61614
$L61613:
  00076	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR -12+[ebp], 0
$L61614:
  0007d	8b 45 f4	 mov	 eax, DWORD PTR -12+[ebp]

; 484  : 	}

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 04 00	 ret	 4
?IsValid@MemoryMgr@@QAEHG@Z ENDP			; MemoryMgr::IsValid
_TEXT	ENDS
PUBLIC	?GetProperty@Object@@QAEFG@Z			; Object::GetProperty
;	COMDAT ?GetProperty@ObjectID@@QBEFG@Z
_TEXT	SEGMENT
_selector$ = 8
_this$ = -4
?GetProperty@ObjectID@@QBEFG@Z PROC NEAR		; ObjectID::GetProperty, COMDAT

; 290  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 291  : 		//	get a property given a selector
; 292  : 		AssureValid();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?AssureValid@ObjectID@@QBEXXZ ; ObjectID::AssureValid

; 293  : 		return (*this)->GetProperty(selector);

  0000f	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  00013	50		 push	 eax
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  0001c	8b c8		 mov	 ecx, eax
  0001e	e8 00 00 00 00	 call	 ?GetProperty@Object@@QAEFG@Z ; Object::GetProperty

; 294  : 	}

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?GetProperty@ObjectID@@QBEFG@Z ENDP			; ObjectID::GetProperty
_TEXT	ENDS
PUBLIC	?GetPropAddrCheck@Object@@QAEPAFG@Z		; Object::GetPropAddrCheck
;	COMDAT ?GetProperty@Object@@QAEFG@Z
_TEXT	SEGMENT
_selector$ = 8
_this$ = -4
?GetProperty@Object@@QAEFG@Z PROC NEAR			; Object::GetProperty, COMDAT

; 170  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 171  : 		//	get a property given a selector
; 172  : 		return *GetPropAddrCheck(selector);

  00007	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?GetPropAddrCheck@Object@@QAEPAFG@Z ; Object::GetPropAddrCheck
  00014	66 8b 00	 mov	 ax, WORD PTR [eax]

; 173  : 	}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?GetProperty@Object@@QAEFG@Z ENDP			; Object::GetProperty
_TEXT	ENDS
PUBLIC	?GetPropAddr@Object@@QAEPAFG@Z			; Object::GetPropAddr
;	COMDAT ?GetPropAddrCheck@Object@@QAEPAFG@Z
_TEXT	SEGMENT
_selector$ = 8
_this$ = -8
_property$ = -4
?GetPropAddrCheck@Object@@QAEPAFG@Z PROC NEAR		; Object::GetPropAddrCheck, COMDAT

; 153  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 154  : 		//	get a property's address, checking for valid property
; 155  : 		Property* property = GetPropAddr(selector);

  00009	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?GetPropAddr@Object@@QAEPAFG@Z ; Object::GetPropAddr
  00016	89 45 fc	 mov	 DWORD PTR _property$[ebp], eax

; 156  : 		if (!property)

  00019	83 7d fc 00	 cmp	 DWORD PTR _property$[ebp], 0
  0001d	75 1b		 jne	 SHORT $L60863

; 157  : 			msgMgr->Fatal(Msg_InvalidProperty, selector);

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _selector$[ebp]
  00022	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00028	51		 push	 ecx
  00029	6a 29		 push	 41			; 00000029H
  0002b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXHZZ	; MsgMgr::Fatal
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
$L60863:

; 158  : 		return property;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _property$[ebp]

; 159  : 	}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
?GetPropAddrCheck@Object@@QAEPAFG@Z ENDP		; Object::GetPropAddrCheck
_TEXT	ENDS
PUBLIC	?selectorDict@Object@@QAEPAVSelectorDict@@XZ	; Object::selectorDict
EXTRN	?get@SelectorDict@@QAEHG@Z:NEAR			; SelectorDict::get
;	COMDAT ?GetPropAddr@Object@@QAEPAFG@Z
_TEXT	SEGMENT
_selector$ = 8
_this$ = -8
_index$ = -4
?GetPropAddr@Object@@QAEPAFG@Z PROC NEAR		; Object::GetPropAddr, COMDAT

; 127  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 128  : 		int index = selectorDict()->get ( selector );

  00009	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?selectorDict@Object@@QAEPAVSelectorDict@@XZ ; Object::selectorDict
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 ?get@SelectorDict@@QAEHG@Z ; SelectorDict::get
  0001d	89 45 fc	 mov	 DWORD PTR _index$[ebp], eax

; 129  : 
; 130  : 		if ( index != -1 && !selectorDict()->script )

  00020	83 7d fc ff	 cmp	 DWORD PTR _index$[ebp], -1
  00024	74 2b		 je	 SHORT $L60854
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?selectorDict@Object@@QAEPAVSelectorDict@@XZ ; Object::selectorDict
  0002e	33 c9		 xor	 ecx, ecx
  00030	66 8b 48 16	 mov	 cx, WORD PTR [eax+22]
  00034	85 c9		 test	 ecx, ecx
  00036	75 19		 jne	 SHORT $L60854

; 131  : 			return &(*this)[selectorDict()->offset]; 

  00038	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?selectorDict@Object@@QAEPAVSelectorDict@@XZ ; Object::selectorDict
  00040	33 d2		 xor	 edx, edx
  00042	66 8b 50 14	 mov	 dx, WORD PTR [eax+20]
  00046	52		 push	 edx
  00047	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ??AObject@@QAEAAFH@Z	; Object::operator[]
  0004f	eb 02		 jmp	 SHORT $L60852
$L60854:

; 132  : 
; 133  : 		return 0;

  00051	33 c0		 xor	 eax, eax
$L60852:

; 134  : 	}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
?GetPropAddr@Object@@QAEPAFG@Z ENDP			; Object::GetPropAddr
_TEXT	ENDS
;	COMDAT ?selectorDict@Object@@QAEPAVSelectorDict@@XZ
_TEXT	SEGMENT
_this$ = -4
?selectorDict@Object@@QAEPAVSelectorDict@@XZ PROC NEAR	; Object::selectorDict, COMDAT

; 102  : 	SelectorDict *selectorDict ( void ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 103  : 		return _selectorDict;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 104  : 	};

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?selectorDict@Object@@QAEPAVSelectorDict@@XZ ENDP	; Object::selectorDict
_TEXT	ENDS
END
