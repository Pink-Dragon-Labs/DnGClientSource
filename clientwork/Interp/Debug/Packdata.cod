	TITLE	C:\Documents and Settings\don\Desktop\sciw\Interp\Packdata.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MemoryMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckValid@MemoryMgr@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GMemoryMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@V1@III@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AMemID@@QBEAADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8MemID@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??7MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeArrayID@@QBEPAUArrayHeader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ArrayID@@QAE@HW4ArrayType@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@ArrayID@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAE?AVMemID@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAEXVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_List@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@SOL_List@@QAEAAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeDispatchTblID@@QBEPAUDispatchTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeScriptEntryID@@QBEPAUScriptEntry@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntry@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeVariableID@@QBEPAUVariable@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Script@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Object@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGraphicsUpdate@Object@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?selectorDict@Object@@QAEPAVSelectorDict@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AObject@@QAEAAFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddr@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedPropAddr@Object@@QAEPBFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedProperty@Object@@QAEFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddrCheck@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@Object@@QAEFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropOffset@Object@@QAEIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetIndexedProperty@Object@@QAEXHF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetProperty@Object@@QAEXGF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssureValid@ObjectID@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsObject@ObjectID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedProperty@ObjectID@@QBEFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@ObjectID@@QBEFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetIndexedProperty@ObjectID@@QBEXHF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetProperty@ObjectID@@QBEXGF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeClassTblID@@QBEPAUClassTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DTextID@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@TextID@@QAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TextID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GPackedData@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7MemoryMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7PackedData@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	??0ObjectID@@QAE@ABV0@@Z			; ObjectID::ObjectID
PUBLIC	??0ObjectID@@QAE@G@Z				; ObjectID::ObjectID
PUBLIC	?IsObject@ObjectID@@QBEHXZ			; ObjectID::IsObject
PUBLIC	?GetIndexedProperty@ObjectID@@QBEFH@Z		; ObjectID::GetIndexedProperty
PUBLIC	?SetIndexedProperty@ObjectID@@QBEXHF@Z		; ObjectID::SetIndexedProperty
PUBLIC	??BMemID@@QBEGXZ				; MemID::operator unsigned short
PUBLIC	??DTextID@@QAEPADXZ				; TextID::operator*
PUBLIC	??0TextID@@QAE@ABV0@@Z				; TextID::TextID
PUBLIC	??0PackedData@@QAE@VObjectID@@@Z		; PackedData::PackedData
PUBLIC	??1PackedData@@UAE@XZ				; PackedData::~PackedData
PUBLIC	?getBits@PackedData@@QAEHH@Z			; PackedData::getBits
PUBLIC	?putBits@PackedData@@QAEXHH@Z			; PackedData::putBits
PUBLIC	?getByte@PackedData@@QAEEXZ			; PackedData::getByte
PUBLIC	?putByte@PackedData@@QAEXE@Z			; PackedData::putByte
PUBLIC	?getWord@PackedData@@QAEFXZ			; PackedData::getWord
PUBLIC	?putWord@PackedData@@QAEXF@Z			; PackedData::putWord
PUBLIC	?getLong@PackedData@@QAEHXZ			; PackedData::getLong
PUBLIC	?putLong@PackedData@@QAEXH@Z			; PackedData::putLong
PUBLIC	?getString@PackedData@@QAE?AVTextID@@H@Z	; PackedData::getString
PUBLIC	?putString@PackedData@@QAEXPADH@Z		; PackedData::putString
PUBLIC	?putArray@PackedData@@QAEXPAXH@Z		; PackedData::putArray
PUBLIC	?KPackData@@YAXPAF@Z				; KPackData
EXTRN	?pm@@3VPMachine@@A:BYTE				; pm
EXTRN	??0TextID@@QAE@G@Z:NEAR				; TextID::TextID
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	?Fatal@MsgMgr@@QAAXPADZZ:NEAR			; MsgMgr::Fatal
EXTRN	?msgMgr@@3PAVMsgMgr@@A:DWORD			; msgMgr
_DATA	SEGMENT
$SG58491 DB	'Invalid object passed to KPackData (0x%x)', 00H
	ORG $+2
$SG58497 DB	'Invalid object passed to KPackData (0x%x)', 00H
_DATA	ENDS
xdata$x	SEGMENT
$T58821	DD	019930520H
	DD	0bH
	DD	FLAT:$T58825
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T58825	DD	0ffffffffH
	DD	FLAT:$L58807
	DD	0ffffffffH
	DD	FLAT:$L58808
	DD	0ffffffffH
	DD	FLAT:$L58809
	DD	0ffffffffH
	DD	FLAT:$L58810
	DD	0ffffffffH
	DD	FLAT:$L58811
	DD	0ffffffffH
	DD	FLAT:$L58812
	DD	0ffffffffH
	DD	FLAT:$L58813
	DD	0ffffffffH
	DD	FLAT:$L58814
	DD	0ffffffffH
	DD	FLAT:$L58815
	DD	0ffffffffH
	DD	FLAT:$L58816
	DD	0ffffffffH
	DD	FLAT:$L58817
xdata$x	ENDS
_TEXT	SEGMENT
_args$ = 8
_data$58454 = -20
_data$58459 = -28
_data$58464 = -36
_data$58469 = -44
_data$58474 = -52
_data$58479 = -60
_data$58484 = -72
_val$58486 = -64
_longID$58487 = -76
_longID$58493 = -92
_objValue$58498 = -88
_data$58503 = -84
_data$58508 = -100
_text$58510 = -104
_data$58515 = -112
_data$58522 = -120
$T58780 = -124
$T58781 = -128
$T58782 = -132
$T58783 = -136
$T58784 = -140
$T58785 = -144
$T58786 = -148
$T58787 = -152
$T58788 = -156
$T58789 = -160
$T58790 = -164
$T58791 = -168
$T58792 = -172
$T58793 = -176
$T58794 = -180
$T58795 = -184
$T58796 = -188
$T58797 = -192
$T58798 = -196
$T58799 = -200
$T58800 = -204
$T58801 = -208
$T58802 = -212
$T58803 = -216
$T58804 = -220
$T58805 = -224
$T58806 = -228
__$EHRec$ = -12
?KPackData@@YAXPAF@Z PROC NEAR				; KPackData

; 20   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 $L58822
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  0001e	56		 push	 esi

; 21   : 	enum {
; 22   : 		_PACK_GET_BITS,
; 23   : 		_PACK_PUT_BITS,
; 24   : 		_PACK_GET_BYTE,
; 25   : 		_PACK_PUT_BYTE,
; 26   : 		_PACK_GET_WORD,
; 27   : 		_PACK_PUT_WORD,
; 28   : 		_PACK_GET_LONG,
; 29   : 		_PACK_PUT_LONG,
; 30   : 		_PACK_GET_STRING,
; 31   : 		_PACK_PUT_STRING,
; 32   : 		_PACK_PUT_ARRAY,
; 33   : 	};
; 34   : 
; 35   : 	pm.acc = 0;

  0001f	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, 0

; 36   : 
; 37   : 	switch ( arg(1) ) {

  00029	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  0002c	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00030	89 8d 18 ff ff
	ff		 mov	 DWORD PTR -232+[ebp], ecx
  00036	83 bd 18 ff ff
	ff 0a		 cmp	 DWORD PTR -232+[ebp], 10 ; 0000000aH
  0003d	0f 87 d4 04 00
	00		 ja	 $L58448
  00043	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR -232+[ebp]
  00049	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L58824[edx*4]
$L58451:

; 39   : 			PackedData data ( (ObjectID)arg(2) );

  00050	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00053	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  00057	51		 push	 ecx
  00058	8d 4d 80	 lea	 ecx, DWORD PTR $T58781[ebp]
  0005b	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  00060	51		 push	 ecx
  00061	8b cc		 mov	 ecx, esp
  00063	89 65 84	 mov	 DWORD PTR $T58780[ebp], esp
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID
  0006c	8d 4d ec	 lea	 ecx, DWORD PTR _data$58454[ebp]
  0006f	e8 00 00 00 00	 call	 ??0PackedData@@QAE@VObjectID@@@Z ; PackedData::PackedData
  00074	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 40   : 			pm.acc = data.getBits ( arg(3) );

  0007b	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  0007e	0f bf 42 06	 movsx	 eax, WORD PTR [edx+6]
  00082	50		 push	 eax
  00083	8d 4d ec	 lea	 ecx, DWORD PTR _data$58454[ebp]
  00086	e8 00 00 00 00	 call	 ?getBits@PackedData@@QAEHH@Z ; PackedData::getBits
  0008b	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 41   : 		}

  00090	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00097	8d 4d ec	 lea	 ecx, DWORD PTR _data$58454[ebp]
  0009a	e8 00 00 00 00	 call	 ??1PackedData@@UAE@XZ	; PackedData::~PackedData

; 42   : 
; 43   : 		break;

  0009f	e9 73 04 00 00	 jmp	 $L58448
$L58456:

; 46   : 			PackedData data ( (ObjectID)arg(2) );

  000a4	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  000a7	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  000ab	52		 push	 edx
  000ac	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T58783[ebp]
  000b2	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  000b7	51		 push	 ecx
  000b8	8b cc		 mov	 ecx, esp
  000ba	89 a5 7c ff ff
	ff		 mov	 DWORD PTR $T58782[ebp], esp
  000c0	50		 push	 eax
  000c1	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID
  000c6	8d 4d e4	 lea	 ecx, DWORD PTR _data$58459[ebp]
  000c9	e8 00 00 00 00	 call	 ??0PackedData@@QAE@VObjectID@@@Z ; PackedData::PackedData
  000ce	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 47   : 			data.putBits ( arg(3), arg(4) );

  000d5	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  000d8	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  000dc	51		 push	 ecx
  000dd	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  000e0	0f bf 42 06	 movsx	 eax, WORD PTR [edx+6]
  000e4	50		 push	 eax
  000e5	8d 4d e4	 lea	 ecx, DWORD PTR _data$58459[ebp]
  000e8	e8 00 00 00 00	 call	 ?putBits@PackedData@@QAEXHH@Z ; PackedData::putBits

; 48   : 		}

  000ed	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000f4	8d 4d e4	 lea	 ecx, DWORD PTR _data$58459[ebp]
  000f7	e8 00 00 00 00	 call	 ??1PackedData@@UAE@XZ	; PackedData::~PackedData

; 49   : 
; 50   : 		break;

  000fc	e9 16 04 00 00	 jmp	 $L58448
$L58461:

; 53   : 			PackedData data ( (ObjectID)arg(2) );

  00101	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00104	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  00108	52		 push	 edx
  00109	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T58785[ebp]
  0010f	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  00114	51		 push	 ecx
  00115	8b cc		 mov	 ecx, esp
  00117	89 a5 74 ff ff
	ff		 mov	 DWORD PTR $T58784[ebp], esp
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID
  00123	8d 4d dc	 lea	 ecx, DWORD PTR _data$58464[ebp]
  00126	e8 00 00 00 00	 call	 ??0PackedData@@QAE@VObjectID@@@Z ; PackedData::PackedData
  0012b	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2

; 54   : 			pm.acc = data.getByte();

  00132	8d 4d dc	 lea	 ecx, DWORD PTR _data$58464[ebp]
  00135	e8 00 00 00 00	 call	 ?getByte@PackedData@@QAEEXZ ; PackedData::getByte
  0013a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0013f	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 55   : 		}

  00144	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0014b	8d 4d dc	 lea	 ecx, DWORD PTR _data$58464[ebp]
  0014e	e8 00 00 00 00	 call	 ??1PackedData@@UAE@XZ	; PackedData::~PackedData

; 56   : 
; 57   : 		break;

  00153	e9 bf 03 00 00	 jmp	 $L58448
$L58466:

; 60   : 			PackedData data ( (ObjectID)arg(2) );

  00158	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  0015b	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  0015f	51		 push	 ecx
  00160	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR $T58787[ebp]
  00166	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  0016b	51		 push	 ecx
  0016c	8b cc		 mov	 ecx, esp
  0016e	89 a5 6c ff ff
	ff		 mov	 DWORD PTR $T58786[ebp], esp
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID
  0017a	8d 4d d4	 lea	 ecx, DWORD PTR _data$58469[ebp]
  0017d	e8 00 00 00 00	 call	 ??0PackedData@@QAE@VObjectID@@@Z ; PackedData::PackedData
  00182	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3

; 61   : 			data.putByte ( arg(3) );

  00189	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  0018c	8a 42 06	 mov	 al, BYTE PTR [edx+6]
  0018f	50		 push	 eax
  00190	8d 4d d4	 lea	 ecx, DWORD PTR _data$58469[ebp]
  00193	e8 00 00 00 00	 call	 ?putByte@PackedData@@QAEXE@Z ; PackedData::putByte

; 62   : 		}

  00198	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0019f	8d 4d d4	 lea	 ecx, DWORD PTR _data$58469[ebp]
  001a2	e8 00 00 00 00	 call	 ??1PackedData@@UAE@XZ	; PackedData::~PackedData

; 63   : 
; 64   : 		break;

  001a7	e9 6b 03 00 00	 jmp	 $L58448
$L58471:

; 67   : 			PackedData data ( (ObjectID)arg(2) );

  001ac	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  001af	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  001b3	52		 push	 edx
  001b4	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR $T58789[ebp]
  001ba	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  001bf	51		 push	 ecx
  001c0	8b cc		 mov	 ecx, esp
  001c2	89 a5 64 ff ff
	ff		 mov	 DWORD PTR $T58788[ebp], esp
  001c8	50		 push	 eax
  001c9	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID
  001ce	8d 4d cc	 lea	 ecx, DWORD PTR _data$58474[ebp]
  001d1	e8 00 00 00 00	 call	 ??0PackedData@@QAE@VObjectID@@@Z ; PackedData::PackedData
  001d6	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4

; 68   : 			pm.acc = data.getWord();

  001dd	8d 4d cc	 lea	 ecx, DWORD PTR _data$58474[ebp]
  001e0	e8 00 00 00 00	 call	 ?getWord@PackedData@@QAEFXZ ; PackedData::getWord
  001e5	0f bf c0	 movsx	 eax, ax
  001e8	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 69   : 		}

  001ed	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001f4	8d 4d cc	 lea	 ecx, DWORD PTR _data$58474[ebp]
  001f7	e8 00 00 00 00	 call	 ??1PackedData@@UAE@XZ	; PackedData::~PackedData

; 70   : 
; 71   : 		break;

  001fc	e9 16 03 00 00	 jmp	 $L58448
$L58476:

; 74   : 			PackedData data ( (ObjectID)arg(2) );

  00201	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00204	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  00208	52		 push	 edx
  00209	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR $T58791[ebp]
  0020f	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  00214	51		 push	 ecx
  00215	8b cc		 mov	 ecx, esp
  00217	89 a5 5c ff ff
	ff		 mov	 DWORD PTR $T58790[ebp], esp
  0021d	50		 push	 eax
  0021e	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID
  00223	8d 4d c4	 lea	 ecx, DWORD PTR _data$58479[ebp]
  00226	e8 00 00 00 00	 call	 ??0PackedData@@QAE@VObjectID@@@Z ; PackedData::PackedData
  0022b	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5

; 75   : 			data.putWord ( arg(3) );

  00232	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00235	66 8b 48 06	 mov	 cx, WORD PTR [eax+6]
  00239	51		 push	 ecx
  0023a	8d 4d c4	 lea	 ecx, DWORD PTR _data$58479[ebp]
  0023d	e8 00 00 00 00	 call	 ?putWord@PackedData@@QAEXF@Z ; PackedData::putWord

; 76   : 		}

  00242	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00249	8d 4d c4	 lea	 ecx, DWORD PTR _data$58479[ebp]
  0024c	e8 00 00 00 00	 call	 ??1PackedData@@UAE@XZ	; PackedData::~PackedData

; 77   : 
; 78   : 		break;

  00251	e9 c1 02 00 00	 jmp	 $L58448
$L58481:

; 81   : 			PackedData data ( (ObjectID)arg(2) );

  00256	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00259	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  0025d	50		 push	 eax
  0025e	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR $T58793[ebp]
  00264	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  00269	51		 push	 ecx
  0026a	8b cc		 mov	 ecx, esp
  0026c	89 a5 54 ff ff
	ff		 mov	 DWORD PTR $T58792[ebp], esp
  00272	50		 push	 eax
  00273	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID
  00278	8d 4d b8	 lea	 ecx, DWORD PTR _data$58484[ebp]
  0027b	e8 00 00 00 00	 call	 ??0PackedData@@QAE@VObjectID@@@Z ; PackedData::PackedData
  00280	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 6

; 82   : 			
; 83   : 			int val = data.getLong();

  00287	8d 4d b8	 lea	 ecx, DWORD PTR _data$58484[ebp]
  0028a	e8 00 00 00 00	 call	 ?getLong@PackedData@@QAEHXZ ; PackedData::getLong
  0028f	89 45 c0	 mov	 DWORD PTR _val$58486[ebp], eax

; 84   : 
; 85   : 			ObjectID longID = (ObjectID)arg ( 3 );

  00292	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00295	66 8b 51 06	 mov	 dx, WORD PTR [ecx+6]
  00299	52		 push	 edx
  0029a	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR $T58794[ebp]
  002a0	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  002a5	50		 push	 eax
  002a6	8d 4d b4	 lea	 ecx, DWORD PTR _longID$58487[ebp]
  002a9	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID

; 86   : 
; 87   : 			// validate the object
; 88   : 			if ( !longID.IsObject() )

  002ae	8d 4d b4	 lea	 ecx, DWORD PTR _longID$58487[ebp]
  002b1	e8 00 00 00 00	 call	 ?IsObject@ObjectID@@QBEHXZ ; ObjectID::IsObject
  002b6	85 c0		 test	 eax, eax
  002b8	75 19		 jne	 SHORT $L58490

; 89   : 				msgMgr->Fatal ( "Invalid object passed to KPackData (0x%x)", longID );

  002ba	66 8b 45 b4	 mov	 ax, WORD PTR _longID$58487[ebp]
  002be	50		 push	 eax
  002bf	68 00 00 00 00	 push	 OFFSET FLAT:$SG58491
  002c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  002ca	51		 push	 ecx
  002cb	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  002d0	83 c4 0c	 add	 esp, 12			; 0000000cH
$L58490:

; 90   : 
; 91   : 			longID.SetIndexedProperty ( longLowWord, val & 0x0000ffff );

  002d3	8b 55 c0	 mov	 edx, DWORD PTR _val$58486[ebp]
  002d6	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  002dc	52		 push	 edx
  002dd	6a 47		 push	 71			; 00000047H
  002df	8d 4d b4	 lea	 ecx, DWORD PTR _longID$58487[ebp]
  002e2	e8 00 00 00 00	 call	 ?SetIndexedProperty@ObjectID@@QBEXHF@Z ; ObjectID::SetIndexedProperty

; 92   : 			longID.SetIndexedProperty ( longHiWord, val >> 16 );

  002e7	8b 45 c0	 mov	 eax, DWORD PTR _val$58486[ebp]
  002ea	c1 f8 10	 sar	 eax, 16			; 00000010H
  002ed	50		 push	 eax
  002ee	6a 48		 push	 72			; 00000048H
  002f0	8d 4d b4	 lea	 ecx, DWORD PTR _longID$58487[ebp]
  002f3	e8 00 00 00 00	 call	 ?SetIndexedProperty@ObjectID@@QBEXHF@Z ; ObjectID::SetIndexedProperty

; 93   : 		}

  002f8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  002ff	8d 4d b8	 lea	 ecx, DWORD PTR _data$58484[ebp]
  00302	e8 00 00 00 00	 call	 ??1PackedData@@UAE@XZ	; PackedData::~PackedData

; 94   : 
; 95   : 		break;

  00307	e9 0b 02 00 00	 jmp	 $L58448
$L58492:

; 98   : 			ObjectID longID = (ObjectID)arg ( 3 );

  0030c	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  0030f	66 8b 51 06	 mov	 dx, WORD PTR [ecx+6]
  00313	52		 push	 edx
  00314	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR $T58795[ebp]
  0031a	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  0031f	50		 push	 eax
  00320	8d 4d a4	 lea	 ecx, DWORD PTR _longID$58493[ebp]
  00323	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID

; 99   : 
; 100  : 			// validate the object
; 101  : 			if ( !longID.IsObject() )

  00328	8d 4d a4	 lea	 ecx, DWORD PTR _longID$58493[ebp]
  0032b	e8 00 00 00 00	 call	 ?IsObject@ObjectID@@QBEHXZ ; ObjectID::IsObject
  00330	85 c0		 test	 eax, eax
  00332	75 19		 jne	 SHORT $L58496

; 102  : 				msgMgr->Fatal ( "Invalid object passed to KPackData (0x%x)", longID );

  00334	66 8b 45 a4	 mov	 ax, WORD PTR _longID$58493[ebp]
  00338	50		 push	 eax
  00339	68 00 00 00 00	 push	 OFFSET FLAT:$SG58497
  0033e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00344	51		 push	 ecx
  00345	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  0034a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L58496:

; 103  : 
; 104  : 			long objValue = (SCIUWord)longID.GetIndexedProperty ( longLowWord ) + ((SCIUWord)longID.GetIndexedProperty ( longHiWord ) << 16);

  0034d	6a 47		 push	 71			; 00000047H
  0034f	8d 4d a4	 lea	 ecx, DWORD PTR _longID$58493[ebp]
  00352	e8 00 00 00 00	 call	 ?GetIndexedProperty@ObjectID@@QBEFH@Z ; ObjectID::GetIndexedProperty
  00357	66 8b f0	 mov	 si, ax
  0035a	81 e6 ff ff 00
	00		 and	 esi, 65535		; 0000ffffH
  00360	6a 48		 push	 72			; 00000048H
  00362	8d 4d a4	 lea	 ecx, DWORD PTR _longID$58493[ebp]
  00365	e8 00 00 00 00	 call	 ?GetIndexedProperty@ObjectID@@QBEFH@Z ; ObjectID::GetIndexedProperty
  0036a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0036f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00372	03 f0		 add	 esi, eax
  00374	89 75 a8	 mov	 DWORD PTR _objValue$58498[ebp], esi

; 105  : 
; 106  : 			PackedData data ( (ObjectID)arg(2) );

  00377	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  0037a	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  0037e	50		 push	 eax
  0037f	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR $T58797[ebp]
  00385	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  0038a	51		 push	 ecx
  0038b	8b cc		 mov	 ecx, esp
  0038d	89 a5 44 ff ff
	ff		 mov	 DWORD PTR $T58796[ebp], esp
  00393	50		 push	 eax
  00394	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID
  00399	8d 4d ac	 lea	 ecx, DWORD PTR _data$58503[ebp]
  0039c	e8 00 00 00 00	 call	 ??0PackedData@@QAE@VObjectID@@@Z ; PackedData::PackedData
  003a1	c7 45 fc 07 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 7

; 107  : 			data.putLong ( objValue );

  003a8	8b 4d a8	 mov	 ecx, DWORD PTR _objValue$58498[ebp]
  003ab	51		 push	 ecx
  003ac	8d 4d ac	 lea	 ecx, DWORD PTR _data$58503[ebp]
  003af	e8 00 00 00 00	 call	 ?putLong@PackedData@@QAEXH@Z ; PackedData::putLong

; 108  : 		}

  003b4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003bb	8d 4d ac	 lea	 ecx, DWORD PTR _data$58503[ebp]
  003be	e8 00 00 00 00	 call	 ??1PackedData@@UAE@XZ	; PackedData::~PackedData

; 109  : 
; 110  : 		break;

  003c3	e9 4f 01 00 00	 jmp	 $L58448
$L58505:

; 113  : 			PackedData data ( (ObjectID)arg(2) );

  003c8	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  003cb	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  003cf	50		 push	 eax
  003d0	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR $T58799[ebp]
  003d6	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  003db	51		 push	 ecx
  003dc	8b cc		 mov	 ecx, esp
  003de	89 a5 3c ff ff
	ff		 mov	 DWORD PTR $T58798[ebp], esp
  003e4	50		 push	 eax
  003e5	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID
  003ea	8d 4d 9c	 lea	 ecx, DWORD PTR _data$58508[ebp]
  003ed	e8 00 00 00 00	 call	 ??0PackedData@@QAE@VObjectID@@@Z ; PackedData::PackedData
  003f2	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 8

; 114  : 
; 115  : 			TextID text = data.getString ( arg(3) );

  003f9	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  003fc	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00400	52		 push	 edx
  00401	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR $T58800[ebp]
  00407	50		 push	 eax
  00408	8d 4d 9c	 lea	 ecx, DWORD PTR _data$58508[ebp]
  0040b	e8 00 00 00 00	 call	 ?getString@PackedData@@QAE?AVTextID@@H@Z ; PackedData::getString
  00410	50		 push	 eax
  00411	8d 4d 98	 lea	 ecx, DWORD PTR _text$58510[ebp]
  00414	e8 00 00 00 00	 call	 ??0TextID@@QAE@ABV0@@Z	; TextID::TextID

; 116  : 
; 117  : 			pm.acc = text;

  00419	8d 4d 98	 lea	 ecx, DWORD PTR _text$58510[ebp]
  0041c	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00421	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00426	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 118  : 		}

  0042b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00432	8d 4d 9c	 lea	 ecx, DWORD PTR _data$58508[ebp]
  00435	e8 00 00 00 00	 call	 ??1PackedData@@UAE@XZ	; PackedData::~PackedData

; 119  : 
; 120  : 		break;

  0043a	e9 d8 00 00 00	 jmp	 $L58448
$L58512:

; 123  : 			PackedData data ( (ObjectID)arg(2) );

  0043f	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00442	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  00446	52		 push	 edx
  00447	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR $T58802[ebp]
  0044d	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  00452	51		 push	 ecx
  00453	8b cc		 mov	 ecx, esp
  00455	89 a5 30 ff ff
	ff		 mov	 DWORD PTR $T58801[ebp], esp
  0045b	50		 push	 eax
  0045c	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID
  00461	8d 4d 90	 lea	 ecx, DWORD PTR _data$58515[ebp]
  00464	e8 00 00 00 00	 call	 ??0PackedData@@QAE@VObjectID@@@Z ; PackedData::PackedData
  00469	c7 45 fc 09 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 9

; 124  : 			data.putString ( *(TextID)arg(3), arg(4) );

  00470	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00473	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00477	51		 push	 ecx
  00478	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  0047b	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  0047f	50		 push	 eax
  00480	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T58803[ebp]
  00486	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  0048b	8b c8		 mov	 ecx, eax
  0048d	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  00492	50		 push	 eax
  00493	8d 4d 90	 lea	 ecx, DWORD PTR _data$58515[ebp]
  00496	e8 00 00 00 00	 call	 ?putString@PackedData@@QAEXPADH@Z ; PackedData::putString

; 125  : 		}

  0049b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  004a2	8d 4d 90	 lea	 ecx, DWORD PTR _data$58515[ebp]
  004a5	e8 00 00 00 00	 call	 ??1PackedData@@UAE@XZ	; PackedData::~PackedData

; 126  : 
; 127  : 		break;

  004aa	eb 6b		 jmp	 SHORT $L58448
$L58519:

; 130  : 			PackedData data ( (ObjectID)arg(2) );

  004ac	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  004af	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  004b3	52		 push	 edx
  004b4	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR $T58805[ebp]
  004ba	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  004bf	51		 push	 ecx
  004c0	8b cc		 mov	 ecx, esp
  004c2	89 a5 24 ff ff
	ff		 mov	 DWORD PTR $T58804[ebp], esp
  004c8	50		 push	 eax
  004c9	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID
  004ce	8d 4d 88	 lea	 ecx, DWORD PTR _data$58522[ebp]
  004d1	e8 00 00 00 00	 call	 ??0PackedData@@QAE@VObjectID@@@Z ; PackedData::PackedData
  004d6	c7 45 fc 0a 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 10 ; 0000000aH

; 131  : 			data.putArray ( *(TextID)arg(3), arg(4) );

  004dd	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  004e0	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  004e4	51		 push	 ecx
  004e5	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  004e8	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  004ec	50		 push	 eax
  004ed	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR $T58806[ebp]
  004f3	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  004f8	8b c8		 mov	 ecx, eax
  004fa	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  004ff	50		 push	 eax
  00500	8d 4d 88	 lea	 ecx, DWORD PTR _data$58522[ebp]
  00503	e8 00 00 00 00	 call	 ?putArray@PackedData@@QAEXPAXH@Z ; PackedData::putArray

; 132  : 		}

  00508	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0050f	8d 4d 88	 lea	 ecx, DWORD PTR _data$58522[ebp]
  00512	e8 00 00 00 00	 call	 ??1PackedData@@UAE@XZ	; PackedData::~PackedData
$L58448:

; 136  : }

  00517	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0051a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00521	5e		 pop	 esi
  00522	8b e5		 mov	 esp, ebp
  00524	5d		 pop	 ebp
  00525	c3		 ret	 0
$L58824:
  00526	00 00 00 00	 DD	 $L58451
  0052a	00 00 00 00	 DD	 $L58456
  0052e	00 00 00 00	 DD	 $L58461
  00532	00 00 00 00	 DD	 $L58466
  00536	00 00 00 00	 DD	 $L58471
  0053a	00 00 00 00	 DD	 $L58476
  0053e	00 00 00 00	 DD	 $L58481
  00542	00 00 00 00	 DD	 $L58492
  00546	00 00 00 00	 DD	 $L58505
  0054a	00 00 00 00	 DD	 $L58512
  0054e	00 00 00 00	 DD	 $L58519
_TEXT	ENDS
text$x	SEGMENT
$L58807:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR _data$58454[ebp]
  00003	e8 00 00 00 00	 call	 ??1PackedData@@UAE@XZ	; PackedData::~PackedData
  00008	c3		 ret	 0
$L58808:
  00009	8d 4d e4	 lea	 ecx, DWORD PTR _data$58459[ebp]
  0000c	e8 00 00 00 00	 call	 ??1PackedData@@UAE@XZ	; PackedData::~PackedData
  00011	c3		 ret	 0
$L58809:
  00012	8d 4d dc	 lea	 ecx, DWORD PTR _data$58464[ebp]
  00015	e8 00 00 00 00	 call	 ??1PackedData@@UAE@XZ	; PackedData::~PackedData
  0001a	c3		 ret	 0
$L58810:
  0001b	8d 4d d4	 lea	 ecx, DWORD PTR _data$58469[ebp]
  0001e	e8 00 00 00 00	 call	 ??1PackedData@@UAE@XZ	; PackedData::~PackedData
  00023	c3		 ret	 0
$L58811:
  00024	8d 4d cc	 lea	 ecx, DWORD PTR _data$58474[ebp]
  00027	e8 00 00 00 00	 call	 ??1PackedData@@UAE@XZ	; PackedData::~PackedData
  0002c	c3		 ret	 0
$L58812:
  0002d	8d 4d c4	 lea	 ecx, DWORD PTR _data$58479[ebp]
  00030	e8 00 00 00 00	 call	 ??1PackedData@@UAE@XZ	; PackedData::~PackedData
  00035	c3		 ret	 0
$L58813:
  00036	8d 4d b8	 lea	 ecx, DWORD PTR _data$58484[ebp]
  00039	e8 00 00 00 00	 call	 ??1PackedData@@UAE@XZ	; PackedData::~PackedData
  0003e	c3		 ret	 0
$L58814:
  0003f	8d 4d ac	 lea	 ecx, DWORD PTR _data$58503[ebp]
  00042	e8 00 00 00 00	 call	 ??1PackedData@@UAE@XZ	; PackedData::~PackedData
  00047	c3		 ret	 0
$L58815:
  00048	8d 4d 9c	 lea	 ecx, DWORD PTR _data$58508[ebp]
  0004b	e8 00 00 00 00	 call	 ??1PackedData@@UAE@XZ	; PackedData::~PackedData
  00050	c3		 ret	 0
$L58816:
  00051	8d 4d 90	 lea	 ecx, DWORD PTR _data$58515[ebp]
  00054	e8 00 00 00 00	 call	 ??1PackedData@@UAE@XZ	; PackedData::~PackedData
  00059	c3		 ret	 0
$L58817:
  0005a	8d 4d 88	 lea	 ecx, DWORD PTR _data$58522[ebp]
  0005d	e8 00 00 00 00	 call	 ??1PackedData@@UAE@XZ	; PackedData::~PackedData
  00062	c3		 ret	 0
$L58822:
  00063	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T58821
  00068	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?KPackData@@YAXPAF@Z ENDP				; KPackData
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4
??BMemID@@QBEGXZ PROC NEAR				; MemID::operator unsigned short, COMDAT

; 93   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   : 		return handle;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 00	 mov	 ax, WORD PTR [eax]

; 95   : 	}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??BMemID@@QBEGXZ ENDP					; MemID::operator unsigned short
_TEXT	ENDS
PUBLIC	??0FakeObjectID@@QAE@ABVMemID@@@Z		; FakeObjectID::FakeObjectID
;	COMDAT ??0ObjectID@@QAE@ABV0@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0ObjectID@@QAE@ABV0@@Z PROC NEAR			; ObjectID::ObjectID, COMDAT

; 229  : 	ObjectID(const ObjectID& id) : FakeObjectID((MemID&) id) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0FakeObjectID@@QAE@ABVMemID@@@Z ; FakeObjectID::FakeObjectID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0ObjectID@@QAE@ABV0@@Z ENDP				; ObjectID::ObjectID
_TEXT	ENDS
PUBLIC	??0MemID@@QAE@ABV0@@Z				; MemID::MemID
;	COMDAT ??0FakeObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0FakeObjectID@@QAE@ABVMemID@@@Z PROC NEAR		; FakeObjectID::FakeObjectID, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0FakeObjectID@@QAE@ABVMemID@@@Z ENDP			; FakeObjectID::FakeObjectID
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0MemID@@QAE@ABV0@@Z PROC NEAR				; MemID::MemID, COMDAT

; 19   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  0000d	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00010	66 89 10	 mov	 WORD PTR [eax], dx

; 20   : 	}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0MemID@@QAE@ABV0@@Z ENDP				; MemID::MemID
_TEXT	ENDS
PUBLIC	??0FakeObjectID@@QAE@G@Z			; FakeObjectID::FakeObjectID
;	COMDAT ??0ObjectID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0ObjectID@@QAE@G@Z PROC NEAR				; ObjectID::ObjectID, COMDAT

; 230  : 	ObjectID(SOL_Handle h) : FakeObjectID(h) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	66 8b 45 08	 mov	 ax, WORD PTR _h$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0FakeObjectID@@QAE@G@Z ; FakeObjectID::FakeObjectID
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0ObjectID@@QAE@G@Z ENDP				; ObjectID::ObjectID
_TEXT	ENDS
PUBLIC	??0MemID@@QAE@G@Z				; MemID::MemID
;	COMDAT ??0FakeObjectID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0FakeObjectID@@QAE@G@Z PROC NEAR			; FakeObjectID::FakeObjectID, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	66 8b 45 08	 mov	 ax, WORD PTR _h$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0FakeObjectID@@QAE@G@Z ENDP				; FakeObjectID::FakeObjectID
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0MemID@@QAE@G@Z PROC NEAR				; MemID::MemID, COMDAT

; 23   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 4d 08	 mov	 cx, WORD PTR _h$[ebp]
  0000e	66 89 08	 mov	 WORD PTR [eax], cx

; 24   : 	}

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??0MemID@@QAE@G@Z ENDP					; MemID::MemID
_TEXT	ENDS
PUBLIC	?IsValid@MemID@@QBEHXZ				; MemID::IsValid
EXTRN	?GetMemType@MemID@@QBE?AW4MemType@@XZ:NEAR	; MemID::GetMemType
;	COMDAT ?IsObject@ObjectID@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsObject@ObjectID@@QBEHXZ PROC NEAR			; ObjectID::IsObject, COMDAT

; 247  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 248  : 		return IsValid() && GetMemType() == MemObject;

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  00011	85 c0		 test	 eax, eax
  00013	74 16		 je	 SHORT $L58835
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  0001d	83 f8 34	 cmp	 eax, 52			; 00000034H
  00020	75 09		 jne	 SHORT $L58835
  00022	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR -8+[ebp], 1
  00029	eb 07		 jmp	 SHORT $L58836
$L58835:
  0002b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], 0
$L58836:
  00032	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]

; 249  : 	}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?IsObject@ObjectID@@QBEHXZ ENDP				; ObjectID::IsObject
_TEXT	ENDS
PUBLIC	?IsValid@MemoryMgr@@QAEHG@Z			; MemoryMgr::IsValid
EXTRN	_memMgr:DWORD
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsValid@MemID@@QBEHXZ PROC NEAR			; MemID::IsValid, COMDAT

; 62   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 63   : 		return memMgr->IsValid(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?IsValid@MemoryMgr@@QAEHG@Z ; MemoryMgr::IsValid

; 64   : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?IsValid@MemID@@QBEHXZ ENDP				; MemID::IsValid
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -8
_tempID$ = -4
?IsValid@MemoryMgr@@QAEHG@Z PROC NEAR			; MemoryMgr::IsValid, COMDAT

; 475  : 	inline Bool MemoryMgr::IsValid(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 476  : 		unsigned short tempID = (unsigned short)theID;

  00009	66 8b 45 08	 mov	 ax, WORD PTR _theID$[ebp]
  0000d	66 89 45 fc	 mov	 WORD PTR _tempID$[ebp], ax

; 477  : 
; 478  : 		return(
; 479  : 				(tempID)															&&
; 480  : 				(tempID < maxDescriptors)									&&
; 481  : 				(desc[tempID].memInfo.bits.freeDescriptor == False)	&&
; 482  : 				(desc[tempID].memInfo.bits.freeMemory == False)
; 483  : 				);

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _tempID$[ebp]
  00014	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 58		 je	 SHORT $L58839
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _tempID$[ebp]
  00021	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  0002d	73 47		 jae	 SHORT $L58839
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _tempID$[ebp]
  00032	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00038	c1 e1 04	 shl	 ecx, 4
  0003b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00041	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00044	c1 e1 0e	 shl	 ecx, 14			; 0000000eH
  00047	c1 f9 1f	 sar	 ecx, 31			; 0000001fH
  0004a	85 c9		 test	 ecx, ecx
  0004c	75 28		 jne	 SHORT $L58839
  0004e	8b 55 fc	 mov	 edx, DWORD PTR _tempID$[ebp]
  00051	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00057	c1 e2 04	 shl	 edx, 4
  0005a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00060	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00063	c1 e2 14	 shl	 edx, 20			; 00000014H
  00066	c1 fa 1f	 sar	 edx, 31			; 0000001fH
  00069	85 d2		 test	 edx, edx
  0006b	75 09		 jne	 SHORT $L58839
  0006d	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR -12+[ebp], 1
  00074	eb 07		 jmp	 SHORT $L58840
$L58839:
  00076	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR -12+[ebp], 0
$L58840:
  0007d	8b 45 f4	 mov	 eax, DWORD PTR -12+[ebp]

; 484  : 	}

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 04 00	 ret	 4
?IsValid@MemoryMgr@@QAEHG@Z ENDP			; MemoryMgr::IsValid
_TEXT	ENDS
PUBLIC	?GetIndexedProperty@Object@@QAEFH@Z		; Object::GetIndexedProperty
PUBLIC	??CFakeObjectID@@QBEPAUObject@@XZ		; FakeObjectID::operator->
PUBLIC	?AssureValid@ObjectID@@QBEXXZ			; ObjectID::AssureValid
;	COMDAT ?GetIndexedProperty@ObjectID@@QBEFH@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
?GetIndexedProperty@ObjectID@@QBEFH@Z PROC NEAR		; ObjectID::GetIndexedProperty, COMDAT

; 266  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 267  : 		//	get a property given an index in the property offsets table
; 268  : 		AssureValid();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?AssureValid@ObjectID@@QBEXXZ ; ObjectID::AssureValid

; 269  : 		return (*this)->GetIndexedProperty(index);

  0000f	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00012	50		 push	 eax
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  0001b	8b c8		 mov	 ecx, eax
  0001d	e8 00 00 00 00	 call	 ?GetIndexedProperty@Object@@QAEFH@Z ; Object::GetIndexedProperty

; 270  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?GetIndexedProperty@ObjectID@@QBEFH@Z ENDP		; ObjectID::GetIndexedProperty
_TEXT	ENDS
PUBLIC	?GetIndexedPropAddr@Object@@QAEPBFH@Z		; Object::GetIndexedPropAddr
;	COMDAT ?GetIndexedProperty@Object@@QAEFH@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
?GetIndexedProperty@Object@@QAEFH@Z PROC NEAR		; Object::GetIndexedProperty, COMDAT

; 146  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 147  : 		//	get a property given an index in the property offsets table
; 148  : 		return *GetIndexedPropAddr(index);

  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?GetIndexedPropAddr@Object@@QAEPBFH@Z ; Object::GetIndexedPropAddr
  00013	66 8b 00	 mov	 ax, WORD PTR [eax]

; 149  : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?GetIndexedProperty@Object@@QAEFH@Z ENDP		; Object::GetIndexedProperty
_TEXT	ENDS
PUBLIC	??AObject@@QAEAAFH@Z				; Object::operator[]
EXTRN	?indexedPropertyOffsets@@3PAIA:BYTE		; indexedPropertyOffsets
;	COMDAT ?GetIndexedPropAddr@Object@@QAEPBFH@Z
_TEXT	SEGMENT
_this$ = -4
_index$ = 8
?GetIndexedPropAddr@Object@@QAEPBFH@Z PROC NEAR		; Object::GetIndexedPropAddr, COMDAT

; 138  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 139  : 		//	get a property address given an index into the property offsets table
; 140  : 		extern size_t indexedPropertyOffsets[];
; 141  : 		return &(*this)[indexedPropertyOffsets[index]];

  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?indexedPropertyOffsets@@3PAIA[eax*4]
  00011	51		 push	 ecx
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??AObject@@QAEAAFH@Z	; Object::operator[]

; 142  : 	}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?GetIndexedPropAddr@Object@@QAEPBFH@Z ENDP		; Object::GetIndexedPropAddr
_TEXT	ENDS
;	COMDAT ??AObject@@QAEAAFH@Z
_TEXT	SEGMENT
_this$ = -4
_index$ = 8
??AObject@@QAEAAFH@Z PROC NEAR				; Object::operator[], COMDAT

; 117  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 118  : 		//	get a reference to a property given the number of the property
; 119  : 		return ((Property*) this)[index];

  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]

; 120  : 	}

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??AObject@@QAEAAFH@Z ENDP				; Object::operator[]
_TEXT	ENDS
PUBLIC	??DMemID@@QBEPAXXZ				; MemID::operator*
;	COMDAT ??CFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT
_this$ = -4
??CFakeObjectID@@QBEPAUObject@@XZ PROC NEAR		; FakeObjectID::operator->, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??CFakeObjectID@@QBEPAUObject@@XZ ENDP			; FakeObjectID::operator->
_TEXT	ENDS
PUBLIC	?GetAddr@MemoryMgr@@QAEPAXG@Z			; MemoryMgr::GetAddr
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT
_this$ = -4
??DMemID@@QBEPAXXZ PROC NEAR				; MemID::operator*, COMDAT

; 98   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 99   : 		return memMgr->GetAddr(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr

; 100  : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??DMemID@@QBEPAXXZ ENDP					; MemID::operator*
_TEXT	ENDS
EXTRN	__descPtrTable:BYTE
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -4
?GetAddr@MemoryMgr@@QAEPAXG@Z PROC NEAR			; MemoryMgr::GetAddr, COMDAT

; 462  : 	inline void* MemoryMgr::GetAddr(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : //		CheckValid(theID);
; 464  : 		return _descPtrTable[(unsigned int)((unsigned short)theID)];

  00007	8b 45 08	 mov	 eax, DWORD PTR _theID$[ebp]
  0000a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0000f	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR __descPtrTable[eax*4]

; 465  : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?GetAddr@MemoryMgr@@QAEPAXG@Z ENDP			; MemoryMgr::GetAddr
_TEXT	ENDS
EXTRN	?Fatal@MsgMgr@@QAAXHZZ:NEAR			; MsgMgr::Fatal
;	COMDAT ?AssureValid@ObjectID@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4
?AssureValid@ObjectID@@QBEXXZ PROC NEAR			; ObjectID::AssureValid, COMDAT

; 238  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 239  : 		if (!IsObject())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?IsObject@ObjectID@@QBEHXZ ; ObjectID::IsObject
  0000f	85 c0		 test	 eax, eax
  00011	75 1e		 jne	 SHORT $L57572

; 240  : 			msgMgr->Fatal(Msg_NotObject, (int) *this);

  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  0001b	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00020	50		 push	 eax
  00021	6a 2f		 push	 47			; 0000002fH
  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXHZZ	; MsgMgr::Fatal
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L57572:

; 241  : 	}

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?AssureValid@ObjectID@@QBEXXZ ENDP			; ObjectID::AssureValid
_TEXT	ENDS
PUBLIC	?SetIndexedProperty@Object@@QAEXHF@Z		; Object::SetIndexedProperty
;	COMDAT ?SetIndexedProperty@ObjectID@@QBEXHF@Z
_TEXT	SEGMENT
_index$ = 8
_property$ = 12
_this$ = -4
?SetIndexedProperty@ObjectID@@QBEXHF@Z PROC NEAR	; ObjectID::SetIndexedProperty, COMDAT

; 324  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 325  : 		//	set a property given an index into property offsets table
; 326  : 		AssureValid();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?AssureValid@ObjectID@@QBEXXZ ; ObjectID::AssureValid

; 327  : 		(*this)->SetIndexedProperty(index, property);

  0000f	66 8b 45 0c	 mov	 ax, WORD PTR _property$[ebp]
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  00017	51		 push	 ecx
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 ?SetIndexedProperty@Object@@QAEXHF@Z ; Object::SetIndexedProperty

; 328  : 	}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
?SetIndexedProperty@ObjectID@@QBEXHF@Z ENDP		; ObjectID::SetIndexedProperty
_TEXT	ENDS
PUBLIC	?SetPropAtOffset@Object@@QAEAAFI@Z		; Object::SetPropAtOffset
EXTRN	?indexedPropertyOffsets@@3PAIA:BYTE		; indexedPropertyOffsets
;	COMDAT ?SetIndexedProperty@Object@@QAEXHF@Z
_TEXT	SEGMENT
_index$ = 8
_property$ = 12
_this$ = -4
?SetIndexedProperty@Object@@QAEXHF@Z PROC NEAR		; Object::SetIndexedProperty, COMDAT

; 188  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 189  : 		//	set a property given an index into property offsets table
; 190  : 		extern size_t indexedPropertyOffsets[];
; 191  : 		SetPropAtOffset(indexedPropertyOffsets[index] * sizeof(Property)) =
; 192  : 			property;

  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?indexedPropertyOffsets@@3PAIA[eax*4]
  00011	d1 e1		 shl	 ecx, 1
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?SetPropAtOffset@Object@@QAEAAFI@Z ; Object::SetPropAtOffset
  0001c	66 8b 55 0c	 mov	 dx, WORD PTR _property$[ebp]
  00020	66 89 10	 mov	 WORD PTR [eax], dx

; 193  : 	}

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
?SetIndexedProperty@Object@@QAEXHF@Z ENDP		; Object::SetIndexedProperty
_TEXT	ENDS
PUBLIC	?GetPropAtOffset@Object@@QAEAAFI@Z		; Object::GetPropAtOffset
PUBLIC	?SetGraphicsUpdate@Object@@QAEXXZ		; Object::SetGraphicsUpdate
;	COMDAT ?SetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT
_offset$ = 8
_this$ = -4
?SetPropAtOffset@Object@@QAEAAFI@Z PROC NEAR		; Object::SetPropAtOffset, COMDAT

; 197  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 198  : 		//	return reference to property that is about to be changed
; 199  : 		if (offset <= MaxGraphUpdateOffset && offset >= MinGraphUpdateOffset)

  00007	83 7d 08 56	 cmp	 DWORD PTR _offset$[ebp], 86 ; 00000056H
  0000b	77 0e		 ja	 SHORT $L57431
  0000d	83 7d 08 30	 cmp	 DWORD PTR _offset$[ebp], 48 ; 00000030H
  00011	72 08		 jb	 SHORT $L57431

; 200  : 			SetGraphicsUpdate();

  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?SetGraphicsUpdate@Object@@QAEXXZ ; Object::SetGraphicsUpdate
$L57431:

; 201  : 		return GetPropAtOffset(offset);

  0001b	8b 45 08	 mov	 eax, DWORD PTR _offset$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?GetPropAtOffset@Object@@QAEAAFI@Z ; Object::GetPropAtOffset

; 202  : 	}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?SetPropAtOffset@Object@@QAEAAFI@Z ENDP			; Object::SetPropAtOffset
_TEXT	ENDS
;	COMDAT ?SetGraphicsUpdate@Object@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?SetGraphicsUpdate@Object@@QAEXXZ PROC NEAR		; Object::SetGraphicsUpdate, COMDAT

; 97   : 	void		SetGraphicsUpdate()		{ info |= GRAPH_UPD; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 48 0e	 mov	 cx, WORD PTR [eax+14]
  0000e	80 c9 08	 or	 cl, 8
  00011	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00014	66 89 4a 0e	 mov	 WORD PTR [edx+14], cx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?SetGraphicsUpdate@Object@@QAEXXZ ENDP			; Object::SetGraphicsUpdate
_TEXT	ENDS
;	COMDAT ?GetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT
_offset$ = 8
_this$ = -4
?GetPropAtOffset@Object@@QAEAAFI@Z PROC NEAR		; Object::GetPropAtOffset, COMDAT

; 163  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 164  : 		//	get a property given an offset into the object
; 165  : 		return (Property&) ((char*) this)[offset];

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	03 45 08	 add	 eax, DWORD PTR _offset$[ebp]

; 166  : 	}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?GetPropAtOffset@Object@@QAEAAFI@Z ENDP			; Object::GetPropAtOffset
_TEXT	ENDS
PUBLIC	??_C@_00A@?$AA@					; `string'
;	COMDAT ??_C@_00A@?$AA@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\textid.hpp
_BSS	SEGMENT
??_C@_00A@?$AA@ DB 01H DUP (?)				; `string'
_BSS	ENDS
;	COMDAT ??DTextID@@QAEPADXZ
_TEXT	SEGMENT
_this$ = -4
??DTextID@@QAEPADXZ PROC NEAR				; TextID::operator*, COMDAT

; 24   : 	char	*operator *() { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 25   : 		return handle ? (char *)MemID::operator*() : ""; 

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	33 c9		 xor	 ecx, ecx
  0000e	66 8b 08	 mov	 cx, WORD PTR [eax]
  00011	85 c9		 test	 ecx, ecx
  00013	74 0d		 je	 SHORT $L58855
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0001d	89 45 f8	 mov	 DWORD PTR -8+[ebp], eax
  00020	eb 07		 jmp	 SHORT $L58856
$L58855:
  00022	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
$L58856:
  00029	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]

; 26   : 	}

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??DTextID@@QAEPADXZ ENDP				; TextID::operator*
_TEXT	ENDS
;	COMDAT ??0TextID@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0TextID@@QAE@ABV0@@Z PROC NEAR			; TextID::TextID, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0TextID@@QAE@ABV0@@Z ENDP				; TextID::TextID
_TEXT	ENDS
PUBLIC	??0ObjectID@@QAE@XZ				; ObjectID::ObjectID
PUBLIC	?GetProperty@ObjectID@@QBEFG@Z			; ObjectID::GetProperty
PUBLIC	??0Array@@QAE@XZ				; Array::Array
PUBLIC	??1Array@@QAE@XZ				; Array::~Array
PUBLIC	?dataID@Array@@QAEXVMemID@@@Z			; Array::dataID
PUBLIC	??_7PackedData@@6B@				; PackedData::`vftable'
PUBLIC	??_GPackedData@@UAEPAXI@Z			; PackedData::`scalar deleting destructor'
PUBLIC	??_EPackedData@@UAEPAXI@Z			; PackedData::`vector deleting destructor'
;	COMDAT ??_7PackedData@@6B@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\Packdata.cpp
CONST	SEGMENT
??_7PackedData@@6B@ DD FLAT:??_EPackedData@@UAEPAXI@Z	; PackedData::`vftable'
CONST	ENDS
_DATA	SEGMENT
	ORG $+2
$SG58534 DB	'PackedData class initialized with invalid object.', 00H
_DATA	ENDS
xdata$x	SEGMENT
$T58864	DD	019930520H
	DD	01H
	DD	FLAT:$T58866
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T58866	DD	0ffffffffH
	DD	FLAT:$L58862
xdata$x	ENDS
_TEXT	SEGMENT
_obj$ = 8
_this$ = -24
$T58860 = -16
$T58861 = -20
__$EHRec$ = -12
??0PackedData@@QAE@VObjectID@@@Z PROC NEAR		; PackedData::PackedData

; 139  : {

  00552	55		 push	 ebp
  00553	8b ec		 mov	 ebp, esp
  00555	6a ff		 push	 -1
  00557	68 00 00 00 00	 push	 $L58865
  0055c	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00562	50		 push	 eax
  00563	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0056a	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0056d	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00570	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00573	83 c1 04	 add	 ecx, 4
  00576	e8 00 00 00 00	 call	 ??0Array@@QAE@XZ	; Array::Array
  0057b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00582	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00585	83 c1 06	 add	 ecx, 6
  00588	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@XZ	; ObjectID::ObjectID
  0058d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00590	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7PackedData@@6B@ ; PackedData::`vftable'

; 140  : 	if ( !obj.IsObject() )

  00596	8d 4d 08	 lea	 ecx, DWORD PTR _obj$[ebp]
  00599	e8 00 00 00 00	 call	 ?IsObject@ObjectID@@QBEHXZ ; ObjectID::IsObject
  0059e	85 c0		 test	 eax, eax
  005a0	75 14		 jne	 SHORT $L58533

; 141  : 		msgMgr->Fatal ( "PackedData class initialized with invalid object." );

  005a2	68 00 00 00 00	 push	 OFFSET FLAT:$SG58534
  005a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  005ad	51		 push	 ecx
  005ae	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  005b3	83 c4 08	 add	 esp, 8
$L58533:

; 142  : 
; 143  : 	_object = obj;

  005b6	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  005b9	66 8b 45 08	 mov	 ax, WORD PTR _obj$[ebp]
  005bd	66 89 42 06	 mov	 WORD PTR [edx+6], ax

; 144  : 
; 145  : 	// get the array information from the passed SCI object
; 146  : 	_array.dataID ( (MemID)obj.GetProperty ( s_data ) );

  005c1	6a 71		 push	 113			; 00000071H
  005c3	8d 4d 08	 lea	 ecx, DWORD PTR _obj$[ebp]
  005c6	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  005cb	50		 push	 eax
  005cc	8d 4d ec	 lea	 ecx, DWORD PTR $T58861[ebp]
  005cf	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  005d4	51		 push	 ecx
  005d5	8b cc		 mov	 ecx, esp
  005d7	89 65 f0	 mov	 DWORD PTR $T58860[ebp], esp
  005da	50		 push	 eax
  005db	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  005e0	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  005e3	83 c1 04	 add	 ecx, 4
  005e6	e8 00 00 00 00	 call	 ?dataID@Array@@QAEXVMemID@@@Z ; Array::dataID

; 147  : }

  005eb	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  005f2	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  005f5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  005f8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  005ff	8b e5		 mov	 esp, ebp
  00601	5d		 pop	 ebp
  00602	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L58862:
  0006d	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	83 c1 04	 add	 ecx, 4
  00073	e8 00 00 00 00	 call	 ??1Array@@QAE@XZ	; Array::~Array
  00078	c3		 ret	 0
$L58865:
  00079	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T58864
  0007e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0PackedData@@QAE@VObjectID@@@Z ENDP			; PackedData::PackedData
PUBLIC	??0MemID@@QAE@XZ				; MemID::MemID
;	COMDAT ??0Array@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8
??0Array@@QAE@XZ PROC NEAR				; Array::Array, COMDAT

; 74   : 	Array() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID

; 75   : 		dataID ( 0 );

  00011	51		 push	 ecx
  00012	8b cc		 mov	 ecx, esp
  00014	6a 00		 push	 0
  00016	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?dataID@Array@@QAEXVMemID@@@Z ; Array::dataID

; 76   : 	}

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??0Array@@QAE@XZ ENDP					; Array::Array
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0MemID@@QAE@XZ PROC NEAR				; MemID::MemID, COMDAT

; 15   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 16   : 	}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0MemID@@QAE@XZ ENDP					; MemID::MemID
_TEXT	ENDS
;	COMDAT ??1Array@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1Array@@QAE@XZ PROC NEAR				; Array::~Array, COMDAT

; 88   : 	~Array() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1Array@@QAE@XZ ENDP					; Array::~Array
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAEXVMemID@@@Z
_TEXT	SEGMENT
_memID$ = 8
_this$ = -4
?dataID@Array@@QAEXVMemID@@@Z PROC NEAR			; Array::dataID, COMDAT

; 111  : 	void dataID ( MemID memID ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		_dataID = memID;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 4d 08	 mov	 cx, WORD PTR _memID$[ebp]
  0000e	66 89 08	 mov	 WORD PTR [eax], cx

; 113  : 	}

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?dataID@Array@@QAEXVMemID@@@Z ENDP			; Array::dataID
_TEXT	ENDS
PUBLIC	??0FakeObjectID@@QAE@XZ				; FakeObjectID::FakeObjectID
;	COMDAT ??0ObjectID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0ObjectID@@QAE@XZ PROC NEAR				; ObjectID::ObjectID, COMDAT

; 227  : 	ObjectID() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0FakeObjectID@@QAE@XZ	; FakeObjectID::FakeObjectID
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0ObjectID@@QAE@XZ ENDP				; ObjectID::ObjectID
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0FakeObjectID@@QAE@XZ PROC NEAR			; FakeObjectID::FakeObjectID, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0FakeObjectID@@QAE@XZ ENDP				; FakeObjectID::FakeObjectID
_TEXT	ENDS
PUBLIC	?GetProperty@Object@@QAEFG@Z			; Object::GetProperty
;	COMDAT ?GetProperty@ObjectID@@QBEFG@Z
_TEXT	SEGMENT
_selector$ = 8
_this$ = -4
?GetProperty@ObjectID@@QBEFG@Z PROC NEAR		; ObjectID::GetProperty, COMDAT

; 290  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 291  : 		//	get a property given a selector
; 292  : 		AssureValid();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?AssureValid@ObjectID@@QBEXXZ ; ObjectID::AssureValid

; 293  : 		return (*this)->GetProperty(selector);

  0000f	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  00013	50		 push	 eax
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  0001c	8b c8		 mov	 ecx, eax
  0001e	e8 00 00 00 00	 call	 ?GetProperty@Object@@QAEFG@Z ; Object::GetProperty

; 294  : 	}

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?GetProperty@ObjectID@@QBEFG@Z ENDP			; ObjectID::GetProperty
_TEXT	ENDS
PUBLIC	?GetPropAddrCheck@Object@@QAEPAFG@Z		; Object::GetPropAddrCheck
;	COMDAT ?GetProperty@Object@@QAEFG@Z
_TEXT	SEGMENT
_selector$ = 8
_this$ = -4
?GetProperty@Object@@QAEFG@Z PROC NEAR			; Object::GetProperty, COMDAT

; 170  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 171  : 		//	get a property given a selector
; 172  : 		return *GetPropAddrCheck(selector);

  00007	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?GetPropAddrCheck@Object@@QAEPAFG@Z ; Object::GetPropAddrCheck
  00014	66 8b 00	 mov	 ax, WORD PTR [eax]

; 173  : 	}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?GetProperty@Object@@QAEFG@Z ENDP			; Object::GetProperty
_TEXT	ENDS
PUBLIC	?GetPropAddr@Object@@QAEPAFG@Z			; Object::GetPropAddr
;	COMDAT ?GetPropAddrCheck@Object@@QAEPAFG@Z
_TEXT	SEGMENT
_selector$ = 8
_this$ = -8
_property$ = -4
?GetPropAddrCheck@Object@@QAEPAFG@Z PROC NEAR		; Object::GetPropAddrCheck, COMDAT

; 153  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 154  : 		//	get a property's address, checking for valid property
; 155  : 		Property* property = GetPropAddr(selector);

  00009	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?GetPropAddr@Object@@QAEPAFG@Z ; Object::GetPropAddr
  00016	89 45 fc	 mov	 DWORD PTR _property$[ebp], eax

; 156  : 		if (!property)

  00019	83 7d fc 00	 cmp	 DWORD PTR _property$[ebp], 0
  0001d	75 1b		 jne	 SHORT $L57413

; 157  : 			msgMgr->Fatal(Msg_InvalidProperty, selector);

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _selector$[ebp]
  00022	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00028	51		 push	 ecx
  00029	6a 29		 push	 41			; 00000029H
  0002b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXHZZ	; MsgMgr::Fatal
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
$L57413:

; 158  : 		return property;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _property$[ebp]

; 159  : 	}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
?GetPropAddrCheck@Object@@QAEPAFG@Z ENDP		; Object::GetPropAddrCheck
_TEXT	ENDS
PUBLIC	?selectorDict@Object@@QAEPAVSelectorDict@@XZ	; Object::selectorDict
EXTRN	?get@SelectorDict@@QAEHG@Z:NEAR			; SelectorDict::get
;	COMDAT ?GetPropAddr@Object@@QAEPAFG@Z
_TEXT	SEGMENT
_this$ = -8
_index$ = -4
_selector$ = 8
?GetPropAddr@Object@@QAEPAFG@Z PROC NEAR		; Object::GetPropAddr, COMDAT

; 127  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 128  : 		int index = selectorDict()->get ( selector );

  00009	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?selectorDict@Object@@QAEPAVSelectorDict@@XZ ; Object::selectorDict
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 ?get@SelectorDict@@QAEHG@Z ; SelectorDict::get
  0001d	89 45 fc	 mov	 DWORD PTR _index$[ebp], eax

; 129  : 
; 130  : 		if ( index != -1 && !selectorDict()->script )

  00020	83 7d fc ff	 cmp	 DWORD PTR _index$[ebp], -1
  00024	74 2b		 je	 SHORT $L57404
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?selectorDict@Object@@QAEPAVSelectorDict@@XZ ; Object::selectorDict
  0002e	33 c9		 xor	 ecx, ecx
  00030	66 8b 48 16	 mov	 cx, WORD PTR [eax+22]
  00034	85 c9		 test	 ecx, ecx
  00036	75 19		 jne	 SHORT $L57404

; 131  : 			return &(*this)[selectorDict()->offset]; 

  00038	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?selectorDict@Object@@QAEPAVSelectorDict@@XZ ; Object::selectorDict
  00040	33 d2		 xor	 edx, edx
  00042	66 8b 50 14	 mov	 dx, WORD PTR [eax+20]
  00046	52		 push	 edx
  00047	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ??AObject@@QAEAAFH@Z	; Object::operator[]
  0004f	eb 02		 jmp	 SHORT $L57402
$L57404:

; 132  : 
; 133  : 		return 0;

  00051	33 c0		 xor	 eax, eax
$L57402:

; 134  : 	}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
?GetPropAddr@Object@@QAEPAFG@Z ENDP			; Object::GetPropAddr
_TEXT	ENDS
;	COMDAT ?selectorDict@Object@@QAEPAVSelectorDict@@XZ
_TEXT	SEGMENT
_this$ = -4
?selectorDict@Object@@QAEPAVSelectorDict@@XZ PROC NEAR	; Object::selectorDict, COMDAT

; 102  : 	SelectorDict *selectorDict ( void ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 103  : 		return _selectorDict;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 104  : 	};

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?selectorDict@Object@@QAEPAVSelectorDict@@XZ ENDP	; Object::selectorDict
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
;	COMDAT ??_GPackedData@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GPackedData@@UAEPAXI@Z PROC NEAR			; PackedData::`scalar deleting destructor', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1PackedData@@UAE@XZ	; PackedData::~PackedData
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L58541
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L58541:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GPackedData@@UAEPAXI@Z ENDP				; PackedData::`scalar deleting destructor'
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4
??1PackedData@@UAE@XZ PROC NEAR				; PackedData::~PackedData

; 150  : {

  00605	55		 push	 ebp
  00606	8b ec		 mov	 ebp, esp
  00608	51		 push	 ecx
  00609	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0060c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0060f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7PackedData@@6B@ ; PackedData::`vftable'

; 151  : }

  00615	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00618	83 c1 04	 add	 ecx, 4
  0061b	e8 00 00 00 00	 call	 ??1Array@@QAE@XZ	; Array::~Array
  00620	8b e5		 mov	 esp, ebp
  00622	5d		 pop	 ebp
  00623	c3		 ret	 0
??1PackedData@@UAE@XZ ENDP				; PackedData::~PackedData
_TEXT	ENDS
PUBLIC	?SetProperty@ObjectID@@QBEXGF@Z			; ObjectID::SetProperty
EXTRN	?at@Array@@QAEHH@Z:NEAR				; Array::at
_TEXT	SEGMENT
_numBits$ = 8
_this$ = -20
_bitGetIndex$ = -8
_getIndex$ = -4
_retVal$ = -16
_bitIndex$ = -12
?getBits@PackedData@@QAEHH@Z PROC NEAR			; PackedData::getBits

; 154  : {

  00624	55		 push	 ebp
  00625	8b ec		 mov	 ebp, esp
  00627	83 ec 14	 sub	 esp, 20			; 00000014H
  0062a	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 155  : 	int bitGetIndex = (int)_object.GetProperty ( s_bitGetIndex );

  0062d	68 90 00 00 00	 push	 144			; 00000090H
  00632	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00635	83 c1 06	 add	 ecx, 6
  00638	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  0063d	0f bf c0	 movsx	 eax, ax
  00640	89 45 f8	 mov	 DWORD PTR _bitGetIndex$[ebp], eax

; 156  : 	int getIndex = (int)(unsigned short)_object.GetProperty ( s_getIndex );

  00643	68 8e 00 00 00	 push	 142			; 0000008eH
  00648	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0064b	83 c1 06	 add	 ecx, 6
  0064e	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  00653	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00658	89 45 fc	 mov	 DWORD PTR _getIndex$[ebp], eax

; 157  : 
; 158  : 	int retVal = 0, bitIndex = 0;

  0065b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _retVal$[ebp], 0
  00662	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _bitIndex$[ebp], 0
$L58557:

; 159  : 
; 160  : 	while ( numBits-- ) {

  00669	8b 4d 08	 mov	 ecx, DWORD PTR _numBits$[ebp]
  0066c	8b 55 08	 mov	 edx, DWORD PTR _numBits$[ebp]
  0066f	83 ea 01	 sub	 edx, 1
  00672	89 55 08	 mov	 DWORD PTR _numBits$[ebp], edx
  00675	85 c9		 test	 ecx, ecx
  00677	74 5b		 je	 SHORT $L58558

; 161  : 		if ( _array.at ( getIndex ) & (1 << bitGetIndex) )

  00679	8b 45 fc	 mov	 eax, DWORD PTR _getIndex$[ebp]
  0067c	50		 push	 eax
  0067d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00680	83 c1 04	 add	 ecx, 4
  00683	e8 00 00 00 00	 call	 ?at@Array@@QAEHH@Z	; Array::at
  00688	ba 01 00 00 00	 mov	 edx, 1
  0068d	8b 4d f8	 mov	 ecx, DWORD PTR _bitGetIndex$[ebp]
  00690	d3 e2		 shl	 edx, cl
  00692	23 c2		 and	 eax, edx
  00694	85 c0		 test	 eax, eax
  00696	74 12		 je	 SHORT $L58559

; 162  : 			retVal |= 1 << bitIndex;

  00698	b8 01 00 00 00	 mov	 eax, 1
  0069d	8b 4d f4	 mov	 ecx, DWORD PTR _bitIndex$[ebp]
  006a0	d3 e0		 shl	 eax, cl
  006a2	8b 4d f0	 mov	 ecx, DWORD PTR _retVal$[ebp]
  006a5	0b c8		 or	 ecx, eax
  006a7	89 4d f0	 mov	 DWORD PTR _retVal$[ebp], ecx
$L58559:

; 163  : 
; 164  : 		bitIndex++;

  006aa	8b 55 f4	 mov	 edx, DWORD PTR _bitIndex$[ebp]
  006ad	83 c2 01	 add	 edx, 1
  006b0	89 55 f4	 mov	 DWORD PTR _bitIndex$[ebp], edx

; 165  : 		bitGetIndex++;

  006b3	8b 45 f8	 mov	 eax, DWORD PTR _bitGetIndex$[ebp]
  006b6	83 c0 01	 add	 eax, 1
  006b9	89 45 f8	 mov	 DWORD PTR _bitGetIndex$[ebp], eax

; 166  : 
; 167  : 		if ( bitGetIndex == 8 ) {

  006bc	83 7d f8 08	 cmp	 DWORD PTR _bitGetIndex$[ebp], 8
  006c0	75 10		 jne	 SHORT $L58560

; 168  : 			getIndex++;

  006c2	8b 4d fc	 mov	 ecx, DWORD PTR _getIndex$[ebp]
  006c5	83 c1 01	 add	 ecx, 1
  006c8	89 4d fc	 mov	 DWORD PTR _getIndex$[ebp], ecx

; 169  : 			bitGetIndex = 0;

  006cb	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _bitGetIndex$[ebp], 0
$L58560:

; 171  : 	}

  006d2	eb 95		 jmp	 SHORT $L58557
$L58558:

; 172  : 
; 173  : 	_object.SetProperty ( s_bitGetIndex, bitGetIndex );

  006d4	66 8b 55 f8	 mov	 dx, WORD PTR _bitGetIndex$[ebp]
  006d8	52		 push	 edx
  006d9	68 90 00 00 00	 push	 144			; 00000090H
  006de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  006e1	83 c1 06	 add	 ecx, 6
  006e4	e8 00 00 00 00	 call	 ?SetProperty@ObjectID@@QBEXGF@Z ; ObjectID::SetProperty

; 174  : 	_object.SetProperty ( s_getIndex, getIndex );

  006e9	66 8b 45 fc	 mov	 ax, WORD PTR _getIndex$[ebp]
  006ed	50		 push	 eax
  006ee	68 8e 00 00 00	 push	 142			; 0000008eH
  006f3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  006f6	83 c1 06	 add	 ecx, 6
  006f9	e8 00 00 00 00	 call	 ?SetProperty@ObjectID@@QBEXGF@Z ; ObjectID::SetProperty

; 175  : 
; 176  : 	return retVal;

  006fe	8b 45 f0	 mov	 eax, DWORD PTR _retVal$[ebp]

; 177  : }

  00701	8b e5		 mov	 esp, ebp
  00703	5d		 pop	 ebp
  00704	c2 04 00	 ret	 4
?getBits@PackedData@@QAEHH@Z ENDP			; PackedData::getBits
_TEXT	ENDS
PUBLIC	?SetProperty@Object@@QAEXGF@Z			; Object::SetProperty
;	COMDAT ?SetProperty@ObjectID@@QBEXGF@Z
_TEXT	SEGMENT
_selector$ = 8
_value$ = 12
_this$ = -4
?SetProperty@ObjectID@@QBEXGF@Z PROC NEAR		; ObjectID::SetProperty, COMDAT

; 340  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 341  : 		//	set a property given a selector
; 342  : 		AssureValid();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?AssureValid@ObjectID@@QBEXXZ ; ObjectID::AssureValid

; 343  : 		(*this)->SetProperty(selector, value);

  0000f	66 8b 45 0c	 mov	 ax, WORD PTR _value$[ebp]
  00013	50		 push	 eax
  00014	66 8b 4d 08	 mov	 cx, WORD PTR _selector$[ebp]
  00018	51		 push	 ecx
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  00021	8b c8		 mov	 ecx, eax
  00023	e8 00 00 00 00	 call	 ?SetProperty@Object@@QAEXGF@Z ; Object::SetProperty

; 344  : 	}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?SetProperty@ObjectID@@QBEXGF@Z ENDP			; ObjectID::SetProperty
_TEXT	ENDS
;	COMDAT ?SetProperty@Object@@QAEXGF@Z
_TEXT	SEGMENT
_selector$ = 8
_value$ = 12
_this$ = -12
_property$ = -8
_index$ = -4
?SetProperty@Object@@QAEXGF@Z PROC NEAR			; Object::SetProperty, COMDAT

; 206  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		//	set a property given a selector
; 208  : 		Property* property = GetPropAddrCheck(selector);

  00009	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?GetPropAddrCheck@Object@@QAEPAFG@Z ; Object::GetPropAddrCheck
  00016	89 45 f8	 mov	 DWORD PTR _property$[ebp], eax

; 209  : 		int index = property - (Property*) this;

  00019	8b 4d f8	 mov	 ecx, DWORD PTR _property$[ebp]
  0001c	2b 4d f4	 sub	 ecx, DWORD PTR _this$[ebp]
  0001f	d1 f9		 sar	 ecx, 1
  00021	89 4d fc	 mov	 DWORD PTR _index$[ebp], ecx

; 210  : 		if (index <= MaxGraphUpdateIndex && index >= MinGraphUpdateIndex)

  00024	83 7d fc 2b	 cmp	 DWORD PTR _index$[ebp], 43 ; 0000002bH
  00028	7f 0e		 jg	 SHORT $L57437
  0002a	83 7d fc 18	 cmp	 DWORD PTR _index$[ebp], 24 ; 00000018H
  0002e	7c 08		 jl	 SHORT $L57437

; 211  : 			SetGraphicsUpdate();

  00030	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?SetGraphicsUpdate@Object@@QAEXXZ ; Object::SetGraphicsUpdate
$L57437:

; 212  : 		*property = value;

  00038	8b 55 f8	 mov	 edx, DWORD PTR _property$[ebp]
  0003b	66 8b 45 0c	 mov	 ax, WORD PTR _value$[ebp]
  0003f	66 89 02	 mov	 WORD PTR [edx], ax

; 213  : 	}

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 08 00	 ret	 8
?SetProperty@Object@@QAEXGF@Z ENDP			; Object::SetProperty
_TEXT	ENDS
EXTRN	?at@Array@@QAEXHH@Z:NEAR			; Array::at
_TEXT	SEGMENT
_value$ = 8
_numBits$ = 12
_this$ = -24
_bitPutIndex$ = -8
_putIndex$ = -12
_bitIndex$ = -16
_val$ = -4
_mask$58575 = -20
?putBits@PackedData@@QAEXHH@Z PROC NEAR			; PackedData::putBits

; 180  : {

  00707	55		 push	 ebp
  00708	8b ec		 mov	 ebp, esp
  0070a	83 ec 18	 sub	 esp, 24			; 00000018H
  0070d	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 181  : 	int bitPutIndex = (int)_object.GetProperty ( s_bitPutIndex );

  00710	68 91 00 00 00	 push	 145			; 00000091H
  00715	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00718	83 c1 06	 add	 ecx, 6
  0071b	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  00720	0f bf c0	 movsx	 eax, ax
  00723	89 45 f8	 mov	 DWORD PTR _bitPutIndex$[ebp], eax

; 182  : 	int putIndex = (int)_object.GetProperty ( s_putIndex );

  00726	68 8f 00 00 00	 push	 143			; 0000008fH
  0072b	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0072e	83 c1 06	 add	 ecx, 6
  00731	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  00736	0f bf c8	 movsx	 ecx, ax
  00739	89 4d f4	 mov	 DWORD PTR _putIndex$[ebp], ecx

; 183  : 
; 184  : 	int bitIndex = 0;

  0073c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _bitIndex$[ebp], 0

; 185  : 	int val = _array.at ( putIndex );

  00743	8b 55 f4	 mov	 edx, DWORD PTR _putIndex$[ebp]
  00746	52		 push	 edx
  00747	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0074a	83 c1 04	 add	 ecx, 4
  0074d	e8 00 00 00 00	 call	 ?at@Array@@QAEHH@Z	; Array::at
  00752	89 45 fc	 mov	 DWORD PTR _val$[ebp], eax
$L58573:

; 186  : 
; 187  : 	while ( numBits-- ) {

  00755	8b 45 0c	 mov	 eax, DWORD PTR _numBits$[ebp]
  00758	8b 4d 0c	 mov	 ecx, DWORD PTR _numBits$[ebp]
  0075b	83 e9 01	 sub	 ecx, 1
  0075e	89 4d 0c	 mov	 DWORD PTR _numBits$[ebp], ecx
  00761	85 c0		 test	 eax, eax
  00763	0f 84 8a 00 00
	00		 je	 $L58574

; 188  : 		int mask = 1 << bitPutIndex;

  00769	ba 01 00 00 00	 mov	 edx, 1
  0076e	8b 4d f8	 mov	 ecx, DWORD PTR _bitPutIndex$[ebp]
  00771	d3 e2		 shl	 edx, cl
  00773	89 55 ec	 mov	 DWORD PTR _mask$58575[ebp], edx

; 189  : 
; 190  : 		if ( value & (1 << bitIndex) ) {

  00776	b8 01 00 00 00	 mov	 eax, 1
  0077b	8b 4d f0	 mov	 ecx, DWORD PTR _bitIndex$[ebp]
  0077e	d3 e0		 shl	 eax, cl
  00780	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  00783	23 c8		 and	 ecx, eax
  00785	85 c9		 test	 ecx, ecx
  00787	74 0b		 je	 SHORT $L58576

; 191  : 			val |= mask;

  00789	8b 55 fc	 mov	 edx, DWORD PTR _val$[ebp]
  0078c	0b 55 ec	 or	 edx, DWORD PTR _mask$58575[ebp]
  0078f	89 55 fc	 mov	 DWORD PTR _val$[ebp], edx

; 192  : 		} else {

  00792	eb 0d		 jmp	 SHORT $L58577
$L58576:

; 193  : 			val &= ~mask;

  00794	8b 45 ec	 mov	 eax, DWORD PTR _mask$58575[ebp]
  00797	f7 d0		 not	 eax
  00799	8b 4d fc	 mov	 ecx, DWORD PTR _val$[ebp]
  0079c	23 c8		 and	 ecx, eax
  0079e	89 4d fc	 mov	 DWORD PTR _val$[ebp], ecx
$L58577:

; 195  : 
; 196  : 		bitIndex++;

  007a1	8b 55 f0	 mov	 edx, DWORD PTR _bitIndex$[ebp]
  007a4	83 c2 01	 add	 edx, 1
  007a7	89 55 f0	 mov	 DWORD PTR _bitIndex$[ebp], edx

; 197  : 		bitPutIndex++;

  007aa	8b 45 f8	 mov	 eax, DWORD PTR _bitPutIndex$[ebp]
  007ad	83 c0 01	 add	 eax, 1
  007b0	89 45 f8	 mov	 DWORD PTR _bitPutIndex$[ebp], eax

; 198  : 
; 199  : 		if ( bitPutIndex == 8 ) {

  007b3	83 7d f8 08	 cmp	 DWORD PTR _bitPutIndex$[ebp], 8
  007b7	75 35		 jne	 SHORT $L58578

; 200  : 			_array.at ( putIndex, val );

  007b9	8b 4d fc	 mov	 ecx, DWORD PTR _val$[ebp]
  007bc	51		 push	 ecx
  007bd	8b 55 f4	 mov	 edx, DWORD PTR _putIndex$[ebp]
  007c0	52		 push	 edx
  007c1	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  007c4	83 c1 04	 add	 ecx, 4
  007c7	e8 00 00 00 00	 call	 ?at@Array@@QAEXHH@Z	; Array::at

; 201  : 			putIndex++;

  007cc	8b 45 f4	 mov	 eax, DWORD PTR _putIndex$[ebp]
  007cf	83 c0 01	 add	 eax, 1
  007d2	89 45 f4	 mov	 DWORD PTR _putIndex$[ebp], eax

; 202  : 			val = _array.at ( putIndex );

  007d5	8b 4d f4	 mov	 ecx, DWORD PTR _putIndex$[ebp]
  007d8	51		 push	 ecx
  007d9	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  007dc	83 c1 04	 add	 ecx, 4
  007df	e8 00 00 00 00	 call	 ?at@Array@@QAEHH@Z	; Array::at
  007e4	89 45 fc	 mov	 DWORD PTR _val$[ebp], eax

; 203  : 
; 204  : 			bitPutIndex = 0;

  007e7	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _bitPutIndex$[ebp], 0
$L58578:

; 206  : 	}

  007ee	e9 62 ff ff ff	 jmp	 $L58573
$L58574:

; 207  : 
; 208  : 	_array.at ( putIndex, val );

  007f3	8b 55 fc	 mov	 edx, DWORD PTR _val$[ebp]
  007f6	52		 push	 edx
  007f7	8b 45 f4	 mov	 eax, DWORD PTR _putIndex$[ebp]
  007fa	50		 push	 eax
  007fb	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  007fe	83 c1 04	 add	 ecx, 4
  00801	e8 00 00 00 00	 call	 ?at@Array@@QAEXHH@Z	; Array::at

; 209  : 
; 210  : 	_object.SetProperty ( s_bitPutIndex, bitPutIndex );

  00806	66 8b 4d f8	 mov	 cx, WORD PTR _bitPutIndex$[ebp]
  0080a	51		 push	 ecx
  0080b	68 91 00 00 00	 push	 145			; 00000091H
  00810	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00813	83 c1 06	 add	 ecx, 6
  00816	e8 00 00 00 00	 call	 ?SetProperty@ObjectID@@QBEXGF@Z ; ObjectID::SetProperty

; 211  : 	_object.SetProperty ( s_putIndex, putIndex );

  0081b	66 8b 55 f4	 mov	 dx, WORD PTR _putIndex$[ebp]
  0081f	52		 push	 edx
  00820	68 8f 00 00 00	 push	 143			; 0000008fH
  00825	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00828	83 c1 06	 add	 ecx, 6
  0082b	e8 00 00 00 00	 call	 ?SetProperty@ObjectID@@QBEXGF@Z ; ObjectID::SetProperty

; 212  : }

  00830	8b e5		 mov	 esp, ebp
  00832	5d		 pop	 ebp
  00833	c2 08 00	 ret	 8
?putBits@PackedData@@QAEXHH@Z ENDP			; PackedData::putBits
_this$ = -12
_bitGetIndex$ = -8
_getIndex$ = -4
?getByte@PackedData@@QAEEXZ PROC NEAR			; PackedData::getByte

; 215  : {

  00836	55		 push	 ebp
  00837	8b ec		 mov	 ebp, esp
  00839	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0083c	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 216  : 	int bitGetIndex = (int)_object.GetProperty ( s_bitGetIndex );

  0083f	68 90 00 00 00	 push	 144			; 00000090H
  00844	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00847	83 c1 06	 add	 ecx, 6
  0084a	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  0084f	0f bf c0	 movsx	 eax, ax
  00852	89 45 f8	 mov	 DWORD PTR _bitGetIndex$[ebp], eax

; 217  : 
; 218  : 	if ( bitGetIndex )

  00855	83 7d f8 00	 cmp	 DWORD PTR _bitGetIndex$[ebp], 0
  00859	74 0c		 je	 SHORT $L58585

; 219  : 		return (unsigned char)getBits ( 8 );

  0085b	6a 08		 push	 8
  0085d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00860	e8 00 00 00 00	 call	 ?getBits@PackedData@@QAEHH@Z ; PackedData::getBits
  00865	eb 3e		 jmp	 SHORT $L58582
$L58585:

; 220  : 
; 221  : 	int getIndex = (int)(unsigned short)_object.GetProperty ( s_getIndex );

  00867	68 8e 00 00 00	 push	 142			; 0000008eH
  0086c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0086f	83 c1 06	 add	 ecx, 6
  00872	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  00877	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0087c	89 45 fc	 mov	 DWORD PTR _getIndex$[ebp], eax

; 222  : 	_object.SetProperty ( s_getIndex, getIndex + 1 );

  0087f	8b 4d fc	 mov	 ecx, DWORD PTR _getIndex$[ebp]
  00882	83 c1 01	 add	 ecx, 1
  00885	51		 push	 ecx
  00886	68 8e 00 00 00	 push	 142			; 0000008eH
  0088b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0088e	83 c1 06	 add	 ecx, 6
  00891	e8 00 00 00 00	 call	 ?SetProperty@ObjectID@@QBEXGF@Z ; ObjectID::SetProperty

; 223  : 
; 224  : 	return (unsigned char)_array.at ( getIndex );

  00896	8b 55 fc	 mov	 edx, DWORD PTR _getIndex$[ebp]
  00899	52		 push	 edx
  0089a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0089d	83 c1 04	 add	 ecx, 4
  008a0	e8 00 00 00 00	 call	 ?at@Array@@QAEHH@Z	; Array::at
$L58582:

; 225  : }

  008a5	8b e5		 mov	 esp, ebp
  008a7	5d		 pop	 ebp
  008a8	c3		 ret	 0
?getByte@PackedData@@QAEEXZ ENDP			; PackedData::getByte
_value$ = 8
_this$ = -12
_bitPutIndex$ = -4
_putIndex$58599 = -8
?putByte@PackedData@@QAEXE@Z PROC NEAR			; PackedData::putByte

; 228  : {

  008a9	55		 push	 ebp
  008aa	8b ec		 mov	 ebp, esp
  008ac	83 ec 0c	 sub	 esp, 12			; 0000000cH
  008af	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 229  : 	int bitPutIndex = (int)_object.GetProperty ( s_bitPutIndex );

  008b2	68 91 00 00 00	 push	 145			; 00000091H
  008b7	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  008ba	83 c1 06	 add	 ecx, 6
  008bd	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  008c2	0f bf c0	 movsx	 eax, ax
  008c5	89 45 fc	 mov	 DWORD PTR _bitPutIndex$[ebp], eax

; 230  : 
; 231  : 	if ( bitPutIndex ) {

  008c8	83 7d fc 00	 cmp	 DWORD PTR _bitPutIndex$[ebp], 0
  008cc	74 16		 je	 SHORT $L58597

; 232  : 		putBits ( value, 8 );

  008ce	6a 08		 push	 8
  008d0	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  008d3	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  008d9	51		 push	 ecx
  008da	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  008dd	e8 00 00 00 00	 call	 ?putBits@PackedData@@QAEXHH@Z ; PackedData::putBits

; 233  : 	} else {

  008e2	eb 46		 jmp	 SHORT $L58598
$L58597:

; 234  : 		int putIndex = (int)_object.GetProperty ( s_putIndex );

  008e4	68 8f 00 00 00	 push	 143			; 0000008fH
  008e9	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  008ec	83 c1 06	 add	 ecx, 6
  008ef	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  008f4	0f bf d0	 movsx	 edx, ax
  008f7	89 55 f8	 mov	 DWORD PTR _putIndex$58599[ebp], edx

; 235  : 		_object.SetProperty ( s_putIndex, putIndex + 1 );

  008fa	8b 45 f8	 mov	 eax, DWORD PTR _putIndex$58599[ebp]
  008fd	83 c0 01	 add	 eax, 1
  00900	50		 push	 eax
  00901	68 8f 00 00 00	 push	 143			; 0000008fH
  00906	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00909	83 c1 06	 add	 ecx, 6
  0090c	e8 00 00 00 00	 call	 ?SetProperty@ObjectID@@QBEXGF@Z ; ObjectID::SetProperty

; 236  : 		
; 237  : 		_array.at ( putIndex, value );

  00911	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  00914	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0091a	51		 push	 ecx
  0091b	8b 55 f8	 mov	 edx, DWORD PTR _putIndex$58599[ebp]
  0091e	52		 push	 edx
  0091f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00922	83 c1 04	 add	 ecx, 4
  00925	e8 00 00 00 00	 call	 ?at@Array@@QAEXHH@Z	; Array::at
$L58598:

; 239  : }

  0092a	8b e5		 mov	 esp, ebp
  0092c	5d		 pop	 ebp
  0092d	c2 04 00	 ret	 4
?putByte@PackedData@@QAEXE@Z ENDP			; PackedData::putByte
_this$ = -4
?getWord@PackedData@@QAEFXZ PROC NEAR			; PackedData::getWord

; 242  : {

  00930	55		 push	 ebp
  00931	8b ec		 mov	 ebp, esp
  00933	51		 push	 ecx
  00934	53		 push	 ebx
  00935	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 243  : //endian	return (short)((getByte() << 8) | getByte());
; 244  : 	return (short) ( getByte() | (getByte() << 8) );

  00938	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0093b	e8 00 00 00 00	 call	 ?getByte@PackedData@@QAEEXZ ; PackedData::getByte
  00940	8a d8		 mov	 bl, al
  00942	81 e3 ff 00 00
	00		 and	 ebx, 255		; 000000ffH
  00948	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0094b	e8 00 00 00 00	 call	 ?getByte@PackedData@@QAEEXZ ; PackedData::getByte
  00950	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00955	c1 e0 08	 shl	 eax, 8
  00958	0b d8		 or	 ebx, eax
  0095a	66 8b c3	 mov	 ax, bx

; 245  : }

  0095d	5b		 pop	 ebx
  0095e	8b e5		 mov	 esp, ebp
  00960	5d		 pop	 ebp
  00961	c3		 ret	 0
?getWord@PackedData@@QAEFXZ ENDP			; PackedData::getWord
_value$ = 8
_this$ = -4
?putWord@PackedData@@QAEXF@Z PROC NEAR			; PackedData::putWord

; 248  : {

  00962	55		 push	 ebp
  00963	8b ec		 mov	 ebp, esp
  00965	51		 push	 ecx
  00966	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 249  : //endian	putByte ( (value & 0xFF00) >> 8 );
; 250  : //endian	putByte ( (value & 0x00FF) );
; 251  : 	putByte ( (value & 0x00FF) );

  00969	0f bf 45 08	 movsx	 eax, WORD PTR _value$[ebp]
  0096d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00972	50		 push	 eax
  00973	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00976	e8 00 00 00 00	 call	 ?putByte@PackedData@@QAEXE@Z ; PackedData::putByte

; 252  : 	putByte ( (value & 0xFF00) >> 8 );

  0097b	0f bf 4d 08	 movsx	 ecx, WORD PTR _value$[ebp]
  0097f	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00985	c1 f9 08	 sar	 ecx, 8
  00988	51		 push	 ecx
  00989	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0098c	e8 00 00 00 00	 call	 ?putByte@PackedData@@QAEXE@Z ; PackedData::putByte

; 253  : }

  00991	8b e5		 mov	 esp, ebp
  00993	5d		 pop	 ebp
  00994	c2 04 00	 ret	 4
?putWord@PackedData@@QAEXF@Z ENDP			; PackedData::putWord
_this$ = -4
?getLong@PackedData@@QAEHXZ PROC NEAR			; PackedData::getLong

; 256  : {

  00997	55		 push	 ebp
  00998	8b ec		 mov	 ebp, esp
  0099a	51		 push	 ecx
  0099b	53		 push	 ebx
  0099c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 257  : //endian	return (int)((getByte() << 24) | (getByte() << 16) | (getByte() << 8) | getByte());
; 258  : 	return (int) (getByte() | (getByte() << 8) | (getByte() << 16) | (getByte() << 24) );

  0099f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  009a2	e8 00 00 00 00	 call	 ?getByte@PackedData@@QAEEXZ ; PackedData::getByte
  009a7	8a d8		 mov	 bl, al
  009a9	81 e3 ff 00 00
	00		 and	 ebx, 255		; 000000ffH
  009af	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  009b2	e8 00 00 00 00	 call	 ?getByte@PackedData@@QAEEXZ ; PackedData::getByte
  009b7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  009bc	c1 e0 08	 shl	 eax, 8
  009bf	0b d8		 or	 ebx, eax
  009c1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  009c4	e8 00 00 00 00	 call	 ?getByte@PackedData@@QAEEXZ ; PackedData::getByte
  009c9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  009ce	c1 e0 10	 shl	 eax, 16			; 00000010H
  009d1	0b d8		 or	 ebx, eax
  009d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  009d6	e8 00 00 00 00	 call	 ?getByte@PackedData@@QAEEXZ ; PackedData::getByte
  009db	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  009e0	c1 e0 18	 shl	 eax, 24			; 00000018H
  009e3	0b c3		 or	 eax, ebx

; 259  : }

  009e5	5b		 pop	 ebx
  009e6	8b e5		 mov	 esp, ebp
  009e8	5d		 pop	 ebp
  009e9	c3		 ret	 0
?getLong@PackedData@@QAEHXZ ENDP			; PackedData::getLong
_value$ = 8
_this$ = -4
?putLong@PackedData@@QAEXH@Z PROC NEAR			; PackedData::putLong

; 262  : {

  009ea	55		 push	 ebp
  009eb	8b ec		 mov	 ebp, esp
  009ed	51		 push	 ecx
  009ee	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 263  : //endian	putByte ( (value & 0xFF000000) >> 24 );
; 264  : //endian	putByte ( (value & 0x00FF0000) >> 16 );
; 265  : //endian	putByte ( (value & 0x0000FF00) >> 8 );
; 266  : //endian	putByte ( (value & 0x000000FF) );
; 267  : 	putByte ( (value & 0x000000FF) );

  009f1	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  009f4	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  009f9	50		 push	 eax
  009fa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  009fd	e8 00 00 00 00	 call	 ?putByte@PackedData@@QAEXE@Z ; PackedData::putByte

; 268  : 	putByte ( (value & 0x0000FF00) >> 8 );

  00a02	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  00a05	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00a0b	c1 f9 08	 sar	 ecx, 8
  00a0e	51		 push	 ecx
  00a0f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a12	e8 00 00 00 00	 call	 ?putByte@PackedData@@QAEXE@Z ; PackedData::putByte

; 269  : 	putByte ( (value & 0x00FF0000) >> 16 );

  00a17	8b 55 08	 mov	 edx, DWORD PTR _value$[ebp]
  00a1a	81 e2 00 00 ff
	00		 and	 edx, 16711680		; 00ff0000H
  00a20	c1 fa 10	 sar	 edx, 16			; 00000010H
  00a23	52		 push	 edx
  00a24	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a27	e8 00 00 00 00	 call	 ?putByte@PackedData@@QAEXE@Z ; PackedData::putByte

; 270  : 	putByte ( (value & 0xFF000000) >> 24 );

  00a2c	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  00a2f	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00a34	c1 e8 18	 shr	 eax, 24			; 00000018H
  00a37	50		 push	 eax
  00a38	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a3b	e8 00 00 00 00	 call	 ?putByte@PackedData@@QAEXE@Z ; PackedData::putByte

; 271  : }

  00a40	8b e5		 mov	 esp, ebp
  00a42	5d		 pop	 ebp
  00a43	c2 04 00	 ret	 4
?putLong@PackedData@@QAEXH@Z ENDP			; PackedData::putLong
_TEXT	ENDS
PUBLIC	?Get@TextID@@QAEXII@Z				; TextID::Get
EXTRN	_memcpy:NEAR
EXTRN	??0TextID@@QAE@XZ:NEAR				; TextID::TextID
EXTRN	?calcAddress@Array@@QAEPAXH@Z:NEAR		; Array::calcAddress
_TEXT	SEGMENT
_len$ = 12
___$ReturnUdt$ = 8
_this$ = -24
_bitGetIndex$ = -12
_text$ = -8
_ptr$ = -4
_getIndex$58634 = -16
_start$58637 = -20
?getString@PackedData@@QAE?AVTextID@@H@Z PROC NEAR	; PackedData::getString

; 274  : {

  00a46	55		 push	 ebp
  00a47	8b ec		 mov	 ebp, esp
  00a49	83 ec 18	 sub	 esp, 24			; 00000018H
  00a4c	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 275  : 	int bitGetIndex = (int)_object.GetProperty ( s_bitGetIndex );

  00a4f	68 90 00 00 00	 push	 144			; 00000090H
  00a54	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a57	83 c1 06	 add	 ecx, 6
  00a5a	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  00a5f	0f bf c0	 movsx	 eax, ax
  00a62	89 45 f4	 mov	 DWORD PTR _bitGetIndex$[ebp], eax

; 276  : 
; 277  : 	if ( !len )

  00a65	83 7d 0c 00	 cmp	 DWORD PTR _len$[ebp], 0
  00a69	75 0e		 jne	 SHORT $L58626

; 278  : 		len = getWord();

  00a6b	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a6e	e8 00 00 00 00	 call	 ?getWord@PackedData@@QAEFXZ ; PackedData::getWord
  00a73	0f bf c8	 movsx	 ecx, ax
  00a76	89 4d 0c	 mov	 DWORD PTR _len$[ebp], ecx
$L58626:

; 279  : 
; 280  : 	TextID text;

  00a79	8d 4d f8	 lea	 ecx, DWORD PTR _text$[ebp]
  00a7c	e8 00 00 00 00	 call	 ??0TextID@@QAE@XZ	; TextID::TextID

; 281  : 	text.Get ( len + 1 );

  00a81	68 00 02 01 00	 push	 66048			; 00010200H
  00a86	8b 55 0c	 mov	 edx, DWORD PTR _len$[ebp]
  00a89	83 c2 01	 add	 edx, 1
  00a8c	52		 push	 edx
  00a8d	8d 4d f8	 lea	 ecx, DWORD PTR _text$[ebp]
  00a90	e8 00 00 00 00	 call	 ?Get@TextID@@QAEXII@Z	; TextID::Get

; 282  : 
; 283  : 	char *ptr = *text;

  00a95	8d 4d f8	 lea	 ecx, DWORD PTR _text$[ebp]
  00a98	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  00a9d	89 45 fc	 mov	 DWORD PTR _ptr$[ebp], eax

; 284  : 
; 285  : 	if ( bitGetIndex ) {

  00aa0	83 7d f4 00	 cmp	 DWORD PTR _bitGetIndex$[ebp], 0
  00aa4	74 39		 je	 SHORT $L58629
$L58631:

; 286  : 		while ( len-- )

  00aa6	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00aa9	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp]
  00aac	83 e9 01	 sub	 ecx, 1
  00aaf	89 4d 0c	 mov	 DWORD PTR _len$[ebp], ecx
  00ab2	85 c0		 test	 eax, eax
  00ab4	74 18		 je	 SHORT $L58632

; 287  : 			*ptr++ = getByte();

  00ab6	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00ab9	e8 00 00 00 00	 call	 ?getByte@PackedData@@QAEEXZ ; PackedData::getByte
  00abe	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  00ac1	88 02		 mov	 BYTE PTR [edx], al
  00ac3	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  00ac6	83 c0 01	 add	 eax, 1
  00ac9	89 45 fc	 mov	 DWORD PTR _ptr$[ebp], eax
  00acc	eb d8		 jmp	 SHORT $L58631
$L58632:

; 288  : 
; 289  : 		*ptr++ = 0;

  00ace	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00ad1	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00ad4	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  00ad7	83 c2 01	 add	 edx, 1
  00ada	89 55 fc	 mov	 DWORD PTR _ptr$[ebp], edx

; 290  : 
; 291  : 	} else {

  00add	eb 65		 jmp	 SHORT $L58633
$L58629:

; 292  : 		int getIndex = (int)(unsigned short)_object.GetProperty ( s_getIndex );

  00adf	68 8e 00 00 00	 push	 142			; 0000008eH
  00ae4	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00ae7	83 c1 06	 add	 ecx, 6
  00aea	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  00aef	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00af4	89 45 f0	 mov	 DWORD PTR _getIndex$58634[ebp], eax

; 293  : 		char *start = (char *)_array.calcAddress ( getIndex );

  00af7	8b 45 f0	 mov	 eax, DWORD PTR _getIndex$58634[ebp]
  00afa	50		 push	 eax
  00afb	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00afe	83 c1 04	 add	 ecx, 4
  00b01	e8 00 00 00 00	 call	 ?calcAddress@Array@@QAEPAXH@Z ; Array::calcAddress
  00b06	89 45 ec	 mov	 DWORD PTR _start$58637[ebp], eax

; 294  : 
; 295  : 		memcpy ( ptr, start, len );

  00b09	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp]
  00b0c	51		 push	 ecx
  00b0d	8b 55 ec	 mov	 edx, DWORD PTR _start$58637[ebp]
  00b10	52		 push	 edx
  00b11	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  00b14	50		 push	 eax
  00b15	e8 00 00 00 00	 call	 _memcpy
  00b1a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 296  : 		ptr[len] = 0;

  00b1d	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00b20	03 4d 0c	 add	 ecx, DWORD PTR _len$[ebp]
  00b23	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 297  : 
; 298  : 		getIndex += len;

  00b26	8b 55 f0	 mov	 edx, DWORD PTR _getIndex$58634[ebp]
  00b29	03 55 0c	 add	 edx, DWORD PTR _len$[ebp]
  00b2c	89 55 f0	 mov	 DWORD PTR _getIndex$58634[ebp], edx

; 299  : 		_object.SetProperty ( s_getIndex, getIndex );

  00b2f	66 8b 45 f0	 mov	 ax, WORD PTR _getIndex$58634[ebp]
  00b33	50		 push	 eax
  00b34	68 8e 00 00 00	 push	 142			; 0000008eH
  00b39	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b3c	83 c1 06	 add	 ecx, 6
  00b3f	e8 00 00 00 00	 call	 ?SetProperty@ObjectID@@QBEXGF@Z ; ObjectID::SetProperty
$L58633:

; 301  : 
; 302  : 	return text;

  00b44	8d 4d f8	 lea	 ecx, DWORD PTR _text$[ebp]
  00b47	51		 push	 ecx
  00b48	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00b4b	e8 00 00 00 00	 call	 ??0TextID@@QAE@ABV0@@Z	; TextID::TextID
  00b50	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 303  : }

  00b53	8b e5		 mov	 esp, ebp
  00b55	5d		 pop	 ebp
  00b56	c2 08 00	 ret	 8
?getString@PackedData@@QAE?AVTextID@@H@Z ENDP		; PackedData::getString
_TEXT	ENDS
PUBLIC	?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get
;	COMDAT ?Get@TextID@@QAEXII@Z
_TEXT	SEGMENT
_size$ = 8
_attrs$ = 12
_this$ = -4
?Get@TextID@@QAEXII@Z PROC NEAR				; TextID::Get, COMDAT

; 34   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 35   : 		MemID::Get(MemText, size, attrs);

  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 00		 push	 0
  0000f	8b 45 0c	 mov	 eax, DWORD PTR _attrs$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  00016	51		 push	 ecx
  00017	6a 33		 push	 51			; 00000033H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get

; 36   : 	}

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?Get@TextID@@QAEXII@Z ENDP				; TextID::Get
_TEXT	ENDS
EXTRN	?Alloc@MemoryMgr@@QAEGIIIPAUMemClient@@DW4ReservedHandle@@@Z:NEAR ; MemoryMgr::Alloc
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT
_type$ = 8
_size$ = 12
_a$ = 16
_num$ = 20
_client$ = 24
_initChar$ = 28
_h$ = 32
_this$ = -4
?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z PROC NEAR ; MemID::Get, COMDAT

; 42   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 43   : 		handle = memMgr->Alloc(type | a, size, num, client, initChar, h);

  00007	8b 45 20	 mov	 eax, DWORD PTR _h$[ebp]
  0000a	50		 push	 eax
  0000b	8a 4d 1c	 mov	 cl, BYTE PTR _initChar$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 18	 mov	 edx, DWORD PTR _client$[ebp]
  00012	52		 push	 edx
  00013	8b 45 14	 mov	 eax, DWORD PTR _num$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 55 08	 mov	 edx, DWORD PTR _type$[ebp]
  0001e	0b 55 10	 or	 edx, DWORD PTR _a$[ebp]
  00021	52		 push	 edx
  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00028	e8 00 00 00 00	 call	 ?Alloc@MemoryMgr@@QAEGIIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemoryMgr::Alloc
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	66 89 01	 mov	 WORD PTR [ecx], ax

; 44   : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 1c 00	 ret	 28			; 0000001cH
?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ENDP ; MemID::Get
_TEXT	ENDS
PUBLIC	?getCharString@PackedData@@QAEPADH@Z		; PackedData::getCharString
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
_TEXT	SEGMENT
_len$ = 8
_this$ = -28
_bitGetIndex$ = -8
_pText$ = -12
_ptr$ = -4
_getIndex$58655 = -16
_start$58658 = -20
$T58896 = -24
?getCharString@PackedData@@QAEPADH@Z PROC NEAR		; PackedData::getCharString

; 306  : {

  00b59	55		 push	 ebp
  00b5a	8b ec		 mov	 ebp, esp
  00b5c	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00b5f	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 307  : 	int bitGetIndex = (int)_object.GetProperty ( s_bitGetIndex );

  00b62	68 90 00 00 00	 push	 144			; 00000090H
  00b67	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00b6a	83 c1 06	 add	 ecx, 6
  00b6d	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  00b72	0f bf c0	 movsx	 eax, ax
  00b75	89 45 f8	 mov	 DWORD PTR _bitGetIndex$[ebp], eax

; 308  : 
; 309  : 	if ( !len )

  00b78	83 7d 08 00	 cmp	 DWORD PTR _len$[ebp], 0
  00b7c	75 0e		 jne	 SHORT $L58645

; 310  : 		len = getWord();

  00b7e	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00b81	e8 00 00 00 00	 call	 ?getWord@PackedData@@QAEFXZ ; PackedData::getWord
  00b86	0f bf c8	 movsx	 ecx, ax
  00b89	89 4d 08	 mov	 DWORD PTR _len$[ebp], ecx
$L58645:

; 311  : 
; 312  : 	char* pText = new char[ len + 1 ];

  00b8c	8b 55 08	 mov	 edx, DWORD PTR _len$[ebp]
  00b8f	83 c2 01	 add	 edx, 1
  00b92	52		 push	 edx
  00b93	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00b98	83 c4 04	 add	 esp, 4
  00b9b	89 45 e8	 mov	 DWORD PTR $T58896[ebp], eax
  00b9e	8b 45 e8	 mov	 eax, DWORD PTR $T58896[ebp]
  00ba1	89 45 f4	 mov	 DWORD PTR _pText$[ebp], eax

; 313  : 	char* ptr = pText;

  00ba4	8b 4d f4	 mov	 ecx, DWORD PTR _pText$[ebp]
  00ba7	89 4d fc	 mov	 DWORD PTR _ptr$[ebp], ecx

; 314  : 
; 315  : 	if ( bitGetIndex ) {

  00baa	83 7d f8 00	 cmp	 DWORD PTR _bitGetIndex$[ebp], 0
  00bae	74 39		 je	 SHORT $L58650
$L58652:

; 316  : 		while ( len-- )

  00bb0	8b 55 08	 mov	 edx, DWORD PTR _len$[ebp]
  00bb3	8b 45 08	 mov	 eax, DWORD PTR _len$[ebp]
  00bb6	83 e8 01	 sub	 eax, 1
  00bb9	89 45 08	 mov	 DWORD PTR _len$[ebp], eax
  00bbc	85 d2		 test	 edx, edx
  00bbe	74 18		 je	 SHORT $L58653

; 317  : 			*ptr++ = getByte();

  00bc0	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00bc3	e8 00 00 00 00	 call	 ?getByte@PackedData@@QAEEXZ ; PackedData::getByte
  00bc8	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00bcb	88 01		 mov	 BYTE PTR [ecx], al
  00bcd	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  00bd0	83 c2 01	 add	 edx, 1
  00bd3	89 55 fc	 mov	 DWORD PTR _ptr$[ebp], edx
  00bd6	eb d8		 jmp	 SHORT $L58652
$L58653:

; 318  : 
; 319  : 		*ptr++ = 0;

  00bd8	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  00bdb	c6 00 00	 mov	 BYTE PTR [eax], 0
  00bde	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00be1	83 c1 01	 add	 ecx, 1
  00be4	89 4d fc	 mov	 DWORD PTR _ptr$[ebp], ecx

; 320  : 
; 321  : 	} else {

  00be7	eb 65		 jmp	 SHORT $L58654
$L58650:

; 322  : 		int getIndex = (int)(unsigned short)_object.GetProperty ( s_getIndex );

  00be9	68 8e 00 00 00	 push	 142			; 0000008eH
  00bee	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00bf1	83 c1 06	 add	 ecx, 6
  00bf4	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  00bf9	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00bfe	89 45 f0	 mov	 DWORD PTR _getIndex$58655[ebp], eax

; 323  : 		char *start = (char *)_array.calcAddress ( getIndex );

  00c01	8b 55 f0	 mov	 edx, DWORD PTR _getIndex$58655[ebp]
  00c04	52		 push	 edx
  00c05	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00c08	83 c1 04	 add	 ecx, 4
  00c0b	e8 00 00 00 00	 call	 ?calcAddress@Array@@QAEPAXH@Z ; Array::calcAddress
  00c10	89 45 ec	 mov	 DWORD PTR _start$58658[ebp], eax

; 324  : 
; 325  : 		memcpy ( ptr, start, len );

  00c13	8b 45 08	 mov	 eax, DWORD PTR _len$[ebp]
  00c16	50		 push	 eax
  00c17	8b 4d ec	 mov	 ecx, DWORD PTR _start$58658[ebp]
  00c1a	51		 push	 ecx
  00c1b	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  00c1e	52		 push	 edx
  00c1f	e8 00 00 00 00	 call	 _memcpy
  00c24	83 c4 0c	 add	 esp, 12			; 0000000cH

; 326  : 		ptr[len] = 0;

  00c27	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  00c2a	03 45 08	 add	 eax, DWORD PTR _len$[ebp]
  00c2d	c6 00 00	 mov	 BYTE PTR [eax], 0

; 327  : 
; 328  : 		getIndex += len;

  00c30	8b 4d f0	 mov	 ecx, DWORD PTR _getIndex$58655[ebp]
  00c33	03 4d 08	 add	 ecx, DWORD PTR _len$[ebp]
  00c36	89 4d f0	 mov	 DWORD PTR _getIndex$58655[ebp], ecx

; 329  : 		_object.SetProperty ( s_getIndex, getIndex );

  00c39	66 8b 55 f0	 mov	 dx, WORD PTR _getIndex$58655[ebp]
  00c3d	52		 push	 edx
  00c3e	68 8e 00 00 00	 push	 142			; 0000008eH
  00c43	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00c46	83 c1 06	 add	 ecx, 6
  00c49	e8 00 00 00 00	 call	 ?SetProperty@ObjectID@@QBEXGF@Z ; ObjectID::SetProperty
$L58654:

; 331  : 
; 332  : 	return pText;

  00c4e	8b 45 f4	 mov	 eax, DWORD PTR _pText$[ebp]

; 333  : }

  00c51	8b e5		 mov	 esp, ebp
  00c53	5d		 pop	 ebp
  00c54	c2 04 00	 ret	 4
?getCharString@PackedData@@QAEPADH@Z ENDP		; PackedData::getCharString
_str$ = 8
_len$ = 12
_this$ = -4
?putString@PackedData@@QAEXPADH@Z PROC NEAR		; PackedData::putString

; 336  : {

  00c57	55		 push	 ebp
  00c58	8b ec		 mov	 ebp, esp
  00c5a	83 ec 08	 sub	 esp, 8
  00c5d	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 337  : 	putWord ( len );

  00c60	66 8b 45 0c	 mov	 ax, WORD PTR _len$[ebp]
  00c64	50		 push	 eax
  00c65	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c68	e8 00 00 00 00	 call	 ?putWord@PackedData@@QAEXF@Z ; PackedData::putWord
$L58666:

; 338  : 
; 339  : 	while ( len-- )

  00c6d	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp]
  00c70	8b 55 0c	 mov	 edx, DWORD PTR _len$[ebp]
  00c73	83 ea 01	 sub	 edx, 1
  00c76	89 55 0c	 mov	 DWORD PTR _len$[ebp], edx
  00c79	85 c9		 test	 ecx, ecx
  00c7b	74 1f		 je	 SHORT $L58667

; 340  : 		putByte ( *str++ );

  00c7d	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00c80	8a 08		 mov	 cl, BYTE PTR [eax]
  00c82	88 4d fb	 mov	 BYTE PTR -5+[ebp], cl
  00c85	8a 55 fb	 mov	 dl, BYTE PTR -5+[ebp]
  00c88	52		 push	 edx
  00c89	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00c8c	83 c0 01	 add	 eax, 1
  00c8f	89 45 08	 mov	 DWORD PTR _str$[ebp], eax
  00c92	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c95	e8 00 00 00 00	 call	 ?putByte@PackedData@@QAEXE@Z ; PackedData::putByte
  00c9a	eb d1		 jmp	 SHORT $L58666
$L58667:

; 341  : }

  00c9c	8b e5		 mov	 esp, ebp
  00c9e	5d		 pop	 ebp
  00c9f	c2 08 00	 ret	 8
?putString@PackedData@@QAEXPADH@Z ENDP			; PackedData::putString
_ptr$ = 8
_size$ = 12
_this$ = -4
?putArray@PackedData@@QAEXPAXH@Z PROC NEAR		; PackedData::putArray

; 344  : {

  00ca2	55		 push	 ebp
  00ca3	8b ec		 mov	 ebp, esp
  00ca5	51		 push	 ecx
  00ca6	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 345  : 	putString ( (char *)ptr, size );

  00ca9	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  00cac	50		 push	 eax
  00cad	8b 4d 08	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00cb0	51		 push	 ecx
  00cb1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00cb4	e8 00 00 00 00	 call	 ?putString@PackedData@@QAEXPADH@Z ; PackedData::putString

; 346  : }

  00cb9	8b e5		 mov	 esp, ebp
  00cbb	5d		 pop	 ebp
  00cbc	c2 08 00	 ret	 8
?putArray@PackedData@@QAEXPAXH@Z ENDP			; PackedData::putArray
_TEXT	ENDS
PUBLIC	?getArray@PackedData@@QAEXPADH@Z		; PackedData::getArray
_TEXT	SEGMENT
_ptr$ = 8
_len$ = 12
_this$ = -16
_bitGetIndex$ = -4
_getIndex$58687 = -8
_start$58690 = -12
?getArray@PackedData@@QAEXPADH@Z PROC NEAR		; PackedData::getArray

; 348  : void PackedData::getArray( char* ptr, int len ) {

  00cbf	55		 push	 ebp
  00cc0	8b ec		 mov	 ebp, esp
  00cc2	83 ec 10	 sub	 esp, 16			; 00000010H
  00cc5	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 349  : 	int bitGetIndex = (int)_object.GetProperty ( s_bitGetIndex );

  00cc8	68 90 00 00 00	 push	 144			; 00000090H
  00ccd	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00cd0	83 c1 06	 add	 ecx, 6
  00cd3	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  00cd8	0f bf c0	 movsx	 eax, ax
  00cdb	89 45 fc	 mov	 DWORD PTR _bitGetIndex$[ebp], eax

; 350  : 
; 351  : 	if ( !len )

  00cde	83 7d 0c 00	 cmp	 DWORD PTR _len$[ebp], 0
  00ce2	75 0e		 jne	 SHORT $L58681

; 352  : 		len = getWord();

  00ce4	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00ce7	e8 00 00 00 00	 call	 ?getWord@PackedData@@QAEFXZ ; PackedData::getWord
  00cec	0f bf c8	 movsx	 ecx, ax
  00cef	89 4d 0c	 mov	 DWORD PTR _len$[ebp], ecx
$L58681:

; 353  : 
; 354  : 	if ( bitGetIndex ) {

  00cf2	83 7d fc 00	 cmp	 DWORD PTR _bitGetIndex$[ebp], 0
  00cf6	74 2a		 je	 SHORT $L58682
$L58684:

; 355  : 		while ( len-- )

  00cf8	8b 55 0c	 mov	 edx, DWORD PTR _len$[ebp]
  00cfb	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00cfe	83 e8 01	 sub	 eax, 1
  00d01	89 45 0c	 mov	 DWORD PTR _len$[ebp], eax
  00d04	85 d2		 test	 edx, edx
  00d06	74 18		 je	 SHORT $L58685

; 356  : 			*ptr++ = getByte();

  00d08	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00d0b	e8 00 00 00 00	 call	 ?getByte@PackedData@@QAEEXZ ; PackedData::getByte
  00d10	8b 4d 08	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00d13	88 01		 mov	 BYTE PTR [ecx], al
  00d15	8b 55 08	 mov	 edx, DWORD PTR _ptr$[ebp]
  00d18	83 c2 01	 add	 edx, 1
  00d1b	89 55 08	 mov	 DWORD PTR _ptr$[ebp], edx
  00d1e	eb d8		 jmp	 SHORT $L58684
$L58685:

; 357  : 	} else {

  00d20	eb 5c		 jmp	 SHORT $L58686
$L58682:

; 358  : 		int getIndex = (int)(unsigned short)_object.GetProperty ( s_getIndex );

  00d22	68 8e 00 00 00	 push	 142			; 0000008eH
  00d27	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00d2a	83 c1 06	 add	 ecx, 6
  00d2d	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  00d32	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00d37	89 45 f8	 mov	 DWORD PTR _getIndex$58687[ebp], eax

; 359  : 		char *start = (char *)_array.calcAddress ( getIndex );

  00d3a	8b 45 f8	 mov	 eax, DWORD PTR _getIndex$58687[ebp]
  00d3d	50		 push	 eax
  00d3e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00d41	83 c1 04	 add	 ecx, 4
  00d44	e8 00 00 00 00	 call	 ?calcAddress@Array@@QAEPAXH@Z ; Array::calcAddress
  00d49	89 45 f4	 mov	 DWORD PTR _start$58690[ebp], eax

; 360  : 
; 361  : 		memcpy ( ptr, start, len );

  00d4c	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp]
  00d4f	51		 push	 ecx
  00d50	8b 55 f4	 mov	 edx, DWORD PTR _start$58690[ebp]
  00d53	52		 push	 edx
  00d54	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00d57	50		 push	 eax
  00d58	e8 00 00 00 00	 call	 _memcpy
  00d5d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 362  : 
; 363  : 		getIndex += len;

  00d60	8b 4d f8	 mov	 ecx, DWORD PTR _getIndex$58687[ebp]
  00d63	03 4d 0c	 add	 ecx, DWORD PTR _len$[ebp]
  00d66	89 4d f8	 mov	 DWORD PTR _getIndex$58687[ebp], ecx

; 364  : 		_object.SetProperty ( s_getIndex, getIndex );

  00d69	66 8b 55 f8	 mov	 dx, WORD PTR _getIndex$58687[ebp]
  00d6d	52		 push	 edx
  00d6e	68 8e 00 00 00	 push	 142			; 0000008eH
  00d73	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00d76	83 c1 06	 add	 ecx, 6
  00d79	e8 00 00 00 00	 call	 ?SetProperty@ObjectID@@QBEXGF@Z ; ObjectID::SetProperty
$L58686:

; 366  : }

  00d7e	8b e5		 mov	 esp, ebp
  00d80	5d		 pop	 ebp
  00d81	c2 08 00	 ret	 8
?getArray@PackedData@@QAEXPADH@Z ENDP			; PackedData::getArray
_TEXT	ENDS
END
