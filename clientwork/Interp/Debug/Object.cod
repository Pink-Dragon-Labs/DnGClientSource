	TITLE	C:\Documents and Settings\don\Desktop\sciw\Interp\Object.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07CCG@ResView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KCEF@?4v56?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06IAEF@ResPic?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04EODC@?4p56?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08OCKJ@ResChunk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PIPI@?4chk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07ICMB@ResHunk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GG@?4scr?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08BLBP@ResSound?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KPDA@?4snd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NNMB@ResVocab?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PGDD@?4voc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FLKK@ResPatch?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CEHK@?4pat?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07MKGC@ResFont?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04IDCK@?4fon?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06DEEM@ResPal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NJLC@?4pal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07HFNL@ResHeap?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GFFD@?4hep?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06HDCC@ResMsg?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JONM@?4msg?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NFDN@ResAudio?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MOHF@?4aud?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BKMJ@ResWave?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MPDF@?4wav?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@IMEI@ResAudio36?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BONB@ResSync?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KFFK@?4syn?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09CBJE@ResSync36?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06MIEL@ResMap?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CFLF@?4map?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@LIAH@ResMsgTranslation?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JFJA@?4trn?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08JLOL@ResRobot?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04LLKI@?4rbt?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06OEMP@ResVMD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04IOID@?4vmd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MemoryMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckValid@MemoryMgr@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GMemoryMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@MemID@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@V1@III@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AMemID@@QBEAADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8MemID@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??7MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeArrayID@@QBEPAUArrayHeader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ArrayID@@QAE@HW4ArrayType@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@ArrayID@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAE?AVMemID@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAEXVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_List@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@SOL_List@@QAEAAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeDispatchTblID@@QBEPAUDispatchTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeScriptEntryID@@QBEPAUScriptEntry@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntry@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeVariableID@@QBEPAUVariable@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Script@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CScriptID@@QBEPAUScript@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?selectorsSize@SelectorDict@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?offsetsSize@SelectorDict@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?scriptsSize@SelectorDict@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Object@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Info@Object@@QAEFXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGraphicsUpdate@Object@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?selectorDict@Object@@QAEPAVSelectorDict@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AObject@@QAEAAFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddr@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedPropAddr@Object@@QAEPBFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedProperty@Object@@QAEFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddrCheck@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@Object@@QAEFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropOffset@Object@@QAEIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetIndexedProperty@Object@@QAEXHF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetProperty@Object@@QAEXGF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@FakeObjectID@@QAEXIIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssureValid@ObjectID@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsObject@ObjectID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@ObjectID@@QBEFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Name@ObjectID@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RespondsTo@ObjectID@@QBEHG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetProperty@ObjectID@@QBEXGF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeClassTblID@@QBEPAUClassTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetExtension@SOL_ResType@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSupported@SOL_ResType@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAttrs@SOL_ResType@@UBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileType@SOL_ResType@@MBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResView@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPic@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResChunk@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResScript@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSound@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResVocab@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPatch@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResFont@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResPal@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResHeap@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMsg@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResAudio@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResWave@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResAudio36@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSync@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResSync36@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMap@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResMsgTranslation@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileType@ResMsgTranslation@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResRobot@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@ResVMD@@UBE?AW4MemType@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@SendStack@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Hide@SendStack@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Pop@SendStack@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PushObject@SendStack@@UAEXVObjectID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PushSelector@SendStack@@UAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Show@SendStack@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Toggle@SendStack@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Top@SendStack@@UAEPAUEntry@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DTextID@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StrGetData@@YA?AVTextID@@VMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TextID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GSelectorDict@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GObject@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7ResPic@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResView@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResPal@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResHeap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResWave@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResRobot@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResPatch@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMsgTranslation@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResScript@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSync36@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMsg@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResAudio36@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResAudio@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResFont@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResMap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7MemoryMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResVMD@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResChunk@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSync@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResVocab@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ResSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7SendStack@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?objInfo@@3PAVObjectInfo@@A			; objInfo
PUBLIC	?indexedPropertyOffsets@@3PAIA			; indexedPropertyOffsets
PUBLIC	?gSelectorDictSize@@3HA				; gSelectorDictSize
PUBLIC	?objectMgr@@3UObjectMgr@@A			; objectMgr
_BSS	SEGMENT
?objInfo@@3PAVObjectInfo@@A DD 01H DUP (?)		; objInfo
?indexedPropertyOffsets@@3PAIA DD 04cH DUP (?)		; indexedPropertyOffsets
?gSelectorDictSize@@3HA DD 01H DUP (?)			; gSelectorDictSize
?objectMgr@@3UObjectMgr@@A DB 01H DUP (?)		; objectMgr
_BSS	ENDS
PUBLIC	??0SelectorDict@@QAE@XZ				; SelectorDict::SelectorDict
PUBLIC	??0Object@@QAE@VMemID@@0II@Z			; Object::Object
PUBLIC	?AddToObjects@Object@@QAEXXZ			; Object::AddToObjects
PUBLIC	??0MemID@@QAE@XZ				; MemID::MemID
PUBLIC	?IsValid@MemID@@QBEHXZ				; MemID::IsValid
PUBLIC	??BMemID@@QBEGXZ				; MemID::operator unsigned short
PUBLIC	??AMemID@@QBEAADI@Z				; MemID::operator[]
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	?Fatal@MsgMgr@@QAAXPADZZ:NEAR			; MsgMgr::Fatal
EXTRN	?msgMgr@@3PAVMsgMgr@@A:DWORD			; msgMgr
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	_memcpy:NEAR
_DATA	SEGMENT
$SG59444 DB	'Object::Object called with invalid id handle of 0x%x', 00H
	ORG $+3
$SG59447 DB	'Object::Object called with invalid source handle of 0x%x'
	DB	00H
_DATA	ENDS
xdata$x	SEGMENT
$T59926	DD	019930520H
	DD	01H
	DD	FLAT:$T59929
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T59929	DD	0ffffffffH
	DD	FLAT:$L59922
xdata$x	ENDS
_TEXT	SEGMENT
_id$ = 8
_source$ = 12
_offset$ = 16
_sz$ = 20
_this$ = -28
_obj$ = -16
$T59918 = -20
$T59919 = -24
__$EHRec$ = -12
??0Object@@QAE@VMemID@@0II@Z PROC NEAR			; Object::Object

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 $L59927
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 14	 sub	 esp, 20			; 00000014H
  0001b	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx
  0001e	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  00026	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	83 c1 0a	 add	 ecx, 10			; 0000000aH
  0002c	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  00031	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00037	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID

; 31   : 	//	create an Object from the Object found in an .HEP file
; 32   : 	if ( !id.IsValid() )

  0003c	8d 4d 08	 lea	 ecx, DWORD PTR _id$[ebp]
  0003f	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  00044	85 c0		 test	 eax, eax
  00046	75 21		 jne	 SHORT $L59442

; 33   : 		msgMgr->Fatal ( "Object::Object called with invalid id handle of 0x%x", (ushort)id );

  00048	8d 4d 08	 lea	 ecx, DWORD PTR _id$[ebp]
  0004b	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00050	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00055	50		 push	 eax
  00056	68 00 00 00 00	 push	 OFFSET FLAT:$SG59444
  0005b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
$L59442:

; 34   : 
; 35   : 	if ( !source.IsValid() )

  00069	8d 4d 0c	 lea	 ecx, DWORD PTR _source$[ebp]
  0006c	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  00071	85 c0		 test	 eax, eax
  00073	75 22		 jne	 SHORT $L59445

; 36   : 		msgMgr->Fatal ( "Object::Object called with invalid source handle of 0x%x", (ushort)source );

  00075	8d 4d 0c	 lea	 ecx, DWORD PTR _source$[ebp]
  00078	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  0007d	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00082	50		 push	 eax
  00083	68 00 00 00 00	 push	 OFFSET FLAT:$SG59447
  00088	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  0008e	51		 push	 ecx
  0008f	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00094	83 c4 0c	 add	 esp, 12			; 0000000cH
$L59445:

; 37   : 
; 38   : 	Object* obj = (Object*) &source[offset];

  00097	8b 55 10	 mov	 edx, DWORD PTR _offset$[ebp]
  0009a	52		 push	 edx
  0009b	8d 4d 0c	 lea	 ecx, DWORD PTR _source$[ebp]
  0009e	e8 00 00 00 00	 call	 ??AMemID@@QBEAADI@Z	; MemID::operator[]
  000a3	89 45 f0	 mov	 DWORD PTR _obj$[ebp], eax

; 39   : 
; 40   : 	//	initialize the fixed properties
; 41   : 	size 		= obj->size;

  000a6	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  000a9	8b 4d f0	 mov	 ecx, DWORD PTR _obj$[ebp]
  000ac	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  000b0	66 89 50 02	 mov	 WORD PTR [eax+2], dx

; 42   : //	methDict	= obj->methDict;
; 43   : 	classNum	= obj->classNum;

  000b4	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  000b7	8b 4d f0	 mov	 ecx, DWORD PTR _obj$[ebp]
  000ba	66 8b 51 08	 mov	 dx, WORD PTR [ecx+8]
  000be	66 89 50 08	 mov	 WORD PTR [eax+8], dx

; 44   : 	script	= obj->script;

  000c2	8b 45 f0	 mov	 eax, DWORD PTR _obj$[ebp]
  000c5	66 8b 48 0a	 mov	 cx, WORD PTR [eax+10]
  000c9	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  000cc	66 89 4a 0a	 mov	 WORD PTR [edx+10], cx

; 45   : 	super		= obj->super;

  000d0	8b 45 f0	 mov	 eax, DWORD PTR _obj$[ebp]
  000d3	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  000d7	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  000da	66 89 4a 0c	 mov	 WORD PTR [edx+12], cx

; 46   : 	info		= obj->info;

  000de	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  000e1	8b 4d f0	 mov	 ecx, DWORD PTR _obj$[ebp]
  000e4	66 8b 51 0e	 mov	 dx, WORD PTR [ecx+14]
  000e8	66 89 50 0e	 mov	 WORD PTR [eax+14], dx

; 47   : 	
; 48   : 	_selectorDict = New SelectorDict;

  000ec	6a 18		 push	 24			; 00000018H
  000ee	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000f3	83 c4 04	 add	 esp, 4
  000f6	89 45 e8	 mov	 DWORD PTR $T59919[ebp], eax
  000f9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00100	83 7d e8 00	 cmp	 DWORD PTR $T59919[ebp], 0
  00104	74 0d		 je	 SHORT $L59920
  00106	8b 4d e8	 mov	 ecx, DWORD PTR $T59919[ebp]
  00109	e8 00 00 00 00	 call	 ??0SelectorDict@@QAE@XZ	; SelectorDict::SelectorDict
  0010e	89 45 e0	 mov	 DWORD PTR -32+[ebp], eax
  00111	eb 07		 jmp	 SHORT $L59921
$L59920:
  00113	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR -32+[ebp], 0
$L59921:
  0011a	8b 45 e0	 mov	 eax, DWORD PTR -32+[ebp]
  0011d	89 45 ec	 mov	 DWORD PTR $T59918[ebp], eax
  00120	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00127	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0012a	8b 55 ec	 mov	 edx, DWORD PTR $T59918[ebp]
  0012d	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 49   : 	_selectorDict->nRefs = 1;

  00130	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00133	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00136	c7 41 0c 01 00
	00 00		 mov	 DWORD PTR [ecx+12], 1

; 50   : 
; 51   : 	//	copy the rest of the data from the end of the object to the end of us
; 52   : 	memcpy(this + 1, obj + 1, sz - sizeof(*obj));

  0013d	8b 55 14	 mov	 edx, DWORD PTR _sz$[ebp]
  00140	83 ea 10	 sub	 edx, 16			; 00000010H
  00143	52		 push	 edx
  00144	8b 45 f0	 mov	 eax, DWORD PTR _obj$[ebp]
  00147	83 c0 10	 add	 eax, 16			; 00000010H
  0014a	50		 push	 eax
  0014b	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0014e	83 c1 10	 add	 ecx, 16			; 00000010H
  00151	51		 push	 ecx
  00152	e8 00 00 00 00	 call	 _memcpy
  00157	83 c4 0c	 add	 esp, 12			; 0000000cH

; 53   : 
; 54   : 	this->id = id;

  0015a	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  0015d	66 8b 45 08	 mov	 ax, WORD PTR _id$[ebp]
  00161	66 89 02	 mov	 WORD PTR [edx], ax

; 55   : 
; 56   : 	AddToObjects();

  00164	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00167	e8 00 00 00 00	 call	 ?AddToObjects@Object@@QAEXXZ ; Object::AddToObjects

; 57   : }

  0016c	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0016f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00172	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00179	8b e5		 mov	 esp, ebp
  0017b	5d		 pop	 ebp
  0017c	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
text$x	SEGMENT
$L59922:
  00000	8b 45 e8	 mov	 eax, DWORD PTR $T59919[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
$L59927:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T59926
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0Object@@QAE@VMemID@@0II@Z ENDP			; Object::Object
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0MemID@@QAE@XZ PROC NEAR				; MemID::MemID, COMDAT

; 15   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 16   : 	}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0MemID@@QAE@XZ ENDP					; MemID::MemID
_TEXT	ENDS
PUBLIC	?IsValid@MemoryMgr@@QAEHG@Z			; MemoryMgr::IsValid
EXTRN	_memMgr:DWORD
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsValid@MemID@@QBEHXZ PROC NEAR			; MemID::IsValid, COMDAT

; 62   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 63   : 		return memMgr->IsValid(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?IsValid@MemoryMgr@@QAEHG@Z ; MemoryMgr::IsValid

; 64   : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?IsValid@MemID@@QBEHXZ ENDP				; MemID::IsValid
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -8
_tempID$ = -4
?IsValid@MemoryMgr@@QAEHG@Z PROC NEAR			; MemoryMgr::IsValid, COMDAT

; 475  : 	inline Bool MemoryMgr::IsValid(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 476  : 		unsigned short tempID = (unsigned short)theID;

  00009	66 8b 45 08	 mov	 ax, WORD PTR _theID$[ebp]
  0000d	66 89 45 fc	 mov	 WORD PTR _tempID$[ebp], ax

; 477  : 
; 478  : 		return(
; 479  : 				(tempID)															&&
; 480  : 				(tempID < maxDescriptors)									&&
; 481  : 				(desc[tempID].memInfo.bits.freeDescriptor == False)	&&
; 482  : 				(desc[tempID].memInfo.bits.freeMemory == False)
; 483  : 				);

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _tempID$[ebp]
  00014	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 58		 je	 SHORT $L59934
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _tempID$[ebp]
  00021	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  0002d	73 47		 jae	 SHORT $L59934
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _tempID$[ebp]
  00032	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00038	c1 e1 04	 shl	 ecx, 4
  0003b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00041	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00044	c1 e1 0e	 shl	 ecx, 14			; 0000000eH
  00047	c1 f9 1f	 sar	 ecx, 31			; 0000001fH
  0004a	85 c9		 test	 ecx, ecx
  0004c	75 28		 jne	 SHORT $L59934
  0004e	8b 55 fc	 mov	 edx, DWORD PTR _tempID$[ebp]
  00051	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00057	c1 e2 04	 shl	 edx, 4
  0005a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00060	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00063	c1 e2 14	 shl	 edx, 20			; 00000014H
  00066	c1 fa 1f	 sar	 edx, 31			; 0000001fH
  00069	85 d2		 test	 edx, edx
  0006b	75 09		 jne	 SHORT $L59934
  0006d	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR -12+[ebp], 1
  00074	eb 07		 jmp	 SHORT $L59935
$L59934:
  00076	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR -12+[ebp], 0
$L59935:
  0007d	8b 45 f4	 mov	 eax, DWORD PTR -12+[ebp]

; 484  : 	}

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 04 00	 ret	 4
?IsValid@MemoryMgr@@QAEHG@Z ENDP			; MemoryMgr::IsValid
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4
??BMemID@@QBEGXZ PROC NEAR				; MemID::operator unsigned short, COMDAT

; 93   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   : 		return handle;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 00	 mov	 ax, WORD PTR [eax]

; 95   : 	}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??BMemID@@QBEGXZ ENDP					; MemID::operator unsigned short
_TEXT	ENDS
PUBLIC	?GetAddr@MemoryMgr@@QAEPAXG@Z			; MemoryMgr::GetAddr
;	COMDAT ??AMemID@@QBEAADI@Z
_TEXT	SEGMENT
_s$ = 8
_this$ = -4
??AMemID@@QBEAADI@Z PROC NEAR				; MemID::operator[], COMDAT

; 103  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 104  : 		return *((char*) memMgr->GetAddr(handle) + s);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr
  00019	03 45 08	 add	 eax, DWORD PTR _s$[ebp]

; 105  : 	}

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??AMemID@@QBEAADI@Z ENDP				; MemID::operator[]
_TEXT	ENDS
EXTRN	__descPtrTable:BYTE
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -4
?GetAddr@MemoryMgr@@QAEPAXG@Z PROC NEAR			; MemoryMgr::GetAddr, COMDAT

; 462  : 	inline void* MemoryMgr::GetAddr(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : //		CheckValid(theID);
; 464  : 		return _descPtrTable[(unsigned int)((unsigned short)theID)];

  00007	8b 45 08	 mov	 eax, DWORD PTR _theID$[ebp]
  0000a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0000f	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR __descPtrTable[eax*4]

; 465  : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?GetAddr@MemoryMgr@@QAEPAXG@Z ENDP			; MemoryMgr::GetAddr
_TEXT	ENDS
PUBLIC	??0Object@@QAE@VMemID@@0@Z			; Object::Object
PUBLIC	??CFakeObjectID@@QBEPAUObject@@XZ		; FakeObjectID::operator->
PUBLIC	??0MemID@@QAE@ABV0@@Z				; MemID::MemID
PUBLIC	??0ScriptID@@QAE@ABVMemID@@@Z			; ScriptID::ScriptID
PUBLIC	??0ObjectID@@QAE@ABVMemID@@@Z			; ObjectID::ObjectID
PUBLIC	??0ObjectID@@QAE@ABV0@@Z			; ObjectID::ObjectID
PUBLIC	?AssureValid@ObjectID@@QBEXXZ			; ObjectID::AssureValid
PUBLIC	??CScriptID@@QBEPAUScript@@XZ			; ScriptID::operator->
PUBLIC	??DMemID@@QBEPAXXZ				; MemID::operator*
_DATA	SEGMENT
	ORG $+3
$SG59463 DB	'Selector dictionary is not valid on Object::Object ( id,'
	DB	' clonee )', 00H
_DATA	ENDS
_TEXT	SEGMENT
_id$ = 8
_clonee$ = 12
_this$ = -16
_obj$ = -4
$T59940 = -8
$T59941 = -12
??0Object@@QAE@VMemID@@0@Z PROC NEAR			; Object::Object

; 61   : {

  0017f	55		 push	 ebp
  00180	8b ec		 mov	 ebp, esp
  00182	83 ec 14	 sub	 esp, 20			; 00000014H
  00185	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00188	8d 45 08	 lea	 eax, DWORD PTR _id$[ebp]
  0018b	50		 push	 eax
  0018c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0018f	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00194	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00197	66 c7 41 02 00
	00		 mov	 WORD PTR [ecx+2], 0
  0019d	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  001a0	66 c7 42 08 00
	00		 mov	 WORD PTR [edx+8], 0
  001a6	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001a9	83 c1 0a	 add	 ecx, 10			; 0000000aH
  001ac	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  001b1	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001b4	83 c1 0c	 add	 ecx, 12			; 0000000cH
  001b7	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  001bc	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001bf	66 c7 40 0e 00
	00		 mov	 WORD PTR [eax+14], 0

; 62   : 	//	clone an object
; 63   : 
; 64   : 	ObjectID obj = (ObjectID) clonee;

  001c5	8d 4d 0c	 lea	 ecx, DWORD PTR _clonee$[ebp]
  001c8	51		 push	 ecx
  001c9	8d 4d f8	 lea	 ecx, DWORD PTR $T59940[ebp]
  001cc	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABVMemID@@@Z ; ObjectID::ObjectID
  001d1	50		 push	 eax
  001d2	8d 4d fc	 lea	 ecx, DWORD PTR _obj$[ebp]
  001d5	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID

; 65   : 	obj.AssureValid();

  001da	8d 4d fc	 lea	 ecx, DWORD PTR _obj$[ebp]
  001dd	e8 00 00 00 00	 call	 ?AssureValid@ObjectID@@QBEXXZ ; ObjectID::AssureValid

; 66   : 
; 67   : 	size 		= obj->size;

  001e2	8d 4d fc	 lea	 ecx, DWORD PTR _obj$[ebp]
  001e5	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  001ea	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  001ed	66 8b 40 02	 mov	 ax, WORD PTR [eax+2]
  001f1	66 89 42 02	 mov	 WORD PTR [edx+2], ax

; 68   : //	methDict	= obj->methDict;
; 69   : 	classNum	= obj->classNum;

  001f5	8d 4d fc	 lea	 ecx, DWORD PTR _obj$[ebp]
  001f8	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  001fd	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00200	66 8b 50 08	 mov	 dx, WORD PTR [eax+8]
  00204	66 89 51 08	 mov	 WORD PTR [ecx+8], dx

; 70   : 	script	= obj->script;

  00208	8d 4d fc	 lea	 ecx, DWORD PTR _obj$[ebp]
  0020b	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  00210	66 8b 40 0a	 mov	 ax, WORD PTR [eax+10]
  00214	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00217	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax

; 71   : 	super		= obj->super;

  0021b	8d 4d fc	 lea	 ecx, DWORD PTR _obj$[ebp]
  0021e	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  00223	66 8b 50 0c	 mov	 dx, WORD PTR [eax+12]
  00227	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0022a	66 89 50 0c	 mov	 WORD PTR [eax+12], dx

; 72   : 	info		= obj->info;

  0022e	8d 4d fc	 lea	 ecx, DWORD PTR _obj$[ebp]
  00231	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  00236	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00239	66 8b 50 0e	 mov	 dx, WORD PTR [eax+14]
  0023d	66 89 51 0e	 mov	 WORD PTR [ecx+14], dx

; 73   : 
; 74   : 	_selectorDict = obj->_selectorDict;

  00241	8d 4d fc	 lea	 ecx, DWORD PTR _obj$[ebp]
  00244	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  00249	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0024c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0024f	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 75   : 
; 76   : 	if ( !_selectorDict )

  00252	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00255	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00259	75 14		 jne	 SHORT $L59462

; 77   : 		msgMgr->Fatal ( "Selector dictionary is not valid on Object::Object ( id, clonee )" );

  0025b	68 00 00 00 00	 push	 OFFSET FLAT:$SG59463
  00260	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00266	51		 push	 ecx
  00267	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  0026c	83 c4 08	 add	 esp, 8
$L59462:

; 78   : 
; 79   :  	_selectorDict->nRefs++;

  0026f	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00272	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00275	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00278	83 c1 01	 add	 ecx, 1
  0027b	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0027e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00281	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 80   : 
; 81   : 	//	copy the variable length portion
; 82   : 	memcpy(this + 1, (Object*) *clonee + 1,
; 83   : 		obj->size * sizeof(Property) - sizeof(Object));

  00284	8d 4d fc	 lea	 ecx, DWORD PTR _obj$[ebp]
  00287	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  0028c	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00290	8d 54 09 f0	 lea	 edx, DWORD PTR [ecx+ecx-16]
  00294	52		 push	 edx
  00295	8d 4d 0c	 lea	 ecx, DWORD PTR _clonee$[ebp]
  00298	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0029d	83 c0 10	 add	 eax, 16			; 00000010H
  002a0	50		 push	 eax
  002a1	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  002a4	83 c0 10	 add	 eax, 16			; 00000010H
  002a7	50		 push	 eax
  002a8	e8 00 00 00 00	 call	 _memcpy
  002ad	83 c4 0c	 add	 esp, 12			; 0000000cH

; 84   : 
; 85   : 	//	if we're copying from a class, set our super to the class and turn off
; 86   : 	//	our class bit
; 87   : 	if (obj->info & CLASSBIT) {

  002b0	8d 4d fc	 lea	 ecx, DWORD PTR _obj$[ebp]
  002b3	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  002b8	0f bf 48 0e	 movsx	 ecx, WORD PTR [eax+14]
  002bc	81 e1 00 80 ff
	ff		 and	 ecx, -32768		; ffff8000H
  002c2	85 c9		 test	 ecx, ecx
  002c4	74 25		 je	 SHORT $L59467

; 88   : 		super = obj->id;

  002c6	8d 4d fc	 lea	 ecx, DWORD PTR _obj$[ebp]
  002c9	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  002ce	66 8b 10	 mov	 dx, WORD PTR [eax]
  002d1	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  002d4	66 89 50 0c	 mov	 WORD PTR [eax+12], dx

; 89   : 		info &= ~CLASSBIT;

  002d8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  002db	66 8b 51 0e	 mov	 dx, WORD PTR [ecx+14]
  002df	66 81 e2 ff 7f	 and	 dx, 32767		; 00007fffH
  002e4	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  002e7	66 89 50 0e	 mov	 WORD PTR [eax+14], dx
$L59467:

; 91   : 
; 92   : 	//	mark the object as cloned
; 93   : 	info |= CLONEBIT;

  002eb	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  002ee	66 8b 51 0e	 mov	 dx, WORD PTR [ecx+14]
  002f2	80 ca 01	 or	 dl, 1
  002f5	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  002f8	66 89 50 0e	 mov	 WORD PTR [eax+14], dx

; 94   : 
; 95   : 	//	increment script's reference count
; 96   : 	((ScriptID) script)->nRefs++;

  002fc	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  002ff	83 c1 0a	 add	 ecx, 10			; 0000000aH
  00302	51		 push	 ecx
  00303	8d 4d f4	 lea	 ecx, DWORD PTR $T59941[ebp]
  00306	e8 00 00 00 00	 call	 ??0ScriptID@@QAE@ABVMemID@@@Z ; ScriptID::ScriptID
  0030b	8b c8		 mov	 ecx, eax
  0030d	e8 00 00 00 00	 call	 ??CScriptID@@QBEPAUScript@@XZ ; ScriptID::operator->
  00312	89 45 ec	 mov	 DWORD PTR -20+[ebp], eax
  00315	8b 55 ec	 mov	 edx, DWORD PTR -20+[ebp]
  00318	8b 02		 mov	 eax, DWORD PTR [edx]
  0031a	83 c0 01	 add	 eax, 1
  0031d	8b 4d ec	 mov	 ecx, DWORD PTR -20+[ebp]
  00320	89 01		 mov	 DWORD PTR [ecx], eax

; 97   : 
; 98   : 	AddToObjects();

  00322	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00325	e8 00 00 00 00	 call	 ?AddToObjects@Object@@QAEXXZ ; Object::AddToObjects

; 99   : }

  0032a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0032d	8b e5		 mov	 esp, ebp
  0032f	5d		 pop	 ebp
  00330	c2 08 00	 ret	 8
??0Object@@QAE@VMemID@@0@Z ENDP				; Object::Object
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0MemID@@QAE@ABV0@@Z PROC NEAR				; MemID::MemID, COMDAT

; 19   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  0000d	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00010	66 89 10	 mov	 WORD PTR [eax], dx

; 20   : 	}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0MemID@@QAE@ABV0@@Z ENDP				; MemID::MemID
_TEXT	ENDS
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT
_this$ = -4
??DMemID@@QBEPAXXZ PROC NEAR				; MemID::operator*, COMDAT

; 98   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 99   : 		return memMgr->GetAddr(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr

; 100  : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??DMemID@@QBEPAXXZ ENDP					; MemID::operator*
_TEXT	ENDS
;	COMDAT ??0ScriptID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0ScriptID@@QAE@ABVMemID@@@Z PROC NEAR			; ScriptID::ScriptID, COMDAT

; 117  : FakeTemplateID(ScriptID, Script, MemScript)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0ScriptID@@QAE@ABVMemID@@@Z ENDP			; ScriptID::ScriptID
_TEXT	ENDS
;	COMDAT ??CScriptID@@QBEPAUScript@@XZ
_TEXT	SEGMENT
_this$ = -4
??CScriptID@@QBEPAUScript@@XZ PROC NEAR			; ScriptID::operator->, COMDAT

; 117  : FakeTemplateID(ScriptID, Script, MemScript)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??CScriptID@@QBEPAUScript@@XZ ENDP			; ScriptID::operator->
_TEXT	ENDS
;	COMDAT ??CFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT
_this$ = -4
??CFakeObjectID@@QBEPAUObject@@XZ PROC NEAR		; FakeObjectID::operator->, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??CFakeObjectID@@QBEPAUObject@@XZ ENDP			; FakeObjectID::operator->
_TEXT	ENDS
PUBLIC	??0FakeObjectID@@QAE@ABVMemID@@@Z		; FakeObjectID::FakeObjectID
;	COMDAT ??0ObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0ObjectID@@QAE@ABVMemID@@@Z PROC NEAR			; ObjectID::ObjectID, COMDAT

; 228  : 	ObjectID(const MemID& id) : FakeObjectID(id) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0FakeObjectID@@QAE@ABVMemID@@@Z ; FakeObjectID::FakeObjectID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0ObjectID@@QAE@ABVMemID@@@Z ENDP			; ObjectID::ObjectID
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0FakeObjectID@@QAE@ABVMemID@@@Z PROC NEAR		; FakeObjectID::FakeObjectID, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0FakeObjectID@@QAE@ABVMemID@@@Z ENDP			; FakeObjectID::FakeObjectID
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@ABV0@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??0ObjectID@@QAE@ABV0@@Z PROC NEAR			; ObjectID::ObjectID, COMDAT

; 229  : 	ObjectID(const ObjectID& id) : FakeObjectID((MemID&) id) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0FakeObjectID@@QAE@ABVMemID@@@Z ; FakeObjectID::FakeObjectID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0ObjectID@@QAE@ABV0@@Z ENDP				; ObjectID::ObjectID
_TEXT	ENDS
PUBLIC	?IsObject@ObjectID@@QBEHXZ			; ObjectID::IsObject
EXTRN	?Fatal@MsgMgr@@QAAXHZZ:NEAR			; MsgMgr::Fatal
;	COMDAT ?AssureValid@ObjectID@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4
?AssureValid@ObjectID@@QBEXXZ PROC NEAR			; ObjectID::AssureValid, COMDAT

; 238  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 239  : 		if (!IsObject())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?IsObject@ObjectID@@QBEHXZ ; ObjectID::IsObject
  0000f	85 c0		 test	 eax, eax
  00011	75 1e		 jne	 SHORT $L58227

; 240  : 			msgMgr->Fatal(Msg_NotObject, (int) *this);

  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  0001b	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00020	50		 push	 eax
  00021	6a 2f		 push	 47			; 0000002fH
  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXHZZ	; MsgMgr::Fatal
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L58227:

; 241  : 	}

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?AssureValid@ObjectID@@QBEXXZ ENDP			; ObjectID::AssureValid
_TEXT	ENDS
EXTRN	?GetMemType@MemID@@QBE?AW4MemType@@XZ:NEAR	; MemID::GetMemType
;	COMDAT ?IsObject@ObjectID@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsObject@ObjectID@@QBEHXZ PROC NEAR			; ObjectID::IsObject, COMDAT

; 247  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 248  : 		return IsValid() && GetMemType() == MemObject;

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  00011	85 c0		 test	 eax, eax
  00013	74 16		 je	 SHORT $L59952
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  0001d	83 f8 34	 cmp	 eax, 52			; 00000034H
  00020	75 09		 jne	 SHORT $L59952
  00022	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR -8+[ebp], 1
  00029	eb 07		 jmp	 SHORT $L59953
$L59952:
  0002b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], 0
$L59953:
  00032	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]

; 249  : 	}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?IsObject@ObjectID@@QBEHXZ ENDP				; ObjectID::IsObject
_TEXT	ENDS
PUBLIC	??_GSelectorDict@@QAEPAXI@Z			; SelectorDict::`scalar deleting destructor'
PUBLIC	??1Object@@QAE@XZ				; Object::~Object
PUBLIC	?DeleteFromObjects@Object@@QAEXXZ		; Object::DeleteFromObjects
PUBLIC	??0MemID@@QAE@G@Z				; MemID::MemID
EXTRN	?Alert@MsgMgr@@QAAHPADZZ:NEAR			; MsgMgr::Alert
_DATA	SEGMENT
	ORG $+2
$SG59478 DB	'Object::~Object called with invalid id member of 0x%x', 00H
_DATA	ENDS
_TEXT	SEGMENT
_this$ = -28
_obj$ = -4
$T59955 = -8
$T59956 = -12
$T59957 = -16
$T59958 = -20
$T59961 = -24
??1Object@@QAE@XZ PROC NEAR				; Object::~Object

; 102  : {

  00333	55		 push	 ebp
  00334	8b ec		 mov	 ebp, esp
  00336	83 ec 24	 sub	 esp, 36			; 00000024H
  00339	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 103  : 	ObjectID obj = (ObjectID)id;

  0033c	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0033f	50		 push	 eax
  00340	8d 4d f8	 lea	 ecx, DWORD PTR $T59955[ebp]
  00343	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABVMemID@@@Z ; ObjectID::ObjectID
  00348	50		 push	 eax
  00349	8d 4d fc	 lea	 ecx, DWORD PTR _obj$[ebp]
  0034c	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID

; 104  : 
; 105  : 	if ( !obj.IsObject() ) {

  00351	8d 4d fc	 lea	 ecx, DWORD PTR _obj$[ebp]
  00354	e8 00 00 00 00	 call	 ?IsObject@ObjectID@@QBEHXZ ; ObjectID::IsObject
  00359	85 c0		 test	 eax, eax
  0035b	75 25		 jne	 SHORT $L59476

; 106  : 		msgMgr->Alert ( "Object::~Object called with invalid id member of 0x%x", (short)id );

  0035d	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00360	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00365	0f bf c8	 movsx	 ecx, ax
  00368	51		 push	 ecx
  00369	68 00 00 00 00	 push	 OFFSET FLAT:$SG59478
  0036e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00374	52		 push	 edx
  00375	e8 00 00 00 00	 call	 ?Alert@MsgMgr@@QAAHPADZZ ; MsgMgr::Alert
  0037a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 107  : 		return;

  0037d	e9 98 00 00 00	 jmp	 $L59472
$L59476:

; 109  : 
; 110  : 	DeleteFromObjects();

  00382	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00385	e8 00 00 00 00	 call	 ?DeleteFromObjects@Object@@QAEXXZ ; Object::DeleteFromObjects

; 111  : 
; 112  : 	id = 0;

  0038a	6a 00		 push	 0
  0038c	8d 4d f4	 lea	 ecx, DWORD PTR $T59956[ebp]
  0038f	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  00394	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00397	66 8b 4d f4	 mov	 cx, WORD PTR $T59956[ebp]
  0039b	66 89 08	 mov	 WORD PTR [eax], cx

; 113  : 
; 114  : 	if ( !--_selectorDict->nRefs ) {

  0039e	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  003a1	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  003a4	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  003a7	83 e9 01	 sub	 ecx, 1
  003aa	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  003ad	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  003b0	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  003b3	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  003b6	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  003b9	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  003bd	75 35		 jne	 SHORT $L59480

; 115  : 		delete _selectorDict;

  003bf	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  003c2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  003c5	89 4d ec	 mov	 DWORD PTR $T59958[ebp], ecx
  003c8	8b 55 ec	 mov	 edx, DWORD PTR $T59958[ebp]
  003cb	89 55 f0	 mov	 DWORD PTR $T59957[ebp], edx
  003ce	83 7d f0 00	 cmp	 DWORD PTR $T59957[ebp], 0
  003d2	74 0f		 je	 SHORT $L59959
  003d4	6a 01		 push	 1
  003d6	8b 4d f0	 mov	 ecx, DWORD PTR $T59957[ebp]
  003d9	e8 00 00 00 00	 call	 ??_GSelectorDict@@QAEPAXI@Z ; SelectorDict::`scalar deleting destructor'
  003de	89 45 e0	 mov	 DWORD PTR -32+[ebp], eax
  003e1	eb 07		 jmp	 SHORT $L59960
$L59959:
  003e3	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR -32+[ebp], 0
$L59960:

; 116  : 		_selectorDict = NULL;

  003ea	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  003ed	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$L59480:

; 118  : 
; 119  : 	((ScriptID) script)->nRefs--;

  003f4	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  003f7	83 c1 0a	 add	 ecx, 10			; 0000000aH
  003fa	51		 push	 ecx
  003fb	8d 4d e8	 lea	 ecx, DWORD PTR $T59961[ebp]
  003fe	e8 00 00 00 00	 call	 ??0ScriptID@@QAE@ABVMemID@@@Z ; ScriptID::ScriptID
  00403	8b c8		 mov	 ecx, eax
  00405	e8 00 00 00 00	 call	 ??CScriptID@@QBEPAUScript@@XZ ; ScriptID::operator->
  0040a	89 45 dc	 mov	 DWORD PTR -36+[ebp], eax
  0040d	8b 55 dc	 mov	 edx, DWORD PTR -36+[ebp]
  00410	8b 02		 mov	 eax, DWORD PTR [edx]
  00412	83 e8 01	 sub	 eax, 1
  00415	8b 4d dc	 mov	 ecx, DWORD PTR -36+[ebp]
  00418	89 01		 mov	 DWORD PTR [ecx], eax
$L59472:

; 120  : }

  0041a	8b e5		 mov	 esp, ebp
  0041c	5d		 pop	 ebp
  0041d	c3		 ret	 0
??1Object@@QAE@XZ ENDP					; Object::~Object
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0MemID@@QAE@G@Z PROC NEAR				; MemID::MemID, COMDAT

; 23   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 4d 08	 mov	 cx, WORD PTR _h$[ebp]
  0000e	66 89 08	 mov	 WORD PTR [eax], cx

; 24   : 	}

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??0MemID@@QAE@G@Z ENDP					; MemID::MemID
_TEXT	ENDS
PUBLIC	??1SelectorDict@@QAE@XZ				; SelectorDict::~SelectorDict
;	COMDAT ??_GSelectorDict@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GSelectorDict@@QAEPAXI@Z PROC NEAR			; SelectorDict::`scalar deleting destructor', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1SelectorDict@@QAE@XZ	; SelectorDict::~SelectorDict
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L59488
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L59488:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GSelectorDict@@QAEPAXI@Z ENDP			; SelectorDict::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp__malloc:NEAR
_DATA	SEGMENT
	ORG $+2
$SG59497 DB	'Could not allocate object information.', 00H
_DATA	ENDS
_TEXT	SEGMENT
_this$ = -12
_info$59493 = -4
$T59965 = -8
?AddToObjects@Object@@QAEXXZ PROC NEAR			; Object::AddToObjects

; 124  : {

  0041e	55		 push	 ebp
  0041f	8b ec		 mov	 ebp, esp
  00421	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00424	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 125  : 	//	add to objects list
; 126  : 
; 127  : //#ifdef DEBUG
; 128  : 	if ( id ) {

  00427	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0042a	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  0042f	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00434	85 c0		 test	 eax, eax
  00436	74 51		 je	 SHORT $L59492

; 129  : 		ObjectInfo *info = (ObjectInfo *)malloc ( sizeof ( ObjectInfo ) );

  00438	6a 06		 push	 6
  0043a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00440	83 c4 04	 add	 esp, 4
  00443	89 45 fc	 mov	 DWORD PTR _info$59493[ebp], eax

; 130  : 
; 131  : 		if ( !info )

  00446	83 7d fc 00	 cmp	 DWORD PTR _info$59493[ebp], 0
  0044a	75 13		 jne	 SHORT $L59496

; 132  : 			msgMgr->Fatal ( "Could not allocate object information." );

  0044c	68 00 00 00 00	 push	 OFFSET FLAT:$SG59497
  00451	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00456	50		 push	 eax
  00457	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  0045c	83 c4 08	 add	 esp, 8
$L59496:

; 133  : 
; 134  : 		info->id = id;

  0045f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00462	51		 push	 ecx
  00463	8d 4d f8	 lea	 ecx, DWORD PTR $T59965[ebp]
  00466	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABVMemID@@@Z ; ObjectID::ObjectID
  0046b	8b 55 fc	 mov	 edx, DWORD PTR _info$59493[ebp]
  0046e	66 8b 45 f8	 mov	 ax, WORD PTR $T59965[ebp]
  00472	66 89 42 04	 mov	 WORD PTR [edx+4], ax

; 135  : 		info->next = objInfo;

  00476	8b 4d fc	 mov	 ecx, DWORD PTR _info$59493[ebp]
  00479	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?objInfo@@3PAVObjectInfo@@A ; objInfo
  0047f	89 11		 mov	 DWORD PTR [ecx], edx

; 136  : 		objInfo = info;

  00481	8b 45 fc	 mov	 eax, DWORD PTR _info$59493[ebp]
  00484	a3 00 00 00 00	 mov	 DWORD PTR ?objInfo@@3PAVObjectInfo@@A, eax ; objInfo
$L59492:

; 138  : //#endif
; 139  : }

  00489	8b e5		 mov	 esp, ebp
  0048b	5d		 pop	 ebp
  0048c	c3		 ret	 0
?AddToObjects@Object@@QAEXXZ ENDP			; Object::AddToObjects
_TEXT	ENDS
PUBLIC	??8MemID@@QBEHABV0@@Z				; MemID::operator==
EXTRN	__imp__free:NEAR
_DATA	SEGMENT
	ORG $+1
$SG59511 DB	'DeleteFromObjects failed for id of 0x%x', 00H
_DATA	ENDS
_TEXT	SEGMENT
_this$ = -12
_info$ = -8
_lastInfo$ = -4
?DeleteFromObjects@Object@@QAEXXZ PROC NEAR		; Object::DeleteFromObjects

; 143  : {

  0048d	55		 push	 ebp
  0048e	8b ec		 mov	 ebp, esp
  00490	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00493	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 144  : 	//	remove from objects list
; 145  : 
; 146  : //#ifdef DEBUG
; 147  : 	ObjectInfo *info = objInfo, *lastInfo = NULL;

  00496	a1 00 00 00 00	 mov	 eax, DWORD PTR ?objInfo@@3PAVObjectInfo@@A ; objInfo
  0049b	89 45 f8	 mov	 DWORD PTR _info$[ebp], eax
  0049e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lastInfo$[ebp], 0
$L59505:

; 148  : 
; 149  : 	while ( info ) {

  004a5	83 7d f8 00	 cmp	 DWORD PTR _info$[ebp], 0
  004a9	74 51		 je	 SHORT $L59506

; 150  : 		if ( info->id == id ) {

  004ab	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  004ae	51		 push	 ecx
  004af	8b 4d f8	 mov	 ecx, DWORD PTR _info$[ebp]
  004b2	83 c1 04	 add	 ecx, 4
  004b5	e8 00 00 00 00	 call	 ??8MemID@@QBEHABV0@@Z	; MemID::operator==
  004ba	85 c0		 test	 eax, eax
  004bc	74 2e		 je	 SHORT $L59507

; 151  : 			if ( lastInfo )

  004be	83 7d fc 00	 cmp	 DWORD PTR _lastInfo$[ebp], 0
  004c2	74 0c		 je	 SHORT $L59508

; 152  : 				lastInfo->next = info->next;

  004c4	8b 55 fc	 mov	 edx, DWORD PTR _lastInfo$[ebp]
  004c7	8b 45 f8	 mov	 eax, DWORD PTR _info$[ebp]
  004ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  004cc	89 0a		 mov	 DWORD PTR [edx], ecx

; 153  : 			else

  004ce	eb 0d		 jmp	 SHORT $L59509
$L59508:

; 154  : 				objInfo = objInfo->next;

  004d0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?objInfo@@3PAVObjectInfo@@A ; objInfo
  004d6	8b 02		 mov	 eax, DWORD PTR [edx]
  004d8	a3 00 00 00 00	 mov	 DWORD PTR ?objInfo@@3PAVObjectInfo@@A, eax ; objInfo
$L59509:

; 155  : 
; 156  : 			free ( info );

  004dd	8b 4d f8	 mov	 ecx, DWORD PTR _info$[ebp]
  004e0	51		 push	 ecx
  004e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  004e7	83 c4 04	 add	 esp, 4

; 157  : 
; 158  : 			return;

  004ea	eb 2f		 jmp	 SHORT $L59501
$L59507:

; 160  : 
; 161  : 		lastInfo = info;

  004ec	8b 55 f8	 mov	 edx, DWORD PTR _info$[ebp]
  004ef	89 55 fc	 mov	 DWORD PTR _lastInfo$[ebp], edx

; 162  : 		info = info->next;

  004f2	8b 45 f8	 mov	 eax, DWORD PTR _info$[ebp]
  004f5	8b 08		 mov	 ecx, DWORD PTR [eax]
  004f7	89 4d f8	 mov	 DWORD PTR _info$[ebp], ecx

; 163  : 	}

  004fa	eb a9		 jmp	 SHORT $L59505
$L59506:

; 164  : 
; 165  : 	msgMgr->Alert ( "DeleteFromObjects failed for id of 0x%x", (short)id );

  004fc	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  004ff	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00504	0f bf d0	 movsx	 edx, ax
  00507	52		 push	 edx
  00508	68 00 00 00 00	 push	 OFFSET FLAT:$SG59511
  0050d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00512	50		 push	 eax
  00513	e8 00 00 00 00	 call	 ?Alert@MsgMgr@@QAAHPADZZ ; MsgMgr::Alert
  00518	83 c4 0c	 add	 esp, 12			; 0000000cH
$L59501:

; 166  : //#endif
; 167  : }

  0051b	8b e5		 mov	 esp, ebp
  0051d	5d		 pop	 ebp
  0051e	c3		 ret	 0
?DeleteFromObjects@Object@@QAEXXZ ENDP			; Object::DeleteFromObjects
_TEXT	ENDS
;	COMDAT ??8MemID@@QBEHABV0@@Z
_TEXT	SEGMENT
_id$ = 8
_this$ = -4
??8MemID@@QBEHABV0@@Z PROC NEAR				; MemID::operator==, COMDAT

; 108  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 109  : 		return handle == id.handle;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000f	8b 55 08	 mov	 edx, DWORD PTR _id$[ebp]
  00012	33 c0		 xor	 eax, eax
  00014	66 8b 02	 mov	 ax, WORD PTR [edx]
  00017	33 d2		 xor	 edx, edx
  00019	3b c8		 cmp	 ecx, eax
  0001b	0f 94 c2	 sete	 dl
  0001e	8b c2		 mov	 eax, edx

; 110  : 	}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??8MemID@@QBEHABV0@@Z ENDP				; MemID::operator==
_TEXT	ENDS
PUBLIC	?GetPropAddr@Object@@QAEPAFG@Z			; Object::GetPropAddr
PUBLIC	?Name@Object@@QAEPBDXZ				; Object::Name
PUBLIC	??DTextID@@QAEPADXZ				; TextID::operator*
EXTRN	??0TextID@@QAE@G@Z:NEAR				; TextID::TextID
_BSS	SEGMENT
	ALIGN	4

$SG59517 DB	01H DUP (?)
	ALIGN	4

$SG59521 DB	01H DUP (?)
	ALIGN	4

$SG59526 DB	01H DUP (?)
_BSS	ENDS
_TEXT	SEGMENT
_this$ = -20
_nameProp$ = -4
_name$ = -8
$T59969 = -12
$T59970 = -16
?Name@Object@@QAEPBDXZ PROC NEAR			; Object::Name

; 171  : {

  0051f	55		 push	 ebp
  00520	8b ec		 mov	 ebp, esp
  00522	83 ec 14	 sub	 esp, 20			; 00000014H
  00525	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 172  : 	//	return object's name, or "" if object doesn't have a name property
; 173  : 
; 174  : 	const Property* nameProp;
; 175  : 	if (!(nameProp = GetPropAddr(s_name)))

  00528	6a 20		 push	 32			; 00000020H
  0052a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0052d	e8 00 00 00 00	 call	 ?GetPropAddr@Object@@QAEPAFG@Z ; Object::GetPropAddr
  00532	89 45 fc	 mov	 DWORD PTR _nameProp$[ebp], eax
  00535	83 7d fc 00	 cmp	 DWORD PTR _nameProp$[ebp], 0
  00539	75 07		 jne	 SHORT $L59516

; 176  : 		return "";

  0053b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$SG59517
  00540	eb 4a		 jmp	 SHORT $L59514
$L59516:

; 177  : 
; 178  : 	if ( !((MemID)*nameProp).IsValid() )

  00542	8b 45 fc	 mov	 eax, DWORD PTR _nameProp$[ebp]
  00545	66 8b 08	 mov	 cx, WORD PTR [eax]
  00548	51		 push	 ecx
  00549	8d 4d f4	 lea	 ecx, DWORD PTR $T59969[ebp]
  0054c	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  00551	8b c8		 mov	 ecx, eax
  00553	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  00558	85 c0		 test	 eax, eax
  0055a	75 07		 jne	 SHORT $L59520

; 179  : 		return "";

  0055c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$SG59521
  00561	eb 29		 jmp	 SHORT $L59514
$L59520:

; 180  : 
; 181  : 	const char* name = *(TextID) *nameProp;

  00563	8b 55 fc	 mov	 edx, DWORD PTR _nameProp$[ebp]
  00566	66 8b 02	 mov	 ax, WORD PTR [edx]
  00569	50		 push	 eax
  0056a	8d 4d f0	 lea	 ecx, DWORD PTR $T59970[ebp]
  0056d	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  00572	8b c8		 mov	 ecx, eax
  00574	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  00579	89 45 f8	 mov	 DWORD PTR _name$[ebp], eax

; 182  : 	if (!name)

  0057c	83 7d f8 00	 cmp	 DWORD PTR _name$[ebp], 0
  00580	75 07		 jne	 SHORT $L59525

; 183  : 		return "";

  00582	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$SG59526
  00587	eb 03		 jmp	 SHORT $L59514
$L59525:

; 184  : 		
; 185  : 	return name;

  00589	8b 45 f8	 mov	 eax, DWORD PTR _name$[ebp]
$L59514:

; 186  : }

  0058c	8b e5		 mov	 esp, ebp
  0058e	5d		 pop	 ebp
  0058f	c3		 ret	 0
?Name@Object@@QAEPBDXZ ENDP				; Object::Name
_TEXT	ENDS
PUBLIC	?get@SelectorDict@@QAEHG@Z			; SelectorDict::get
PUBLIC	?selectorDict@Object@@QAEPAVSelectorDict@@XZ	; Object::selectorDict
PUBLIC	??AObject@@QAEAAFH@Z				; Object::operator[]
;	COMDAT ?GetPropAddr@Object@@QAEPAFG@Z
_TEXT	SEGMENT
_selector$ = 8
_this$ = -8
_index$ = -4
?GetPropAddr@Object@@QAEPAFG@Z PROC NEAR		; Object::GetPropAddr, COMDAT

; 127  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 128  : 		int index = selectorDict()->get ( selector );

  00009	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?selectorDict@Object@@QAEPAVSelectorDict@@XZ ; Object::selectorDict
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 ?get@SelectorDict@@QAEHG@Z ; SelectorDict::get
  0001d	89 45 fc	 mov	 DWORD PTR _index$[ebp], eax

; 129  : 
; 130  : 		if ( index != -1 && !selectorDict()->script )

  00020	83 7d fc ff	 cmp	 DWORD PTR _index$[ebp], -1
  00024	74 2b		 je	 SHORT $L58059
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?selectorDict@Object@@QAEPAVSelectorDict@@XZ ; Object::selectorDict
  0002e	33 c9		 xor	 ecx, ecx
  00030	66 8b 48 16	 mov	 cx, WORD PTR [eax+22]
  00034	85 c9		 test	 ecx, ecx
  00036	75 19		 jne	 SHORT $L58059

; 131  : 			return &(*this)[selectorDict()->offset]; 

  00038	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?selectorDict@Object@@QAEPAVSelectorDict@@XZ ; Object::selectorDict
  00040	33 d2		 xor	 edx, edx
  00042	66 8b 50 14	 mov	 dx, WORD PTR [eax+20]
  00046	52		 push	 edx
  00047	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ??AObject@@QAEAAFH@Z	; Object::operator[]
  0004f	eb 02		 jmp	 SHORT $L58057
$L58059:

; 132  : 
; 133  : 		return 0;

  00051	33 c0		 xor	 eax, eax
$L58057:

; 134  : 	}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
?GetPropAddr@Object@@QAEPAFG@Z ENDP			; Object::GetPropAddr
_TEXT	ENDS
;	COMDAT ?selectorDict@Object@@QAEPAVSelectorDict@@XZ
_TEXT	SEGMENT
_this$ = -4
?selectorDict@Object@@QAEPAVSelectorDict@@XZ PROC NEAR	; Object::selectorDict, COMDAT

; 102  : 	SelectorDict *selectorDict ( void ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 103  : 		return _selectorDict;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 104  : 	};

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?selectorDict@Object@@QAEPAVSelectorDict@@XZ ENDP	; Object::selectorDict
_TEXT	ENDS
;	COMDAT ??AObject@@QAEAAFH@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
??AObject@@QAEAAFH@Z PROC NEAR				; Object::operator[], COMDAT

; 117  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 118  : 		//	get a reference to a property given the number of the property
; 119  : 		return ((Property*) this)[index];

  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]

; 120  : 	}

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??AObject@@QAEAAFH@Z ENDP				; Object::operator[]
_TEXT	ENDS
PUBLIC	??_C@_00A@?$AA@					; `string'
;	COMDAT ??_C@_00A@?$AA@
; File C:\Documents and Settings\don\Desktop\sciw\Interp\textid.hpp
_BSS	SEGMENT
??_C@_00A@?$AA@ DB 01H DUP (?)				; `string'
_BSS	ENDS
;	COMDAT ??DTextID@@QAEPADXZ
_TEXT	SEGMENT
_this$ = -4
??DTextID@@QAEPADXZ PROC NEAR				; TextID::operator*, COMDAT

; 24   : 	char	*operator *() { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 25   : 		return handle ? (char *)MemID::operator*() : ""; 

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	33 c9		 xor	 ecx, ecx
  0000e	66 8b 08	 mov	 cx, WORD PTR [eax]
  00011	85 c9		 test	 ecx, ecx
  00013	74 0d		 je	 SHORT $L59975
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0001d	89 45 f8	 mov	 DWORD PTR -8+[ebp], eax
  00020	eb 07		 jmp	 SHORT $L59976
$L59975:
  00022	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
$L59976:
  00029	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]

; 26   : 	}

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??DTextID@@QAEPADXZ ENDP				; TextID::operator*
_TEXT	ENDS
PUBLIC	?RespondsTo@Object@@QAEHG@Z			; Object::RespondsTo
_TEXT	SEGMENT
_selector$ = 8
_this$ = -4
?RespondsTo@Object@@QAEHG@Z PROC NEAR			; Object::RespondsTo

; 190  : {

  00590	55		 push	 ebp
  00591	8b ec		 mov	 ebp, esp
  00593	51		 push	 ecx
  00594	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 191  : 	//	return whether 'selector' is a property or method of us or our
; 192  : 	//	superclasses
; 193  : 	if ( selectorDict()->get ( selector ) != -1 )

  00597	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  0059b	50		 push	 eax
  0059c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0059f	e8 00 00 00 00	 call	 ?selectorDict@Object@@QAEPAVSelectorDict@@XZ ; Object::selectorDict
  005a4	8b c8		 mov	 ecx, eax
  005a6	e8 00 00 00 00	 call	 ?get@SelectorDict@@QAEHG@Z ; SelectorDict::get
  005ab	83 f8 ff	 cmp	 eax, -1
  005ae	74 07		 je	 SHORT $L59531

; 194  : 		return True;

  005b0	b8 01 00 00 00	 mov	 eax, 1
  005b5	eb 02		 jmp	 SHORT $L59530
$L59531:

; 195  : 
; 196  : 	return False;

  005b7	33 c0		 xor	 eax, eax
$L59530:

; 197  : }

  005b9	8b e5		 mov	 esp, ebp
  005bb	5d		 pop	 ebp
  005bc	c2 04 00	 ret	 4
?RespondsTo@Object@@QAEHG@Z ENDP			; Object::RespondsTo
_TEXT	ENDS
PUBLIC	?Get@FakeObjectID@@QAEXIIIPAUMemClient@@DW4ReservedHandle@@@Z ; FakeObjectID::Get
PUBLIC	?Get@ObjectID@@QAEXVMemID@@II@Z			; ObjectID::Get
PUBLIC	??2@YAPAXIG@Z					; operator new
_TEXT	SEGMENT
_id$ = 8
_ofs$ = 12
_size$ = 16
_this$ = -16
$T59980 = -4
?Get@ObjectID@@QAEXVMemID@@II@Z PROC NEAR		; ObjectID::Get

; 203  : {

  005bf	55		 push	 ebp
  005c0	8b ec		 mov	 ebp, esp
  005c2	83 ec 14	 sub	 esp, 20			; 00000014H
  005c5	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 204  : 	//	get memory to read an .HEP object into
; 205  : 
; 206  : 	FakeObjectID::Get(size);

  005c8	6a 00		 push	 0
  005ca	6a 00		 push	 0
  005cc	6a 00		 push	 0
  005ce	6a 00		 push	 0
  005d0	68 00 02 00 00	 push	 512			; 00000200H
  005d5	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  005d8	50		 push	 eax
  005d9	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  005dc	e8 00 00 00 00	 call	 ?Get@FakeObjectID@@QAEXIIIPAUMemClient@@DW4ReservedHandle@@@Z ; FakeObjectID::Get

; 207  : 
; 208  : //	Object *obj = (Object *)**this;
; 209  : //	obj->_selectorDict.Get ( MemDictionary, sizeof ( SelectorDict ) );
; 210  : 
; 211  : 	new(handle) Object(*this, id, ofs, size);

  005e1	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  005e4	66 8b 11	 mov	 dx, WORD PTR [ecx]
  005e7	52		 push	 edx
  005e8	6a 10		 push	 16			; 00000010H
  005ea	e8 00 00 00 00	 call	 ??2@YAPAXIG@Z		; operator new
  005ef	83 c4 08	 add	 esp, 8
  005f2	89 45 fc	 mov	 DWORD PTR $T59980[ebp], eax
  005f5	83 7d fc 00	 cmp	 DWORD PTR $T59980[ebp], 0
  005f9	74 2d		 je	 SHORT $L59983
  005fb	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  005fe	50		 push	 eax
  005ff	8b 4d 0c	 mov	 ecx, DWORD PTR _ofs$[ebp]
  00602	51		 push	 ecx
  00603	51		 push	 ecx
  00604	8b cc		 mov	 ecx, esp
  00606	8d 55 08	 lea	 edx, DWORD PTR _id$[ebp]
  00609	52		 push	 edx
  0060a	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  0060f	51		 push	 ecx
  00610	8b cc		 mov	 ecx, esp
  00612	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00615	50		 push	 eax
  00616	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  0061b	8b 4d fc	 mov	 ecx, DWORD PTR $T59980[ebp]
  0061e	e8 00 00 00 00	 call	 ??0Object@@QAE@VMemID@@0II@Z ; Object::Object
  00623	89 45 ec	 mov	 DWORD PTR -20+[ebp], eax
  00626	eb 07		 jmp	 SHORT $L59984
$L59983:
  00628	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR -20+[ebp], 0
$L59984:

; 212  : }

  0062f	8b e5		 mov	 esp, ebp
  00631	5d		 pop	 ebp
  00632	c2 0c 00	 ret	 12			; 0000000cH
?Get@ObjectID@@QAEXVMemID@@II@Z ENDP			; ObjectID::Get
_TEXT	ENDS
;	COMDAT ??2@YAPAXIG@Z
_TEXT	SEGMENT
_handle$ = 12
??2@YAPAXIG@Z PROC NEAR					; operator new, COMDAT

; 186  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 	return memMgr->GetAddr(handle);

  00003	66 8b 45 0c	 mov	 ax, WORD PTR _handle$[ebp]
  00007	50		 push	 eax
  00008	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  0000e	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr

; 188  : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??2@YAPAXIG@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get
;	COMDAT ?Get@FakeObjectID@@QAEXIIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT
_size$ = 8
_attrs$ = 12
_num$ = 16
_client$ = 20
_initChar$ = 24
_h$ = 28
_this$ = -4
?Get@FakeObjectID@@QAEXIIIPAUMemClient@@DW4ReservedHandle@@@Z PROC NEAR ; FakeObjectID::Get, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 1c	 mov	 eax, DWORD PTR _h$[ebp]
  0000a	50		 push	 eax
  0000b	8a 4d 18	 mov	 cl, BYTE PTR _initChar$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 14	 mov	 edx, DWORD PTR _client$[ebp]
  00012	52		 push	 edx
  00013	8b 45 10	 mov	 eax, DWORD PTR _num$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _attrs$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 55 08	 mov	 edx, DWORD PTR _size$[ebp]
  0001e	52		 push	 edx
  0001f	6a 34		 push	 52			; 00000034H
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemID::Get
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 18 00	 ret	 24			; 00000018H
?Get@FakeObjectID@@QAEXIIIPAUMemClient@@DW4ReservedHandle@@@Z ENDP ; FakeObjectID::Get
_TEXT	ENDS
EXTRN	?Alloc@MemoryMgr@@QAEGIIIPAUMemClient@@DW4ReservedHandle@@@Z:NEAR ; MemoryMgr::Alloc
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT
_type$ = 8
_size$ = 12
_a$ = 16
_num$ = 20
_client$ = 24
_initChar$ = 28
_h$ = 32
_this$ = -4
?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z PROC NEAR ; MemID::Get, COMDAT

; 42   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 43   : 		handle = memMgr->Alloc(type | a, size, num, client, initChar, h);

  00007	8b 45 20	 mov	 eax, DWORD PTR _h$[ebp]
  0000a	50		 push	 eax
  0000b	8a 4d 1c	 mov	 cl, BYTE PTR _initChar$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 18	 mov	 edx, DWORD PTR _client$[ebp]
  00012	52		 push	 edx
  00013	8b 45 14	 mov	 eax, DWORD PTR _num$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 55 08	 mov	 edx, DWORD PTR _type$[ebp]
  0001e	0b 55 10	 or	 edx, DWORD PTR _a$[ebp]
  00021	52		 push	 edx
  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00028	e8 00 00 00 00	 call	 ?Alloc@MemoryMgr@@QAEGIIIPAUMemClient@@DW4ReservedHandle@@@Z ; MemoryMgr::Alloc
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	66 89 01	 mov	 WORD PTR [ecx], ax

; 44   : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 1c 00	 ret	 28			; 0000001cH
?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z ENDP ; MemID::Get
_TEXT	ENDS
PUBLIC	?Get@ObjectID@@QAEXV1@@Z			; ObjectID::Get
_TEXT	SEGMENT
_clonee$ = 8
_this$ = -16
$T59989 = -4
?Get@ObjectID@@QAEXV1@@Z PROC NEAR			; ObjectID::Get

; 216  : {

  00635	55		 push	 ebp
  00636	8b ec		 mov	 ebp, esp
  00638	83 ec 14	 sub	 esp, 20			; 00000014H
  0063b	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 217  : 	//	clone an Object
; 218  : 
; 219  : 	FakeObjectID::Get(clonee->size * sizeof(Property));

  0063e	6a 00		 push	 0
  00640	6a 00		 push	 0
  00642	6a 00		 push	 0
  00644	6a 00		 push	 0
  00646	68 00 02 00 00	 push	 512			; 00000200H
  0064b	8d 4d 08	 lea	 ecx, DWORD PTR _clonee$[ebp]
  0064e	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  00653	0f bf 40 02	 movsx	 eax, WORD PTR [eax+2]
  00657	d1 e0		 shl	 eax, 1
  00659	50		 push	 eax
  0065a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0065d	e8 00 00 00 00	 call	 ?Get@FakeObjectID@@QAEXIIIPAUMemClient@@DW4ReservedHandle@@@Z ; FakeObjectID::Get

; 220  : 	new(handle) Object(*this, clonee);

  00662	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00665	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00668	52		 push	 edx
  00669	6a 10		 push	 16			; 00000010H
  0066b	e8 00 00 00 00	 call	 ??2@YAPAXIG@Z		; operator new
  00670	83 c4 08	 add	 esp, 8
  00673	89 45 fc	 mov	 DWORD PTR $T59989[ebp], eax
  00676	83 7d fc 00	 cmp	 DWORD PTR $T59989[ebp], 0
  0067a	74 25		 je	 SHORT $L59992
  0067c	51		 push	 ecx
  0067d	8b cc		 mov	 ecx, esp
  0067f	8d 45 08	 lea	 eax, DWORD PTR _clonee$[ebp]
  00682	50		 push	 eax
  00683	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00688	51		 push	 ecx
  00689	8b cc		 mov	 ecx, esp
  0068b	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0068e	52		 push	 edx
  0068f	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00694	8b 4d fc	 mov	 ecx, DWORD PTR $T59989[ebp]
  00697	e8 00 00 00 00	 call	 ??0Object@@QAE@VMemID@@0@Z ; Object::Object
  0069c	89 45 ec	 mov	 DWORD PTR -20+[ebp], eax
  0069f	eb 07		 jmp	 SHORT $L59993
$L59992:
  006a1	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR -20+[ebp], 0
$L59993:

; 221  : }

  006a8	8b e5		 mov	 esp, ebp
  006aa	5d		 pop	 ebp
  006ab	c2 04 00	 ret	 4
?Get@ObjectID@@QAEXV1@@Z ENDP				; ObjectID::Get
_TEXT	ENDS
PUBLIC	??_GObject@@QAEPAXI@Z				; Object::`scalar deleting destructor'
PUBLIC	??DFakeObjectID@@QBEPAUObject@@XZ		; FakeObjectID::operator*
PUBLIC	?Free@MemID@@QAEXXZ				; MemID::Free
PUBLIC	?Free@ObjectID@@QAEXXZ				; ObjectID::Free
_DATA	SEGMENT
$SG59560 DB	'ObjectID::Free called on non-object (MemID = 0x%x).', 00H
_DATA	ENDS
_TEXT	SEGMENT
_this$ = -4
?Free@ObjectID@@QAEXXZ PROC NEAR			; ObjectID::Free

; 225  : {

  006ae	55		 push	 ebp
  006af	8b ec		 mov	 ebp, esp
  006b1	51		 push	 ecx
  006b2	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 226  : 	//	this is necessary because of a bug in WATCOM 9.5 (see MEMID.HPP)
; 227  : 	if (handle) {

  006b5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  006b8	33 c9		 xor	 ecx, ecx
  006ba	66 8b 08	 mov	 cx, WORD PTR [eax]
  006bd	85 c9		 test	 ecx, ecx
  006bf	74 3a		 je	 SHORT $L59558

; 228  : 		if ( !IsObject() )

  006c1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006c4	e8 00 00 00 00	 call	 ?IsObject@ObjectID@@QBEHXZ ; ObjectID::IsObject
  006c9	85 c0		 test	 eax, eax
  006cb	75 1d		 jne	 SHORT $L59559

; 229  : 			msgMgr->Fatal ( "ObjectID::Free called on non-object (MemID = 0x%x).", handle );

  006cd	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  006d0	33 c0		 xor	 eax, eax
  006d2	66 8b 02	 mov	 ax, WORD PTR [edx]
  006d5	50		 push	 eax
  006d6	68 00 00 00 00	 push	 OFFSET FLAT:$SG59560
  006db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  006e1	51		 push	 ecx
  006e2	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  006e7	83 c4 0c	 add	 esp, 12			; 0000000cH
$L59559:

; 230  : 
; 231  : 		(**this)->~Object();

  006ea	6a 00		 push	 0
  006ec	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006ef	e8 00 00 00 00	 call	 ??DFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator*
  006f4	8b c8		 mov	 ecx, eax
  006f6	e8 00 00 00 00	 call	 ??_GObject@@QAEPAXI@Z	; Object::`scalar deleting destructor'
$L59558:

; 233  : 
; 234  : 	FakeObjectID::Free();

  006fb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006fe	e8 00 00 00 00	 call	 ?Free@MemID@@QAEXXZ	; MemID::Free

; 235  : }

  00703	8b e5		 mov	 esp, ebp
  00705	5d		 pop	 ebp
  00706	c3		 ret	 0
?Free@ObjectID@@QAEXXZ ENDP				; ObjectID::Free
_TEXT	ENDS
EXTRN	?Free@MemoryMgr@@QAEXG@Z:NEAR			; MemoryMgr::Free
;	COMDAT ?Free@MemID@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Free@MemID@@QAEXXZ PROC NEAR				; MemID::Free, COMDAT

; 32   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 33   : 		if (handle) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000f	85 c9		 test	 ecx, ecx
  00011	74 1a		 je	 SHORT $L55156

; 34   : 			memMgr->Free(handle);

  00013	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00016	66 8b 02	 mov	 ax, WORD PTR [edx]
  00019	50		 push	 eax
  0001a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00020	e8 00 00 00 00	 call	 ?Free@MemoryMgr@@QAEXG@Z ; MemoryMgr::Free

; 35   : 			handle = 0;

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	66 c7 01 00 00	 mov	 WORD PTR [ecx], 0
$L55156:

; 37   : 	}

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?Free@MemID@@QAEXXZ ENDP				; MemID::Free
_TEXT	ENDS
;	COMDAT ??DFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT
_this$ = -4
??DFakeObjectID@@QBEPAUObject@@XZ PROC NEAR		; FakeObjectID::operator*, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??DFakeObjectID@@QBEPAUObject@@XZ ENDP			; FakeObjectID::operator*
_TEXT	ENDS
;	COMDAT ??_GObject@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GObject@@QAEPAXI@Z PROC NEAR				; Object::`scalar deleting destructor', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1Object@@QAE@XZ	; Object::~Object
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L59564
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L59564:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GObject@@QAEPAXI@Z ENDP				; Object::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0ObjectID@@QAE@XZ				; ObjectID::ObjectID
PUBLIC	?Clone@ObjectID@@QAE?AV1@XZ			; ObjectID::Clone
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -12
_newObject$ = -4
?Clone@ObjectID@@QAE?AV1@XZ PROC NEAR			; ObjectID::Clone

; 239  : {

  00707	55		 push	 ebp
  00708	8b ec		 mov	 ebp, esp
  0070a	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0070d	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 240  : 	//	return pointer to copy of an object or class
; 241  : 
; 242  : 	//	get memory and copy into it
; 243  : 	ObjectID newObject;

  00710	8d 4d fc	 lea	 ecx, DWORD PTR _newObject$[ebp]
  00713	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@XZ	; ObjectID::ObjectID

; 244  : 	newObject.Get(*this);

  00718	51		 push	 ecx
  00719	8b cc		 mov	 ecx, esp
  0071b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0071e	50		 push	 eax
  0071f	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID
  00724	8d 4d fc	 lea	 ecx, DWORD PTR _newObject$[ebp]
  00727	e8 00 00 00 00	 call	 ?Get@ObjectID@@QAEXV1@@Z ; ObjectID::Get

; 245  : 
; 246  : 	return newObject;

  0072c	8d 4d fc	 lea	 ecx, DWORD PTR _newObject$[ebp]
  0072f	51		 push	 ecx
  00730	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00733	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID
  00738	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 247  : }

  0073b	8b e5		 mov	 esp, ebp
  0073d	5d		 pop	 ebp
  0073e	c2 04 00	 ret	 4
?Clone@ObjectID@@QAE?AV1@XZ ENDP			; ObjectID::Clone
_TEXT	ENDS
PUBLIC	??0FakeObjectID@@QAE@XZ				; FakeObjectID::FakeObjectID
;	COMDAT ??0ObjectID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0ObjectID@@QAE@XZ PROC NEAR				; ObjectID::ObjectID, COMDAT

; 227  : 	ObjectID() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0FakeObjectID@@QAE@XZ	; FakeObjectID::FakeObjectID
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0ObjectID@@QAE@XZ ENDP				; ObjectID::ObjectID
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0FakeObjectID@@QAE@XZ PROC NEAR			; FakeObjectID::FakeObjectID, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0FakeObjectID@@QAE@XZ ENDP				; FakeObjectID::FakeObjectID
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4
??0SelectorDict@@QAE@XZ PROC NEAR			; SelectorDict::SelectorDict

; 252  : {

  00741	55		 push	 ebp
  00742	8b ec		 mov	 ebp, esp
  00744	51		 push	 ecx
  00745	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 	size = 0;

  00748	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0074b	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 254  : 	selectors = NULL;

  00752	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00755	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 255  : 	offsets = NULL;

  0075b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0075e	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 256  : 	scripts = NULL;

  00765	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00768	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 257  : }

  0076f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00772	8b e5		 mov	 esp, ebp
  00774	5d		 pop	 ebp
  00775	c3		 ret	 0
??0SelectorDict@@QAE@XZ ENDP				; SelectorDict::SelectorDict
_TEXT	ENDS
PUBLIC	?selectorsSize@SelectorDict@@QAEHXZ		; SelectorDict::selectorsSize
PUBLIC	?offsetsSize@SelectorDict@@QAEHXZ		; SelectorDict::offsetsSize
PUBLIC	?scriptsSize@SelectorDict@@QAEHXZ		; SelectorDict::scriptsSize
_TEXT	SEGMENT
_this$ = -4
??1SelectorDict@@QAE@XZ PROC NEAR			; SelectorDict::~SelectorDict

; 260  : {

  00776	55		 push	 ebp
  00777	8b ec		 mov	 ebp, esp
  00779	51		 push	 ecx
  0077a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 261  : 	if ( selectors ) {

  0077d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00780	83 38 00	 cmp	 DWORD PTR [eax], 0
  00783	74 25		 je	 SHORT $L59577

; 262  : 		free ( selectors );

  00785	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00788	8b 11		 mov	 edx, DWORD PTR [ecx]
  0078a	52		 push	 edx
  0078b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00791	83 c4 04	 add	 esp, 4

; 263  : 		gSelectorDictSize -= selectorsSize();

  00794	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00797	e8 00 00 00 00	 call	 ?selectorsSize@SelectorDict@@QAEHXZ ; SelectorDict::selectorsSize
  0079c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gSelectorDictSize@@3HA ; gSelectorDictSize
  007a2	2b c8		 sub	 ecx, eax
  007a4	89 0d 00 00 00
	00		 mov	 DWORD PTR ?gSelectorDictSize@@3HA, ecx ; gSelectorDictSize
$L59577:

; 265  : 
; 266  : 	if ( offsets ) {

  007aa	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  007ad	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  007b1	74 26		 je	 SHORT $L59578

; 267  : 		free ( offsets );

  007b3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  007b6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  007b9	51		 push	 ecx
  007ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  007c0	83 c4 04	 add	 esp, 4

; 268  : 		gSelectorDictSize -= offsetsSize();

  007c3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  007c6	e8 00 00 00 00	 call	 ?offsetsSize@SelectorDict@@QAEHXZ ; SelectorDict::offsetsSize
  007cb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gSelectorDictSize@@3HA ; gSelectorDictSize
  007d1	2b d0		 sub	 edx, eax
  007d3	89 15 00 00 00
	00		 mov	 DWORD PTR ?gSelectorDictSize@@3HA, edx ; gSelectorDictSize
$L59578:

; 270  : 
; 271  : 	if ( scripts ) {

  007d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  007dc	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  007e0	74 26		 je	 SHORT $L59579

; 272  : 		free ( scripts );

  007e2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  007e5	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  007e8	52		 push	 edx
  007e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  007ef	83 c4 04	 add	 esp, 4

; 273  : 		gSelectorDictSize -= scriptsSize();

  007f2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  007f5	e8 00 00 00 00	 call	 ?scriptsSize@SelectorDict@@QAEHXZ ; SelectorDict::scriptsSize
  007fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gSelectorDictSize@@3HA ; gSelectorDictSize
  00800	2b c8		 sub	 ecx, eax
  00802	89 0d 00 00 00
	00		 mov	 DWORD PTR ?gSelectorDictSize@@3HA, ecx ; gSelectorDictSize
$L59579:

; 275  : 
; 276  : 	size = 0;

  00808	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0080b	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0

; 277  : 	selectors = NULL;

  00812	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00815	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 278  : 	offsets = NULL;

  0081b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0081e	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 279  : 	scripts = NULL;

  00825	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00828	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 280  : }

  0082f	8b e5		 mov	 esp, ebp
  00831	5d		 pop	 ebp
  00832	c3		 ret	 0
??1SelectorDict@@QAE@XZ ENDP				; SelectorDict::~SelectorDict
_TEXT	ENDS
;	COMDAT ?selectorsSize@SelectorDict@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?selectorsSize@SelectorDict@@QAEHXZ PROC NEAR		; SelectorDict::selectorsSize, COMDAT

; 81   : 	inline int selectorsSize ( void ) { return sizeof ( Selector ) * size + 16; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000d	8d 44 09 10	 lea	 eax, DWORD PTR [ecx+ecx+16]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?selectorsSize@SelectorDict@@QAEHXZ ENDP		; SelectorDict::selectorsSize
_TEXT	ENDS
;	COMDAT ?offsetsSize@SelectorDict@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?offsetsSize@SelectorDict@@QAEHXZ PROC NEAR		; SelectorDict::offsetsSize, COMDAT

; 82   : 	inline int offsetsSize ( void ) { return sizeof ( unsigned int ) * size + 16; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000d	8d 04 8d 10 00
	00 00		 lea	 eax, DWORD PTR [ecx*4+16]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?offsetsSize@SelectorDict@@QAEHXZ ENDP			; SelectorDict::offsetsSize
_TEXT	ENDS
;	COMDAT ?scriptsSize@SelectorDict@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?scriptsSize@SelectorDict@@QAEHXZ PROC NEAR		; SelectorDict::scriptsSize, COMDAT

; 83   : 	inline int scriptsSize ( void ) { return sizeof ( unsigned int ) * size + 16; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000d	8d 04 8d 10 00
	00 00		 lea	 eax, DWORD PTR [ecx*4+16]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?scriptsSize@SelectorDict@@QAEHXZ ENDP			; SelectorDict::scriptsSize
_TEXT	ENDS
PUBLIC	?add@SelectorDict@@QAEXGII@Z			; SelectorDict::add
_DATA	SEGMENT
$SG59600 DB	'Could not reallocate selector dictionary on add.', 00H
_DATA	ENDS
_TEXT	SEGMENT
_selector$ = 8
_offset$ = 12
_script$ = 16
_this$ = -12
_index$ = -4
_ptr$59588 = -8
?add@SelectorDict@@QAEXGII@Z PROC NEAR			; SelectorDict::add

; 284  : {

  00833	55		 push	 ebp
  00834	8b ec		 mov	 ebp, esp
  00836	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00839	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 285  : 	int index = get ( selector );

  0083c	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  00840	50		 push	 eax
  00841	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00844	e8 00 00 00 00	 call	 ?get@SelectorDict@@QAEHG@Z ; SelectorDict::get
  00849	89 45 fc	 mov	 DWORD PTR _index$[ebp], eax

; 286  : 
; 287  : 	if ( index == -1 ) {

  0084c	83 7d fc ff	 cmp	 DWORD PTR _index$[ebp], -1
  00850	0f 85 59 01 00
	00		 jne	 $L59587

; 288  : 		index = size;

  00856	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00859	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0085c	89 55 fc	 mov	 DWORD PTR _index$[ebp], edx

; 289  : 		size++;

  0085f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00862	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00865	83 c1 01	 add	 ecx, 1
  00868	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0086b	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 290  : 
; 291  : 		void *ptr = NULL;

  0086e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _ptr$59588[ebp], 0

; 292  : 
; 293  : 		ptr = malloc ( selectorsSize() );

  00875	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00878	e8 00 00 00 00	 call	 ?selectorsSize@SelectorDict@@QAEHXZ ; SelectorDict::selectorsSize
  0087d	50		 push	 eax
  0087e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00884	83 c4 04	 add	 esp, 4
  00887	89 45 f8	 mov	 DWORD PTR _ptr$59588[ebp], eax

; 294  : 
; 295  : 		if ( selectors ) {

  0088a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0088d	83 38 00	 cmp	 DWORD PTR [eax], 0
  00890	74 2d		 je	 SHORT $L59589

; 296  : 			memcpy ( ptr, selectors, selectorsSize() - sizeof ( Selector ) );

  00892	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00895	e8 00 00 00 00	 call	 ?selectorsSize@SelectorDict@@QAEHXZ ; SelectorDict::selectorsSize
  0089a	83 e8 02	 sub	 eax, 2
  0089d	50		 push	 eax
  0089e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  008a1	8b 11		 mov	 edx, DWORD PTR [ecx]
  008a3	52		 push	 edx
  008a4	8b 45 f8	 mov	 eax, DWORD PTR _ptr$59588[ebp]
  008a7	50		 push	 eax
  008a8	e8 00 00 00 00	 call	 _memcpy
  008ad	83 c4 0c	 add	 esp, 12			; 0000000cH

; 297  : 			free ( selectors );

  008b0	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  008b3	8b 11		 mov	 edx, DWORD PTR [ecx]
  008b5	52		 push	 edx
  008b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  008bc	83 c4 04	 add	 esp, 4
$L59589:

; 299  : 
; 300  : 		selectors = (Selector *)ptr;

  008bf	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  008c2	8b 4d f8	 mov	 ecx, DWORD PTR _ptr$59588[ebp]
  008c5	89 08		 mov	 DWORD PTR [eax], ecx

; 301  : 
; 302  : 		ptr = malloc ( offsetsSize() );

  008c7	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  008ca	e8 00 00 00 00	 call	 ?offsetsSize@SelectorDict@@QAEHXZ ; SelectorDict::offsetsSize
  008cf	50		 push	 eax
  008d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  008d6	83 c4 04	 add	 esp, 4
  008d9	89 45 f8	 mov	 DWORD PTR _ptr$59588[ebp], eax

; 303  : 
; 304  : 		if ( offsets ) {

  008dc	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  008df	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  008e3	74 2f		 je	 SHORT $L59592

; 305  : 			memcpy ( ptr, offsets, offsetsSize() - sizeof ( unsigned int ) );

  008e5	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  008e8	e8 00 00 00 00	 call	 ?offsetsSize@SelectorDict@@QAEHXZ ; SelectorDict::offsetsSize
  008ed	83 e8 04	 sub	 eax, 4
  008f0	50		 push	 eax
  008f1	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  008f4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  008f7	51		 push	 ecx
  008f8	8b 55 f8	 mov	 edx, DWORD PTR _ptr$59588[ebp]
  008fb	52		 push	 edx
  008fc	e8 00 00 00 00	 call	 _memcpy
  00901	83 c4 0c	 add	 esp, 12			; 0000000cH

; 306  : 			free ( offsets );

  00904	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00907	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0090a	51		 push	 ecx
  0090b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00911	83 c4 04	 add	 esp, 4
$L59592:

; 308  : 
; 309  : 		offsets = (unsigned int *)ptr;

  00914	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00917	8b 45 f8	 mov	 eax, DWORD PTR _ptr$59588[ebp]
  0091a	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 310  : 
; 311  : 		ptr = malloc ( scriptsSize() );

  0091d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00920	e8 00 00 00 00	 call	 ?scriptsSize@SelectorDict@@QAEHXZ ; SelectorDict::scriptsSize
  00925	50		 push	 eax
  00926	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0092c	83 c4 04	 add	 esp, 4
  0092f	89 45 f8	 mov	 DWORD PTR _ptr$59588[ebp], eax

; 312  : 
; 313  : 		if ( scripts ) {

  00932	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00935	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00939	74 2f		 je	 SHORT $L59595

; 314  : 			memcpy ( ptr, scripts, scriptsSize() - sizeof ( unsigned int ) );

  0093b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0093e	e8 00 00 00 00	 call	 ?scriptsSize@SelectorDict@@QAEHXZ ; SelectorDict::scriptsSize
  00943	83 e8 04	 sub	 eax, 4
  00946	50		 push	 eax
  00947	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0094a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0094d	50		 push	 eax
  0094e	8b 4d f8	 mov	 ecx, DWORD PTR _ptr$59588[ebp]
  00951	51		 push	 ecx
  00952	e8 00 00 00 00	 call	 _memcpy
  00957	83 c4 0c	 add	 esp, 12			; 0000000cH

; 315  : 			free ( scripts );

  0095a	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0095d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00960	50		 push	 eax
  00961	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00967	83 c4 04	 add	 esp, 4
$L59595:

; 317  : 
; 318  : 		scripts = (unsigned int *)ptr;

  0096a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0096d	8b 55 f8	 mov	 edx, DWORD PTR _ptr$59588[ebp]
  00970	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 319  : 
; 320  : 		if ( !selectors || !offsets || !scripts )

  00973	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00976	83 38 00	 cmp	 DWORD PTR [eax], 0
  00979	74 12		 je	 SHORT $L59599
  0097b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0097e	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00982	74 09		 je	 SHORT $L59599
  00984	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00987	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  0098b	75 13		 jne	 SHORT $L59598
$L59599:

; 321  : 			msgMgr->Fatal ( "Could not reallocate selector dictionary on add." );

  0098d	68 00 00 00 00	 push	 OFFSET FLAT:$SG59600
  00992	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00997	50		 push	 eax
  00998	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  0099d	83 c4 08	 add	 esp, 8
$L59598:

; 322  : 
; 323  : 		gSelectorDictSize += sizeof ( Selector ) + sizeof ( unsigned int ) + sizeof ( unsigned int );

  009a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gSelectorDictSize@@3HA ; gSelectorDictSize
  009a6	83 c1 0a	 add	 ecx, 10			; 0000000aH
  009a9	89 0d 00 00 00
	00		 mov	 DWORD PTR ?gSelectorDictSize@@3HA, ecx ; gSelectorDictSize
$L59587:

; 325  : 
; 326  : 	selectors[index] = selector;

  009af	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  009b2	8b 02		 mov	 eax, DWORD PTR [edx]
  009b4	8b 4d fc	 mov	 ecx, DWORD PTR _index$[ebp]
  009b7	66 8b 55 08	 mov	 dx, WORD PTR _selector$[ebp]
  009bb	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 327  : 	offsets[index] = offset;

  009bf	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  009c2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  009c5	8b 55 fc	 mov	 edx, DWORD PTR _index$[ebp]
  009c8	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  009cb	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax

; 328  : 	scripts[index] = script;

  009ce	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  009d1	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  009d4	8b 45 fc	 mov	 eax, DWORD PTR _index$[ebp]
  009d7	8b 4d 10	 mov	 ecx, DWORD PTR _script$[ebp]
  009da	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx

; 329  : }

  009dd	8b e5		 mov	 esp, ebp
  009df	5d		 pop	 ebp
  009e0	c2 0c 00	 ret	 12			; 0000000cH
?add@SelectorDict@@QAEXGII@Z ENDP			; SelectorDict::add
_TEXT	ENDS
_DATA	SEGMENT
	ORG $+3
$SG59614 DB	'SelectorDict::get called with no selectors allocated.', 00H
_DATA	ENDS
_TEXT	SEGMENT
_selector$ = 8
_this$ = -12
_ptr$ = -4
_i$ = -8
?get@SelectorDict@@QAEHG@Z PROC NEAR			; SelectorDict::get

; 332  : {

  009e3	55		 push	 ebp
  009e4	8b ec		 mov	 ebp, esp
  009e6	83 ec 0c	 sub	 esp, 12			; 0000000cH
  009e9	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 333  : 	Selector *ptr = selectors;

  009ec	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  009ef	8b 08		 mov	 ecx, DWORD PTR [eax]
  009f1	89 4d fc	 mov	 DWORD PTR _ptr$[ebp], ecx

; 334  : 
; 335  : 	for ( int i=0; i<size; i++ ) {

  009f4	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  009fb	eb 09		 jmp	 SHORT $L59610
$L59611:
  009fd	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00a00	83 c2 01	 add	 edx, 1
  00a03	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$L59610:
  00a06	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00a09	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00a0c	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  00a0f	7d 67		 jge	 SHORT $L59612

; 336  : 		if ( !ptr ) 

  00a11	83 7d fc 00	 cmp	 DWORD PTR _ptr$[ebp], 0
  00a15	75 14		 jne	 SHORT $L59613

; 337  : 			msgMgr->Fatal ( "SelectorDict::get called with no selectors allocated." );

  00a17	68 00 00 00 00	 push	 OFFSET FLAT:$SG59614
  00a1c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00a22	52		 push	 edx
  00a23	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00a28	83 c4 08	 add	 esp, 8
$L59613:

; 338  : 
; 339  : 		if ( *ptr++ == selector ) {

  00a2b	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  00a2e	33 c9		 xor	 ecx, ecx
  00a30	66 8b 08	 mov	 cx, WORD PTR [eax]
  00a33	8b 55 08	 mov	 edx, DWORD PTR _selector$[ebp]
  00a36	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00a3c	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  00a3f	83 c0 02	 add	 eax, 2
  00a42	89 45 fc	 mov	 DWORD PTR _ptr$[ebp], eax
  00a45	3b ca		 cmp	 ecx, edx
  00a47	75 2d		 jne	 SHORT $L59615

; 340  : 			script = scripts[i];

  00a49	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00a4c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00a4f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00a52	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00a55	66 8b 14 8a	 mov	 dx, WORD PTR [edx+ecx*4]
  00a59	66 89 50 16	 mov	 WORD PTR [eax+22], dx

; 341  : 			offset = offsets[i];

  00a5d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00a60	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00a63	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00a66	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00a69	66 8b 0c 81	 mov	 cx, WORD PTR [ecx+eax*4]
  00a6d	66 89 4a 14	 mov	 WORD PTR [edx+20], cx

; 342  : 			return i;

  00a71	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00a74	eb 05		 jmp	 SHORT $L59607
$L59615:

; 344  : 	}

  00a76	eb 85		 jmp	 SHORT $L59611
$L59612:

; 345  : 
; 346  : 	return -1;

  00a78	83 c8 ff	 or	 eax, -1
$L59607:

; 347  : }

  00a7b	8b e5		 mov	 esp, ebp
  00a7d	5d		 pop	 ebp
  00a7e	c2 04 00	 ret	 4
?get@SelectorDict@@QAEHG@Z ENDP				; SelectorDict::get
_TEXT	ENDS
PUBLIC	?copy@SelectorDict@@QAEXPAV1@@Z			; SelectorDict::copy
_DATA	SEGMENT
	ORG $+2
$SG59625 DB	'Could not allocate selector dictionary on copy.', 00H
_DATA	ENDS
_TEXT	SEGMENT
_dict$ = 8
_this$ = -4
?copy@SelectorDict@@QAEXPAV1@@Z PROC NEAR		; SelectorDict::copy

; 350  : {

  00a81	55		 push	 ebp
  00a82	8b ec		 mov	 ebp, esp
  00a84	51		 push	 ecx
  00a85	56		 push	 esi
  00a86	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 351  : 	size = dict->size;

  00a89	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a8c	8b 4d 08	 mov	 ecx, DWORD PTR _dict$[ebp]
  00a8f	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00a92	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 352  : 
; 353  : 	selectors = (Selector *) malloc ( selectorsSize() );

  00a95	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a98	e8 00 00 00 00	 call	 ?selectorsSize@SelectorDict@@QAEHXZ ; SelectorDict::selectorsSize
  00a9d	50		 push	 eax
  00a9e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00aa4	83 c4 04	 add	 esp, 4
  00aa7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00aaa	89 01		 mov	 DWORD PTR [ecx], eax

; 354  : 	offsets = (unsigned int *) malloc ( offsetsSize() );

  00aac	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00aaf	e8 00 00 00 00	 call	 ?offsetsSize@SelectorDict@@QAEHXZ ; SelectorDict::offsetsSize
  00ab4	50		 push	 eax
  00ab5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00abb	83 c4 04	 add	 esp, 4
  00abe	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00ac1	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 355  : 	scripts = (unsigned int *) malloc ( scriptsSize() );

  00ac4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ac7	e8 00 00 00 00	 call	 ?scriptsSize@SelectorDict@@QAEHXZ ; SelectorDict::scriptsSize
  00acc	50		 push	 eax
  00acd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00ad3	83 c4 04	 add	 esp, 4
  00ad6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ad9	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 356  : 
; 357  : 	if ( !selectors || !offsets || !scripts )

  00adc	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00adf	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00ae2	74 12		 je	 SHORT $L59624
  00ae4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00ae7	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00aeb	74 09		 je	 SHORT $L59624
  00aed	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00af0	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00af4	75 14		 jne	 SHORT $L59623
$L59624:

; 358  : 		msgMgr->Fatal ( "Could not allocate selector dictionary on copy." );

  00af6	68 00 00 00 00	 push	 OFFSET FLAT:$SG59625
  00afb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00b01	52		 push	 edx
  00b02	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  00b07	83 c4 08	 add	 esp, 8
$L59623:

; 359  : 
; 360  : 	gSelectorDictSize += selectorsSize() + offsetsSize() + scriptsSize();

  00b0a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b0d	e8 00 00 00 00	 call	 ?selectorsSize@SelectorDict@@QAEHXZ ; SelectorDict::selectorsSize
  00b12	8b f0		 mov	 esi, eax
  00b14	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b17	e8 00 00 00 00	 call	 ?offsetsSize@SelectorDict@@QAEHXZ ; SelectorDict::offsetsSize
  00b1c	03 f0		 add	 esi, eax
  00b1e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b21	e8 00 00 00 00	 call	 ?scriptsSize@SelectorDict@@QAEHXZ ; SelectorDict::scriptsSize
  00b26	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gSelectorDictSize@@3HA ; gSelectorDictSize
  00b2c	03 c6		 add	 eax, esi
  00b2e	a3 00 00 00 00	 mov	 DWORD PTR ?gSelectorDictSize@@3HA, eax ; gSelectorDictSize

; 361  : 
; 362  : 	memcpy ( selectors, dict->selectors, selectorsSize() );

  00b33	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b36	e8 00 00 00 00	 call	 ?selectorsSize@SelectorDict@@QAEHXZ ; SelectorDict::selectorsSize
  00b3b	50		 push	 eax
  00b3c	8b 45 08	 mov	 eax, DWORD PTR _dict$[ebp]
  00b3f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b41	51		 push	 ecx
  00b42	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00b45	8b 02		 mov	 eax, DWORD PTR [edx]
  00b47	50		 push	 eax
  00b48	e8 00 00 00 00	 call	 _memcpy
  00b4d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 363  : 	memcpy ( offsets, dict->offsets, offsetsSize() );

  00b50	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b53	e8 00 00 00 00	 call	 ?offsetsSize@SelectorDict@@QAEHXZ ; SelectorDict::offsetsSize
  00b58	50		 push	 eax
  00b59	8b 4d 08	 mov	 ecx, DWORD PTR _dict$[ebp]
  00b5c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00b5f	52		 push	 edx
  00b60	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b63	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00b66	51		 push	 ecx
  00b67	e8 00 00 00 00	 call	 _memcpy
  00b6c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 364  : 	memcpy ( scripts, dict->scripts, scriptsSize() );

  00b6f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b72	e8 00 00 00 00	 call	 ?scriptsSize@SelectorDict@@QAEHXZ ; SelectorDict::scriptsSize
  00b77	50		 push	 eax
  00b78	8b 55 08	 mov	 edx, DWORD PTR _dict$[ebp]
  00b7b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00b7e	50		 push	 eax
  00b7f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b82	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00b85	52		 push	 edx
  00b86	e8 00 00 00 00	 call	 _memcpy
  00b8b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 365  : }

  00b8e	5e		 pop	 esi
  00b8f	8b e5		 mov	 esp, ebp
  00b91	5d		 pop	 ebp
  00b92	c2 04 00	 ret	 4
?copy@SelectorDict@@QAEXPAV1@@Z ENDP			; SelectorDict::copy
_TEXT	ENDS
PUBLIC	?GetClass@@YA?AVObjectID@@PBD@Z			; GetClass
PUBLIC	??0ObjectID@@QAE@G@Z				; ObjectID::ObjectID
PUBLIC	?Name@ObjectID@@QBEPBDXZ			; ObjectID::Name
EXTRN	_strcmp:NEAR
_TEXT	SEGMENT
_name$ = 12
___$ReturnUdt$ = 8
_obj$ = -8
_info$ = -4
?GetClass@@YA?AVObjectID@@PBD@Z PROC NEAR		; GetClass

; 371  : {

  00b95	55		 push	 ebp
  00b96	8b ec		 mov	 ebp, esp
  00b98	83 ec 08	 sub	 esp, 8

; 372  : 	//	return the class object with a given name
; 373  : 	ObjectID obj;

  00b9b	8d 4d f8	 lea	 ecx, DWORD PTR _obj$[ebp]
  00b9e	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@XZ	; ObjectID::ObjectID

; 374  : 	ObjectInfo *info = objInfo;

  00ba3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?objInfo@@3PAVObjectInfo@@A ; objInfo
  00ba8	89 45 fc	 mov	 DWORD PTR _info$[ebp], eax
$L59633:

; 375  : 
; 376  : 	while ( info ) {

  00bab	83 7d fc 00	 cmp	 DWORD PTR _info$[ebp], 0
  00baf	74 3f		 je	 SHORT $L59634

; 377  : 		obj = info->id;

  00bb1	8b 4d fc	 mov	 ecx, DWORD PTR _info$[ebp]
  00bb4	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  00bb8	66 89 55 f8	 mov	 WORD PTR _obj$[ebp], dx

; 378  : 
; 379  : 		if (!strcmp(obj.Name(), name))

  00bbc	8b 45 0c	 mov	 eax, DWORD PTR _name$[ebp]
  00bbf	50		 push	 eax
  00bc0	8d 4d f8	 lea	 ecx, DWORD PTR _obj$[ebp]
  00bc3	e8 00 00 00 00	 call	 ?Name@ObjectID@@QBEPBDXZ ; ObjectID::Name
  00bc8	50		 push	 eax
  00bc9	e8 00 00 00 00	 call	 _strcmp
  00bce	83 c4 08	 add	 esp, 8
  00bd1	85 c0		 test	 eax, eax
  00bd3	75 11		 jne	 SHORT $L59635

; 380  : 			return obj;

  00bd5	8d 4d f8	 lea	 ecx, DWORD PTR _obj$[ebp]
  00bd8	51		 push	 ecx
  00bd9	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00bdc	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID
  00be1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00be4	eb 17		 jmp	 SHORT $L59629
$L59635:

; 381  : 
; 382  : 		info = info->next;

  00be6	8b 55 fc	 mov	 edx, DWORD PTR _info$[ebp]
  00be9	8b 02		 mov	 eax, DWORD PTR [edx]
  00beb	89 45 fc	 mov	 DWORD PTR _info$[ebp], eax

; 383  : 	}

  00bee	eb bb		 jmp	 SHORT $L59633
$L59634:

; 384  : 
; 385  : 	return 0;

  00bf0	6a 00		 push	 0
  00bf2	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00bf5	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  00bfa	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$L59629:

; 386  : }

  00bfd	8b e5		 mov	 esp, ebp
  00bff	5d		 pop	 ebp
  00c00	c3		 ret	 0
?GetClass@@YA?AVObjectID@@PBD@Z ENDP			; GetClass
_TEXT	ENDS
PUBLIC	??0FakeObjectID@@QAE@G@Z			; FakeObjectID::FakeObjectID
;	COMDAT ??0ObjectID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0ObjectID@@QAE@G@Z PROC NEAR				; ObjectID::ObjectID, COMDAT

; 230  : 	ObjectID(SOL_Handle h) : FakeObjectID(h) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	66 8b 45 08	 mov	 ax, WORD PTR _h$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0FakeObjectID@@QAE@G@Z ; FakeObjectID::FakeObjectID
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0ObjectID@@QAE@G@Z ENDP				; ObjectID::ObjectID
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0FakeObjectID@@QAE@G@Z PROC NEAR			; FakeObjectID::FakeObjectID, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	66 8b 45 08	 mov	 ax, WORD PTR _h$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0FakeObjectID@@QAE@G@Z ENDP				; FakeObjectID::FakeObjectID
_TEXT	ENDS
;	COMDAT ?Name@ObjectID@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?Name@ObjectID@@QBEPBDXZ PROC NEAR			; ObjectID::Name, COMDAT

; 306  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 307  : 		//	return object's name, or "" if invalid object
; 308  : 		if (!IsObject())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?IsObject@ObjectID@@QBEHXZ ; ObjectID::IsObject
  0000f	85 c0		 test	 eax, eax
  00011	75 07		 jne	 SHORT $L58245

; 309  : 			return "";

  00013	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
  00018	eb 0f		 jmp	 SHORT $L58244
$L58245:

; 310  : 		return (*this)->Name();

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  00022	8b c8		 mov	 ecx, eax
  00024	e8 00 00 00 00	 call	 ?Name@Object@@QAEPBDXZ	; Object::Name
$L58244:

; 311  : 	}

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?Name@ObjectID@@QBEPBDXZ ENDP				; ObjectID::Name
_TEXT	ENDS
PUBLIC	?GetSelector@@YAGPBD@Z				; GetSelector
EXTRN	?GetVocabStr@@YAHHHPAD@Z:NEAR			; GetVocabStr
_TEXT	SEGMENT
_name$ = 8
_buf$ = -28
_i$ = -32
?GetSelector@@YAGPBD@Z PROC NEAR			; GetSelector

; 390  : {

  00c01	55		 push	 ebp
  00c02	8b ec		 mov	 ebp, esp
  00c04	83 ec 20	 sub	 esp, 32			; 00000020H

; 391  : 	//	find the selector number for a selector name
; 392  : 
; 393  :  	char buf[MaxSelectorName + 1];
; 394  :  	for (int i = 0; GetVocabStr(SELECTOR_VOCAB, i, buf); i++)

  00c07	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00c0e	eb 09		 jmp	 SHORT $L59641
$L59642:
  00c10	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  00c13	83 c0 01	 add	 eax, 1
  00c16	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax
$L59641:
  00c19	8d 4d e4	 lea	 ecx, DWORD PTR _buf$[ebp]
  00c1c	51		 push	 ecx
  00c1d	8b 55 e0	 mov	 edx, DWORD PTR _i$[ebp]
  00c20	52		 push	 edx
  00c21	68 e5 03 00 00	 push	 997			; 000003e5H
  00c26	e8 00 00 00 00	 call	 ?GetVocabStr@@YAHHHPAD@Z ; GetVocabStr
  00c2b	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c2e	85 c0		 test	 eax, eax
  00c30	74 1c		 je	 SHORT $L59643

; 395  : 		if (!strcmp(name, buf))

  00c32	8d 45 e4	 lea	 eax, DWORD PTR _buf$[ebp]
  00c35	50		 push	 eax
  00c36	8b 4d 08	 mov	 ecx, DWORD PTR _name$[ebp]
  00c39	51		 push	 ecx
  00c3a	e8 00 00 00 00	 call	 _strcmp
  00c3f	83 c4 08	 add	 esp, 8
  00c42	85 c0		 test	 eax, eax
  00c44	75 06		 jne	 SHORT $L59644

; 396  : 			return i;

  00c46	66 8b 45 e0	 mov	 ax, WORD PTR _i$[ebp]
  00c4a	eb 05		 jmp	 SHORT $L59638
$L59644:

; 397  : 	return 0;

  00c4c	eb c2		 jmp	 SHORT $L59642
$L59643:
  00c4e	66 33 c0	 xor	 ax, ax
$L59638:

; 398  : }

  00c51	8b e5		 mov	 esp, ebp
  00c53	5d		 pop	 ebp
  00c54	c3		 ret	 0
?GetSelector@@YAGPBD@Z ENDP				; GetSelector
_TEXT	ENDS
PUBLIC	?GetSelectorName@@YAPBDGPAD@Z			; GetSelectorName
EXTRN	__imp__sprintf:NEAR
_DATA	SEGMENT
$SG59650 DB	'%x', 00H
_DATA	ENDS
_TEXT	SEGMENT
_selector$ = 8
_str$ = 12
?GetSelectorName@@YAPBDGPAD@Z PROC NEAR			; GetSelectorName

; 402  : {

  00c55	55		 push	 ebp
  00c56	8b ec		 mov	 ebp, esp

; 403  : 	if (!GetVocabStr(SELECTOR_VOCAB, selector, str))

  00c58	8b 45 0c	 mov	 eax, DWORD PTR _str$[ebp]
  00c5b	50		 push	 eax
  00c5c	8b 4d 08	 mov	 ecx, DWORD PTR _selector$[ebp]
  00c5f	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00c65	51		 push	 ecx
  00c66	68 e5 03 00 00	 push	 997			; 000003e5H
  00c6b	e8 00 00 00 00	 call	 ?GetVocabStr@@YAHHHPAD@Z ; GetVocabStr
  00c70	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c73	85 c0		 test	 eax, eax
  00c75	75 1c		 jne	 SHORT $L59649

; 404  : 		sprintf(str, "%x", selector);

  00c77	8b 55 08	 mov	 edx, DWORD PTR _selector$[ebp]
  00c7a	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00c80	52		 push	 edx
  00c81	68 00 00 00 00	 push	 OFFSET FLAT:$SG59650
  00c86	8b 45 0c	 mov	 eax, DWORD PTR _str$[ebp]
  00c89	50		 push	 eax
  00c8a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  00c90	83 c4 0c	 add	 esp, 12			; 0000000cH
$L59649:

; 405  : 	return str;

  00c93	8b 45 0c	 mov	 eax, DWORD PTR _str$[ebp]

; 406  : }

  00c96	5d		 pop	 ebp
  00c97	c3		 ret	 0
?GetSelectorName@@YAPBDGPAD@Z ENDP			; GetSelectorName
_TEXT	ENDS
PUBLIC	_LoadPropOffsets
EXTRN	?resMgr@@3PAVResourceMgr@@A:DWORD		; resMgr
_TEXT	SEGMENT
_op$ = -4
_i$ = -8
$T60017 = -12
_LoadPropOffsets PROC NEAR

; 410  : {

  00c98	55		 push	 ebp
  00c99	8b ec		 mov	 ebp, esp
  00c9b	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 411  : 	// Load the offsets to indexed object properties from a file.
; 412  : 
; 413  : 	SCIWord* op = (SCIWord*) *resMgr->Get(MemResVocab, PROPOFS_VOCAB);

  00c9e	6a 00		 push	 0
  00ca0	68 e2 03 00 00	 push	 994			; 000003e2H
  00ca5	6a 06		 push	 6
  00ca7	8d 45 f4	 lea	 eax, DWORD PTR $T60017[ebp]
  00caa	50		 push	 eax
  00cab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMgr@@3PAVResourceMgr@@A ; resMgr
  00cb1	8b 11		 mov	 edx, DWORD PTR [ecx]
  00cb3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?resMgr@@3PAVResourceMgr@@A ; resMgr
  00cb9	ff 52 20	 call	 DWORD PTR [edx+32]
  00cbc	8b c8		 mov	 ecx, eax
  00cbe	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  00cc3	89 45 fc	 mov	 DWORD PTR _op$[ebp], eax

; 414  : 
; 415  : 	// Read and store each offset.
; 416  : 	for (int i = 0 ; i < MaxIndexedProperty ; ++i)

  00cc6	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00ccd	eb 09		 jmp	 SHORT $L59657
$L59658:
  00ccf	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00cd2	83 c0 01	 add	 eax, 1
  00cd5	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L59657:
  00cd8	83 7d f8 4c	 cmp	 DWORD PTR _i$[ebp], 76	; 0000004cH
  00cdc	7d 1b		 jge	 SHORT $L59659

; 417  : 		indexedPropertyOffsets[i] = *op++;

  00cde	8b 4d fc	 mov	 ecx, DWORD PTR _op$[ebp]
  00ce1	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00ce4	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00ce7	89 14 85 00 00
	00 00		 mov	 DWORD PTR ?indexedPropertyOffsets@@3PAIA[eax*4], edx
  00cee	8b 4d fc	 mov	 ecx, DWORD PTR _op$[ebp]
  00cf1	83 c1 02	 add	 ecx, 2
  00cf4	89 4d fc	 mov	 DWORD PTR _op$[ebp], ecx
  00cf7	eb d6		 jmp	 SHORT $L59658
$L59659:

; 418  : }

  00cf9	8b e5		 mov	 esp, ebp
  00cfb	5d		 pop	 ebp
  00cfc	c3		 ret	 0
_LoadPropOffsets ENDP
_TEXT	ENDS
PUBLIC	?KIsObject@@YAXPAF@Z				; KIsObject
EXTRN	?pm@@3VPMachine@@A:BYTE				; pm
_TEXT	SEGMENT
_args$ = 8
$T60019 = -4
?KIsObject@@YAXPAF@Z PROC NEAR				; KIsObject

; 428  : {

  00cfd	55		 push	 ebp
  00cfe	8b ec		 mov	 ebp, esp
  00d00	51		 push	 ecx

; 429  : 	pm.acc = (Acc) ((ObjectID) arg(1)).IsObject();

  00d01	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00d04	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  00d08	51		 push	 ecx
  00d09	8d 4d fc	 lea	 ecx, DWORD PTR $T60019[ebp]
  00d0c	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  00d11	8b c8		 mov	 ecx, eax
  00d13	e8 00 00 00 00	 call	 ?IsObject@ObjectID@@QBEHXZ ; ObjectID::IsObject
  00d18	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 430  : }

  00d1d	8b e5		 mov	 esp, ebp
  00d1f	5d		 pop	 ebp
  00d20	c3		 ret	 0
?KIsObject@@YAXPAF@Z ENDP				; KIsObject
_TEXT	ENDS
PUBLIC	?KRespondsTo@@YAXPAF@Z				; KRespondsTo
PUBLIC	?RespondsTo@ObjectID@@QBEHG@Z			; ObjectID::RespondsTo
_TEXT	SEGMENT
_args$ = 8
$T60021 = -4
?KRespondsTo@@YAXPAF@Z PROC NEAR			; KRespondsTo

; 434  : {

  00d21	55		 push	 ebp
  00d22	8b ec		 mov	 ebp, esp
  00d24	51		 push	 ecx

; 435  : 	pm.acc = (Acc) ((ObjectID) arg(1)).RespondsTo(arg(2));

  00d25	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00d28	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  00d2c	51		 push	 ecx
  00d2d	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00d30	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]
  00d34	50		 push	 eax
  00d35	8d 4d fc	 lea	 ecx, DWORD PTR $T60021[ebp]
  00d38	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  00d3d	8b c8		 mov	 ecx, eax
  00d3f	e8 00 00 00 00	 call	 ?RespondsTo@ObjectID@@QBEHG@Z ; ObjectID::RespondsTo
  00d44	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 436  : }

  00d49	8b e5		 mov	 esp, ebp
  00d4b	5d		 pop	 ebp
  00d4c	c3		 ret	 0
?KRespondsTo@@YAXPAF@Z ENDP				; KRespondsTo
_TEXT	ENDS
;	COMDAT ?RespondsTo@ObjectID@@QBEHG@Z
_TEXT	SEGMENT
_selector$ = 8
_this$ = -4
?RespondsTo@ObjectID@@QBEHG@Z PROC NEAR			; ObjectID::RespondsTo, COMDAT

; 315  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 316  : 		//	return whether 'selector' is a property or method of us or our
; 317  : 		//	superclasses
; 318  : 		AssureValid();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?AssureValid@ObjectID@@QBEXXZ ; ObjectID::AssureValid

; 319  : 		return (*this)->RespondsTo(selector);

  0000f	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  00013	50		 push	 eax
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  0001c	8b c8		 mov	 ecx, eax
  0001e	e8 00 00 00 00	 call	 ?RespondsTo@Object@@QAEHG@Z ; Object::RespondsTo

; 320  : 	}

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?RespondsTo@ObjectID@@QBEHG@Z ENDP			; ObjectID::RespondsTo
_TEXT	ENDS
PUBLIC	?KClone@@YAXPAF@Z				; KClone
PUBLIC	?SetProperty@ObjectID@@QBEXGF@Z			; ObjectID::SetProperty
_TEXT	SEGMENT
_args$ = 8
_theSource$ = -4
_theClone$ = -8
_numArgs$ = -12
$T60024 = -16
$T60025 = -20
$T60026 = -24
?KClone@@YAXPAF@Z PROC NEAR				; KClone

; 439  : KClone(argList) {

  00d4d	55		 push	 ebp
  00d4e	8b ec		 mov	 ebp, esp
  00d50	83 ec 18	 sub	 esp, 24			; 00000018H

; 440  : 	// Get a clone of the object.
; 441  : 
; 442  : 	ObjectID theSource = (ObjectID) arg(1);

  00d53	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00d56	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  00d5a	51		 push	 ecx
  00d5b	8d 4d f0	 lea	 ecx, DWORD PTR $T60024[ebp]
  00d5e	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  00d63	50		 push	 eax
  00d64	8d 4d fc	 lea	 ecx, DWORD PTR _theSource$[ebp]
  00d67	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID

; 443  : 
; 444  : 	ObjectID theClone = ((ObjectID) arg(1)).Clone();

  00d6c	8d 55 e8	 lea	 edx, DWORD PTR $T60026[ebp]
  00d6f	52		 push	 edx
  00d70	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00d73	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  00d77	51		 push	 ecx
  00d78	8d 4d ec	 lea	 ecx, DWORD PTR $T60025[ebp]
  00d7b	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  00d80	8b c8		 mov	 ecx, eax
  00d82	e8 00 00 00 00	 call	 ?Clone@ObjectID@@QAE?AV1@XZ ; ObjectID::Clone
  00d87	50		 push	 eax
  00d88	8d 4d f8	 lea	 ecx, DWORD PTR _theClone$[ebp]
  00d8b	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID

; 445  : 
; 446  : 	// Set any properties
; 447  : 	int numArgs;
; 448  : 	for (numArgs = argCount - 1, args += 2;numArgs > 0;numArgs -= 2, args += 2)

  00d90	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00d93	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00d96	83 e8 01	 sub	 eax, 1
  00d99	89 45 f4	 mov	 DWORD PTR _numArgs$[ebp], eax
  00d9c	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00d9f	83 c1 04	 add	 ecx, 4
  00da2	89 4d 08	 mov	 DWORD PTR _args$[ebp], ecx
  00da5	eb 12		 jmp	 SHORT $L59683
$L59684:
  00da7	8b 55 f4	 mov	 edx, DWORD PTR _numArgs$[ebp]
  00daa	83 ea 02	 sub	 edx, 2
  00dad	89 55 f4	 mov	 DWORD PTR _numArgs$[ebp], edx
  00db0	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00db3	83 c0 04	 add	 eax, 4
  00db6	89 45 08	 mov	 DWORD PTR _args$[ebp], eax
$L59683:
  00db9	83 7d f4 00	 cmp	 DWORD PTR _numArgs$[ebp], 0
  00dbd	7e 19		 jle	 SHORT $L59685

; 449  : 		theClone.SetProperty(arg(0), arg(1));

  00dbf	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00dc2	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  00dc6	52		 push	 edx
  00dc7	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00dca	66 8b 08	 mov	 cx, WORD PTR [eax]
  00dcd	51		 push	 ecx
  00dce	8d 4d f8	 lea	 ecx, DWORD PTR _theClone$[ebp]
  00dd1	e8 00 00 00 00	 call	 ?SetProperty@ObjectID@@QBEXGF@Z ; ObjectID::SetProperty
  00dd6	eb cf		 jmp	 SHORT $L59684
$L59685:

; 450  : 
; 451  : 	// clear out the module and line number properties
; 452  : #ifdef DEBUG
; 453  : 	theSource.SetIndexedProperty ( objModule, -1 );
; 454  : 	theSource.SetIndexedProperty ( objLine, -1 );
; 455  : #endif
; 456  : 
; 457  : 	pm.acc = (Acc) theClone;

  00dd8	8d 4d f8	 lea	 ecx, DWORD PTR _theClone$[ebp]
  00ddb	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00de0	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00de5	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 458  : }

  00dea	8b e5		 mov	 esp, ebp
  00dec	5d		 pop	 ebp
  00ded	c3		 ret	 0
?KClone@@YAXPAF@Z ENDP					; KClone
_TEXT	ENDS
PUBLIC	?SetProperty@Object@@QAEXGF@Z			; Object::SetProperty
;	COMDAT ?SetProperty@ObjectID@@QBEXGF@Z
_TEXT	SEGMENT
_selector$ = 8
_value$ = 12
_this$ = -4
?SetProperty@ObjectID@@QBEXGF@Z PROC NEAR		; ObjectID::SetProperty, COMDAT

; 340  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 341  : 		//	set a property given a selector
; 342  : 		AssureValid();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?AssureValid@ObjectID@@QBEXXZ ; ObjectID::AssureValid

; 343  : 		(*this)->SetProperty(selector, value);

  0000f	66 8b 45 0c	 mov	 ax, WORD PTR _value$[ebp]
  00013	50		 push	 eax
  00014	66 8b 4d 08	 mov	 cx, WORD PTR _selector$[ebp]
  00018	51		 push	 ecx
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  00021	8b c8		 mov	 ecx, eax
  00023	e8 00 00 00 00	 call	 ?SetProperty@Object@@QAEXGF@Z ; Object::SetProperty

; 344  : 	}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?SetProperty@ObjectID@@QBEXGF@Z ENDP			; ObjectID::SetProperty
_TEXT	ENDS
PUBLIC	?SetGraphicsUpdate@Object@@QAEXXZ		; Object::SetGraphicsUpdate
PUBLIC	?GetPropAddrCheck@Object@@QAEPAFG@Z		; Object::GetPropAddrCheck
;	COMDAT ?SetProperty@Object@@QAEXGF@Z
_TEXT	SEGMENT
_selector$ = 8
_value$ = 12
_this$ = -12
_property$ = -8
_index$ = -4
?SetProperty@Object@@QAEXGF@Z PROC NEAR			; Object::SetProperty, COMDAT

; 206  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		//	set a property given a selector
; 208  : 		Property* property = GetPropAddrCheck(selector);

  00009	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?GetPropAddrCheck@Object@@QAEPAFG@Z ; Object::GetPropAddrCheck
  00016	89 45 f8	 mov	 DWORD PTR _property$[ebp], eax

; 209  : 		int index = property - (Property*) this;

  00019	8b 4d f8	 mov	 ecx, DWORD PTR _property$[ebp]
  0001c	2b 4d f4	 sub	 ecx, DWORD PTR _this$[ebp]
  0001f	d1 f9		 sar	 ecx, 1
  00021	89 4d fc	 mov	 DWORD PTR _index$[ebp], ecx

; 210  : 		if (index <= MaxGraphUpdateIndex && index >= MinGraphUpdateIndex)

  00024	83 7d fc 2b	 cmp	 DWORD PTR _index$[ebp], 43 ; 0000002bH
  00028	7f 0e		 jg	 SHORT $L58092
  0002a	83 7d fc 18	 cmp	 DWORD PTR _index$[ebp], 24 ; 00000018H
  0002e	7c 08		 jl	 SHORT $L58092

; 211  : 			SetGraphicsUpdate();

  00030	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?SetGraphicsUpdate@Object@@QAEXXZ ; Object::SetGraphicsUpdate
$L58092:

; 212  : 		*property = value;

  00038	8b 55 f8	 mov	 edx, DWORD PTR _property$[ebp]
  0003b	66 8b 45 0c	 mov	 ax, WORD PTR _value$[ebp]
  0003f	66 89 02	 mov	 WORD PTR [edx], ax

; 213  : 	}

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 08 00	 ret	 8
?SetProperty@Object@@QAEXGF@Z ENDP			; Object::SetProperty
_TEXT	ENDS
;	COMDAT ?SetGraphicsUpdate@Object@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?SetGraphicsUpdate@Object@@QAEXXZ PROC NEAR		; Object::SetGraphicsUpdate, COMDAT

; 97   : 	void		SetGraphicsUpdate()		{ info |= GRAPH_UPD; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 48 0e	 mov	 cx, WORD PTR [eax+14]
  0000e	80 c9 08	 or	 cl, 8
  00011	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00014	66 89 4a 0e	 mov	 WORD PTR [edx+14], cx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?SetGraphicsUpdate@Object@@QAEXXZ ENDP			; Object::SetGraphicsUpdate
_TEXT	ENDS
;	COMDAT ?GetPropAddrCheck@Object@@QAEPAFG@Z
_TEXT	SEGMENT
_selector$ = 8
_this$ = -8
_property$ = -4
?GetPropAddrCheck@Object@@QAEPAFG@Z PROC NEAR		; Object::GetPropAddrCheck, COMDAT

; 153  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 154  : 		//	get a property's address, checking for valid property
; 155  : 		Property* property = GetPropAddr(selector);

  00009	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?GetPropAddr@Object@@QAEPAFG@Z ; Object::GetPropAddr
  00016	89 45 fc	 mov	 DWORD PTR _property$[ebp], eax

; 156  : 		if (!property)

  00019	83 7d fc 00	 cmp	 DWORD PTR _property$[ebp], 0
  0001d	75 1b		 jne	 SHORT $L58068

; 157  : 			msgMgr->Fatal(Msg_InvalidProperty, selector);

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _selector$[ebp]
  00022	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00028	51		 push	 ecx
  00029	6a 29		 push	 41			; 00000029H
  0002b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXHZZ	; MsgMgr::Fatal
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
$L58068:

; 158  : 		return property;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _property$[ebp]

; 159  : 	}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
?GetPropAddrCheck@Object@@QAEPAFG@Z ENDP		; Object::GetPropAddrCheck
_TEXT	ENDS
PUBLIC	?Info@Object@@QAEFXZ				; Object::Info
PUBLIC	?KDisposeClone@@YAXPAF@Z			; KDisposeClone
_TEXT	SEGMENT
_args$ = 8
_obj$ = -4
?KDisposeClone@@YAXPAF@Z PROC NEAR			; KDisposeClone

; 462  : {

  00dee	55		 push	 ebp
  00def	8b ec		 mov	 ebp, esp
  00df1	51		 push	 ecx

; 463  : 	//	if the object was cloned, free it
; 464  : 
; 465  : 	ObjectID obj = arg(1);

  00df2	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00df5	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  00df9	51		 push	 ecx
  00dfa	8d 4d fc	 lea	 ecx, DWORD PTR _obj$[ebp]
  00dfd	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID

; 466  : 	obj.AssureValid();

  00e02	8d 4d fc	 lea	 ecx, DWORD PTR _obj$[ebp]
  00e05	e8 00 00 00 00	 call	 ?AssureValid@ObjectID@@QBEXXZ ; ObjectID::AssureValid

; 467  : 	if ((obj->Info() & (CLONEBIT | NODISPOSE)) == CLONEBIT) {

  00e0a	8d 4d fc	 lea	 ecx, DWORD PTR _obj$[ebp]
  00e0d	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  00e12	8b c8		 mov	 ecx, eax
  00e14	e8 00 00 00 00	 call	 ?Info@Object@@QAEFXZ	; Object::Info
  00e19	0f bf d0	 movsx	 edx, ax
  00e1c	83 e2 03	 and	 edx, 3
  00e1f	83 fa 01	 cmp	 edx, 1
  00e22	75 08		 jne	 SHORT $L59691

; 468  : 		obj.Free();

  00e24	8d 4d fc	 lea	 ecx, DWORD PTR _obj$[ebp]
  00e27	e8 00 00 00 00	 call	 ?Free@ObjectID@@QAEXXZ	; ObjectID::Free
$L59691:

; 470  : }

  00e2c	8b e5		 mov	 esp, ebp
  00e2e	5d		 pop	 ebp
  00e2f	c3		 ret	 0
?KDisposeClone@@YAXPAF@Z ENDP				; KDisposeClone
_TEXT	ENDS
;	COMDAT ?Info@Object@@QAEFXZ
_TEXT	SEGMENT
_this$ = -4
?Info@Object@@QAEFXZ PROC NEAR				; Object::Info, COMDAT

; 94   : 	Property	Info() { return info; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 40 0e	 mov	 ax, WORD PTR [eax+14]
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?Info@Object@@QAEFXZ ENDP				; Object::Info
_TEXT	ENDS
PUBLIC	?KFindSelector@@YAXPAF@Z			; KFindSelector
PUBLIC	?StrGetData@@YA?AVTextID@@VMemID@@@Z		; StrGetData
_TEXT	SEGMENT
_args$ = 8
$T60035 = -8
?KFindSelector@@YAXPAF@Z PROC NEAR			; KFindSelector

; 474  : {

  00e30	55		 push	 ebp
  00e31	8b ec		 mov	 ebp, esp
  00e33	83 ec 08	 sub	 esp, 8

; 475  : 	//	find the selector number for a selector name
; 476  : 
; 477  :  	pm.acc = GetSelector(*StrGetData(arg(1)));

  00e36	51		 push	 ecx
  00e37	8b cc		 mov	 ecx, esp
  00e39	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00e3c	66 8b 50 02	 mov	 dx, WORD PTR [eax+2]
  00e40	52		 push	 edx
  00e41	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  00e46	8d 45 f8	 lea	 eax, DWORD PTR $T60035[ebp]
  00e49	50		 push	 eax
  00e4a	e8 00 00 00 00	 call	 ?StrGetData@@YA?AVTextID@@VMemID@@@Z ; StrGetData
  00e4f	83 c4 08	 add	 esp, 8
  00e52	8b c8		 mov	 ecx, eax
  00e54	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  00e59	50		 push	 eax
  00e5a	e8 00 00 00 00	 call	 ?GetSelector@@YAGPBD@Z	; GetSelector
  00e5f	83 c4 04	 add	 esp, 4
  00e62	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00e67	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 478  : }

  00e6c	8b e5		 mov	 esp, ebp
  00e6e	5d		 pop	 ebp
  00e6f	c3		 ret	 0
?KFindSelector@@YAXPAF@Z ENDP				; KFindSelector
_TEXT	ENDS
PUBLIC	?GetProperty@ObjectID@@QBEFG@Z			; ObjectID::GetProperty
PUBLIC	??0TextID@@QAE@ABV0@@Z				; TextID::TextID
EXTRN	??0TextID@@QAE@ABVMemID@@@Z:NEAR		; TextID::TextID
;	COMDAT ?StrGetData@@YA?AVTextID@@VMemID@@@Z
_TEXT	SEGMENT
$T60037 = -8
$T60038 = -12
_id$ = 12
___$ReturnUdt$ = 8
_obj$ = -4
?StrGetData@@YA?AVTextID@@VMemID@@@Z PROC NEAR		; StrGetData, COMDAT

; 41   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 42   : //	following code fails to compile with CodeWarrior 1.1.1.2.
; 43   : //	ObjectID obj(id);
; 44   : //	return (TextID) (obj.IsObject() ? obj.GetProperty(s_data) : obj);
; 45   : //	replaced code with the following...
; 46   : 
; 47   : 	ObjectID	obj = (ObjectID) (id);

  00006	8d 45 0c	 lea	 eax, DWORD PTR _id$[ebp]
  00009	50		 push	 eax
  0000a	8d 4d f8	 lea	 ecx, DWORD PTR $T60037[ebp]
  0000d	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABVMemID@@@Z ; ObjectID::ObjectID
  00012	50		 push	 eax
  00013	8d 4d fc	 lea	 ecx, DWORD PTR _obj$[ebp]
  00016	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@ABV0@@Z ; ObjectID::ObjectID

; 48   : 	if (obj.IsObject())

  0001b	8d 4d fc	 lea	 ecx, DWORD PTR _obj$[ebp]
  0001e	e8 00 00 00 00	 call	 ?IsObject@ObjectID@@QBEHXZ ; ObjectID::IsObject
  00023	85 c0		 test	 eax, eax
  00025	74 18		 je	 SHORT $L59370

; 49   : 		return obj.GetProperty(s_data);

  00027	6a 71		 push	 113			; 00000071H
  00029	8d 4d fc	 lea	 ecx, DWORD PTR _obj$[ebp]
  0002c	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  00031	50		 push	 eax
  00032	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00035	e8 00 00 00 00	 call	 ??0TextID@@QAE@G@Z	; TextID::TextID
  0003a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003d	eb 18		 jmp	 SHORT $L59371
$L59370:

; 51   : 		return (TextID) id;

  0003f	8d 4d 0c	 lea	 ecx, DWORD PTR _id$[ebp]
  00042	51		 push	 ecx
  00043	8d 4d f4	 lea	 ecx, DWORD PTR $T60038[ebp]
  00046	e8 00 00 00 00	 call	 ??0TextID@@QAE@ABVMemID@@@Z ; TextID::TextID
  0004b	50		 push	 eax
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0004f	e8 00 00 00 00	 call	 ??0TextID@@QAE@ABV0@@Z	; TextID::TextID
  00054	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$L59371:

; 52   : }

  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?StrGetData@@YA?AVTextID@@VMemID@@@Z ENDP		; StrGetData
_TEXT	ENDS
PUBLIC	?GetProperty@Object@@QAEFG@Z			; Object::GetProperty
;	COMDAT ?GetProperty@ObjectID@@QBEFG@Z
_TEXT	SEGMENT
_selector$ = 8
_this$ = -4
?GetProperty@ObjectID@@QBEFG@Z PROC NEAR		; ObjectID::GetProperty, COMDAT

; 290  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 291  : 		//	get a property given a selector
; 292  : 		AssureValid();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?AssureValid@ObjectID@@QBEXXZ ; ObjectID::AssureValid

; 293  : 		return (*this)->GetProperty(selector);

  0000f	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  00013	50		 push	 eax
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  0001c	8b c8		 mov	 ecx, eax
  0001e	e8 00 00 00 00	 call	 ?GetProperty@Object@@QAEFG@Z ; Object::GetProperty

; 294  : 	}

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?GetProperty@ObjectID@@QBEFG@Z ENDP			; ObjectID::GetProperty
_TEXT	ENDS
;	COMDAT ?GetProperty@Object@@QAEFG@Z
_TEXT	SEGMENT
_selector$ = 8
_this$ = -4
?GetProperty@Object@@QAEFG@Z PROC NEAR			; Object::GetProperty, COMDAT

; 170  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 171  : 		//	get a property given a selector
; 172  : 		return *GetPropAddrCheck(selector);

  00007	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?GetPropAddrCheck@Object@@QAEPAFG@Z ; Object::GetPropAddrCheck
  00014	66 8b 00	 mov	 ax, WORD PTR [eax]

; 173  : 	}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?GetProperty@Object@@QAEFG@Z ENDP			; Object::GetProperty
_TEXT	ENDS
;	COMDAT ??0TextID@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0TextID@@QAE@ABV0@@Z PROC NEAR			; TextID::TextID, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0MemID@@QAE@ABV0@@Z	; MemID::MemID
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0TextID@@QAE@ABV0@@Z ENDP				; TextID::TextID
_TEXT	ENDS
PUBLIC	?KFindClass@@YAXPAF@Z				; KFindClass
_TEXT	SEGMENT
_args$ = 8
$T60044 = -8
$T60045 = -12
?KFindClass@@YAXPAF@Z PROC NEAR				; KFindClass

; 482  : {

  00e70	55		 push	 ebp
  00e71	8b ec		 mov	 ebp, esp
  00e73	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 483  : 	//	return the class object for a given name
; 484  : 
; 485  :  	pm.acc = GetClass(*StrGetData(arg(1)));

  00e76	51		 push	 ecx
  00e77	8b cc		 mov	 ecx, esp
  00e79	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00e7c	66 8b 50 02	 mov	 dx, WORD PTR [eax+2]
  00e80	52		 push	 edx
  00e81	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  00e86	8d 45 f8	 lea	 eax, DWORD PTR $T60044[ebp]
  00e89	50		 push	 eax
  00e8a	e8 00 00 00 00	 call	 ?StrGetData@@YA?AVTextID@@VMemID@@@Z ; StrGetData
  00e8f	83 c4 08	 add	 esp, 8
  00e92	8b c8		 mov	 ecx, eax
  00e94	e8 00 00 00 00	 call	 ??DTextID@@QAEPADXZ	; TextID::operator*
  00e99	50		 push	 eax
  00e9a	8d 4d f4	 lea	 ecx, DWORD PTR $T60045[ebp]
  00e9d	51		 push	 ecx
  00e9e	e8 00 00 00 00	 call	 ?GetClass@@YA?AVObjectID@@PBD@Z ; GetClass
  00ea3	83 c4 08	 add	 esp, 8
  00ea6	8b c8		 mov	 ecx, eax
  00ea8	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00ead	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00eb2	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 486  : }

  00eb7	8b e5		 mov	 esp, ebp
  00eb9	5d		 pop	 ebp
  00eba	c3		 ret	 0
?KFindClass@@YAXPAF@Z ENDP				; KFindClass
_TEXT	ENDS
PUBLIC	?KIsKindOf@@YAXPAF@Z				; KIsKindOf
_TEXT	SEGMENT
_args$ = 8
_src$ = -12
_dst$ = -8
_dict$ = -4
$T60047 = -16
$T60048 = -20
$T60049 = -24
$T60050 = -28
?KIsKindOf@@YAXPAF@Z PROC NEAR				; KIsKindOf

; 490  : {

  00ebb	55		 push	 ebp
  00ebc	8b ec		 mov	 ebp, esp
  00ebe	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 491  : 	((ObjectID)arg(1)).AssureValid();

  00ec1	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00ec4	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  00ec8	51		 push	 ecx
  00ec9	8d 4d f0	 lea	 ecx, DWORD PTR $T60047[ebp]
  00ecc	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  00ed1	8b c8		 mov	 ecx, eax
  00ed3	e8 00 00 00 00	 call	 ?AssureValid@ObjectID@@QBEXXZ ; ObjectID::AssureValid

; 492  : 	((ObjectID)arg(2)).AssureValid();

  00ed8	8b 55 08	 mov	 edx, DWORD PTR _args$[ebp]
  00edb	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  00edf	50		 push	 eax
  00ee0	8d 4d ec	 lea	 ecx, DWORD PTR $T60048[ebp]
  00ee3	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  00ee8	8b c8		 mov	 ecx, eax
  00eea	e8 00 00 00 00	 call	 ?AssureValid@ObjectID@@QBEXXZ ; ObjectID::AssureValid

; 493  : 
; 494  : 	Object *src = (Object *)*(ObjectID)arg(1);

  00eef	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00ef2	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  00ef6	52		 push	 edx
  00ef7	8d 4d e8	 lea	 ecx, DWORD PTR $T60049[ebp]
  00efa	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  00eff	8b c8		 mov	 ecx, eax
  00f01	e8 00 00 00 00	 call	 ??DFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator*
  00f06	89 45 f4	 mov	 DWORD PTR _src$[ebp], eax

; 495  : 	Object *dst = (Object *)*(ObjectID)arg(2);

  00f09	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  00f0c	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  00f10	51		 push	 ecx
  00f11	8d 4d e4	 lea	 ecx, DWORD PTR $T60050[ebp]
  00f14	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID
  00f19	8b c8		 mov	 ecx, eax
  00f1b	e8 00 00 00 00	 call	 ??DFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator*
  00f20	89 45 f8	 mov	 DWORD PTR _dst$[ebp], eax

; 496  : 
; 497  : 	SelectorDict *dict = src->selectorDict();

  00f23	8b 4d f4	 mov	 ecx, DWORD PTR _src$[ebp]
  00f26	e8 00 00 00 00	 call	 ?selectorDict@Object@@QAEPAVSelectorDict@@XZ ; Object::selectorDict
  00f2b	89 45 fc	 mov	 DWORD PTR _dict$[ebp], eax
$L59720:

; 498  : 
; 499  : 	while ( dst->selectorDict() != dict ) {

  00f2e	8b 4d f8	 mov	 ecx, DWORD PTR _dst$[ebp]
  00f31	e8 00 00 00 00	 call	 ?selectorDict@Object@@QAEPAVSelectorDict@@XZ ; Object::selectorDict
  00f36	3b 45 fc	 cmp	 eax, DWORD PTR _dict$[ebp]
  00f39	74 32		 je	 SHORT $L59721

; 500  : 		if ( dst->super ) {

  00f3b	8b 4d f8	 mov	 ecx, DWORD PTR _dst$[ebp]
  00f3e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00f41	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  00f46	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00f4b	85 c0		 test	 eax, eax
  00f4d	74 10		 je	 SHORT $L59722

; 501  : 			dst = (Object *)*(dst->super);

  00f4f	8b 4d f8	 mov	 ecx, DWORD PTR _dst$[ebp]
  00f52	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00f55	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  00f5a	89 45 f8	 mov	 DWORD PTR _dst$[ebp], eax

; 502  : 		} else {

  00f5d	eb 0c		 jmp	 SHORT $L59724
$L59722:

; 503  : 			pm.acc = 0;

  00f5f	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, 0

; 504  : 			return;

  00f69	eb 0c		 jmp	 SHORT $L59705
$L59724:

; 506  : 	}

  00f6b	eb c1		 jmp	 SHORT $L59720
$L59721:

; 507  : 
; 508  : 	pm.acc = 1;

  00f6d	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, 1
$L59705:

; 509  : }

  00f77	8b e5		 mov	 esp, ebp
  00f79	5d		 pop	 ebp
  00f7a	c3		 ret	 0
?KIsKindOf@@YAXPAF@Z ENDP				; KIsKindOf
_TEXT	ENDS
END
