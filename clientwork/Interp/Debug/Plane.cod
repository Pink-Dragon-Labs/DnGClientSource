	TITLE	C:\Documents and Settings\don\Desktop\sciw\Interp\Plane.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BM@LHED@Instructed?5to?5scale?5to?5zero?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0SOL_Point@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCI_Point@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@NN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPoint@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SOL_Point@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9SOL_Point@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@AAVSOL_Point@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Set@SOL_Rect@@QAEXHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEmpty@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeEmpty@SOL_Rect@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Xlen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ylen@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8SOL_Rect@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9SOL_Rect@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clip@SOL_Rect@@QAEXABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Both@SOL_Rect@@QAEXABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Includes@SOL_Rect@@QAEHABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveTo@SOL_Rect@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Offset@SOL_Rect@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Ratio@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Ratio@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D@YAHHABVRatio@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MemoryMgr@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckValid@MemoryMgr@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GMemoryMgr@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@IIIPAUMemClient@@DW4ReservedHandle@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@MemID@@QAEXW4MemType@@V1@III@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AMemID@@QBEAADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8MemID@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??7MemID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Rgb24@@QAE@EEE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Rgb24@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Rgb24F@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@HHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@VMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Type@Bitmap@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPic@Bitmap@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Cel@Bitmap@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObj@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Skip@CelObj@@QBEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasSkip@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemapState@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Mirrored@CelObj@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObj@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjView@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjView@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjView@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjView@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjMem@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjMem@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjMem@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjMem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Pos@CelObjPic@@QBE?AVSOL_Point@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Priority@CelObjPic@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CelCount@CelObjPic@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duplicate@CelObjColor@@UBEPAVCelObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CelObjColor@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCelObjColor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CelObjColor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FixedPri@ScreenItem@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Id@ScreenItem@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PicResNum@ScreenItem@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Priority@ScreenItem@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateCount@ScreenItem@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeleteCount@ScreenItem@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCount@ScreenItem@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DecUpdateCount@ScreenItem@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DecAddCount@ScreenItem@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DecDeleteCount@ScreenItem@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Draw@ScreenItem@@QAEXABVBuffer@@ABVSOL_Rect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoUpdate@ScreenItem@@QAEXABVSOL_Plane@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemapState@ScreenItem@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCel@ScreenItem@@QAEXPAVCelObj@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetUpdateCount@ScreenItem@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetAddCount@ScreenItem@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetDeleteCount@ScreenItem@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPicResNum@ScreenItem@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPriority@ScreenItem@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetUserMirror@ScreenItem@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4SOL_Rect@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@ScreenItemList@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Exists@ScreenItemList@@QBEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AScreenItemList@@QBEABVScreenItem@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AScreenItemList@@QAEAAVScreenItem@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnScreen@DrawItem@@QAEAAVSOL_Rect@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SI@DrawItem@@QAEAAVScreenItem@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@DrawList@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Exists@DrawList@@QBEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??ADrawList@@QAEAAVDrawItem@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Color@SOL_Plane@@QBEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DefRect@SOL_Plane@@QBEABVSOL_Rect@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GameRect@SOL_Plane@@QBEABVSOL_Rect@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PicResNum@SOL_Plane@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PicMirror@SOL_Plane@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Priority@SOL_Plane@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTransparent@SOL_Plane@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPictureSkip@SOL_Plane@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnScreen@SOL_Plane@@QAEAAVSOL_Rect@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SIList@SOL_Plane@@QAEAAVScreenItemList@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@PlaneList@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??APlaneList@@QAEAAVSOL_Plane@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@RectList@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??ARectList@@QAEAAVSOL_Rect@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ScreenRect@Screen@@QBEABVSOL_Rect@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TopPlane@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TopSCIPlane@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Xdim@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ydim@Screen@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Planes@Screen@@QAEAAVPlaneList@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Xdim@GraphicsMgr@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ydim@GraphicsMgr@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TopPlane@GraphicsMgr@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NextScreen@GraphicsMgr@@QAEPAVScreen@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeArrayID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeArrayID@@QBEPAUArrayHeader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ArrayID@@QAE@HW4ArrayType@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@ArrayID@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Array@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAE?AVMemID@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dataID@Array@@QAEXVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SOL_List@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@SOL_List@@QAEAAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeSOL_ListID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeDispatchTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeDispatchTblID@@QBEPAUDispatchTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DispatchTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeScriptEntryID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeScriptEntryID@@QBEPAUScriptEntry@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntry@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ScriptEntryID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeVariableID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeVariableID@@QBEPAUVariable@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VariableID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Script@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Object@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGraphicsUpdate@Object@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?selectorDict@Object@@QAEPAVSelectorDict@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AObject@@QAEAAFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddr@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedPropAddr@Object@@QAEPBFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedProperty@Object@@QAEFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAddrCheck@Object@@QAEPAFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@Object@@QAEFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropOffset@Object@@QAEIG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetIndexedProperty@Object@@QAEXHF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetProperty@Object@@QAEXGF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ObjectID@@QAE@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssureValid@ObjectID@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsObject@ObjectID@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedProperty@ObjectID@@QBEFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProperty@ObjectID@@QBEFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetIndexedProperty@ObjectID@@QBEXHF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FakeClassTblID@@QAE@ABVMemID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DFakeClassTblID@@QBEPAUClassTbl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TranslateMacColor@@YAXAAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CelObj@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7Buffer@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjColor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjView@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7MemoryMgr@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CelObjMem@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?gPlaneFatalStr@@3PADA				; gPlaneFatalStr
PUBLIC	?nextId@SOL_Plane@@1JA				; SOL_Plane::nextId
_DATA	SEGMENT
?gPlaneFatalStr@@3PADA DD FLAT:$SG61727			; gPlaneFatalStr
?nextId@SOL_Plane@@1JA DD 0186a0H			; SOL_Plane::nextId
$SG61727 DB	'trails', 00H
_DATA	ENDS
PUBLIC	??0SOL_Plane@@QAE@VObjectID@@@Z			; SOL_Plane::SOL_Plane
PUBLIC	?TranslateMacColor@@YAXAAE@Z			; TranslateMacColor
PUBLIC	?ConvGameRectToPlaneRect@SOL_Plane@@QAEXXZ	; SOL_Plane::ConvGameRectToPlaneRect
PUBLIC	?Xdim@GraphicsMgr@@QBEHXZ			; GraphicsMgr::Xdim
PUBLIC	?SetType@SOL_Plane@@QAEXXZ			; SOL_Plane::SetType
PUBLIC	?Ydim@GraphicsMgr@@QBEHXZ			; GraphicsMgr::Ydim
PUBLIC	??0SOL_Point@@QAE@HH@Z				; SOL_Point::SOL_Point
PUBLIC	?ChangePic@SOL_Plane@@IAEXXZ			; SOL_Plane::ChangePic
PUBLIC	?GetPicResolution@SOL_Plane@@IAEXXZ		; SOL_Plane::GetPicResolution
PUBLIC	??0SOL_Rect@@QAE@XZ				; SOL_Rect::SOL_Rect
PUBLIC	??4SOL_Rect@@QAEAAV0@ABV0@@Z			; SOL_Rect::operator=
PUBLIC	?GetProperty@ObjectID@@QBEFG@Z			; ObjectID::GetProperty
PUBLIC	??BMemID@@QBEGXZ				; MemID::operator unsigned short
PUBLIC	??0Ratio@@QAE@XZ				; Ratio::Ratio
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	??0ScreenItemList@@QAE@XZ:NEAR			; ScreenItemList::ScreenItemList
EXTRN	??1ScreenItemList@@QAE@XZ:NEAR			; ScreenItemList::~ScreenItemList
EXTRN	?AddPalShift@@YAHH@Z:NEAR			; AddPalShift
EXTRN	?graphMgr@@3PAVGraphicsMgr@@A:DWORD		; graphMgr
xdata$x	SEGMENT
$T62556	DD	019930520H
	DD	01H
	DD	FLAT:$T62559
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T62559	DD	0ffffffffH
	DD	FLAT:$L62552
xdata$x	ENDS
_TEXT	SEGMENT
__$EHRec$ = -12
_ID$ = 8
_this$ = -44
_rect$ = -28
_xdim$ = -36
_ydim$ = -40
_screenCount$ = -32
??0SOL_Plane@@QAE@VObjectID@@@Z PROC NEAR		; SOL_Plane::SOL_Plane

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 $L62557
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 20	 sub	 esp, 32			; 00000020H
  0001b	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx
  0001e	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00024	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@XZ	; SOL_Rect::SOL_Rect
  00029	6a 6c		 push	 108			; 0000006cH
  0002b	8d 4d 08	 lea	 ecx, DWORD PTR _ID$[ebp]
  0002e	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  00033	0f bf c0	 movsx	 eax, ax
  00036	50		 push	 eax
  00037	6a 6b		 push	 107			; 0000006bH
  00039	8d 4d 08	 lea	 ecx, DWORD PTR _ID$[ebp]
  0003c	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  00041	0f bf c8	 movsx	 ecx, ax
  00044	51		 push	 ecx
  00045	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	83 c1 28	 add	 ecx, 40			; 00000028H
  0004b	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@HH@Z	; SOL_Point::SOL_Point
  00050	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	83 c1 34	 add	 ecx, 52			; 00000034H
  00056	e8 00 00 00 00	 call	 ??0Ratio@@QAE@XZ	; Ratio::Ratio
  0005b	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00061	e8 00 00 00 00	 call	 ??0Ratio@@QAE@XZ	; Ratio::Ratio
  00066	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0006c	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@XZ	; SOL_Rect::SOL_Rect
  00071	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	83 c1 64	 add	 ecx, 100		; 00000064H
  00077	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@XZ	; SOL_Rect::SOL_Rect
  0007c	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00082	e8 00 00 00 00	 call	 ??0ScreenItemList@@QAE@XZ ; ScreenItemList::ScreenItemList
  00087	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 41   : 	// Plane created from an SCI plane object
; 42   : 	SOL_Rect rect;

  0008e	8d 4d e4	 lea	 ecx, DWORD PTR _rect$[ebp]
  00091	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@XZ	; SOL_Rect::SOL_Rect

; 43   : 
; 44   : 	planeId = ID;

  00096	8d 4d 08	 lea	 ecx, DWORD PTR _ID$[ebp]
  00099	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  0009e	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000a3	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  000a6	89 02		 mov	 DWORD PTR [edx], eax

; 45   : 
; 46   : 	int xdim = graphMgr->Xdim();

  000a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  000ae	e8 00 00 00 00	 call	 ?Xdim@GraphicsMgr@@QBEHXZ ; GraphicsMgr::Xdim
  000b3	89 45 dc	 mov	 DWORD PTR _xdim$[ebp], eax

; 47   : 	int ydim = graphMgr->Ydim();

  000b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  000bc	e8 00 00 00 00	 call	 ?Ydim@GraphicsMgr@@QBEHXZ ; GraphicsMgr::Ydim
  000c1	89 45 d8	 mov	 DWORD PTR _ydim$[ebp], eax

; 48   : 
; 49   : #ifdef NETWORK
; 50   : 	gameRect.A.x = ID.GetProperty(s_left);

  000c4	68 87 00 00 00	 push	 135			; 00000087H
  000c9	8d 4d 08	 lea	 ecx, DWORD PTR _ID$[ebp]
  000cc	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  000d1	0f bf c0	 movsx	 eax, ax
  000d4	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 51   : 	gameRect.A.y = ID.GetProperty(s_top);

  000da	68 89 00 00 00	 push	 137			; 00000089H
  000df	8d 4d 08	 lea	 ecx, DWORD PTR _ID$[ebp]
  000e2	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  000e7	0f bf d0	 movsx	 edx, ax
  000ea	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000ed	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 52   : 	gameRect.B.x = ID.GetProperty(s_right); // + 1) * xdim) / SCIRESX) - 1;

  000f0	68 88 00 00 00	 push	 136			; 00000088H
  000f5	8d 4d 08	 lea	 ecx, DWORD PTR _ID$[ebp]
  000f8	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  000fd	0f bf c8	 movsx	 ecx, ax
  00100	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  00103	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 53   : 	gameRect.B.y = ID.GetProperty(s_bottom); // + 1) * ydim) / SCIRESY) - 1;

  00106	68 8a 00 00 00	 push	 138			; 0000008aH
  0010b	8d 4d 08	 lea	 ecx, DWORD PTR _ID$[ebp]
  0010e	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  00113	0f bf c0	 movsx	 eax, ax
  00116	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00119	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 54   : #else
; 55   : 	gameRect.A.x = ID.GetProperty(s_insetRectL);
; 56   : 	gameRect.A.y = ID.GetProperty(s_insetRectT);
; 57   : 	gameRect.B.x = ID.GetProperty(s_insetRectR); // + 1) * xdim) / SCIRESX) - 1;
; 58   : 	gameRect.B.y = ID.GetProperty(s_insetRectB); // + 1) * ydim) / SCIRESY) - 1;
; 59   : #endif
; 60   : 
; 61   : 	ConvGameRectToPlaneRect();

  0011c	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0011f	e8 00 00 00 00	 call	 ?ConvGameRectToPlaneRect@SOL_Plane@@QAEXXZ ; SOL_Plane::ConvGameRectToPlaneRect

; 62   : 
; 63   : #ifndef WIN32S
; 64   : 	color = ID.GetProperty(s_back);
; 65   : #else
; 66   : 	color = (uchar)AddPalShift((int)ID.GetProperty(s_back));

  00124	6a 26		 push	 38			; 00000026H
  00126	8d 4d 08	 lea	 ecx, DWORD PTR _ID$[ebp]
  00129	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  0012e	0f bf d0	 movsx	 edx, ax
  00131	52		 push	 edx
  00132	e8 00 00 00 00	 call	 ?AddPalShift@@YAHH@Z	; AddPalShift
  00137	83 c4 04	 add	 esp, 4
  0013a	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0013d	88 41 08	 mov	 BYTE PTR [ecx+8], al

; 67   : #endif
; 68   : 
; 69   : 	TranslateMacColor(color);

  00140	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  00143	83 c2 08	 add	 edx, 8
  00146	52		 push	 edx
  00147	e8 00 00 00 00	 call	 ?TranslateMacColor@@YAXAAE@Z ; TranslateMacColor
  0014c	83 c4 04	 add	 esp, 4

; 70   : 
; 71   : 	priority	= ID.GetProperty(s_priority);

  0014f	6a 07		 push	 7
  00151	8d 4d 08	 lea	 ecx, DWORD PTR _ID$[ebp]
  00154	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  00159	0f bf c0	 movsx	 eax, ax
  0015c	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0015f	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 72   : 	picResNum = ID.GetProperty(s_picture);

  00162	6a 6d		 push	 109			; 0000006dH
  00164	8d 4d 08	 lea	 ecx, DWORD PTR _ID$[ebp]
  00167	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  0016c	0f bf d0	 movsx	 edx, ax
  0016f	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00172	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 73   : 	SetType();

  00175	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00178	e8 00 00 00 00	 call	 ?SetType@SOL_Plane@@QAEXXZ ; SOL_Plane::SetType

; 74   : 	picMirror = ID.GetProperty(s_mirrored);

  0017d	68 83 00 00 00	 push	 131			; 00000083H
  00182	8d 4d 08	 lea	 ecx, DWORD PTR _ID$[ebp]
  00185	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  0018a	0f bf c8	 movsx	 ecx, ax
  0018d	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  00190	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 75   : 
; 76   : 	GetPicResolution();

  00193	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00196	e8 00 00 00 00	 call	 ?GetPicResolution@SOL_Plane@@IAEXXZ ; SOL_Plane::GetPicResolution

; 77   : 
; 78   : 	int screenCount = graphMgr->ScreenCount();

  0019b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  001a0	8b 10		 mov	 edx, DWORD PTR [eax]
  001a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  001a8	ff 52 04	 call	 DWORD PTR [edx+4]
  001ab	89 45 e0	 mov	 DWORD PTR _screenCount$[ebp], eax

; 79   : 	onScreen = plane;

  001ae	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  001b1	83 c0 64	 add	 eax, 100		; 00000064H
  001b4	50		 push	 eax
  001b5	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  001b8	83 c1 4c	 add	 ecx, 76			; 0000004cH
  001bb	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 80   : 	addCount = screenCount;

  001c0	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  001c3	8b 55 e0	 mov	 edx, DWORD PTR _screenCount$[ebp]
  001c6	89 51 30	 mov	 DWORD PTR [ecx+48], edx

; 81   : 	deleteCount = 0;

  001c9	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  001cc	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], 0

; 82   : 	eraseCount = 0;

  001d3	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  001d6	c7 41 48 00 00
	00 00		 mov	 DWORD PTR [ecx+72], 0

; 83   : 	priorityCount = 0;

  001dd	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  001e0	c7 42 74 00 00
	00 00		 mov	 DWORD PTR [edx+116], 0

; 84   : 	redrawAllCount = screenCount;

  001e7	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  001ea	8b 4d e0	 mov	 ecx, DWORD PTR _screenCount$[ebp]
  001ed	89 48 78	 mov	 DWORD PTR [eax+120], ecx

; 85   : 	updateCount = 0;

  001f0	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  001f3	c7 82 c0 9c 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+40128], 0

; 86   : 
; 87   : 	ChangePic();

  001fd	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00200	e8 00 00 00 00	 call	 ?ChangePic@SOL_Plane@@IAEXXZ ; SOL_Plane::ChangePic

; 88   : }

  00205	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0020c	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0020f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00212	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00219	8b e5		 mov	 esp, ebp
  0021b	5d		 pop	 ebp
  0021c	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L62552:
  00000	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00006	e8 00 00 00 00	 call	 ??1ScreenItemList@@QAE@XZ ; ScreenItemList::~ScreenItemList
  0000b	c3		 ret	 0
$L62557:
  0000c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T62556
  00011	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0SOL_Plane@@QAE@VObjectID@@@Z ENDP			; SOL_Plane::SOL_Plane
;	COMDAT ??0SOL_Point@@QAE@HH@Z
_TEXT	SEGMENT
_x$ = 8
_y$ = 12
_this$ = -4
??0SOL_Point@@QAE@HH@Z PROC NEAR			; SOL_Point::SOL_Point, COMDAT

; 21   : 	SOL_Point(Coord x, Coord y) : x(x), y(y) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0SOL_Point@@QAE@HH@Z ENDP				; SOL_Point::SOL_Point
_TEXT	ENDS
PUBLIC	??0SOL_Point@@QAE@XZ				; SOL_Point::SOL_Point
;	COMDAT ??0SOL_Rect@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0SOL_Rect@@QAE@XZ PROC NEAR				; SOL_Rect::SOL_Rect, COMDAT

; 13   : 	SOL_Rect()  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 08	 add	 ecx, 8
  00015	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0SOL_Rect@@QAE@XZ ENDP				; SOL_Rect::SOL_Rect
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0SOL_Point@@QAE@XZ PROC NEAR				; SOL_Point::SOL_Point, COMDAT

; 20   : 	SOL_Point() : x(DefaultCoord), y(DefaultCoord) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 ef cd ab
	89		 mov	 DWORD PTR [eax], -1985229329 ; 89abcdefH
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 ef cd
	ab 89		 mov	 DWORD PTR [ecx+4], -1985229329 ; 89abcdefH
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0SOL_Point@@QAE@XZ ENDP				; SOL_Point::SOL_Point
_TEXT	ENDS
;	COMDAT ??0Ratio@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Ratio@@QAE@XZ PROC NEAR				; Ratio::Ratio, COMDAT

; 7    : 	Ratio()							:	numer(1), denom(1) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0Ratio@@QAE@XZ ENDP					; Ratio::Ratio
_TEXT	ENDS
;	COMDAT ??BMemID@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4
??BMemID@@QBEGXZ PROC NEAR				; MemID::operator unsigned short, COMDAT

; 93   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   : 		return handle;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 00	 mov	 ax, WORD PTR [eax]

; 95   : 	}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??BMemID@@QBEGXZ ENDP					; MemID::operator unsigned short
_TEXT	ENDS
PUBLIC	??4SOL_Point@@QAEAAV0@ABV0@@Z			; SOL_Point::operator=
;	COMDAT ??4SOL_Rect@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??4SOL_Rect@@QAEAAV0@ABV0@@Z PROC NEAR			; SOL_Rect::operator=, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??4SOL_Point@@QAEAAV0@ABV0@@Z ; SOL_Point::operator=
  00013	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00016	83 c1 08	 add	 ecx, 8
  00019	51		 push	 ecx
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 08	 add	 ecx, 8
  00020	e8 00 00 00 00	 call	 ??4SOL_Point@@QAEAAV0@ABV0@@Z ; SOL_Point::operator=
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??4SOL_Rect@@QAEAAV0@ABV0@@Z ENDP			; SOL_Rect::operator=
_TEXT	ENDS
;	COMDAT ??4SOL_Point@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
??4SOL_Point@@QAEAAV0@ABV0@@Z PROC NEAR			; SOL_Point::operator=, COMDAT

; 117  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 118  : 	x = p.x;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx

; 119  : 	y = p.y;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00017	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001a	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 120  : 	return *this;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 121  : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??4SOL_Point@@QAEAAV0@ABV0@@Z ENDP			; SOL_Point::operator=
_TEXT	ENDS
PUBLIC	?Xdim@Screen@@QBEHXZ				; Screen::Xdim
;	COMDAT ?Xdim@GraphicsMgr@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Xdim@GraphicsMgr@@QBEHXZ PROC NEAR			; GraphicsMgr::Xdim, COMDAT

; 53   : 	int		Xdim() const							{return next.Xdim();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 14	 add	 ecx, 20			; 00000014H
  0000d	e8 00 00 00 00	 call	 ?Xdim@Screen@@QBEHXZ	; Screen::Xdim
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?Xdim@GraphicsMgr@@QBEHXZ ENDP				; GraphicsMgr::Xdim
_TEXT	ENDS
;	COMDAT ?Xdim@Screen@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Xdim@Screen@@QBEHXZ PROC NEAR				; Screen::Xdim, COMDAT

; 33   : 	int	Xdim() const						{return xDim;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 80 48 11 00
	00		 mov	 eax, DWORD PTR [eax+4424]
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?Xdim@Screen@@QBEHXZ ENDP				; Screen::Xdim
_TEXT	ENDS
PUBLIC	?Ydim@Screen@@QBEHXZ				; Screen::Ydim
;	COMDAT ?Ydim@GraphicsMgr@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Ydim@GraphicsMgr@@QBEHXZ PROC NEAR			; GraphicsMgr::Ydim, COMDAT

; 54   : 	int		Ydim() const							{return next.Ydim();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 14	 add	 ecx, 20			; 00000014H
  0000d	e8 00 00 00 00	 call	 ?Ydim@Screen@@QBEHXZ	; Screen::Ydim
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?Ydim@GraphicsMgr@@QBEHXZ ENDP				; GraphicsMgr::Ydim
_TEXT	ENDS
;	COMDAT ?Ydim@Screen@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Ydim@Screen@@QBEHXZ PROC NEAR				; Screen::Ydim, COMDAT

; 34   : 	int	Ydim() const						{return yDim;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 80 4c 11 00
	00		 mov	 eax, DWORD PTR [eax+4428]
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?Ydim@Screen@@QBEHXZ ENDP				; Screen::Ydim
_TEXT	ENDS
PUBLIC	?GetProperty@Object@@QAEFG@Z			; Object::GetProperty
PUBLIC	??CFakeObjectID@@QBEPAUObject@@XZ		; FakeObjectID::operator->
PUBLIC	?AssureValid@ObjectID@@QBEXXZ			; ObjectID::AssureValid
;	COMDAT ?GetProperty@ObjectID@@QBEFG@Z
_TEXT	SEGMENT
_selector$ = 8
_this$ = -4
?GetProperty@ObjectID@@QBEFG@Z PROC NEAR		; ObjectID::GetProperty, COMDAT

; 290  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 291  : 		//	get a property given a selector
; 292  : 		AssureValid();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?AssureValid@ObjectID@@QBEXXZ ; ObjectID::AssureValid

; 293  : 		return (*this)->GetProperty(selector);

  0000f	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  00013	50		 push	 eax
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  0001c	8b c8		 mov	 ecx, eax
  0001e	e8 00 00 00 00	 call	 ?GetProperty@Object@@QAEFG@Z ; Object::GetProperty

; 294  : 	}

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?GetProperty@ObjectID@@QBEFG@Z ENDP			; ObjectID::GetProperty
_TEXT	ENDS
PUBLIC	?GetPropAddrCheck@Object@@QAEPAFG@Z		; Object::GetPropAddrCheck
;	COMDAT ?GetProperty@Object@@QAEFG@Z
_TEXT	SEGMENT
_selector$ = 8
_this$ = -4
?GetProperty@Object@@QAEFG@Z PROC NEAR			; Object::GetProperty, COMDAT

; 170  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 171  : 		//	get a property given a selector
; 172  : 		return *GetPropAddrCheck(selector);

  00007	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?GetPropAddrCheck@Object@@QAEPAFG@Z ; Object::GetPropAddrCheck
  00014	66 8b 00	 mov	 ax, WORD PTR [eax]

; 173  : 	}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?GetProperty@Object@@QAEFG@Z ENDP			; Object::GetProperty
_TEXT	ENDS
PUBLIC	?GetPropAddr@Object@@QAEPAFG@Z			; Object::GetPropAddr
EXTRN	?Fatal@MsgMgr@@QAAXHZZ:NEAR			; MsgMgr::Fatal
EXTRN	?msgMgr@@3PAVMsgMgr@@A:DWORD			; msgMgr
;	COMDAT ?GetPropAddrCheck@Object@@QAEPAFG@Z
_TEXT	SEGMENT
_selector$ = 8
_this$ = -8
_property$ = -4
?GetPropAddrCheck@Object@@QAEPAFG@Z PROC NEAR		; Object::GetPropAddrCheck, COMDAT

; 153  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 154  : 		//	get a property's address, checking for valid property
; 155  : 		Property* property = GetPropAddr(selector);

  00009	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?GetPropAddr@Object@@QAEPAFG@Z ; Object::GetPropAddr
  00016	89 45 fc	 mov	 DWORD PTR _property$[ebp], eax

; 156  : 		if (!property)

  00019	83 7d fc 00	 cmp	 DWORD PTR _property$[ebp], 0
  0001d	75 1b		 jne	 SHORT $L61118

; 157  : 			msgMgr->Fatal(Msg_InvalidProperty, selector);

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _selector$[ebp]
  00022	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00028	51		 push	 ecx
  00029	6a 29		 push	 41			; 00000029H
  0002b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXHZZ	; MsgMgr::Fatal
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
$L61118:

; 158  : 		return property;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _property$[ebp]

; 159  : 	}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
?GetPropAddrCheck@Object@@QAEPAFG@Z ENDP		; Object::GetPropAddrCheck
_TEXT	ENDS
PUBLIC	?selectorDict@Object@@QAEPAVSelectorDict@@XZ	; Object::selectorDict
PUBLIC	??AObject@@QAEAAFH@Z				; Object::operator[]
EXTRN	?get@SelectorDict@@QAEHG@Z:NEAR			; SelectorDict::get
;	COMDAT ?GetPropAddr@Object@@QAEPAFG@Z
_TEXT	SEGMENT
_selector$ = 8
_this$ = -8
_index$ = -4
?GetPropAddr@Object@@QAEPAFG@Z PROC NEAR		; Object::GetPropAddr, COMDAT

; 127  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 128  : 		int index = selectorDict()->get ( selector );

  00009	66 8b 45 08	 mov	 ax, WORD PTR _selector$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?selectorDict@Object@@QAEPAVSelectorDict@@XZ ; Object::selectorDict
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 ?get@SelectorDict@@QAEHG@Z ; SelectorDict::get
  0001d	89 45 fc	 mov	 DWORD PTR _index$[ebp], eax

; 129  : 
; 130  : 		if ( index != -1 && !selectorDict()->script )

  00020	83 7d fc ff	 cmp	 DWORD PTR _index$[ebp], -1
  00024	74 2b		 je	 SHORT $L61109
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?selectorDict@Object@@QAEPAVSelectorDict@@XZ ; Object::selectorDict
  0002e	33 c9		 xor	 ecx, ecx
  00030	66 8b 48 16	 mov	 cx, WORD PTR [eax+22]
  00034	85 c9		 test	 ecx, ecx
  00036	75 19		 jne	 SHORT $L61109

; 131  : 			return &(*this)[selectorDict()->offset]; 

  00038	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?selectorDict@Object@@QAEPAVSelectorDict@@XZ ; Object::selectorDict
  00040	33 d2		 xor	 edx, edx
  00042	66 8b 50 14	 mov	 dx, WORD PTR [eax+20]
  00046	52		 push	 edx
  00047	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ??AObject@@QAEAAFH@Z	; Object::operator[]
  0004f	eb 02		 jmp	 SHORT $L61107
$L61109:

; 132  : 
; 133  : 		return 0;

  00051	33 c0		 xor	 eax, eax
$L61107:

; 134  : 	}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
?GetPropAddr@Object@@QAEPAFG@Z ENDP			; Object::GetPropAddr
_TEXT	ENDS
;	COMDAT ?selectorDict@Object@@QAEPAVSelectorDict@@XZ
_TEXT	SEGMENT
_this$ = -4
?selectorDict@Object@@QAEPAVSelectorDict@@XZ PROC NEAR	; Object::selectorDict, COMDAT

; 102  : 	SelectorDict *selectorDict ( void ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 103  : 		return _selectorDict;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 104  : 	};

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?selectorDict@Object@@QAEPAVSelectorDict@@XZ ENDP	; Object::selectorDict
_TEXT	ENDS
;	COMDAT ??AObject@@QAEAAFH@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
??AObject@@QAEAAFH@Z PROC NEAR				; Object::operator[], COMDAT

; 117  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 118  : 		//	get a reference to a property given the number of the property
; 119  : 		return ((Property*) this)[index];

  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]

; 120  : 	}

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??AObject@@QAEAAFH@Z ENDP				; Object::operator[]
_TEXT	ENDS
PUBLIC	??DMemID@@QBEPAXXZ				; MemID::operator*
;	COMDAT ??CFakeObjectID@@QBEPAUObject@@XZ
_TEXT	SEGMENT
_this$ = -4
??CFakeObjectID@@QBEPAUObject@@XZ PROC NEAR		; FakeObjectID::operator->, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??DMemID@@QBEPAXXZ	; MemID::operator*
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??CFakeObjectID@@QBEPAUObject@@XZ ENDP			; FakeObjectID::operator->
_TEXT	ENDS
PUBLIC	?GetAddr@MemoryMgr@@QAEPAXG@Z			; MemoryMgr::GetAddr
EXTRN	_memMgr:DWORD
;	COMDAT ??DMemID@@QBEPAXXZ
_TEXT	SEGMENT
_this$ = -4
??DMemID@@QBEPAXXZ PROC NEAR				; MemID::operator*, COMDAT

; 98   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 99   : 		return memMgr->GetAddr(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?GetAddr@MemoryMgr@@QAEPAXG@Z ; MemoryMgr::GetAddr

; 100  : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??DMemID@@QBEPAXXZ ENDP					; MemID::operator*
_TEXT	ENDS
EXTRN	__descPtrTable:BYTE
;	COMDAT ?GetAddr@MemoryMgr@@QAEPAXG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -4
?GetAddr@MemoryMgr@@QAEPAXG@Z PROC NEAR			; MemoryMgr::GetAddr, COMDAT

; 462  : 	inline void* MemoryMgr::GetAddr(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : //		CheckValid(theID);
; 464  : 		return _descPtrTable[(unsigned int)((unsigned short)theID)];

  00007	8b 45 08	 mov	 eax, DWORD PTR _theID$[ebp]
  0000a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0000f	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR __descPtrTable[eax*4]

; 465  : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?GetAddr@MemoryMgr@@QAEPAXG@Z ENDP			; MemoryMgr::GetAddr
_TEXT	ENDS
PUBLIC	?IsObject@ObjectID@@QBEHXZ			; ObjectID::IsObject
;	COMDAT ?AssureValid@ObjectID@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4
?AssureValid@ObjectID@@QBEXXZ PROC NEAR			; ObjectID::AssureValid, COMDAT

; 238  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 239  : 		if (!IsObject())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?IsObject@ObjectID@@QBEHXZ ; ObjectID::IsObject
  0000f	85 c0		 test	 eax, eax
  00011	75 1e		 jne	 SHORT $L61277

; 240  : 			msgMgr->Fatal(Msg_NotObject, (int) *this);

  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  0001b	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00020	50		 push	 eax
  00021	6a 2f		 push	 47			; 0000002fH
  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXHZZ	; MsgMgr::Fatal
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L61277:

; 241  : 	}

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?AssureValid@ObjectID@@QBEXXZ ENDP			; ObjectID::AssureValid
_TEXT	ENDS
PUBLIC	?IsValid@MemID@@QBEHXZ				; MemID::IsValid
EXTRN	?GetMemType@MemID@@QBE?AW4MemType@@XZ:NEAR	; MemID::GetMemType
;	COMDAT ?IsObject@ObjectID@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsObject@ObjectID@@QBEHXZ PROC NEAR			; ObjectID::IsObject, COMDAT

; 247  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 248  : 		return IsValid() && GetMemType() == MemObject;

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?IsValid@MemID@@QBEHXZ	; MemID::IsValid
  00011	85 c0		 test	 eax, eax
  00013	74 16		 je	 SHORT $L62583
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?GetMemType@MemID@@QBE?AW4MemType@@XZ ; MemID::GetMemType
  0001d	83 f8 34	 cmp	 eax, 52			; 00000034H
  00020	75 09		 jne	 SHORT $L62583
  00022	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR -8+[ebp], 1
  00029	eb 07		 jmp	 SHORT $L62584
$L62583:
  0002b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], 0
$L62584:
  00032	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]

; 249  : 	}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?IsObject@ObjectID@@QBEHXZ ENDP				; ObjectID::IsObject
_TEXT	ENDS
PUBLIC	?IsValid@MemoryMgr@@QAEHG@Z			; MemoryMgr::IsValid
;	COMDAT ?IsValid@MemID@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsValid@MemID@@QBEHXZ PROC NEAR			; MemID::IsValid, COMDAT

; 62   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 63   : 		return memMgr->IsValid(handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0000d	51		 push	 ecx
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _memMgr
  00014	e8 00 00 00 00	 call	 ?IsValid@MemoryMgr@@QAEHG@Z ; MemoryMgr::IsValid

; 64   : 	}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?IsValid@MemID@@QBEHXZ ENDP				; MemID::IsValid
_TEXT	ENDS
;	COMDAT ?IsValid@MemoryMgr@@QAEHG@Z
_TEXT	SEGMENT
_theID$ = 8
_this$ = -8
_tempID$ = -4
?IsValid@MemoryMgr@@QAEHG@Z PROC NEAR			; MemoryMgr::IsValid, COMDAT

; 475  : 	inline Bool MemoryMgr::IsValid(SOL_Handle theID) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 476  : 		unsigned short tempID = (unsigned short)theID;

  00009	66 8b 45 08	 mov	 ax, WORD PTR _theID$[ebp]
  0000d	66 89 45 fc	 mov	 WORD PTR _tempID$[ebp], ax

; 477  : 
; 478  : 		return(
; 479  : 				(tempID)															&&
; 480  : 				(tempID < maxDescriptors)									&&
; 481  : 				(desc[tempID].memInfo.bits.freeDescriptor == False)	&&
; 482  : 				(desc[tempID].memInfo.bits.freeMemory == False)
; 483  : 				);

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _tempID$[ebp]
  00014	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 58		 je	 SHORT $L62587
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _tempID$[ebp]
  00021	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  0002d	73 47		 jae	 SHORT $L62587
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _tempID$[ebp]
  00032	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00038	c1 e1 04	 shl	 ecx, 4
  0003b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00041	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00044	c1 e1 0e	 shl	 ecx, 14			; 0000000eH
  00047	c1 f9 1f	 sar	 ecx, 31			; 0000001fH
  0004a	85 c9		 test	 ecx, ecx
  0004c	75 28		 jne	 SHORT $L62587
  0004e	8b 55 fc	 mov	 edx, DWORD PTR _tempID$[ebp]
  00051	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00057	c1 e2 04	 shl	 edx, 4
  0005a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00060	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00063	c1 e2 14	 shl	 edx, 20			; 00000014H
  00066	c1 fa 1f	 sar	 edx, 31			; 0000001fH
  00069	85 d2		 test	 edx, edx
  0006b	75 09		 jne	 SHORT $L62587
  0006d	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR -12+[ebp], 1
  00074	eb 07		 jmp	 SHORT $L62588
$L62587:
  00076	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR -12+[ebp], 0
$L62588:
  0007d	8b 45 f4	 mov	 eax, DWORD PTR -12+[ebp]

; 484  : 	}

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 04 00	 ret	 4
?IsValid@MemoryMgr@@QAEHG@Z ENDP			; MemoryMgr::IsValid
_TEXT	ENDS
;	COMDAT ?TranslateMacColor@@YAXAAE@Z
_TEXT	SEGMENT
_color$ = 8
?TranslateMacColor@@YAXAAE@Z PROC NEAR			; TranslateMacColor, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : #ifdef MACINTOSH
; 26   : 	if (color == SOL_BLACK)
; 27   : 		color = SOL_WHITE;
; 28   : 	else if (color == SOL_WHITE)
; 29   : 		color = SOL_BLACK;
; 30   : #else
; 31   : 	color = color;

  00003	8b 45 08	 mov	 eax, DWORD PTR _color$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _color$[ebp]
  00009	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000b	88 10		 mov	 BYTE PTR [eax], dl

; 32   : #endif
; 33   : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?TranslateMacColor@@YAXAAE@Z ENDP			; TranslateMacColor
_TEXT	ENDS
PUBLIC	??0SOL_Plane@@QAE@ABV0@@Z			; SOL_Plane::SOL_Plane
EXTRN	??4ScreenItemList@@QAEABV0@ABV0@@Z:NEAR		; ScreenItemList::operator=
xdata$x	SEGMENT
$T62593	DD	019930520H
	DD	01H
	DD	FLAT:$T62595
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T62595	DD	0ffffffffH
	DD	FLAT:$L62591
xdata$x	ENDS
_TEXT	SEGMENT
__$EHRec$ = -12
_src$ = 8
_this$ = -16
??0SOL_Plane@@QAE@ABV0@@Z PROC NEAR			; SOL_Plane::SOL_Plane

; 91   : {

  0021f	55		 push	 ebp
  00220	8b ec		 mov	 ebp, esp
  00222	6a ff		 push	 -1
  00224	68 00 00 00 00	 push	 $L62594
  00229	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0022f	50		 push	 eax
  00230	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00237	51		 push	 ecx
  00238	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0023b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0023e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00241	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@XZ	; SOL_Rect::SOL_Rect
  00246	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00249	83 c1 28	 add	 ecx, 40			; 00000028H
  0024c	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point
  00251	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00254	83 c1 34	 add	 ecx, 52			; 00000034H
  00257	e8 00 00 00 00	 call	 ??0Ratio@@QAE@XZ	; Ratio::Ratio
  0025c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0025f	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00262	e8 00 00 00 00	 call	 ??0Ratio@@QAE@XZ	; Ratio::Ratio
  00267	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0026a	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0026d	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@XZ	; SOL_Rect::SOL_Rect
  00272	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00275	83 c1 64	 add	 ecx, 100		; 00000064H
  00278	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@XZ	; SOL_Rect::SOL_Rect
  0027d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00280	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00283	e8 00 00 00 00	 call	 ??0ScreenItemList@@QAE@XZ ; ScreenItemList::ScreenItemList
  00288	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 92   : 	// This constructor should only be used to create a copy
; 93   : 	// for the last screen's planes list when a Plane has been
; 94   : 	// added.
; 95   : 	
; 96   : 	planeId = src.planeId;

  0028f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00292	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  00295	8b 11		 mov	 edx, DWORD PTR [ecx]
  00297	89 10		 mov	 DWORD PTR [eax], edx

; 97   : 	priority = src.priority;

  00299	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0029c	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  0029f	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  002a2	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 98   : 	picResNum = src.picResNum;

  002a5	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  002a8	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  002ab	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  002ae	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 99   : 	picMirror = src.picMirror;

  002b1	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  002b4	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  002b7	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  002ba	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 100  : 	color = src.color;

  002bd	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  002c0	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  002c3	8a 51 08	 mov	 dl, BYTE PTR [ecx+8]
  002c6	88 50 08	 mov	 BYTE PTR [eax+8], dl

; 101  : 	TranslateMacColor(color);

  002c9	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  002cc	83 c0 08	 add	 eax, 8
  002cf	50		 push	 eax
  002d0	e8 00 00 00 00	 call	 ?TranslateMacColor@@YAXAAE@Z ; TranslateMacColor
  002d5	83 c4 04	 add	 esp, 4

; 102  : 
; 103  : 	plane = src.plane;

  002d8	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  002db	83 c1 64	 add	 ecx, 100		; 00000064H
  002de	51		 push	 ecx
  002df	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  002e2	83 c1 64	 add	 ecx, 100		; 00000064H
  002e5	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 104  : 	gameRect = src.gameRect;

  002ea	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  002ed	83 c2 0c	 add	 edx, 12			; 0000000cH
  002f0	52		 push	 edx
  002f1	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  002f4	83 c1 0c	 add	 ecx, 12			; 0000000cH
  002f7	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 105  : 	onScreen = src.onScreen;

  002fc	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  002ff	83 c0 4c	 add	 eax, 76			; 0000004cH
  00302	50		 push	 eax
  00303	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00306	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00309	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 106  : 
; 107  : 	// Copy over all the new screen items
; 108  : 	siArray = src.siArray;

  0030e	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  00311	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00314	51		 push	 ecx
  00315	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00318	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0031b	e8 00 00 00 00	 call	 ??4ScreenItemList@@QAEABV0@ABV0@@Z ; ScreenItemList::operator=

; 109  : }

  00320	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00327	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0032a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0032d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00334	8b e5		 mov	 esp, ebp
  00336	5d		 pop	 ebp
  00337	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L62591:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0001c	e8 00 00 00 00	 call	 ??1ScreenItemList@@QAE@XZ ; ScreenItemList::~ScreenItemList
  00021	c3		 ret	 0
$L62594:
  00022	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T62593
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0SOL_Plane@@QAE@ABV0@@Z ENDP				; SOL_Plane::SOL_Plane
PUBLIC	??0SOL_Plane@@QAE@ABVSOL_Rect@@@Z		; SOL_Plane::SOL_Plane
PUBLIC	?TopPlane@GraphicsMgr@@QBEHXZ			; GraphicsMgr::TopPlane
xdata$x	SEGMENT
$T62599	DD	019930520H
	DD	01H
	DD	FLAT:$T62601
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T62601	DD	0ffffffffH
	DD	FLAT:$L62597
xdata$x	ENDS
_TEXT	SEGMENT
__$EHRec$ = -12
_rect$ = 8
_this$ = -20
_screenCount$ = -16
??0SOL_Plane@@QAE@ABVSOL_Rect@@@Z PROC NEAR		; SOL_Plane::SOL_Plane

; 112  : {

  0033a	55		 push	 ebp
  0033b	8b ec		 mov	 ebp, esp
  0033d	6a ff		 push	 -1
  0033f	68 00 00 00 00	 push	 $L62600
  00344	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0034a	50		 push	 eax
  0034b	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00352	83 ec 08	 sub	 esp, 8
  00355	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00358	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0035b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0035e	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@XZ	; SOL_Rect::SOL_Rect
  00363	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00366	83 c1 28	 add	 ecx, 40			; 00000028H
  00369	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@XZ	; SOL_Point::SOL_Point
  0036e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00371	83 c1 34	 add	 ecx, 52			; 00000034H
  00374	e8 00 00 00 00	 call	 ??0Ratio@@QAE@XZ	; Ratio::Ratio
  00379	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0037c	83 c1 3c	 add	 ecx, 60			; 0000003cH
  0037f	e8 00 00 00 00	 call	 ??0Ratio@@QAE@XZ	; Ratio::Ratio
  00384	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00387	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0038a	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@XZ	; SOL_Rect::SOL_Rect
  0038f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00392	83 c1 64	 add	 ecx, 100		; 00000064H
  00395	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@XZ	; SOL_Rect::SOL_Rect
  0039a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0039d	83 c1 7c	 add	 ecx, 124		; 0000007cH
  003a0	e8 00 00 00 00	 call	 ??0ScreenItemList@@QAE@XZ ; ScreenItemList::ScreenItemList
  003a5	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 113  : 	// Plane created internally
; 114  : 
; 115  : 	planeId = nextId;

  003ac	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  003af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nextId@SOL_Plane@@1JA ; SOL_Plane::nextId
  003b5	89 08		 mov	 DWORD PTR [eax], ecx

; 116  : 	nextId++;

  003b7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?nextId@SOL_Plane@@1JA ; SOL_Plane::nextId
  003bd	83 c2 01	 add	 edx, 1
  003c0	89 15 00 00 00
	00		 mov	 DWORD PTR ?nextId@SOL_Plane@@1JA, edx ; SOL_Plane::nextId

; 117  : 
; 118  : 	gameRect = rect;

  003c6	8b 45 08	 mov	 eax, DWORD PTR _rect$[ebp]
  003c9	50		 push	 eax
  003ca	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  003cd	83 c1 0c	 add	 ecx, 12			; 0000000cH
  003d0	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 119  : 	ConvGameRectToPlaneRect();

  003d5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  003d8	e8 00 00 00 00	 call	 ?ConvGameRectToPlaneRect@SOL_Plane@@QAEXXZ ; SOL_Plane::ConvGameRectToPlaneRect

; 120  : 
; 121  : 	// Default to highest priority
; 122  : 	color = SOL_BLACK;

  003dd	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  003e0	c6 41 08 00	 mov	 BYTE PTR [ecx+8], 0

; 123  : 	priority = graphMgr->TopPlane()+1;

  003e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  003ea	e8 00 00 00 00	 call	 ?TopPlane@GraphicsMgr@@QBEHXZ ; GraphicsMgr::TopPlane
  003ef	83 c0 01	 add	 eax, 1
  003f2	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  003f5	89 42 24	 mov	 DWORD PTR [edx+36], eax

; 124  : 	if (priority < PLANEPRIORITYSTART)

  003f8	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  003fb	81 78 24 10 27
	00 00		 cmp	 DWORD PTR [eax+36], 10000 ; 00002710H
  00402	7d 0a		 jge	 SHORT $L61749

; 125  : 		priority = PLANEPRIORITYSTART;

  00404	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00407	c7 41 24 10 27
	00 00		 mov	 DWORD PTR [ecx+36], 10000 ; 00002710H
$L61749:

; 126  : 
; 127  : 	picResNum = -1;

  0040e	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00411	c7 42 20 ff ff
	ff ff		 mov	 DWORD PTR [edx+32], -1

; 128  : 	SetType();

  00418	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0041b	e8 00 00 00 00	 call	 ?SetType@SOL_Plane@@QAEXXZ ; SOL_Plane::SetType

; 129  : 	picMirror = False;

  00420	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00423	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 130  : 
; 131  : 	GetPicResolution();

  0042a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0042d	e8 00 00 00 00	 call	 ?GetPicResolution@SOL_Plane@@IAEXXZ ; SOL_Plane::GetPicResolution

; 132  : 
; 133  : 	int screenCount = graphMgr->ScreenCount();

  00432	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  00438	8b 11		 mov	 edx, DWORD PTR [ecx]
  0043a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  00440	ff 52 04	 call	 DWORD PTR [edx+4]
  00443	89 45 f0	 mov	 DWORD PTR _screenCount$[ebp], eax

; 134  : 	onScreen = plane;

  00446	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00449	83 c0 64	 add	 eax, 100		; 00000064H
  0044c	50		 push	 eax
  0044d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00450	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00453	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 135  : 	addCount = screenCount;

  00458	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0045b	8b 55 f0	 mov	 edx, DWORD PTR _screenCount$[ebp]
  0045e	89 51 30	 mov	 DWORD PTR [ecx+48], edx

; 136  : 	deleteCount = 0;

  00461	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00464	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], 0

; 137  : 	eraseCount = 0;

  0046b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0046e	c7 41 48 00 00
	00 00		 mov	 DWORD PTR [ecx+72], 0

; 138  : 	priorityCount = 0;

  00475	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00478	c7 42 74 00 00
	00 00		 mov	 DWORD PTR [edx+116], 0

; 139  : 	redrawAllCount = screenCount;

  0047f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00482	8b 4d f0	 mov	 ecx, DWORD PTR _screenCount$[ebp]
  00485	89 48 78	 mov	 DWORD PTR [eax+120], ecx

; 140  : 	updateCount = 0;

  00488	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0048b	c7 82 c0 9c 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+40128], 0

; 141  : }

  00495	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0049c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0049f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  004a2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  004a9	8b e5		 mov	 esp, ebp
  004ab	5d		 pop	 ebp
  004ac	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L62597:
  0002c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00032	e8 00 00 00 00	 call	 ??1ScreenItemList@@QAE@XZ ; ScreenItemList::~ScreenItemList
  00037	c3		 ret	 0
$L62600:
  00038	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T62599
  0003d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0SOL_Plane@@QAE@ABVSOL_Rect@@@Z ENDP			; SOL_Plane::SOL_Plane
PUBLIC	?TopPlane@Screen@@QBEHXZ			; Screen::TopPlane
;	COMDAT ?TopPlane@GraphicsMgr@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?TopPlane@GraphicsMgr@@QBEHXZ PROC NEAR			; GraphicsMgr::TopPlane, COMDAT

; 55   : 	int		TopPlane() const						{return next.TopPlane();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 14	 add	 ecx, 20			; 00000014H
  0000d	e8 00 00 00 00	 call	 ?TopPlane@Screen@@QBEHXZ ; Screen::TopPlane
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?TopPlane@GraphicsMgr@@QBEHXZ ENDP			; GraphicsMgr::TopPlane
_TEXT	ENDS
EXTRN	?TopPlane@PlaneList@@QBEHXZ:NEAR		; PlaneList::TopPlane
;	COMDAT ?TopPlane@Screen@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?TopPlane@Screen@@QBEHXZ PROC NEAR			; Screen::TopPlane, COMDAT

; 30   : 	int	TopPlane() const					{return planes.TopPlane();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?TopPlane@PlaneList@@QBEHXZ ; PlaneList::TopPlane
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?TopPlane@Screen@@QBEHXZ ENDP				; Screen::TopPlane
_TEXT	ENDS
PUBLIC	??4SOL_Plane@@QAEAAV0@AAVObjectID@@@Z		; SOL_Plane::operator=
PUBLIC	?Set@SOL_Rect@@QAEXHHHH@Z			; SOL_Rect::Set
_TEXT	SEGMENT
_id$ = 8
_this$ = -8
_newPic$ = -4
??4SOL_Plane@@QAEAAV0@AAVObjectID@@@Z PROC NEAR		; SOL_Plane::operator=

; 145  : {

  004af	55		 push	 ebp
  004b0	8b ec		 mov	 ebp, esp
  004b2	83 ec 08	 sub	 esp, 8
  004b5	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 146  : 	// This assignment operator is used to update
; 147  : 	// a planes data from an SCI plane object
; 148  : 	
; 149  : 	/*
; 150  : 		If the plane moved then every screenItem in the nextList
; 151  : 		gets added to the drawList except screenItems not on the
; 152  : 		plane and the screen.
; 153  : 
; 154  : 		A plane moved if:
; 155  : 			1) It's resolution changed.
; 156  : 			2) It's top,left corner changed.
; 157  : 			3) There is a new pic for it.
; 158  : 
; 159  : 		A plane did not move if:
; 160  : 			1) It's bottom,right moved.
; 161  : 	*/
; 162  : 
; 163  : 
; 164  : 	vanish.x = id.GetProperty(s_vanishingX);

  004b8	6a 6b		 push	 107			; 0000006bH
  004ba	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  004bd	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  004c2	0f bf c0	 movsx	 eax, ax
  004c5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  004c8	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 165  : 	vanish.y = id.GetProperty(s_vanishingY);

  004cb	6a 6c		 push	 108			; 0000006cH
  004cd	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  004d0	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  004d5	0f bf d0	 movsx	 edx, ax
  004d8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  004db	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 166  : 
; 167  : #ifdef NETWORK
; 168  : 	gameRect.Set(id.GetProperty(s_left),
; 169  : 					 id.GetProperty(s_top),
; 170  : 					 id.GetProperty(s_right),
; 171  : 					 id.GetProperty(s_bottom));

  004de	68 8a 00 00 00	 push	 138			; 0000008aH
  004e3	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  004e6	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  004eb	0f bf c8	 movsx	 ecx, ax
  004ee	51		 push	 ecx
  004ef	68 88 00 00 00	 push	 136			; 00000088H
  004f4	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  004f7	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  004fc	0f bf d0	 movsx	 edx, ax
  004ff	52		 push	 edx
  00500	68 89 00 00 00	 push	 137			; 00000089H
  00505	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  00508	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  0050d	0f bf c0	 movsx	 eax, ax
  00510	50		 push	 eax
  00511	68 87 00 00 00	 push	 135			; 00000087H
  00516	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  00519	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  0051e	0f bf c8	 movsx	 ecx, ax
  00521	51		 push	 ecx
  00522	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00525	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00528	e8 00 00 00 00	 call	 ?Set@SOL_Rect@@QAEXHHHH@Z ; SOL_Rect::Set

; 172  : #else
; 173  : 	gameRect.Set(id.GetProperty(s_insetRectL),
; 174  : 					 id.GetProperty(s_insetRectT),
; 175  : 					 id.GetProperty(s_insetRectR),
; 176  : 					 id.GetProperty(s_insetRectB));
; 177  : #endif
; 178  : 
; 179  : 	ConvGameRectToPlaneRect();

  0052d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00530	e8 00 00 00 00	 call	 ?ConvGameRectToPlaneRect@SOL_Plane@@QAEXXZ ; SOL_Plane::ConvGameRectToPlaneRect

; 180  : 
; 181  : 	priority = id.GetProperty(s_priority);

  00535	6a 07		 push	 7
  00537	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  0053a	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  0053f	0f bf d0	 movsx	 edx, ax
  00542	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00545	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 182  : 
; 183  : 	int newPic = id.GetProperty(s_picture);

  00548	6a 6d		 push	 109			; 0000006dH
  0054a	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  0054d	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  00552	0f bf c8	 movsx	 ecx, ax
  00555	89 4d fc	 mov	 DWORD PTR _newPic$[ebp], ecx

; 184  : 	if (picResNum != newPic) {

  00558	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0055b	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0055e	3b 45 fc	 cmp	 eax, DWORD PTR _newPic$[ebp]
  00561	74 16		 je	 SHORT $L61756

; 185  : 		picResNum = newPic;

  00563	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00566	8b 55 fc	 mov	 edx, DWORD PTR _newPic$[ebp]
  00569	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 186  : 		changePic = True;

  0056c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0056f	c7 80 c4 9c 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+40132], 1
$L61756:

; 188  : 	picMirror = id.GetProperty(s_mirrored);

  00579	68 83 00 00 00	 push	 131			; 00000083H
  0057e	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  00581	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  00586	0f bf c8	 movsx	 ecx, ax
  00589	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0058c	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 189  : 
; 190  : #ifndef WIN32S
; 191  : 	color = id.GetProperty(s_back);
; 192  : #else
; 193  : 	color = (uchar)AddPalShift((int)id.GetProperty(s_back));

  0058f	6a 26		 push	 38			; 00000026H
  00591	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  00594	e8 00 00 00 00	 call	 ?GetProperty@ObjectID@@QBEFG@Z ; ObjectID::GetProperty
  00599	0f bf c0	 movsx	 eax, ax
  0059c	50		 push	 eax
  0059d	e8 00 00 00 00	 call	 ?AddPalShift@@YAHH@Z	; AddPalShift
  005a2	83 c4 04	 add	 esp, 4
  005a5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  005a8	88 41 08	 mov	 BYTE PTR [ecx+8], al

; 194  : #endif
; 195  : 
; 196  : 	TranslateMacColor(color);

  005ab	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  005ae	83 c2 08	 add	 edx, 8
  005b1	52		 push	 edx
  005b2	e8 00 00 00 00	 call	 ?TranslateMacColor@@YAXAAE@Z ; TranslateMacColor
  005b7	83 c4 04	 add	 esp, 4

; 197  : 
; 198  : 	return *this;

  005ba	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 199  : }

  005bd	8b e5		 mov	 esp, ebp
  005bf	5d		 pop	 ebp
  005c0	c2 04 00	 ret	 4
??4SOL_Plane@@QAEAAV0@AAVObjectID@@@Z ENDP		; SOL_Plane::operator=
_TEXT	ENDS
;	COMDAT ?Set@SOL_Rect@@QAEXHHHH@Z
_TEXT	SEGMENT
_xa$ = 8
_ya$ = 12
_xb$ = 16
_yb$ = 20
_this$ = -4
?Set@SOL_Rect@@QAEXHHHH@Z PROC NEAR			; SOL_Rect::Set, COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 	A.x = xa;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _xa$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 75   : 	A.y = ya;

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _ya$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 76   : 	B.x = xb;

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 55 10	 mov	 edx, DWORD PTR _xb$[ebp]
  0001e	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 77   : 	B.y = yb;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 4d 14	 mov	 ecx, DWORD PTR _yb$[ebp]
  00027	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 78   : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 10 00	 ret	 16			; 00000010H
?Set@SOL_Rect@@QAEXHHHH@Z ENDP				; SOL_Rect::Set
_TEXT	ENDS
PUBLIC	??4SOL_Plane@@QAEAAV0@ABV0@@Z			; SOL_Plane::operator=
_TEXT	SEGMENT
_src$ = 8
_this$ = -4
??4SOL_Plane@@QAEAAV0@ABV0@@Z PROC NEAR			; SOL_Plane::operator=

; 203  : {

  005c3	55		 push	 ebp
  005c4	8b ec		 mov	 ebp, esp
  005c6	51		 push	 ecx
  005c7	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 204  : 	// This assignment should only be used to
; 205  : 	// update a plane from next to last screens
; 206  : 	// The siList will be updated separtely by
; 207  : 	// plane::Calclists
; 208  : 
; 209  : 	gameRect = src.gameRect;

  005ca	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  005cd	83 c0 0c	 add	 eax, 12			; 0000000cH
  005d0	50		 push	 eax
  005d1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005d4	83 c1 0c	 add	 ecx, 12			; 0000000cH
  005d7	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 210  : 	plane = src.plane;

  005dc	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  005df	83 c1 64	 add	 ecx, 100		; 00000064H
  005e2	51		 push	 ecx
  005e3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005e6	83 c1 64	 add	 ecx, 100		; 00000064H
  005e9	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 211  : 	vanish = src.vanish;

  005ee	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  005f1	83 c2 28	 add	 edx, 40			; 00000028H
  005f4	52		 push	 edx
  005f5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005f8	83 c1 28	 add	 ecx, 40			; 00000028H
  005fb	e8 00 00 00 00	 call	 ??4SOL_Point@@QAEAAV0@ABV0@@Z ; SOL_Point::operator=

; 212  : 	picResNum = src.picResNum;

  00600	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00603	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  00606	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00609	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 213  : 	type = src.type;

  0060c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0060f	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  00612	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00615	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 214  : 	picMirror = src.picMirror;

  00618	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0061b	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  0061e	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00621	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 215  : 	priority = src.priority;

  00624	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00627	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  0062a	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0062d	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 216  : 	color = src.color;

  00630	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00633	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  00636	8a 51 08	 mov	 dl, BYTE PTR [ecx+8]
  00639	88 50 08	 mov	 BYTE PTR [eax+8], dl

; 217  : 
; 218  : 	TranslateMacColor(color);

  0063c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0063f	83 c0 08	 add	 eax, 8
  00642	50		 push	 eax
  00643	e8 00 00 00 00	 call	 ?TranslateMacColor@@YAXAAE@Z ; TranslateMacColor
  00648	83 c4 04	 add	 esp, 4

; 219  : 
; 220  : 	picResX = src.picResX;

  0064b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0064e	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  00651	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  00654	89 41 5c	 mov	 DWORD PTR [ecx+92], eax

; 221  : 	picResY = src.picResY;

  00657	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0065a	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  0065d	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00660	89 41 60	 mov	 DWORD PTR [ecx+96], eax

; 222  : 	coordScaleX = src.coordScaleX;

  00663	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  00666	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00669	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  0066c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0066f	89 51 34	 mov	 DWORD PTR [ecx+52], edx
  00672	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 223  : 	coordScaleY = src.coordScaleY;

  00675	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  00678	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0067b	8b 4a 40	 mov	 ecx, DWORD PTR [edx+64]
  0067e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00681	89 42 3c	 mov	 DWORD PTR [edx+60], eax
  00684	89 4a 40	 mov	 DWORD PTR [edx+64], ecx

; 224  : 	onScreen = src.onScreen;

  00687	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0068a	83 c0 4c	 add	 eax, 76			; 0000004cH
  0068d	50		 push	 eax
  0068e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00691	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00694	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 225  : 	priorityCount = src.priorityCount;

  00699	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0069c	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  0069f	8b 42 74	 mov	 eax, DWORD PTR [edx+116]
  006a2	89 41 74	 mov	 DWORD PTR [ecx+116], eax

; 226  : 	return *this;

  006a5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 227  : }

  006a8	8b e5		 mov	 esp, ebp
  006aa	5d		 pop	 ebp
  006ab	c2 04 00	 ret	 4
??4SOL_Plane@@QAEAAV0@ABV0@@Z ENDP			; SOL_Plane::operator=
_TEXT	ENDS
PUBLIC	?UpdateRedrawAllCount@SOL_Plane@@QAEXXZ		; SOL_Plane::UpdateRedrawAllCount
_TEXT	SEGMENT
_this$ = -4
?UpdateRedrawAllCount@SOL_Plane@@QAEXXZ PROC NEAR	; SOL_Plane::UpdateRedrawAllCount

; 231  : {

  006ae	55		 push	 ebp
  006af	8b ec		 mov	 ebp, esp
  006b1	51		 push	 ecx
  006b2	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 232  : 	redrawAllCount = graphMgr->ScreenCount();

  006b5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  006ba	8b 10		 mov	 edx, DWORD PTR [eax]
  006bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  006c2	ff 52 04	 call	 DWORD PTR [edx+4]
  006c5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006c8	89 41 78	 mov	 DWORD PTR [ecx+120], eax

; 233  : }

  006cb	8b e5		 mov	 esp, ebp
  006cd	5d		 pop	 ebp
  006ce	c3		 ret	 0
?UpdateRedrawAllCount@SOL_Plane@@QAEXXZ ENDP		; SOL_Plane::UpdateRedrawAllCount
_TEXT	ENDS
PUBLIC	?ScreenRect@Screen@@QBEABVSOL_Rect@@XZ		; Screen::ScreenRect
PUBLIC	?Color@SOL_Plane@@QBEEXZ			; SOL_Plane::Color
PUBLIC	?DefRect@SOL_Plane@@QBEABVSOL_Rect@@XZ		; SOL_Plane::DefRect
PUBLIC	?PicResNum@SOL_Plane@@QBEHXZ			; SOL_Plane::PicResNum
PUBLIC	?PicMirror@SOL_Plane@@QBEHXZ			; SOL_Plane::PicMirror
PUBLIC	?Priority@SOL_Plane@@QBEHXZ			; SOL_Plane::Priority
PUBLIC	?UpdatePlane@SOL_Plane@@QAEXPAV1@@Z		; SOL_Plane::UpdatePlane
PUBLIC	??9SOL_Point@@QBEHABV0@@Z			; SOL_Point::operator!=
PUBLIC	?NextScreen@GraphicsMgr@@QAEPAVScreen@@XZ	; GraphicsMgr::NextScreen
PUBLIC	?DeleteAllPics@SOL_Plane@@IAEXXZ		; SOL_Plane::DeleteAllPics
PUBLIC	??9SOL_Rect@@QBEHABV0@@Z			; SOL_Rect::operator!=
PUBLIC	?Clip@SOL_Rect@@QAEXABV1@@Z			; SOL_Rect::Clip
_TEXT	SEGMENT
_lastPlane$ = 8
_this$ = -8
_screenCount$ = -4
?UpdatePlane@SOL_Plane@@QAEXPAV1@@Z PROC NEAR		; SOL_Plane::UpdatePlane

; 237  : {

  006cf	55		 push	 ebp
  006d0	8b ec		 mov	 ebp, esp
  006d2	83 ec 08	 sub	 esp, 8
  006d5	56		 push	 esi
  006d6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 238  : 	// Update from the last screen plane
; 239  : 
; 240  : 	//	If the plane moved then every screenItem in the nextList
; 241  : 	//	gets added to the drawList except screenItems not on the
; 242  : 	//	plane and the screen.
; 243  : 	//
; 244  : 	//	A plane moved if:
; 245  : 	//		1) It's resolution changed.
; 246  : 	//		2) It's top,left corner changed.
; 247  : 	//		3) There is a new pic for it.
; 248  : 	//
; 249  : 	//	A plane did not move if:
; 250  : 	//		1) It's bottom,right moved.
; 251  : 
; 252  : 	int screenCount = graphMgr->ScreenCount();

  006d9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  006de	8b 10		 mov	 edx, DWORD PTR [eax]
  006e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  006e6	ff 52 04	 call	 DWORD PTR [edx+4]
  006e9	89 45 fc	 mov	 DWORD PTR _screenCount$[ebp], eax

; 253  : 
; 254  : 	if (lastPlane == NULL) {

  006ec	83 7d 08 00	 cmp	 DWORD PTR _lastPlane$[ebp], 0
  006f0	75 3c		 jne	 SHORT $L61771

; 255  : 		if (changePic) {

  006f2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  006f5	83 b8 c4 9c 00
	00 00		 cmp	 DWORD PTR [eax+40132], 0
  006fc	74 23		 je	 SHORT $L61772

; 256  : 			DeleteAllPics();

  006fe	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00701	e8 00 00 00 00	 call	 ?DeleteAllPics@SOL_Plane@@IAEXXZ ; SOL_Plane::DeleteAllPics

; 257  : 			SetType();

  00706	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00709	e8 00 00 00 00	 call	 ?SetType@SOL_Plane@@QAEXXZ ; SOL_Plane::SetType

; 258  : 			ChangePic();

  0070e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00711	e8 00 00 00 00	 call	 ?ChangePic@SOL_Plane@@IAEXXZ ; SOL_Plane::ChangePic

; 259  : 			redrawAllCount = screenCount;

  00716	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00719	8b 55 fc	 mov	 edx, DWORD PTR _screenCount$[ebp]
  0071c	89 51 78	 mov	 DWORD PTR [ecx+120], edx

; 261  : 		else

  0071f	eb 08		 jmp	 SHORT $L61773
$L61772:

; 262  : 			SetType();

  00721	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00724	e8 00 00 00 00	 call	 ?SetType@SOL_Plane@@QAEXXZ ; SOL_Plane::SetType
$L61773:

; 264  : 	else {

  00729	e9 11 01 00 00	 jmp	 $L61784
$L61771:

; 265  : 		if (plane.A != lastPlane->DefRect().A) {

  0072e	8b 4d 08	 mov	 ecx, DWORD PTR _lastPlane$[ebp]
  00731	e8 00 00 00 00	 call	 ?DefRect@SOL_Plane@@QBEABVSOL_Rect@@XZ ; SOL_Plane::DefRect
  00736	50		 push	 eax
  00737	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0073a	83 c1 64	 add	 ecx, 100		; 00000064H
  0073d	e8 00 00 00 00	 call	 ??9SOL_Point@@QBEHABV0@@Z ; SOL_Point::operator!=
  00742	85 c0		 test	 eax, eax
  00744	74 14		 je	 SHORT $L61775

; 266  : 			// The plane moved
; 267  : 			redrawAllCount = screenCount;

  00746	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00749	8b 4d fc	 mov	 ecx, DWORD PTR _screenCount$[ebp]
  0074c	89 48 78	 mov	 DWORD PTR [eax+120], ecx

; 268  : 			eraseCount = screenCount;

  0074f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00752	8b 45 fc	 mov	 eax, DWORD PTR _screenCount$[ebp]
  00755	89 42 48	 mov	 DWORD PTR [edx+72], eax

; 270  : 		else {

  00758	eb 5b		 jmp	 SHORT $L61780
$L61775:

; 272  : 				(plane.B.y > lastPlane->DefRect().B.y)) {

  0075a	8b 4d 08	 mov	 ecx, DWORD PTR _lastPlane$[ebp]
  0075d	e8 00 00 00 00	 call	 ?DefRect@SOL_Plane@@QBEABVSOL_Rect@@XZ ; SOL_Plane::DefRect
  00762	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00765	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  00768	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0076b	7f 13		 jg	 SHORT $L61778
  0076d	8b 4d 08	 mov	 ecx, DWORD PTR _lastPlane$[ebp]
  00770	e8 00 00 00 00	 call	 ?DefRect@SOL_Plane@@QBEABVSOL_Rect@@XZ ; SOL_Plane::DefRect
  00775	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00778	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  0077b	3b 50 0c	 cmp	 edx, DWORD PTR [eax+12]
  0077e	7e 14		 jle	 SHORT $L61777
$L61778:

; 273  : 				// Plane got larger in either x or y direction but did not move
; 274  : 				redrawAllCount = screenCount;

  00780	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00783	8b 4d fc	 mov	 ecx, DWORD PTR _screenCount$[ebp]
  00786	89 48 78	 mov	 DWORD PTR [eax+120], ecx

; 275  : 				eraseCount = screenCount;

  00789	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0078c	8b 45 fc	 mov	 eax, DWORD PTR _screenCount$[ebp]
  0078f	89 42 48	 mov	 DWORD PTR [edx+72], eax

; 277  : 			else {

  00792	eb 21		 jmp	 SHORT $L61780
$L61777:

; 278  : 				if (plane != lastPlane->DefRect()) {

  00794	8b 4d 08	 mov	 ecx, DWORD PTR _lastPlane$[ebp]
  00797	e8 00 00 00 00	 call	 ?DefRect@SOL_Plane@@QBEABVSOL_Rect@@XZ ; SOL_Plane::DefRect
  0079c	50		 push	 eax
  0079d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  007a0	83 c1 64	 add	 ecx, 100		; 00000064H
  007a3	e8 00 00 00 00	 call	 ??9SOL_Rect@@QBEHABV0@@Z ; SOL_Rect::operator!=
  007a8	85 c0		 test	 eax, eax
  007aa	74 09		 je	 SHORT $L61780

; 279  : 					// plane got smaller but did not move
; 280  : 					eraseCount = screenCount;

  007ac	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  007af	8b 55 fc	 mov	 edx, DWORD PTR _screenCount$[ebp]
  007b2	89 51 48	 mov	 DWORD PTR [ecx+72], edx
$L61780:

; 284  : 
; 285  : 		if (priority != lastPlane->Priority())

  007b5	8b 4d 08	 mov	 ecx, DWORD PTR _lastPlane$[ebp]
  007b8	e8 00 00 00 00	 call	 ?Priority@SOL_Plane@@QBEHXZ ; SOL_Plane::Priority
  007bd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  007c0	39 41 24	 cmp	 DWORD PTR [ecx+36], eax
  007c3	74 09		 je	 SHORT $L61781

; 286  : 			priorityCount = screenCount;

  007c5	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  007c8	8b 45 fc	 mov	 eax, DWORD PTR _screenCount$[ebp]
  007cb	89 42 74	 mov	 DWORD PTR [edx+116], eax
$L61781:

; 289  : 		 	(picMirror != lastPlane->PicMirror())  ||
; 290  :          changePic) {

  007ce	8b 4d 08	 mov	 ecx, DWORD PTR _lastPlane$[ebp]
  007d1	e8 00 00 00 00	 call	 ?PicResNum@SOL_Plane@@QBEHXZ ; SOL_Plane::PicResNum
  007d6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  007d9	39 41 20	 cmp	 DWORD PTR [ecx+32], eax
  007dc	75 1c		 jne	 SHORT $L61783
  007de	8b 4d 08	 mov	 ecx, DWORD PTR _lastPlane$[ebp]
  007e1	e8 00 00 00 00	 call	 ?PicMirror@SOL_Plane@@QBEHXZ ; SOL_Plane::PicMirror
  007e6	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  007e9	39 42 1c	 cmp	 DWORD PTR [edx+28], eax
  007ec	75 0c		 jne	 SHORT $L61783
  007ee	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  007f1	83 b8 c4 9c 00
	00 00		 cmp	 DWORD PTR [eax+40132], 0
  007f8	74 21		 je	 SHORT $L61782
$L61783:

; 291  : 			DeleteAllPics();

  007fa	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  007fd	e8 00 00 00 00	 call	 ?DeleteAllPics@SOL_Plane@@IAEXXZ ; SOL_Plane::DeleteAllPics

; 292  : 			SetType();

  00802	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00805	e8 00 00 00 00	 call	 ?SetType@SOL_Plane@@QAEXXZ ; SOL_Plane::SetType

; 293  : 			ChangePic();

  0080a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0080d	e8 00 00 00 00	 call	 ?ChangePic@SOL_Plane@@IAEXXZ ; SOL_Plane::ChangePic

; 294  : 			redrawAllCount = screenCount;

  00812	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00815	8b 55 fc	 mov	 edx, DWORD PTR _screenCount$[ebp]
  00818	89 51 78	 mov	 DWORD PTR [ecx+120], edx
$L61782:

; 296  : 
; 297  : 		if (color != lastPlane->Color())

  0081b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0081e	33 c9		 xor	 ecx, ecx
  00820	8a 48 08	 mov	 cl, BYTE PTR [eax+8]
  00823	8b f1		 mov	 esi, ecx
  00825	8b 4d 08	 mov	 ecx, DWORD PTR _lastPlane$[ebp]
  00828	e8 00 00 00 00	 call	 ?Color@SOL_Plane@@QBEEXZ ; SOL_Plane::Color
  0082d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00832	3b f0		 cmp	 esi, eax
  00834	74 09		 je	 SHORT $L61784

; 298  : 			redrawAllCount = screenCount;

  00836	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00839	8b 45 fc	 mov	 eax, DWORD PTR _screenCount$[ebp]
  0083c	89 42 78	 mov	 DWORD PTR [edx+120], eax
$L61784:

; 300  : 	deleteCount	= 0;

  0083f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00842	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 301  : 	if (!addCount)

  00849	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0084c	83 7a 30 00	 cmp	 DWORD PTR [edx+48], 0
  00850	75 0c		 jne	 SHORT $L61785

; 302  : 		updateCount = screenCount;

  00852	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00855	8b 4d fc	 mov	 ecx, DWORD PTR _screenCount$[ebp]
  00858	89 88 c0 9c 00
	00		 mov	 DWORD PTR [eax+40128], ecx
$L61785:

; 303  : 	ConvGameRectToPlaneRect();

  0085e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00861	e8 00 00 00 00	 call	 ?ConvGameRectToPlaneRect@SOL_Plane@@QAEXXZ ; SOL_Plane::ConvGameRectToPlaneRect

; 304  : 	GetPicResolution();

  00866	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00869	e8 00 00 00 00	 call	 ?GetPicResolution@SOL_Plane@@IAEXXZ ; SOL_Plane::GetPicResolution

; 305  : 	onScreen = plane;

  0086e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00871	83 c2 64	 add	 edx, 100		; 00000064H
  00874	52		 push	 edx
  00875	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00878	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0087b	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 306  : 	onScreen.Clip(graphMgr->NextScreen()->ScreenRect());

  00880	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  00886	e8 00 00 00 00	 call	 ?NextScreen@GraphicsMgr@@QAEPAVScreen@@XZ ; GraphicsMgr::NextScreen
  0088b	8b c8		 mov	 ecx, eax
  0088d	e8 00 00 00 00	 call	 ?ScreenRect@Screen@@QBEABVSOL_Rect@@XZ ; Screen::ScreenRect
  00892	50		 push	 eax
  00893	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00896	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00899	e8 00 00 00 00	 call	 ?Clip@SOL_Rect@@QAEXABV1@@Z ; SOL_Rect::Clip

; 307  : }

  0089e	5e		 pop	 esi
  0089f	8b e5		 mov	 esp, ebp
  008a1	5d		 pop	 ebp
  008a2	c2 04 00	 ret	 4
?UpdatePlane@SOL_Plane@@QAEXPAV1@@Z ENDP		; SOL_Plane::UpdatePlane
_TEXT	ENDS
;	COMDAT ??9SOL_Point@@QBEHABV0@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
??9SOL_Point@@QBEHABV0@@Z PROC NEAR			; SOL_Point::operator!=, COMDAT

; 197  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 198  : 	return x != p.x  ||  y != p.y;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00013	75 17		 jne	 SHORT $L62610
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0001b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001e	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00021	75 09		 jne	 SHORT $L62610
  00023	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], 0
  0002a	eb 07		 jmp	 SHORT $L62611
$L62610:
  0002c	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR -8+[ebp], 1
$L62611:
  00033	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]

; 199  : }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
??9SOL_Point@@QBEHABV0@@Z ENDP				; SOL_Point::operator!=
_TEXT	ENDS
PUBLIC	??8SOL_Rect@@QBEHABV0@@Z			; SOL_Rect::operator==
;	COMDAT ??9SOL_Rect@@QBEHABV0@@Z
_TEXT	SEGMENT
_r$ = 8
_this$ = -4
??9SOL_Rect@@QBEHABV0@@Z PROC NEAR			; SOL_Rect::operator!=, COMDAT

; 215  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 216  : 	return !operator==(r);

  00007	8b 45 08	 mov	 eax, DWORD PTR _r$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??8SOL_Rect@@QBEHABV0@@Z ; SOL_Rect::operator==
  00013	f7 d8		 neg	 eax
  00015	1b c0		 sbb	 eax, eax
  00017	40		 inc	 eax

; 217  : }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
??9SOL_Rect@@QBEHABV0@@Z ENDP				; SOL_Rect::operator!=
_TEXT	ENDS
;	COMDAT ??8SOL_Rect@@QBEHABV0@@Z
_TEXT	SEGMENT
_r$ = 8
_this$ = -4
??8SOL_Rect@@QBEHABV0@@Z PROC NEAR			; SOL_Rect::operator==, COMDAT

; 205  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 206  : 	if (A.x == r.A.x  &&  A.y == r.A.y  &&  B.x == r.B.x  &&  B.y == r.B.y)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  0000d	8b 10		 mov	 edx, DWORD PTR [eax]
  0000f	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00011	75 31		 jne	 SHORT $L912
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00019	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001c	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0001f	75 23		 jne	 SHORT $L912
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00027	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0002a	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0002d	75 15		 jne	 SHORT $L912
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00035	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00038	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  0003b	75 07		 jne	 SHORT $L912

; 207  : 		return True;

  0003d	b8 01 00 00 00	 mov	 eax, 1
  00042	eb 02		 jmp	 SHORT $L911
$L912:

; 208  : 	return False;

  00044	33 c0		 xor	 eax, eax
$L911:

; 209  : }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
??8SOL_Rect@@QBEHABV0@@Z ENDP				; SOL_Rect::operator==
_TEXT	ENDS
PUBLIC	?Intersect@SOL_Rect@@QBEHABV1@@Z		; SOL_Rect::Intersect
PUBLIC	?MakeEmpty@SOL_Rect@@QAEXXZ			; SOL_Rect::MakeEmpty
;	COMDAT ?Clip@SOL_Rect@@QAEXABV1@@Z
_TEXT	SEGMENT
_r$ = 8
_this$ = -4
?Clip@SOL_Rect@@QAEXABV1@@Z PROC NEAR			; SOL_Rect::Clip, COMDAT

; 224  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 225  : 	if (Intersect(r))  {

  00007	8b 45 08	 mov	 eax, DWORD PTR _r$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?Intersect@SOL_Rect@@QBEHABV1@@Z ; SOL_Rect::Intersect
  00013	85 c0		 test	 eax, eax
  00015	74 66		 je	 SHORT $L921

; 226  : 		if (A.x < r.A.x)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  0001d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001f	3b 02		 cmp	 eax, DWORD PTR [edx]
  00021	7d 0a		 jge	 SHORT $L922

; 227  : 			A.x = r.A.x;

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00029	8b 02		 mov	 eax, DWORD PTR [edx]
  0002b	89 01		 mov	 DWORD PTR [ecx], eax
$L922:

; 228  : 		if (A.y < r.A.y)

  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00033	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00036	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00039	7d 0c		 jge	 SHORT $L923

; 229  : 			A.y = r.A.y;

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00041	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00044	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$L923:

; 230  : 		if (B.x > r.B.x)

  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  0004d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00050	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00053	7e 0c		 jle	 SHORT $L924

; 231  : 			B.x = r.B.x;

  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  0005b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0005e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L924:

; 232  : 		if (B.y > r.B.y)

  00061	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00067	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0006a	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  0006d	7e 0c		 jle	 SHORT $L925

; 233  : 			B.y = r.B.y;

  0006f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00075	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00078	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$L925:

; 235  : 	else

  0007b	eb 08		 jmp	 SHORT $L926
$L921:

; 236  : 		MakeEmpty();

  0007d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	e8 00 00 00 00	 call	 ?MakeEmpty@SOL_Rect@@QAEXXZ ; SOL_Rect::MakeEmpty
$L926:

; 237  : }

  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
?Clip@SOL_Rect@@QAEXABV1@@Z ENDP			; SOL_Rect::Clip
_TEXT	ENDS
;	COMDAT ?MakeEmpty@SOL_Rect@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?MakeEmpty@SOL_Rect@@QAEXXZ PROC NEAR			; SOL_Rect::MakeEmpty, COMDAT

; 142  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 143  : 	B.x = -1;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 08 ff ff
	ff ff		 mov	 DWORD PTR [eax+8], -1

; 144  : 	B.y = -1;

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 0c ff ff
	ff ff		 mov	 DWORD PTR [ecx+12], -1

; 145  : 	A.x = 0;

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 146  : 	A.y = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 147  : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?MakeEmpty@SOL_Rect@@QAEXXZ ENDP			; SOL_Rect::MakeEmpty
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHABV1@@Z
_TEXT	SEGMENT
_r$ = 8
_this$ = -4
?Intersect@SOL_Rect@@QBEHABV1@@Z PROC NEAR		; SOL_Rect::Intersect, COMDAT

; 189  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 190  : 	if (B.x < r.A.x)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  0000d	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00010	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00012	7d 04		 jge	 SHORT $L904

; 191  : 		return False;

  00014	33 c0		 xor	 eax, eax
  00016	eb 3a		 jmp	 SHORT $L903
$L904:

; 192  : 	if (B.y < r.A.y)

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  0001e	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00021	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00024	7d 04		 jge	 SHORT $L905

; 193  : 		return False;

  00026	33 c0		 xor	 eax, eax
  00028	eb 28		 jmp	 SHORT $L903
$L905:

; 194  : 	if (A.x > r.B.x)

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00030	8b 10		 mov	 edx, DWORD PTR [eax]
  00032	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00035	7e 04		 jle	 SHORT $L906

; 195  : 		return False;

  00037	33 c0		 xor	 eax, eax
  00039	eb 17		 jmp	 SHORT $L903
$L906:

; 196  : 	if (A.y > r.B.y)

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00041	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00044	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00047	7e 04		 jle	 SHORT $L907

; 197  : 		return False;

  00049	33 c0		 xor	 eax, eax
  0004b	eb 05		 jmp	 SHORT $L903
$L907:

; 198  : 	return True;

  0004d	b8 01 00 00 00	 mov	 eax, 1
$L903:

; 199  : }

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?Intersect@SOL_Rect@@QBEHABV1@@Z ENDP			; SOL_Rect::Intersect
_TEXT	ENDS
;	COMDAT ?Color@SOL_Plane@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4
?Color@SOL_Plane@@QBEEXZ PROC NEAR			; SOL_Plane::Color, COMDAT

; 57   : 	uchar				Color() const				{return color;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 08	 mov	 al, BYTE PTR [eax+8]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Color@SOL_Plane@@QBEEXZ ENDP				; SOL_Plane::Color
_TEXT	ENDS
;	COMDAT ?DefRect@SOL_Plane@@QBEABVSOL_Rect@@XZ
_TEXT	SEGMENT
_this$ = -4
?DefRect@SOL_Plane@@QBEABVSOL_Rect@@XZ PROC NEAR	; SOL_Plane::DefRect, COMDAT

; 58   : 	const SOL_Rect& DefRect() const			{return plane;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 64	 add	 eax, 100		; 00000064H
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?DefRect@SOL_Plane@@QBEABVSOL_Rect@@XZ ENDP		; SOL_Plane::DefRect
_TEXT	ENDS
;	COMDAT ?PicResNum@SOL_Plane@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?PicResNum@SOL_Plane@@QBEHXZ PROC NEAR			; SOL_Plane::PicResNum, COMDAT

; 65   : 	int				PicResNum() const			{return picResNum;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?PicResNum@SOL_Plane@@QBEHXZ ENDP			; SOL_Plane::PicResNum
_TEXT	ENDS
;	COMDAT ?PicMirror@SOL_Plane@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?PicMirror@SOL_Plane@@QBEHXZ PROC NEAR			; SOL_Plane::PicMirror, COMDAT

; 66   : 	int				PicMirror() const			{return picMirror;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?PicMirror@SOL_Plane@@QBEHXZ ENDP			; SOL_Plane::PicMirror
_TEXT	ENDS
;	COMDAT ?Priority@SOL_Plane@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Priority@SOL_Plane@@QBEHXZ PROC NEAR			; SOL_Plane::Priority, COMDAT

; 67   : 	int				Priority() const			{return priority;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Priority@SOL_Plane@@QBEHXZ ENDP			; SOL_Plane::Priority
_TEXT	ENDS
;	COMDAT ?ScreenRect@Screen@@QBEABVSOL_Rect@@XZ
_TEXT	SEGMENT
_this$ = -4
?ScreenRect@Screen@@QBEABVSOL_Rect@@XZ PROC NEAR	; Screen::ScreenRect, COMDAT

; 29   : 	const	SOL_Rect& ScreenRect() const	{return screenRect;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	05 94 01 00 00	 add	 eax, 404		; 00000194H
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?ScreenRect@Screen@@QBEABVSOL_Rect@@XZ ENDP		; Screen::ScreenRect
_TEXT	ENDS
;	COMDAT ?NextScreen@GraphicsMgr@@QAEPAVScreen@@XZ
_TEXT	SEGMENT
_this$ = -4
?NextScreen@GraphicsMgr@@QAEPAVScreen@@XZ PROC NEAR	; GraphicsMgr::NextScreen, COMDAT

; 72   : 	Screen*	NextScreen() 							{return &next;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 14	 add	 eax, 20			; 00000014H
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?NextScreen@GraphicsMgr@@QAEPAVScreen@@XZ ENDP		; GraphicsMgr::NextScreen
_TEXT	ENDS
PUBLIC	?NewScreenDim@SOL_Plane@@QAEXVSOL_Rect@@@Z	; SOL_Plane::NewScreenDim
_TEXT	SEGMENT
_theScreen$ = 8
_this$ = -8
_screenCount$ = -4
?NewScreenDim@SOL_Plane@@QAEXVSOL_Rect@@@Z PROC NEAR	; SOL_Plane::NewScreenDim

; 311  : {

  008a5	55		 push	 ebp
  008a6	8b ec		 mov	 ebp, esp
  008a8	83 ec 08	 sub	 esp, 8
  008ab	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 312  : 	int screenCount = graphMgr->ScreenCount();

  008ae	a1 00 00 00 00	 mov	 eax, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  008b3	8b 10		 mov	 edx, DWORD PTR [eax]
  008b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  008bb	ff 52 04	 call	 DWORD PTR [edx+4]
  008be	89 45 fc	 mov	 DWORD PTR _screenCount$[ebp], eax

; 313  : 
; 314  : 	ConvGameRectToPlaneRect();

  008c1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  008c4	e8 00 00 00 00	 call	 ?ConvGameRectToPlaneRect@SOL_Plane@@QAEXXZ ; SOL_Plane::ConvGameRectToPlaneRect

; 315  : 	redrawAllCount = screenCount;

  008c9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  008cc	8b 4d fc	 mov	 ecx, DWORD PTR _screenCount$[ebp]
  008cf	89 48 78	 mov	 DWORD PTR [eax+120], ecx

; 316  : 
; 317  : 	// clip the onScreen by the screen
; 318  : 	onScreen = plane;

  008d2	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  008d5	83 c2 64	 add	 edx, 100		; 00000064H
  008d8	52		 push	 edx
  008d9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  008dc	83 c1 4c	 add	 ecx, 76			; 0000004cH
  008df	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 319  : 	onScreen.Clip(theScreen);

  008e4	8d 45 08	 lea	 eax, DWORD PTR _theScreen$[ebp]
  008e7	50		 push	 eax
  008e8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  008eb	83 c1 4c	 add	 ecx, 76			; 0000004cH
  008ee	e8 00 00 00 00	 call	 ?Clip@SOL_Rect@@QAEXABV1@@Z ; SOL_Rect::Clip

; 320  : }

  008f3	8b e5		 mov	 esp, ebp
  008f5	5d		 pop	 ebp
  008f6	c2 10 00	 ret	 16			; 00000010H
?NewScreenDim@SOL_Plane@@QAEXVSOL_Rect@@@Z ENDP		; SOL_Plane::NewScreenDim
_this$ = -4
?SetType@SOL_Plane@@QAEXXZ PROC NEAR			; SOL_Plane::SetType

; 323  : SOL_Plane::SetType() {

  008f9	55		 push	 ebp
  008fa	8b ec		 mov	 ebp, esp
  008fc	83 ec 08	 sub	 esp, 8
  008ff	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 324  : 	switch (picResNum) {

  00902	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00905	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00908	89 4d f8	 mov	 DWORD PTR -8+[ebp], ecx
  0090b	8b 55 f8	 mov	 edx, DWORD PTR -8+[ebp]
  0090e	83 c2 04	 add	 edx, 4
  00911	89 55 f8	 mov	 DWORD PTR -8+[ebp], edx
  00914	83 7d f8 03	 cmp	 DWORD PTR -8+[ebp], 3
  00918	77 3a		 ja	 SHORT $L61802
  0091a	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]
  0091d	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L62626[eax*4]
$L61798:

; 325  : 		case -1:
; 326  : 			type = coloredPlane;

  00924	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00927	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 327  : 			break;

  0092e	eb 40		 jmp	 SHORT $L61795
$L61799:

; 328  : 		case -2:
; 329  : 			type = transparentPlane;

  00930	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00933	c7 42 04 02 00
	00 00		 mov	 DWORD PTR [edx+4], 2

; 330  : 			break;

  0093a	eb 34		 jmp	 SHORT $L61795
$L61800:

; 331  : 		case -3:
; 332  : 			type = opaquePlane;

  0093c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0093f	c7 40 04 03 00
	00 00		 mov	 DWORD PTR [eax+4], 3

; 333  : 			break;

  00946	eb 28		 jmp	 SHORT $L61795
$L61801:

; 334  : 		case -4:
; 335  : 			type = pictureSkipPlane;

  00948	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0094b	c7 41 04 04 00
	00 00		 mov	 DWORD PTR [ecx+4], 4

; 336  : 			break;

  00952	eb 1c		 jmp	 SHORT $L61795
$L61802:

; 337  : 		default:
; 338  : 			if ((type != picturePlane) && (type != pictureSkipPlane))

  00954	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00957	83 7a 04 01	 cmp	 DWORD PTR [edx+4], 1
  0095b	74 13		 je	 SHORT $L61803
  0095d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00960	83 78 04 04	 cmp	 DWORD PTR [eax+4], 4
  00964	74 0a		 je	 SHORT $L61803

; 339  : 				// Set if it's not already a picture plane
; 340  : 				type = picturePlane;

  00966	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00969	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1
$L61803:
$L61795:

; 343  : }

  00970	8b e5		 mov	 esp, ebp
  00972	5d		 pop	 ebp
  00973	c3		 ret	 0
$L62626:
  00974	00 00 00 00	 DD	 $L61801
  00978	00 00 00 00	 DD	 $L61800
  0097c	00 00 00 00	 DD	 $L61799
  00980	00 00 00 00	 DD	 $L61798
?SetType@SOL_Plane@@QAEXXZ ENDP				; SOL_Plane::SetType
_TEXT	ENDS
PUBLIC	?SetCel@ScreenItem@@QAEXPAVCelObj@@@Z		; ScreenItem::SetCel
PUBLIC	?SetPicResNum@ScreenItem@@QAEXH@Z		; ScreenItem::SetPicResNum
PUBLIC	?SetPriority@ScreenItem@@QAEXH@Z		; ScreenItem::SetPriority
PUBLIC	?SetUserMirror@ScreenItem@@QAEXH@Z		; ScreenItem::SetUserMirror
PUBLIC	?AddScreenItem@SOL_Plane@@QAEXPAVScreenItem@@@Z	; SOL_Plane::AddScreenItem
PUBLIC	??0Bitmap@@QAE@HH@Z				; Bitmap::Bitmap
PUBLIC	?HasSkip@CelObj@@QBEHXZ				; CelObj::HasSkip
PUBLIC	?Pos@CelObjPic@@QBE?AVSOL_Point@@XZ		; CelObjPic::Pos
PUBLIC	?Priority@CelObjPic@@QBEHXZ			; CelObjPic::Priority
PUBLIC	?CelCount@CelObjPic@@QBEHXZ			; CelObjPic::CelCount
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	??0CelObjPic@@QAE@HH@Z:NEAR			; CelObjPic::CelObjPic
EXTRN	??0ScreenItem@@QAE@JABVBitmap@@@Z:NEAR		; ScreenItem::ScreenItem
xdata$x	SEGMENT
$T62641	DD	019930520H
	DD	02H
	DD	FLAT:$T62643
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T62643	DD	0ffffffffH
	DD	FLAT:$L62638
	DD	0ffffffffH
	DD	FLAT:$L62639
xdata$x	ENDS
_TEXT	SEGMENT
$T62628 = -36
$T62629 = -40
$T62632 = -44
$T62633 = -48
$T62634 = -68
$T62637 = -76
__$EHRec$ = -12
_this$ = -80
_count$ = -16
_hasSkipInBackground$ = -24
_i$ = -20
_picCel$61814 = -32
_si$61821 = -28
?ChangePic@SOL_Plane@@IAEXXZ PROC NEAR			; SOL_Plane::ChangePic

; 347  : {

  00984	55		 push	 ebp
  00985	8b ec		 mov	 ebp, esp
  00987	6a ff		 push	 -1
  00989	68 00 00 00 00	 push	 $L62642
  0098e	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00994	50		 push	 eax
  00995	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0099c	83 ec 4c	 sub	 esp, 76			; 0000004cH
  0099f	89 4d b0	 mov	 DWORD PTR _this$[ebp], ecx

; 348  :    changePic = False;

  009a2	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  009a5	c7 80 c4 9c 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+40132], 0

; 349  : 	if ((type != picturePlane) && (type != pictureSkipPlane))

  009af	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  009b2	83 79 04 01	 cmp	 DWORD PTR [ecx+4], 1
  009b6	74 0e		 je	 SHORT $L61807
  009b8	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  009bb	83 7a 04 04	 cmp	 DWORD PTR [edx+4], 4
  009bf	74 05		 je	 SHORT $L61807

; 350  : 		return;

  009c1	e9 7e 01 00 00	 jmp	 $L61806
$L61807:

; 351  : 
; 352  : 	//  Add the pic cels to the plane
; 353  : 	int count = 1000000;

  009c6	c7 45 f0 40 42
	0f 00		 mov	 DWORD PTR _count$[ebp], 1000000 ; 000f4240H

; 354  : 	Bool hasSkipInBackground = True;

  009cd	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _hasSkipInBackground$[ebp], 1

; 355  : 	for (int i = 0;i < count; i++)  {

  009d4	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  009db	eb 09		 jmp	 SHORT $L61811
$L61812:
  009dd	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  009e0	83 c0 01	 add	 eax, 1
  009e3	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$L61811:
  009e6	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  009e9	3b 4d f0	 cmp	 ecx, DWORD PTR _count$[ebp]
  009ec	0f 8d 36 01 00
	00		 jge	 $L61813

; 356  : 		CelObjPic* picCel = New CelObjPic(picResNum,i);

  009f2	6a 60		 push	 96			; 00000060H
  009f4	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  009f9	83 c4 04	 add	 esp, 4
  009fc	89 45 d8	 mov	 DWORD PTR $T62629[ebp], eax
  009ff	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00a06	83 7d d8 00	 cmp	 DWORD PTR $T62629[ebp], 0
  00a0a	74 18		 je	 SHORT $L62630
  00a0c	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  00a0f	52		 push	 edx
  00a10	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00a13	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00a16	51		 push	 ecx
  00a17	8b 4d d8	 mov	 ecx, DWORD PTR $T62629[ebp]
  00a1a	e8 00 00 00 00	 call	 ??0CelObjPic@@QAE@HH@Z	; CelObjPic::CelObjPic
  00a1f	89 45 ac	 mov	 DWORD PTR -84+[ebp], eax
  00a22	eb 07		 jmp	 SHORT $L62631
$L62630:
  00a24	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR -84+[ebp], 0
$L62631:
  00a2b	8b 55 ac	 mov	 edx, DWORD PTR -84+[ebp]
  00a2e	89 55 dc	 mov	 DWORD PTR $T62628[ebp], edx
  00a31	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00a38	8b 45 dc	 mov	 eax, DWORD PTR $T62628[ebp]
  00a3b	89 45 e0	 mov	 DWORD PTR _picCel$61814[ebp], eax

; 357  : 		if (count == 1000000) {

  00a3e	81 7d f0 40 42
	0f 00		 cmp	 DWORD PTR _count$[ebp], 1000000 ; 000f4240H
  00a45	75 0b		 jne	 SHORT $L61819

; 358  : 			count = picCel->CelCount();

  00a47	8b 4d e0	 mov	 ecx, DWORD PTR _picCel$61814[ebp]
  00a4a	e8 00 00 00 00	 call	 ?CelCount@CelObjPic@@QBEHXZ ; CelObjPic::CelCount
  00a4f	89 45 f0	 mov	 DWORD PTR _count$[ebp], eax
$L61819:

; 360  : 		if (!picCel->HasSkip())

  00a52	8b 4d e0	 mov	 ecx, DWORD PTR _picCel$61814[ebp]
  00a55	e8 00 00 00 00	 call	 ?HasSkip@CelObj@@QBEHXZ	; CelObj::HasSkip
  00a5a	85 c0		 test	 eax, eax
  00a5c	75 07		 jne	 SHORT $L61820

; 361  : 			hasSkipInBackground = False;

  00a5e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _hasSkipInBackground$[ebp], 0
$L61820:

; 362  : 		ScreenItem* si = New ScreenItem(planeId,Bitmap(picResNum,i));

  00a65	68 98 00 00 00	 push	 152			; 00000098H
  00a6a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00a6f	83 c4 04	 add	 esp, 4
  00a72	89 45 d0	 mov	 DWORD PTR $T62633[ebp], eax
  00a75	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00a7c	83 7d d0 00	 cmp	 DWORD PTR $T62633[ebp], 0
  00a80	74 27		 je	 SHORT $L62635
  00a82	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  00a85	51		 push	 ecx
  00a86	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  00a89	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00a8c	50		 push	 eax
  00a8d	8d 4d bc	 lea	 ecx, DWORD PTR $T62634[ebp]
  00a90	e8 00 00 00 00	 call	 ??0Bitmap@@QAE@HH@Z	; Bitmap::Bitmap
  00a95	50		 push	 eax
  00a96	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00a99	8b 11		 mov	 edx, DWORD PTR [ecx]
  00a9b	52		 push	 edx
  00a9c	8b 4d d0	 mov	 ecx, DWORD PTR $T62633[ebp]
  00a9f	e8 00 00 00 00	 call	 ??0ScreenItem@@QAE@JABVBitmap@@@Z ; ScreenItem::ScreenItem
  00aa4	89 45 a8	 mov	 DWORD PTR -88+[ebp], eax
  00aa7	eb 07		 jmp	 SHORT $L62636
$L62635:
  00aa9	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR -88+[ebp], 0
$L62636:
  00ab0	8b 45 a8	 mov	 eax, DWORD PTR -88+[ebp]
  00ab3	89 45 d4	 mov	 DWORD PTR $T62632[ebp], eax
  00ab6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00abd	8b 4d d4	 mov	 ecx, DWORD PTR $T62632[ebp]
  00ac0	89 4d e4	 mov	 DWORD PTR _si$61821[ebp], ecx

; 363  : 		if (picMirror)

  00ac3	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  00ac6	83 7a 1c 00	 cmp	 DWORD PTR [edx+28], 0
  00aca	74 0a		 je	 SHORT $L61827

; 364  : 			si->SetUserMirror(True);

  00acc	6a 01		 push	 1
  00ace	8b 4d e4	 mov	 ecx, DWORD PTR _si$61821[ebp]
  00ad1	e8 00 00 00 00	 call	 ?SetUserMirror@ScreenItem@@QAEXH@Z ; ScreenItem::SetUserMirror
$L61827:

; 365  : 		si->SetPriority(picCel->Priority());

  00ad6	8b 4d e0	 mov	 ecx, DWORD PTR _picCel$61814[ebp]
  00ad9	e8 00 00 00 00	 call	 ?Priority@CelObjPic@@QBEHXZ ; CelObjPic::Priority
  00ade	50		 push	 eax
  00adf	8b 4d e4	 mov	 ecx, DWORD PTR _si$61821[ebp]
  00ae2	e8 00 00 00 00	 call	 ?SetPriority@ScreenItem@@QAEXH@Z ; ScreenItem::SetPriority

; 366  : 		si->pos = picCel->Pos();

  00ae7	8d 45 b4	 lea	 eax, DWORD PTR $T62637[ebp]
  00aea	50		 push	 eax
  00aeb	8b 4d e0	 mov	 ecx, DWORD PTR _picCel$61814[ebp]
  00aee	e8 00 00 00 00	 call	 ?Pos@CelObjPic@@QBE?AVSOL_Point@@XZ ; CelObjPic::Pos
  00af3	50		 push	 eax
  00af4	8b 4d e4	 mov	 ecx, DWORD PTR _si$61821[ebp]
  00af7	e8 00 00 00 00	 call	 ??4SOL_Point@@QAEAAV0@ABV0@@Z ; SOL_Point::operator=

; 367  : 		si->SetPicResNum(picResNum);

  00afc	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00aff	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00b02	52		 push	 edx
  00b03	8b 4d e4	 mov	 ecx, DWORD PTR _si$61821[ebp]
  00b06	e8 00 00 00 00	 call	 ?SetPicResNum@ScreenItem@@QAEXH@Z ; ScreenItem::SetPicResNum

; 368  : 		AddScreenItem(si);

  00b0b	8b 45 e4	 mov	 eax, DWORD PTR _si$61821[ebp]
  00b0e	50		 push	 eax
  00b0f	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00b12	e8 00 00 00 00	 call	 ?AddScreenItem@SOL_Plane@@QAEXPAVScreenItem@@@Z ; SOL_Plane::AddScreenItem

; 369  : 		si->SetCel(picCel);

  00b17	8b 4d e0	 mov	 ecx, DWORD PTR _picCel$61814[ebp]
  00b1a	51		 push	 ecx
  00b1b	8b 4d e4	 mov	 ecx, DWORD PTR _si$61821[ebp]
  00b1e	e8 00 00 00 00	 call	 ?SetCel@ScreenItem@@QAEXPAVCelObj@@@Z ; ScreenItem::SetCel

; 370  : 	}

  00b23	e9 b5 fe ff ff	 jmp	 $L61812
$L61813:

; 371  : 	if (hasSkipInBackground)

  00b28	83 7d e8 00	 cmp	 DWORD PTR _hasSkipInBackground$[ebp], 0
  00b2c	74 0c		 je	 SHORT $L61829

; 372  : 		type = pictureSkipPlane;

  00b2e	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  00b31	c7 42 04 04 00
	00 00		 mov	 DWORD PTR [edx+4], 4

; 373  : 	else

  00b38	eb 0a		 jmp	 SHORT $L61830
$L61829:

; 374  : 		type = picturePlane;

  00b3a	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00b3d	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [eax+4], 1
$L61830:
$L61806:

; 375  : }

  00b44	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00b47	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00b4e	8b e5		 mov	 esp, ebp
  00b50	5d		 pop	 ebp
  00b51	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L62638:
  00042	8b 45 d8	 mov	 eax, DWORD PTR $T62629[ebp]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004b	59		 pop	 ecx
  0004c	c3		 ret	 0
$L62639:
  0004d	8b 45 d0	 mov	 eax, DWORD PTR $T62633[ebp]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	59		 pop	 ecx
  00057	c3		 ret	 0
$L62642:
  00058	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T62641
  0005d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ChangePic@SOL_Plane@@IAEXXZ ENDP			; SOL_Plane::ChangePic
PUBLIC	??0MemID@@QAE@XZ				; MemID::MemID
;	COMDAT ??0Bitmap@@QAE@HH@Z
_TEXT	SEGMENT
_p$ = 8
_c$ = 12
_this$ = -4
??0Bitmap@@QAE@HH@Z PROC NEAR				; Bitmap::Bitmap, COMDAT

; 127  : 	Bitmap(const int p, const int c)						{view = p; loop = 0; cel = c; type = tPic;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 10	 add	 ecx, 16			; 00000010H
  0000d	e8 00 00 00 00	 call	 ??0MemID@@QAE@XZ	; MemID::MemID
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00018	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b 4d 0c	 mov	 ecx, DWORD PTR _c$[ebp]
  0002b	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0002e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00031	c7 02 01 00 00
	00		 mov	 DWORD PTR [edx], 1
  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
??0Bitmap@@QAE@HH@Z ENDP				; Bitmap::Bitmap
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0MemID@@QAE@XZ PROC NEAR				; MemID::MemID, COMDAT

; 15   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 16   : 	}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0MemID@@QAE@XZ ENDP					; MemID::MemID
_TEXT	ENDS
;	COMDAT ?HasSkip@CelObj@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?HasSkip@CelObj@@QBEHXZ PROC NEAR			; CelObj::HasSkip, COMDAT

; 185  : 	Bool	HasSkip() const		{return hasSkip;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?HasSkip@CelObj@@QBEHXZ ENDP				; CelObj::HasSkip
_TEXT	ENDS
PUBLIC	??0SOL_Point@@QAE@ABV0@@Z			; SOL_Point::SOL_Point
;	COMDAT ?Pos@CelObjPic@@QBE?AVSOL_Point@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
?Pos@CelObjPic@@QBE?AVSOL_Point@@XZ PROC NEAR		; CelObjPic::Pos, COMDAT

; 328  : 	SOL_Point	Pos() const 				{return pos;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 54	 add	 eax, 84			; 00000054H
  0000d	50		 push	 eax
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?Pos@CelObjPic@@QBE?AVSOL_Point@@XZ ENDP		; CelObjPic::Pos
_TEXT	ENDS
;	COMDAT ??0SOL_Point@@QAE@ABV0@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
??0SOL_Point@@QAE@ABV0@@Z PROC NEAR			; SOL_Point::SOL_Point, COMDAT

; 22   : 	SOL_Point(const SOL_Point& p) : x(p.x), y(p.y) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00017	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001a	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??0SOL_Point@@QAE@ABV0@@Z ENDP				; SOL_Point::SOL_Point
_TEXT	ENDS
;	COMDAT ?Priority@CelObjPic@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Priority@CelObjPic@@QBEHXZ PROC NEAR			; CelObjPic::Priority, COMDAT

; 329  : 	int			Priority() const			{return priority;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 5c	 mov	 eax, DWORD PTR [eax+92]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Priority@CelObjPic@@QBEHXZ ENDP			; CelObjPic::Priority
_TEXT	ENDS
;	COMDAT ?CelCount@CelObjPic@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?CelCount@CelObjPic@@QBEHXZ PROC NEAR			; CelObjPic::CelCount, COMDAT

; 330  : 	int			CelCount() const			{return celCount;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?CelCount@CelObjPic@@QBEHXZ ENDP			; CelObjPic::CelCount
_TEXT	ENDS
;	COMDAT ?SetCel@ScreenItem@@QAEXPAVCelObj@@@Z
_TEXT	SEGMENT
_theCel$ = 8
_this$ = -12
$T62652 = -4
$T62653 = -8
?SetCel@ScreenItem@@QAEXPAVCelObj@@@Z PROC NEAR		; ScreenItem::SetCel, COMDAT

; 93   : 	void			SetCel(CelObj* theCel)  {delete cel; cel = theCel;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  0000f	89 4d f8	 mov	 DWORD PTR $T62653[ebp], ecx
  00012	8b 55 f8	 mov	 edx, DWORD PTR $T62653[ebp]
  00015	89 55 fc	 mov	 DWORD PTR $T62652[ebp], edx
  00018	83 7d fc 00	 cmp	 DWORD PTR $T62652[ebp], 0
  0001c	74 11		 je	 SHORT $L62654
  0001e	6a 01		 push	 1
  00020	8b 45 fc	 mov	 eax, DWORD PTR $T62652[ebp]
  00023	8b 10		 mov	 edx, DWORD PTR [eax]
  00025	8b 4d fc	 mov	 ecx, DWORD PTR $T62652[ebp]
  00028	ff 12		 call	 DWORD PTR [edx]
  0002a	89 45 f0	 mov	 DWORD PTR -16+[ebp], eax
  0002d	eb 07		 jmp	 SHORT $L62655
$L62654:
  0002f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR -16+[ebp], 0
$L62655:
  00036	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 4d 08	 mov	 ecx, DWORD PTR _theCel$[ebp]
  0003c	89 48 54	 mov	 DWORD PTR [eax+84], ecx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?SetCel@ScreenItem@@QAEXPAVCelObj@@@Z ENDP		; ScreenItem::SetCel
_TEXT	ENDS
;	COMDAT ?SetPicResNum@ScreenItem@@QAEXH@Z
_TEXT	SEGMENT
_pic$ = 8
_this$ = -4
?SetPicResNum@ScreenItem@@QAEXH@Z PROC NEAR		; ScreenItem::SetPicResNum, COMDAT

; 99   : 	void			SetPicResNum(int pic)	{picResNum = pic;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _pic$[ebp]
  0000d	89 48 38	 mov	 DWORD PTR [eax+56], ecx
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetPicResNum@ScreenItem@@QAEXH@Z ENDP			; ScreenItem::SetPicResNum
_TEXT	ENDS
;	COMDAT ?SetPriority@ScreenItem@@QAEXH@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
?SetPriority@ScreenItem@@QAEXH@Z PROC NEAR		; ScreenItem::SetPriority, COMDAT

; 100  : 	void			SetPriority(int p)		{priority = p; fixedPriFlag = True;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0000d	89 48 40	 mov	 DWORD PTR [eax+64], ecx
  00010	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00013	c7 42 44 01 00
	00 00		 mov	 DWORD PTR [edx+68], 1
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?SetPriority@ScreenItem@@QAEXH@Z ENDP			; ScreenItem::SetPriority
_TEXT	ENDS
;	COMDAT ?SetUserMirror@ScreenItem@@QAEXH@Z
_TEXT	SEGMENT
_f$ = 8
_this$ = -4
?SetUserMirror@ScreenItem@@QAEXH@Z PROC NEAR		; ScreenItem::SetUserMirror, COMDAT

; 102  : 	void			SetUserMirror(Bool f)	{userMirror = f;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _f$[ebp]
  0000d	89 48 5c	 mov	 DWORD PTR [eax+92], ecx
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetUserMirror@ScreenItem@@QAEXH@Z ENDP			; ScreenItem::SetUserMirror
_TEXT	ENDS
PUBLIC	?AddPic@SOL_Plane@@QAEHHABVSOL_Point@@HH@Z	; SOL_Plane::AddPic
PUBLIC	?DeletePic@SOL_Plane@@QAEXH@Z			; SOL_Plane::DeletePic
xdata$x	SEGMENT
$T62673	DD	019930520H
	DD	02H
	DD	FLAT:$T62675
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T62675	DD	0ffffffffH
	DD	FLAT:$L62670
	DD	0ffffffffH
	DD	FLAT:$L62671
xdata$x	ENDS
_TEXT	SEGMENT
$T62660 = -32
$T62661 = -36
$T62664 = -40
$T62665 = -44
$T62666 = -64
$T62669 = -72
__$EHRec$ = -12
_thePic$ = 8
_thePoint$ = 12
_mirror$ = 16
_delCopy$ = 20
_this$ = -76
_count$ = -16
_i$ = -20
_picCel$61844 = -28
_si$61850 = -24
?AddPic@SOL_Plane@@QAEHHABVSOL_Point@@HH@Z PROC NEAR	; SOL_Plane::AddPic

; 379  : {

  00b52	55		 push	 ebp
  00b53	8b ec		 mov	 ebp, esp
  00b55	6a ff		 push	 -1
  00b57	68 00 00 00 00	 push	 $L62674
  00b5c	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00b62	50		 push	 eax
  00b63	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00b6a	83 ec 48	 sub	 esp, 72			; 00000048H
  00b6d	89 4d b4	 mov	 DWORD PTR _this$[ebp], ecx

; 380  : 	// Delete the pic if it's already present
; 381  : 	// This is needed for restore	because they are
; 382  : 	// deleting the plane then adding the plane 
; 383  : 	// then adding the pics again.
; 384  : 	if (delCopy)

  00b70	83 7d 14 00	 cmp	 DWORD PTR _delCopy$[ebp], 0
  00b74	74 0c		 je	 SHORT $L61838

; 385  : 		DeletePic(thePic);

  00b76	8b 45 08	 mov	 eax, DWORD PTR _thePic$[ebp]
  00b79	50		 push	 eax
  00b7a	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00b7d	e8 00 00 00 00	 call	 ?DeletePic@SOL_Plane@@QAEXH@Z ; SOL_Plane::DeletePic
$L61838:

; 386  : 
; 387  : 	//  Add the pic cels to the plane
; 388  : 	int count = 1000;

  00b82	c7 45 f0 e8 03
	00 00		 mov	 DWORD PTR _count$[ebp], 1000 ; 000003e8H

; 389  : 	for (int i = 0; i < count; i++)  {

  00b89	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00b90	eb 09		 jmp	 SHORT $L61841
$L61842:
  00b92	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  00b95	83 c1 01	 add	 ecx, 1
  00b98	89 4d ec	 mov	 DWORD PTR _i$[ebp], ecx
$L61841:
  00b9b	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  00b9e	3b 55 f0	 cmp	 edx, DWORD PTR _count$[ebp]
  00ba1	0f 8d 38 01 00
	00		 jge	 $L61843

; 390  : 		CelObjPic* picCel = New CelObjPic(thePic,i);

  00ba7	6a 60		 push	 96			; 00000060H
  00ba9	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00bae	83 c4 04	 add	 esp, 4
  00bb1	89 45 dc	 mov	 DWORD PTR $T62661[ebp], eax
  00bb4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00bbb	83 7d dc 00	 cmp	 DWORD PTR $T62661[ebp], 0
  00bbf	74 15		 je	 SHORT $L62662
  00bc1	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00bc4	50		 push	 eax
  00bc5	8b 4d 08	 mov	 ecx, DWORD PTR _thePic$[ebp]
  00bc8	51		 push	 ecx
  00bc9	8b 4d dc	 mov	 ecx, DWORD PTR $T62661[ebp]
  00bcc	e8 00 00 00 00	 call	 ??0CelObjPic@@QAE@HH@Z	; CelObjPic::CelObjPic
  00bd1	89 45 b0	 mov	 DWORD PTR -80+[ebp], eax
  00bd4	eb 07		 jmp	 SHORT $L62663
$L62662:
  00bd6	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR -80+[ebp], 0
$L62663:
  00bdd	8b 55 b0	 mov	 edx, DWORD PTR -80+[ebp]
  00be0	89 55 e0	 mov	 DWORD PTR $T62660[ebp], edx
  00be3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00bea	8b 45 e0	 mov	 eax, DWORD PTR $T62660[ebp]
  00bed	89 45 e4	 mov	 DWORD PTR _picCel$61844[ebp], eax

; 391  : 		if (count == 1000)

  00bf0	81 7d f0 e8 03
	00 00		 cmp	 DWORD PTR _count$[ebp], 1000 ; 000003e8H
  00bf7	75 0b		 jne	 SHORT $L61849

; 392  : 			count = picCel->CelCount();

  00bf9	8b 4d e4	 mov	 ecx, DWORD PTR _picCel$61844[ebp]
  00bfc	e8 00 00 00 00	 call	 ?CelCount@CelObjPic@@QBEHXZ ; CelObjPic::CelCount
  00c01	89 45 f0	 mov	 DWORD PTR _count$[ebp], eax
$L61849:

; 393  : 		ScreenItem* si = New ScreenItem(planeId,Bitmap(thePic,i));

  00c04	68 98 00 00 00	 push	 152			; 00000098H
  00c09	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00c0e	83 c4 04	 add	 esp, 4
  00c11	89 45 d4	 mov	 DWORD PTR $T62665[ebp], eax
  00c14	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00c1b	83 7d d4 00	 cmp	 DWORD PTR $T62665[ebp], 0
  00c1f	74 24		 je	 SHORT $L62667
  00c21	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  00c24	51		 push	 ecx
  00c25	8b 55 08	 mov	 edx, DWORD PTR _thePic$[ebp]
  00c28	52		 push	 edx
  00c29	8d 4d c0	 lea	 ecx, DWORD PTR $T62666[ebp]
  00c2c	e8 00 00 00 00	 call	 ??0Bitmap@@QAE@HH@Z	; Bitmap::Bitmap
  00c31	50		 push	 eax
  00c32	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  00c35	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c37	51		 push	 ecx
  00c38	8b 4d d4	 mov	 ecx, DWORD PTR $T62665[ebp]
  00c3b	e8 00 00 00 00	 call	 ??0ScreenItem@@QAE@JABVBitmap@@@Z ; ScreenItem::ScreenItem
  00c40	89 45 ac	 mov	 DWORD PTR -84+[ebp], eax
  00c43	eb 07		 jmp	 SHORT $L62668
$L62667:
  00c45	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR -84+[ebp], 0
$L62668:
  00c4c	8b 55 ac	 mov	 edx, DWORD PTR -84+[ebp]
  00c4f	89 55 d8	 mov	 DWORD PTR $T62664[ebp], edx
  00c52	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00c59	8b 45 d8	 mov	 eax, DWORD PTR $T62664[ebp]
  00c5c	89 45 e8	 mov	 DWORD PTR _si$61850[ebp], eax

; 394  : 		if (mirror)

  00c5f	83 7d 10 00	 cmp	 DWORD PTR _mirror$[ebp], 0
  00c63	74 0a		 je	 SHORT $L61856

; 395  : 			si->SetUserMirror(True);

  00c65	6a 01		 push	 1
  00c67	8b 4d e8	 mov	 ecx, DWORD PTR _si$61850[ebp]
  00c6a	e8 00 00 00 00	 call	 ?SetUserMirror@ScreenItem@@QAEXH@Z ; ScreenItem::SetUserMirror
$L61856:

; 396  : 		si->SetPriority(picCel->Priority());

  00c6f	8b 4d e4	 mov	 ecx, DWORD PTR _picCel$61844[ebp]
  00c72	e8 00 00 00 00	 call	 ?Priority@CelObjPic@@QBEHXZ ; CelObjPic::Priority
  00c77	50		 push	 eax
  00c78	8b 4d e8	 mov	 ecx, DWORD PTR _si$61850[ebp]
  00c7b	e8 00 00 00 00	 call	 ?SetPriority@ScreenItem@@QAEXH@Z ; ScreenItem::SetPriority

; 397  : 		si->pos = picCel->Pos();

  00c80	8d 4d b8	 lea	 ecx, DWORD PTR $T62669[ebp]
  00c83	51		 push	 ecx
  00c84	8b 4d e4	 mov	 ecx, DWORD PTR _picCel$61844[ebp]
  00c87	e8 00 00 00 00	 call	 ?Pos@CelObjPic@@QBE?AVSOL_Point@@XZ ; CelObjPic::Pos
  00c8c	50		 push	 eax
  00c8d	8b 4d e8	 mov	 ecx, DWORD PTR _si$61850[ebp]
  00c90	e8 00 00 00 00	 call	 ??4SOL_Point@@QAEAAV0@ABV0@@Z ; SOL_Point::operator=

; 398  : 		si->SetPicResNum(thePic);

  00c95	8b 55 08	 mov	 edx, DWORD PTR _thePic$[ebp]
  00c98	52		 push	 edx
  00c99	8b 4d e8	 mov	 ecx, DWORD PTR _si$61850[ebp]
  00c9c	e8 00 00 00 00	 call	 ?SetPicResNum@ScreenItem@@QAEXH@Z ; ScreenItem::SetPicResNum

; 399  : 		// Position the cels 
; 400  : 		si->pos.x += thePoint.x;

  00ca1	8b 45 e8	 mov	 eax, DWORD PTR _si$61850[ebp]
  00ca4	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ca6	8b 55 0c	 mov	 edx, DWORD PTR _thePoint$[ebp]
  00ca9	03 0a		 add	 ecx, DWORD PTR [edx]
  00cab	8b 45 e8	 mov	 eax, DWORD PTR _si$61850[ebp]
  00cae	89 08		 mov	 DWORD PTR [eax], ecx

; 401  : 		si->pos.y += thePoint.y;

  00cb0	8b 4d e8	 mov	 ecx, DWORD PTR _si$61850[ebp]
  00cb3	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00cb6	8b 45 0c	 mov	 eax, DWORD PTR _thePoint$[ebp]
  00cb9	03 50 04	 add	 edx, DWORD PTR [eax+4]
  00cbc	8b 4d e8	 mov	 ecx, DWORD PTR _si$61850[ebp]
  00cbf	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 402  : 		AddScreenItem(si);

  00cc2	8b 55 e8	 mov	 edx, DWORD PTR _si$61850[ebp]
  00cc5	52		 push	 edx
  00cc6	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00cc9	e8 00 00 00 00	 call	 ?AddScreenItem@SOL_Plane@@QAEXPAVScreenItem@@@Z ; SOL_Plane::AddScreenItem

; 403  : 		si->SetCel(picCel);

  00cce	8b 45 e4	 mov	 eax, DWORD PTR _picCel$61844[ebp]
  00cd1	50		 push	 eax
  00cd2	8b 4d e8	 mov	 ecx, DWORD PTR _si$61850[ebp]
  00cd5	e8 00 00 00 00	 call	 ?SetCel@ScreenItem@@QAEXPAVCelObj@@@Z ; ScreenItem::SetCel

; 404  : 	}

  00cda	e9 b3 fe ff ff	 jmp	 $L61842
$L61843:

; 405  : 	return picResNum;

  00cdf	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00ce2	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]

; 406  : }

  00ce5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00ce8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00cef	8b e5		 mov	 esp, ebp
  00cf1	5d		 pop	 ebp
  00cf2	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
text$x	SEGMENT
$L62670:
  00062	8b 45 dc	 mov	 eax, DWORD PTR $T62661[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0006b	59		 pop	 ecx
  0006c	c3		 ret	 0
$L62671:
  0006d	8b 45 d4	 mov	 eax, DWORD PTR $T62665[ebp]
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00076	59		 pop	 ecx
  00077	c3		 ret	 0
$L62674:
  00078	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T62673
  0007d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?AddPic@SOL_Plane@@QAEHHABVSOL_Point@@HH@Z ENDP		; SOL_Plane::AddPic
PUBLIC	?AddCount@ScreenItem@@QBEHXZ			; ScreenItem::AddCount
PUBLIC	?SetUpdateCount@ScreenItem@@QAEXH@Z		; ScreenItem::SetUpdateCount
PUBLIC	?SetAddCount@ScreenItem@@QAEXH@Z		; ScreenItem::SetAddCount
PUBLIC	?SetDeleteCount@ScreenItem@@QAEXH@Z		; ScreenItem::SetDeleteCount
PUBLIC	?Length@ScreenItemList@@QBEHXZ			; ScreenItemList::Length
PUBLIC	?Exists@ScreenItemList@@QBEHH@Z			; ScreenItemList::Exists
PUBLIC	??AScreenItemList@@QAEAAVScreenItem@@H@Z	; ScreenItemList::operator[]
PUBLIC	?AbortScreenItem@SOL_Plane@@QAEXPBVScreenItem@@@Z ; SOL_Plane::AbortScreenItem
PUBLIC	?IsPic@Bitmap@@QBEHXZ				; Bitmap::IsPic
EXTRN	?Pack@ScreenItemList@@QAEXXZ:NEAR		; ScreenItemList::Pack
_TEXT	SEGMENT
_this$ = -12
_count$ = -4
_i$ = -8
?DeleteAllPics@SOL_Plane@@IAEXXZ PROC NEAR		; SOL_Plane::DeleteAllPics

; 411  : {

  00cf5	55		 push	 ebp
  00cf6	8b ec		 mov	 ebp, esp
  00cf8	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00cfb	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 412  : 	int count = siArray.Length();

  00cfe	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00d01	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00d04	e8 00 00 00 00	 call	 ?Length@ScreenItemList@@QBEHXZ ; ScreenItemList::Length
  00d09	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 413  : 	for (int i = 0; i < count; i++) {

  00d0c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00d13	eb 09		 jmp	 SHORT $L61863
$L61864:
  00d15	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00d18	83 c0 01	 add	 eax, 1
  00d1b	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L61863:
  00d1e	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00d21	3b 4d fc	 cmp	 ecx, DWORD PTR _count$[ebp]
  00d24	0f 8d c8 00 00
	00		 jge	 $L61865

; 414  : 		if (siArray.Exists(i))  {

  00d2a	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00d2d	52		 push	 edx
  00d2e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00d31	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00d34	e8 00 00 00 00	 call	 ?Exists@ScreenItemList@@QBEHH@Z ; ScreenItemList::Exists
  00d39	85 c0		 test	 eax, eax
  00d3b	0f 84 ac 00 00
	00		 je	 $L61869

; 415  : 			if (siArray[i].bitmap.IsPic()) {

  00d41	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00d44	50		 push	 eax
  00d45	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00d48	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00d4b	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  00d50	8b c8		 mov	 ecx, eax
  00d52	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00d55	e8 00 00 00 00	 call	 ?IsPic@Bitmap@@QBEHXZ	; Bitmap::IsPic
  00d5a	85 c0		 test	 eax, eax
  00d5c	0f 84 8b 00 00
	00		 je	 $L61869

; 416  : 				if (siArray[i].AddCount()) {

  00d62	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00d65	51		 push	 ecx
  00d66	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00d69	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00d6c	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  00d71	8b c8		 mov	 ecx, eax
  00d73	e8 00 00 00 00	 call	 ?AddCount@ScreenItem@@QBEHXZ ; ScreenItem::AddCount
  00d78	85 c0		 test	 eax, eax
  00d7a	74 1a		 je	 SHORT $L61868

; 417  : 					AbortScreenItem(&siArray[i]);

  00d7c	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00d7f	52		 push	 edx
  00d80	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00d83	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00d86	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  00d8b	50		 push	 eax
  00d8c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00d8f	e8 00 00 00 00	 call	 ?AbortScreenItem@SOL_Plane@@QAEXPBVScreenItem@@@Z ; SOL_Plane::AbortScreenItem

; 419  : 				else {

  00d94	eb 57		 jmp	 SHORT $L61869
$L61868:

; 420  : 					siArray[i].SetDeleteCount(graphMgr->ScreenCount());

  00d96	a1 00 00 00 00	 mov	 eax, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  00d9b	8b 10		 mov	 edx, DWORD PTR [eax]
  00d9d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  00da3	ff 52 04	 call	 DWORD PTR [edx+4]
  00da6	50		 push	 eax
  00da7	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00daa	50		 push	 eax
  00dab	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00dae	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00db1	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  00db6	8b c8		 mov	 ecx, eax
  00db8	e8 00 00 00 00	 call	 ?SetDeleteCount@ScreenItem@@QAEXH@Z ; ScreenItem::SetDeleteCount

; 421  : 					siArray[i].SetAddCount(0);

  00dbd	6a 00		 push	 0
  00dbf	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00dc2	51		 push	 ecx
  00dc3	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00dc6	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00dc9	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  00dce	8b c8		 mov	 ecx, eax
  00dd0	e8 00 00 00 00	 call	 ?SetAddCount@ScreenItem@@QAEXH@Z ; ScreenItem::SetAddCount

; 422  : 					siArray[i].SetUpdateCount(0);

  00dd5	6a 00		 push	 0
  00dd7	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00dda	52		 push	 edx
  00ddb	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00dde	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00de1	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  00de6	8b c8		 mov	 ecx, eax
  00de8	e8 00 00 00 00	 call	 ?SetUpdateCount@ScreenItem@@QAEXH@Z ; ScreenItem::SetUpdateCount
$L61869:

; 426  : 	}

  00ded	e9 23 ff ff ff	 jmp	 $L61864
$L61865:

; 427  : 	siArray.Pack();

  00df2	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00df5	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00df8	e8 00 00 00 00	 call	 ?Pack@ScreenItemList@@QAEXXZ ; ScreenItemList::Pack

; 428  : }

  00dfd	8b e5		 mov	 esp, ebp
  00dff	5d		 pop	 ebp
  00e00	c3		 ret	 0
?DeleteAllPics@SOL_Plane@@IAEXXZ ENDP			; SOL_Plane::DeleteAllPics
_TEXT	ENDS
;	COMDAT ?IsPic@Bitmap@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPic@Bitmap@@QBEHXZ PROC NEAR				; Bitmap::IsPic, COMDAT

; 134  : 	Bool	IsPic() const			{return type == tPic;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	83 38 01	 cmp	 DWORD PTR [eax], 1
  0000f	0f 94 c1	 sete	 cl
  00012	8b c1		 mov	 eax, ecx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?IsPic@Bitmap@@QBEHXZ ENDP				; Bitmap::IsPic
_TEXT	ENDS
;	COMDAT ?AddCount@ScreenItem@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?AddCount@ScreenItem@@QBEHXZ PROC NEAR			; ScreenItem::AddCount, COMDAT

; 72   : 	int			AddCount() const			{return addCount;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?AddCount@ScreenItem@@QBEHXZ ENDP			; ScreenItem::AddCount
_TEXT	ENDS
;	COMDAT ?SetUpdateCount@ScreenItem@@QAEXH@Z
_TEXT	SEGMENT
_val$ = 8
_this$ = -4
?SetUpdateCount@ScreenItem@@QAEXH@Z PROC NEAR		; ScreenItem::SetUpdateCount, COMDAT

; 94   : 	void			SetUpdateCount(int val)	{updateCount = val;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _val$[ebp]
  0000d	89 48 48	 mov	 DWORD PTR [eax+72], ecx
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetUpdateCount@ScreenItem@@QAEXH@Z ENDP		; ScreenItem::SetUpdateCount
_TEXT	ENDS
;	COMDAT ?SetAddCount@ScreenItem@@QAEXH@Z
_TEXT	SEGMENT
_val$ = 8
_this$ = -4
?SetAddCount@ScreenItem@@QAEXH@Z PROC NEAR		; ScreenItem::SetAddCount, COMDAT

; 95   : 	void			SetAddCount(int val)		{addCount = val;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _val$[ebp]
  0000d	89 48 4c	 mov	 DWORD PTR [eax+76], ecx
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetAddCount@ScreenItem@@QAEXH@Z ENDP			; ScreenItem::SetAddCount
_TEXT	ENDS
;	COMDAT ?SetDeleteCount@ScreenItem@@QAEXH@Z
_TEXT	SEGMENT
_val$ = 8
_this$ = -4
?SetDeleteCount@ScreenItem@@QAEXH@Z PROC NEAR		; ScreenItem::SetDeleteCount, COMDAT

; 96   : 	void			SetDeleteCount(int val)	{deleteCount = val;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _val$[ebp]
  0000d	89 48 50	 mov	 DWORD PTR [eax+80], ecx
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetDeleteCount@ScreenItem@@QAEXH@Z ENDP		; ScreenItem::SetDeleteCount
_TEXT	ENDS
;	COMDAT ?Length@ScreenItemList@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Length@ScreenItemList@@QBEHXZ PROC NEAR		; ScreenItemList::Length, COMDAT

; 20   : 	int	Length() const							{return length;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 80 40 9c 00
	00		 mov	 eax, DWORD PTR [eax+40000]
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?Length@ScreenItemList@@QBEHXZ ENDP			; ScreenItemList::Length
_TEXT	ENDS
;	COMDAT ?Exists@ScreenItemList@@QBEHH@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
?Exists@ScreenItemList@@QBEHH@Z PROC NEAR		; ScreenItemList::Exists, COMDAT

; 21   : 	Bool	Exists(int index) const				{return (index < length) && (siArray[index] != NULL);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  0000f	3b 88 40 9c 00
	00		 cmp	 ecx, DWORD PTR [eax+40000]
  00015	7d 15		 jge	 SHORT $L62684
  00017	8b 55 08	 mov	 edx, DWORD PTR _index$[ebp]
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 3c 90 00	 cmp	 DWORD PTR [eax+edx*4], 0
  00021	74 09		 je	 SHORT $L62684
  00023	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR -8+[ebp], 1
  0002a	eb 07		 jmp	 SHORT $L62685
$L62684:
  0002c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], 0
$L62685:
  00033	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
?Exists@ScreenItemList@@QBEHH@Z ENDP			; ScreenItemList::Exists
_TEXT	ENDS
;	COMDAT ??AScreenItemList@@QAEAAVScreenItem@@H@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
??AScreenItemList@@QAEAAVScreenItem@@H@Z PROC NEAR	; ScreenItemList::operator[], COMDAT

; 27   : 	ScreenItem& operator[](int index) 		{return *siArray[index];}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??AScreenItemList@@QAEAAVScreenItem@@H@Z ENDP		; ScreenItemList::operator[]
_TEXT	ENDS
PUBLIC	?DeletePic@SOL_Plane@@QAEXHH@Z			; SOL_Plane::DeletePic
_TEXT	SEGMENT
_oldPic$ = 8
_newPic$ = 12
_this$ = -4
?DeletePic@SOL_Plane@@QAEXHH@Z PROC NEAR		; SOL_Plane::DeletePic

; 432  : {

  00e01	55		 push	 ebp
  00e02	8b ec		 mov	 ebp, esp
  00e04	51		 push	 ecx
  00e05	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 433  : 	DeletePic(oldPic);

  00e08	8b 45 08	 mov	 eax, DWORD PTR _oldPic$[ebp]
  00e0b	50		 push	 eax
  00e0c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e0f	e8 00 00 00 00	 call	 ?DeletePic@SOL_Plane@@QAEXH@Z ; SOL_Plane::DeletePic

; 434  : 	picResNum = newPic;

  00e14	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e17	8b 55 0c	 mov	 edx, DWORD PTR _newPic$[ebp]
  00e1a	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 435  : }

  00e1d	8b e5		 mov	 esp, ebp
  00e1f	5d		 pop	 ebp
  00e20	c2 08 00	 ret	 8
?DeletePic@SOL_Plane@@QAEXHH@Z ENDP			; SOL_Plane::DeletePic
_TEXT	ENDS
PUBLIC	?PicResNum@ScreenItem@@QBEHXZ			; ScreenItem::PicResNum
_TEXT	SEGMENT
_picNumber$ = 8
_this$ = -12
_count$ = -4
_i$ = -8
?DeletePic@SOL_Plane@@QAEXH@Z PROC NEAR			; SOL_Plane::DeletePic

; 439  : {

  00e23	55		 push	 ebp
  00e24	8b ec		 mov	 ebp, esp
  00e26	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00e29	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 440  : 	int count = siArray.Length();

  00e2c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00e2f	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00e32	e8 00 00 00 00	 call	 ?Length@ScreenItemList@@QBEHXZ ; ScreenItemList::Length
  00e37	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 441  : 	for (int i = 0; i < count; i++) {

  00e3a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00e41	eb 09		 jmp	 SHORT $L61881
$L61882:
  00e43	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00e46	83 c0 01	 add	 eax, 1
  00e49	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L61881:
  00e4c	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00e4f	3b 4d fc	 cmp	 ecx, DWORD PTR _count$[ebp]
  00e52	0f 8d 8b 00 00
	00		 jge	 $L61883

; 442  : 		if (siArray.Exists(i))  {

  00e58	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00e5b	52		 push	 edx
  00e5c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00e5f	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00e62	e8 00 00 00 00	 call	 ?Exists@ScreenItemList@@QBEHH@Z ; ScreenItemList::Exists
  00e67	85 c0		 test	 eax, eax
  00e69	74 73		 je	 SHORT $L61885

; 443  : 			if (siArray[i].PicResNum() == picNumber) {

  00e6b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00e6e	50		 push	 eax
  00e6f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00e72	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00e75	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  00e7a	8b c8		 mov	 ecx, eax
  00e7c	e8 00 00 00 00	 call	 ?PicResNum@ScreenItem@@QBEHXZ ; ScreenItem::PicResNum
  00e81	3b 45 08	 cmp	 eax, DWORD PTR _picNumber$[ebp]
  00e84	75 58		 jne	 SHORT $L61885

; 444  : 				siArray[i].SetDeleteCount(graphMgr->ScreenCount());

  00e86	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  00e8c	8b 11		 mov	 edx, DWORD PTR [ecx]
  00e8e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  00e94	ff 52 04	 call	 DWORD PTR [edx+4]
  00e97	50		 push	 eax
  00e98	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00e9b	50		 push	 eax
  00e9c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00e9f	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00ea2	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  00ea7	8b c8		 mov	 ecx, eax
  00ea9	e8 00 00 00 00	 call	 ?SetDeleteCount@ScreenItem@@QAEXH@Z ; ScreenItem::SetDeleteCount

; 445  : 				siArray[i].SetAddCount(0);

  00eae	6a 00		 push	 0
  00eb0	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00eb3	51		 push	 ecx
  00eb4	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00eb7	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00eba	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  00ebf	8b c8		 mov	 ecx, eax
  00ec1	e8 00 00 00 00	 call	 ?SetAddCount@ScreenItem@@QAEXH@Z ; ScreenItem::SetAddCount

; 446  : 				siArray[i].SetUpdateCount(0);

  00ec6	6a 00		 push	 0
  00ec8	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00ecb	52		 push	 edx
  00ecc	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00ecf	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00ed2	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  00ed7	8b c8		 mov	 ecx, eax
  00ed9	e8 00 00 00 00	 call	 ?SetUpdateCount@ScreenItem@@QAEXH@Z ; ScreenItem::SetUpdateCount
$L61885:

; 449  : 	}

  00ede	e9 60 ff ff ff	 jmp	 $L61882
$L61883:

; 450  : }

  00ee3	8b e5		 mov	 esp, ebp
  00ee5	5d		 pop	 ebp
  00ee6	c2 04 00	 ret	 4
?DeletePic@SOL_Plane@@QAEXH@Z ENDP			; SOL_Plane::DeletePic
_TEXT	ENDS
;	COMDAT ?PicResNum@ScreenItem@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?PicResNum@ScreenItem@@QBEHXZ PROC NEAR			; ScreenItem::PicResNum, COMDAT

; 62   : 	int			PicResNum() const			{return picResNum;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?PicResNum@ScreenItem@@QBEHXZ ENDP			; ScreenItem::PicResNum
_TEXT	ENDS
PUBLIC	?DeleteCount@ScreenItem@@QBEHXZ			; ScreenItem::DeleteCount
PUBLIC	?ScrollScreenItems@SOL_Plane@@QAEXHHH@Z		; SOL_Plane::ScrollScreenItems
_TEXT	SEGMENT
_xStep$ = 8
_yStep$ = 12
_movePic$ = 16
_this$ = -12
_count$ = -4
_i$ = -8
?ScrollScreenItems@SOL_Plane@@QAEXHHH@Z PROC NEAR	; SOL_Plane::ScrollScreenItems

; 454  : {

  00ee9	55		 push	 ebp
  00eea	8b ec		 mov	 ebp, esp
  00eec	83 ec 14	 sub	 esp, 20			; 00000014H
  00eef	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 455  : 	redrawAllCount = graphMgr->ScreenCount();

  00ef2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  00ef7	8b 10		 mov	 edx, DWORD PTR [eax]
  00ef9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  00eff	ff 52 04	 call	 DWORD PTR [edx+4]
  00f02	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00f05	89 41 78	 mov	 DWORD PTR [ecx+120], eax

; 456  : 	int count = siArray.Length();

  00f08	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00f0b	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00f0e	e8 00 00 00 00	 call	 ?Length@ScreenItemList@@QBEHXZ ; ScreenItemList::Length
  00f13	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 457  : 	for (int i = 0; i < count; i++) {

  00f16	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00f1d	eb 09		 jmp	 SHORT $L61894
$L61895:
  00f1f	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00f22	83 c2 01	 add	 edx, 1
  00f25	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$L61894:
  00f28	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00f2b	3b 45 fc	 cmp	 eax, DWORD PTR _count$[ebp]
  00f2e	0f 8d 96 00 00
	00		 jge	 $L61896

; 458  : 		if (siArray.Exists(i))  {

  00f34	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00f37	51		 push	 ecx
  00f38	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00f3b	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00f3e	e8 00 00 00 00	 call	 ?Exists@ScreenItemList@@QBEHH@Z ; ScreenItemList::Exists
  00f43	85 c0		 test	 eax, eax
  00f45	74 7e		 je	 SHORT $L61898

; 460  : 				 (!siArray[i].bitmap.IsPic()	||	movePic)) {

  00f47	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00f4a	52		 push	 edx
  00f4b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00f4e	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00f51	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  00f56	8b c8		 mov	 ecx, eax
  00f58	e8 00 00 00 00	 call	 ?DeleteCount@ScreenItem@@QBEHXZ ; ScreenItem::DeleteCount
  00f5d	85 c0		 test	 eax, eax
  00f5f	75 64		 jne	 SHORT $L61898
  00f61	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00f64	50		 push	 eax
  00f65	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00f68	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00f6b	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  00f70	8b c8		 mov	 ecx, eax
  00f72	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00f75	e8 00 00 00 00	 call	 ?IsPic@Bitmap@@QBEHXZ	; Bitmap::IsPic
  00f7a	85 c0		 test	 eax, eax
  00f7c	74 06		 je	 SHORT $L61899
  00f7e	83 7d 10 00	 cmp	 DWORD PTR _movePic$[ebp], 0
  00f82	74 41		 je	 SHORT $L61898
$L61899:

; 461  : 				siArray[i].pos.x += xStep;

  00f84	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00f87	51		 push	 ecx
  00f88	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00f8b	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00f8e	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  00f93	89 45 f0	 mov	 DWORD PTR -16+[ebp], eax
  00f96	8b 55 f0	 mov	 edx, DWORD PTR -16+[ebp]
  00f99	8b 02		 mov	 eax, DWORD PTR [edx]
  00f9b	03 45 08	 add	 eax, DWORD PTR _xStep$[ebp]
  00f9e	8b 4d f0	 mov	 ecx, DWORD PTR -16+[ebp]
  00fa1	89 01		 mov	 DWORD PTR [ecx], eax

; 462  : 				siArray[i].pos.y += yStep;

  00fa3	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00fa6	52		 push	 edx
  00fa7	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00faa	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00fad	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  00fb2	83 c0 04	 add	 eax, 4
  00fb5	89 45 ec	 mov	 DWORD PTR -20+[ebp], eax
  00fb8	8b 45 ec	 mov	 eax, DWORD PTR -20+[ebp]
  00fbb	8b 08		 mov	 ecx, DWORD PTR [eax]
  00fbd	03 4d 0c	 add	 ecx, DWORD PTR _yStep$[ebp]
  00fc0	8b 55 ec	 mov	 edx, DWORD PTR -20+[ebp]
  00fc3	89 0a		 mov	 DWORD PTR [edx], ecx
$L61898:

; 465  : 	}

  00fc5	e9 55 ff ff ff	 jmp	 $L61895
$L61896:

; 466  : }

  00fca	8b e5		 mov	 esp, ebp
  00fcc	5d		 pop	 ebp
  00fcd	c2 0c 00	 ret	 12			; 0000000cH
?ScrollScreenItems@SOL_Plane@@QAEXHHH@Z ENDP		; SOL_Plane::ScrollScreenItems
_TEXT	ENDS
;	COMDAT ?DeleteCount@ScreenItem@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?DeleteCount@ScreenItem@@QBEHXZ PROC NEAR		; ScreenItem::DeleteCount, COMDAT

; 71   : 	int			DeleteCount() const		{return deleteCount;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?DeleteCount@ScreenItem@@QBEHXZ ENDP			; ScreenItem::DeleteCount
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4
?GetPicResolution@SOL_Plane@@IAEXXZ PROC NEAR		; SOL_Plane::GetPicResolution

; 470  : {

  00fd0	55		 push	 ebp
  00fd1	8b ec		 mov	 ebp, esp
  00fd3	51		 push	 ecx
  00fd4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 471  : 	picResX = SCIRESX;

  00fd7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00fda	c7 40 5c 80 02
	00 00		 mov	 DWORD PTR [eax+92], 640	; 00000280H

; 472  : 	picResY = SCIRESY;

  00fe1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00fe4	c7 41 60 e0 01
	00 00		 mov	 DWORD PTR [ecx+96], 480	; 000001e0H

; 473  : }

  00feb	8b e5		 mov	 esp, ebp
  00fed	5d		 pop	 ebp
  00fee	c3		 ret	 0
?GetPicResolution@SOL_Plane@@IAEXXZ ENDP		; SOL_Plane::GetPicResolution
_TEXT	ENDS
PUBLIC	?SetOnScreen@SOL_Plane@@QAEXABVSOL_Rect@@@Z	; SOL_Plane::SetOnScreen
_TEXT	SEGMENT
_r$ = 8
_this$ = -4
?SetOnScreen@SOL_Plane@@QAEXABVSOL_Rect@@@Z PROC NEAR	; SOL_Plane::SetOnScreen

; 477  : {

  00fef	55		 push	 ebp
  00ff0	8b ec		 mov	 ebp, esp
  00ff2	51		 push	 ecx
  00ff3	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 478  : 	onScreen = r;

  00ff6	8b 45 08	 mov	 eax, DWORD PTR _r$[ebp]
  00ff9	50		 push	 eax
  00ffa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ffd	83 c1 4c	 add	 ecx, 76			; 0000004cH
  01000	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 479  : }

  01005	8b e5		 mov	 esp, ebp
  01007	5d		 pop	 ebp
  01008	c2 04 00	 ret	 4
?SetOnScreen@SOL_Plane@@QAEXABVSOL_Rect@@@Z ENDP	; SOL_Plane::SetOnScreen
_TEXT	ENDS
PUBLIC	?Move@SOL_Plane@@QAEXABVSOL_Point@@@Z		; SOL_Plane::Move
PUBLIC	?MoveTo@SOL_Plane@@QAEXVSOL_Point@@@Z		; SOL_Plane::MoveTo
_TEXT	SEGMENT
_ul$ = 8
_this$ = -8
?Move@SOL_Plane@@QAEXABVSOL_Point@@@Z PROC NEAR		; SOL_Plane::Move

; 484  : {

  0100b	55		 push	 ebp
  0100c	8b ec		 mov	 ebp, esp
  0100e	83 ec 08	 sub	 esp, 8
  01011	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 485  : 	MoveTo(ul);

  01014	83 ec 08	 sub	 esp, 8
  01017	8b cc		 mov	 ecx, esp
  01019	8b 45 08	 mov	 eax, DWORD PTR _ul$[ebp]
  0101c	50		 push	 eax
  0101d	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  01022	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01025	e8 00 00 00 00	 call	 ?MoveTo@SOL_Plane@@QAEXVSOL_Point@@@Z ; SOL_Plane::MoveTo

; 486  : 	onScreen = plane;

  0102a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0102d	83 c1 64	 add	 ecx, 100		; 00000064H
  01030	51		 push	 ecx
  01031	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01034	83 c1 4c	 add	 ecx, 76			; 0000004cH
  01037	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 487  : }

  0103c	8b e5		 mov	 esp, ebp
  0103e	5d		 pop	 ebp
  0103f	c2 04 00	 ret	 4
?Move@SOL_Plane@@QAEXABVSOL_Point@@@Z ENDP		; SOL_Plane::Move
_TEXT	ENDS
PUBLIC	?MoveDelta@SOL_Plane@@QAEXHH@Z			; SOL_Plane::MoveDelta
PUBLIC	?Offset@SOL_Rect@@QAEXHH@Z			; SOL_Rect::Offset
_TEXT	SEGMENT
_deltaX$ = 8
_deltaY$ = 12
_this$ = -4
?MoveDelta@SOL_Plane@@QAEXHH@Z PROC NEAR		; SOL_Plane::MoveDelta

; 491  : {

  01042	55		 push	 ebp
  01043	8b ec		 mov	 ebp, esp
  01045	51		 push	 ecx
  01046	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 492  : 	gameRect.Offset(deltaX,deltaY);

  01049	8b 45 0c	 mov	 eax, DWORD PTR _deltaY$[ebp]
  0104c	50		 push	 eax
  0104d	8b 4d 08	 mov	 ecx, DWORD PTR _deltaX$[ebp]
  01050	51		 push	 ecx
  01051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01054	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01057	e8 00 00 00 00	 call	 ?Offset@SOL_Rect@@QAEXHH@Z ; SOL_Rect::Offset

; 493  : 	ConvGameRectToPlaneRect();

  0105c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0105f	e8 00 00 00 00	 call	 ?ConvGameRectToPlaneRect@SOL_Plane@@QAEXXZ ; SOL_Plane::ConvGameRectToPlaneRect

; 494  : 	// Mark as update
; 495  : 	deleteCount	= 0;

  01064	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01067	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], 0

; 496  : 	if (!addCount)

  0106e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01071	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0
  01075	75 1a		 jne	 SHORT $L61917

; 497  : 		updateCount = graphMgr->ScreenCount();

  01077	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  0107d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0107f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  01085	ff 52 04	 call	 DWORD PTR [edx+4]
  01088	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0108b	89 81 c0 9c 00
	00		 mov	 DWORD PTR [ecx+40128], eax
$L61917:

; 498  : }

  01091	8b e5		 mov	 esp, ebp
  01093	5d		 pop	 ebp
  01094	c2 08 00	 ret	 8
?MoveDelta@SOL_Plane@@QAEXHH@Z ENDP			; SOL_Plane::MoveDelta
_TEXT	ENDS
;	COMDAT ?Offset@SOL_Rect@@QAEXHH@Z
_TEXT	SEGMENT
_dx$ = 8
_dy$ = 12
_this$ = -4
?Offset@SOL_Rect@@QAEXHH@Z PROC NEAR			; SOL_Rect::Offset, COMDAT

; 317  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 318  : 	A.x += dx;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	03 4d 08	 add	 ecx, DWORD PTR _dx$[ebp]
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	89 0a		 mov	 DWORD PTR [edx], ecx

; 319  : 	B.x += dx;

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001a	03 4d 08	 add	 ecx, DWORD PTR _dx$[ebp]
  0001d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00020	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 320  : 	A.y += dy;

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00029	03 4d 0c	 add	 ecx, DWORD PTR _dy$[ebp]
  0002c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 321  : 	B.y += dy;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00038	03 4d 0c	 add	 ecx, DWORD PTR _dy$[ebp]
  0003b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 322  : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 08 00	 ret	 8
?Offset@SOL_Rect@@QAEXHH@Z ENDP				; SOL_Rect::Offset
_TEXT	ENDS
PUBLIC	??D@YAHHABVRatio@@@Z				; operator*
PUBLIC	?MoveTo@SOL_Rect@@QAEXHH@Z			; SOL_Rect::MoveTo
PUBLIC	??0Ratio@@QAE@HH@Z				; Ratio::Ratio
_TEXT	SEGMENT
_ul$ = 8
_this$ = -20
_scaleX$ = -16
_scaleY$ = -8
?MoveTo@SOL_Plane@@QAEXVSOL_Point@@@Z PROC NEAR		; SOL_Plane::MoveTo

; 502  : {

  01097	55		 push	 ebp
  01098	8b ec		 mov	 ebp, esp
  0109a	83 ec 14	 sub	 esp, 20			; 00000014H
  0109d	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 503  : 	Ratio scaleX(graphMgr->Xdim(), SCIRESX);

  010a0	68 80 02 00 00	 push	 640			; 00000280H
  010a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  010ab	e8 00 00 00 00	 call	 ?Xdim@GraphicsMgr@@QBEHXZ ; GraphicsMgr::Xdim
  010b0	50		 push	 eax
  010b1	8d 4d f0	 lea	 ecx, DWORD PTR _scaleX$[ebp]
  010b4	e8 00 00 00 00	 call	 ??0Ratio@@QAE@HH@Z	; Ratio::Ratio

; 504  : 	Ratio scaleY(graphMgr->Ydim(), SCIRESY);

  010b9	68 e0 01 00 00	 push	 480			; 000001e0H
  010be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  010c4	e8 00 00 00 00	 call	 ?Ydim@GraphicsMgr@@QBEHXZ ; GraphicsMgr::Ydim
  010c9	50		 push	 eax
  010ca	8d 4d f8	 lea	 ecx, DWORD PTR _scaleY$[ebp]
  010cd	e8 00 00 00 00	 call	 ??0Ratio@@QAE@HH@Z	; Ratio::Ratio

; 505  : 	ul.x = ul.x * scaleX;

  010d2	8d 45 f0	 lea	 eax, DWORD PTR _scaleX$[ebp]
  010d5	50		 push	 eax
  010d6	8b 4d 08	 mov	 ecx, DWORD PTR _ul$[ebp]
  010d9	51		 push	 ecx
  010da	e8 00 00 00 00	 call	 ??D@YAHHABVRatio@@@Z	; operator*
  010df	83 c4 08	 add	 esp, 8
  010e2	89 45 08	 mov	 DWORD PTR _ul$[ebp], eax

; 506  : 	ul.y = ul.y * scaleY;

  010e5	8d 55 f8	 lea	 edx, DWORD PTR _scaleY$[ebp]
  010e8	52		 push	 edx
  010e9	8b 45 0c	 mov	 eax, DWORD PTR _ul$[ebp+4]
  010ec	50		 push	 eax
  010ed	e8 00 00 00 00	 call	 ??D@YAHHABVRatio@@@Z	; operator*
  010f2	83 c4 08	 add	 esp, 8
  010f5	89 45 0c	 mov	 DWORD PTR _ul$[ebp+4], eax

; 507  : 	gameRect.MoveTo(ul.x,ul.y);

  010f8	8b 4d 0c	 mov	 ecx, DWORD PTR _ul$[ebp+4]
  010fb	51		 push	 ecx
  010fc	8b 55 08	 mov	 edx, DWORD PTR _ul$[ebp]
  010ff	52		 push	 edx
  01100	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01103	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01106	e8 00 00 00 00	 call	 ?MoveTo@SOL_Rect@@QAEXHH@Z ; SOL_Rect::MoveTo

; 508  : 	ConvGameRectToPlaneRect();

  0110b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0110e	e8 00 00 00 00	 call	 ?ConvGameRectToPlaneRect@SOL_Plane@@QAEXXZ ; SOL_Plane::ConvGameRectToPlaneRect

; 509  : 	// Mark as update
; 510  : 	deleteCount	= 0;

  01113	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  01116	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], 0

; 511  : 	if (!addCount)

  0111d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01120	83 79 30 00	 cmp	 DWORD PTR [ecx+48], 0
  01124	75 1a		 jne	 SHORT $L61924

; 512  : 		updateCount = graphMgr->ScreenCount();

  01126	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  0112c	8b 02		 mov	 eax, DWORD PTR [edx]
  0112e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  01134	ff 50 04	 call	 DWORD PTR [eax+4]
  01137	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0113a	89 81 c0 9c 00
	00		 mov	 DWORD PTR [ecx+40128], eax
$L61924:

; 513  : }

  01140	8b e5		 mov	 esp, ebp
  01142	5d		 pop	 ebp
  01143	c2 08 00	 ret	 8
?MoveTo@SOL_Plane@@QAEXVSOL_Point@@@Z ENDP		; SOL_Plane::MoveTo
_TEXT	ENDS
;	COMDAT ?MoveTo@SOL_Rect@@QAEXHH@Z
_TEXT	SEGMENT
_xa$ = 8
_ya$ = 12
_this$ = -4
?MoveTo@SOL_Rect@@QAEXHH@Z PROC NEAR			; SOL_Rect::MoveTo, COMDAT

; 295  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 296  : 	B.x += xa - A.x;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _xa$[ebp]
  0000d	2b 08		 sub	 ecx, DWORD PTR [eax]
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00015	03 c1		 add	 eax, ecx
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 297  : 	B.y += ya - A.y;

  0001d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00020	8b 45 0c	 mov	 eax, DWORD PTR _ya$[ebp]
  00023	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0002c	03 d0		 add	 edx, eax
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 298  : 	A.x = xa;

  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 55 08	 mov	 edx, DWORD PTR _xa$[ebp]
  0003a	89 11		 mov	 DWORD PTR [ecx], edx

; 299  : 	A.y = ya;

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	8b 4d 0c	 mov	 ecx, DWORD PTR _ya$[ebp]
  00042	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 300  : }

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 08 00	 ret	 8
?MoveTo@SOL_Rect@@QAEXHH@Z ENDP				; SOL_Rect::MoveTo
_TEXT	ENDS
;	COMDAT ??0Ratio@@QAE@HH@Z
_TEXT	SEGMENT
_num$ = 8
_denom$ = 12
_this$ = -4
??0Ratio@@QAE@HH@Z PROC NEAR				; Ratio::Ratio, COMDAT

; 9    : 	Ratio(int num, int denom)	:	numer(num), denom(denom) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _num$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _denom$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0Ratio@@QAE@HH@Z ENDP					; Ratio::Ratio
_TEXT	ENDS
;	COMDAT ??D@YAHHABVRatio@@@Z
_TEXT	SEGMENT
_i$ = 8
_ratio$ = 12
_total$ = -8
_val$ = -4
??D@YAHHABVRatio@@@Z PROC NEAR				; operator*, COMDAT

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 54   : 	int total = i * ratio.numer;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _ratio$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  0000c	0f af 08	 imul	 ecx, DWORD PTR [eax]
  0000f	89 4d f8	 mov	 DWORD PTR _total$[ebp], ecx

; 55   : 	int val = total / ratio.denom;

  00012	8b 4d 0c	 mov	 ecx, DWORD PTR _ratio$[ebp]
  00015	8b 45 f8	 mov	 eax, DWORD PTR _total$[ebp]
  00018	99		 cdq
  00019	f7 79 04	 idiv	 DWORD PTR [ecx+4]
  0001c	89 45 fc	 mov	 DWORD PTR _val$[ebp], eax

; 56   : 	if (total > ratio.denom  &&  total % ratio.denom)

  0001f	8b 55 0c	 mov	 edx, DWORD PTR _ratio$[ebp]
  00022	8b 45 f8	 mov	 eax, DWORD PTR _total$[ebp]
  00025	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00028	7e 17		 jle	 SHORT $L1043
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _ratio$[ebp]
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _total$[ebp]
  00030	99		 cdq
  00031	f7 79 04	 idiv	 DWORD PTR [ecx+4]
  00034	85 d2		 test	 edx, edx
  00036	74 09		 je	 SHORT $L1043

; 57   : 		val++;

  00038	8b 55 fc	 mov	 edx, DWORD PTR _val$[ebp]
  0003b	83 c2 01	 add	 edx, 1
  0003e	89 55 fc	 mov	 DWORD PTR _val$[ebp], edx
$L1043:

; 58   : 	return val;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _val$[ebp]

; 59   : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
??D@YAHHABVRatio@@@Z ENDP				; operator*
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -20
_scaleX$ = -16
_scaleY$ = -8
?ConvGameRectToPlaneRect@SOL_Plane@@QAEXXZ PROC NEAR	; SOL_Plane::ConvGameRectToPlaneRect

; 517  : {

  01146	55		 push	 ebp
  01147	8b ec		 mov	 ebp, esp
  01149	83 ec 14	 sub	 esp, 20			; 00000014H
  0114c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 518  : 	plane = gameRect;

  0114f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  01152	83 c0 0c	 add	 eax, 12			; 0000000cH
  01155	50		 push	 eax
  01156	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01159	83 c1 64	 add	 ecx, 100		; 00000064H
  0115c	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 519  : 	Ratio scaleX(graphMgr->Xdim(), SCIRESX);

  01161	68 80 02 00 00	 push	 640			; 00000280H
  01166	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  0116c	e8 00 00 00 00	 call	 ?Xdim@GraphicsMgr@@QBEHXZ ; GraphicsMgr::Xdim
  01171	50		 push	 eax
  01172	8d 4d f0	 lea	 ecx, DWORD PTR _scaleX$[ebp]
  01175	e8 00 00 00 00	 call	 ??0Ratio@@QAE@HH@Z	; Ratio::Ratio

; 520  : 	Ratio scaleY(graphMgr->Ydim(), SCIRESY);

  0117a	68 e0 01 00 00	 push	 480			; 000001e0H
  0117f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  01185	e8 00 00 00 00	 call	 ?Ydim@GraphicsMgr@@QBEHXZ ; GraphicsMgr::Ydim
  0118a	50		 push	 eax
  0118b	8d 4d f8	 lea	 ecx, DWORD PTR _scaleY$[ebp]
  0118e	e8 00 00 00 00	 call	 ??0Ratio@@QAE@HH@Z	; Ratio::Ratio

; 521  : 	plane.A.x = plane.A.x * scaleX;

  01193	8d 4d f0	 lea	 ecx, DWORD PTR _scaleX$[ebp]
  01196	51		 push	 ecx
  01197	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0119a	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  0119d	50		 push	 eax
  0119e	e8 00 00 00 00	 call	 ??D@YAHHABVRatio@@@Z	; operator*
  011a3	83 c4 08	 add	 esp, 8
  011a6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  011a9	89 41 64	 mov	 DWORD PTR [ecx+100], eax

; 522  : 	plane.A.y = plane.A.y * scaleY;

  011ac	8d 55 f8	 lea	 edx, DWORD PTR _scaleY$[ebp]
  011af	52		 push	 edx
  011b0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  011b3	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  011b6	51		 push	 ecx
  011b7	e8 00 00 00 00	 call	 ??D@YAHHABVRatio@@@Z	; operator*
  011bc	83 c4 08	 add	 esp, 8
  011bf	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  011c2	89 42 68	 mov	 DWORD PTR [edx+104], eax

; 523  : 	plane.B.x = ((plane.B.x + 1) * scaleX) - 1;

  011c5	8d 45 f0	 lea	 eax, DWORD PTR _scaleX$[ebp]
  011c8	50		 push	 eax
  011c9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  011cc	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  011cf	83 c2 01	 add	 edx, 1
  011d2	52		 push	 edx
  011d3	e8 00 00 00 00	 call	 ??D@YAHHABVRatio@@@Z	; operator*
  011d8	83 c4 08	 add	 esp, 8
  011db	83 e8 01	 sub	 eax, 1
  011de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  011e1	89 41 6c	 mov	 DWORD PTR [ecx+108], eax

; 524  : 	plane.B.y = ((plane.B.y + 1) * scaleY) - 1;

  011e4	8d 55 f8	 lea	 edx, DWORD PTR _scaleY$[ebp]
  011e7	52		 push	 edx
  011e8	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  011eb	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  011ee	83 c1 01	 add	 ecx, 1
  011f1	51		 push	 ecx
  011f2	e8 00 00 00 00	 call	 ??D@YAHHABVRatio@@@Z	; operator*
  011f7	83 c4 08	 add	 esp, 8
  011fa	83 e8 01	 sub	 eax, 1
  011fd	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  01200	89 42 70	 mov	 DWORD PTR [edx+112], eax

; 525  : }

  01203	8b e5		 mov	 esp, ebp
  01205	5d		 pop	 ebp
  01206	c3		 ret	 0
?ConvGameRectToPlaneRect@SOL_Plane@@QAEXXZ ENDP		; SOL_Plane::ConvGameRectToPlaneRect
_TEXT	ENDS
PUBLIC	?ResizePlane@SOL_Plane@@QAEXHH@Z		; SOL_Plane::ResizePlane
_TEXT	SEGMENT
_xdim$ = 8
_ydim$ = 12
_this$ = -4
?ResizePlane@SOL_Plane@@QAEXHH@Z PROC NEAR		; SOL_Plane::ResizePlane

; 529  : {

  01207	55		 push	 ebp
  01208	8b ec		 mov	 ebp, esp
  0120a	51		 push	 ecx
  0120b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 530  : 	gameRect.Set(gameRect.A.x,gameRect.A.y,gameRect.A.x + xdim - 1,gameRect.A.y + ydim - 1);

  0120e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01211	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  01214	8b 55 0c	 mov	 edx, DWORD PTR _ydim$[ebp]
  01217	8d 44 11 ff	 lea	 eax, DWORD PTR [ecx+edx-1]
  0121b	50		 push	 eax
  0121c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0121f	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  01222	8b 45 08	 mov	 eax, DWORD PTR _xdim$[ebp]
  01225	8d 4c 02 ff	 lea	 ecx, DWORD PTR [edx+eax-1]
  01229	51		 push	 ecx
  0122a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0122d	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  01230	50		 push	 eax
  01231	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01234	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  01237	52		 push	 edx
  01238	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0123b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0123e	e8 00 00 00 00	 call	 ?Set@SOL_Rect@@QAEXHHHH@Z ; SOL_Rect::Set

; 531  : 	ConvGameRectToPlaneRect();

  01243	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01246	e8 00 00 00 00	 call	 ?ConvGameRectToPlaneRect@SOL_Plane@@QAEXXZ ; SOL_Plane::ConvGameRectToPlaneRect

; 532  : 	onScreen = plane;

  0124b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0124e	83 c0 64	 add	 eax, 100		; 00000064H
  01251	50		 push	 eax
  01252	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01255	83 c1 4c	 add	 ecx, 76			; 0000004cH
  01258	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 533  : 	// Mark as update
; 534  : 	deleteCount	= 0;

  0125d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01260	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 535  : 	if (!addCount) {

  01267	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0126a	83 7a 30 00	 cmp	 DWORD PTR [edx+48], 0
  0126e	75 53		 jne	 SHORT $L61935

; 536  : 		if ((xdim > 0) || (ydim > 0))

  01270	83 7d 08 00	 cmp	 DWORD PTR _xdim$[ebp], 0
  01274	7f 06		 jg	 SHORT $L61937
  01276	83 7d 0c 00	 cmp	 DWORD PTR _ydim$[ebp], 0
  0127a	7e 16		 jle	 SHORT $L61936
$L61937:

; 537  : 			// Plane got larger in either x or y direction
; 538  : 			redrawAllCount = graphMgr->ScreenCount();

  0127c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  01281	8b 10		 mov	 edx, DWORD PTR [eax]
  01283	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  01289	ff 52 04	 call	 DWORD PTR [edx+4]
  0128c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0128f	89 41 78	 mov	 DWORD PTR [ecx+120], eax
$L61936:

; 539  : 		updateCount = graphMgr->ScreenCount();

  01292	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  01298	8b 02		 mov	 eax, DWORD PTR [edx]
  0129a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  012a0	ff 50 04	 call	 DWORD PTR [eax+4]
  012a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  012a6	89 81 c0 9c 00
	00		 mov	 DWORD PTR [ecx+40128], eax

; 540  : 		eraseCount = graphMgr->ScreenCount();

  012ac	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  012b2	8b 02		 mov	 eax, DWORD PTR [edx]
  012b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  012ba	ff 50 04	 call	 DWORD PTR [eax+4]
  012bd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  012c0	89 41 48	 mov	 DWORD PTR [ecx+72], eax
$L61935:

; 542  : 
; 543  : 	onScreen.Clip(graphMgr->NextScreen()->ScreenRect());

  012c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  012c9	e8 00 00 00 00	 call	 ?NextScreen@GraphicsMgr@@QAEPAVScreen@@XZ ; GraphicsMgr::NextScreen
  012ce	8b c8		 mov	 ecx, eax
  012d0	e8 00 00 00 00	 call	 ?ScreenRect@Screen@@QBEABVSOL_Rect@@XZ ; Screen::ScreenRect
  012d5	50		 push	 eax
  012d6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  012d9	83 c1 4c	 add	 ecx, 76			; 0000004cH
  012dc	e8 00 00 00 00	 call	 ?Clip@SOL_Rect@@QAEXABV1@@Z ; SOL_Rect::Clip

; 544  : }

  012e1	8b e5		 mov	 esp, ebp
  012e3	5d		 pop	 ebp
  012e4	c2 08 00	 ret	 8
?ResizePlane@SOL_Plane@@QAEXHH@Z ENDP			; SOL_Plane::ResizePlane
_TEXT	ENDS
EXTRN	?Add@ScreenItemList@@QAEHPAVScreenItem@@@Z:NEAR	; ScreenItemList::Add
_TEXT	SEGMENT
_si$ = 8
_this$ = -4
?AddScreenItem@SOL_Plane@@QAEXPAVScreenItem@@@Z PROC NEAR ; SOL_Plane::AddScreenItem

; 548  : {

  012e7	55		 push	 ebp
  012e8	8b ec		 mov	 ebp, esp
  012ea	51		 push	 ecx
  012eb	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 549  : 	siArray.Add(si);

  012ee	8b 45 08	 mov	 eax, DWORD PTR _si$[ebp]
  012f1	50		 push	 eax
  012f2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  012f5	83 c1 7c	 add	 ecx, 124		; 0000007cH
  012f8	e8 00 00 00 00	 call	 ?Add@ScreenItemList@@QAEHPAVScreenItem@@@Z ; ScreenItemList::Add

; 550  : }

  012fd	8b e5		 mov	 esp, ebp
  012ff	5d		 pop	 ebp
  01300	c2 04 00	 ret	 4
?AddScreenItem@SOL_Plane@@QAEXPAVScreenItem@@@Z ENDP	; SOL_Plane::AddScreenItem
_TEXT	ENDS
EXTRN	?Delete@ScreenItemList@@QAEXPBVScreenItem@@@Z:NEAR ; ScreenItemList::Delete
_TEXT	SEGMENT
_si$ = 8
_this$ = -4
?AbortScreenItem@SOL_Plane@@QAEXPBVScreenItem@@@Z PROC NEAR ; SOL_Plane::AbortScreenItem

; 554  : {

  01303	55		 push	 ebp
  01304	8b ec		 mov	 ebp, esp
  01306	51		 push	 ecx
  01307	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 555  : 	siArray.Delete(si);

  0130a	8b 45 08	 mov	 eax, DWORD PTR _si$[ebp]
  0130d	50		 push	 eax
  0130e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01311	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01314	e8 00 00 00 00	 call	 ?Delete@ScreenItemList@@QAEXPBVScreenItem@@@Z ; ScreenItemList::Delete

; 556  : }

  01319	8b e5		 mov	 esp, ebp
  0131b	5d		 pop	 ebp
  0131c	c2 04 00	 ret	 4
?AbortScreenItem@SOL_Plane@@QAEXPBVScreenItem@@@Z ENDP	; SOL_Plane::AbortScreenItem
_TEXT	ENDS
PUBLIC	??AScreenItemList@@QBEABVScreenItem@@H@Z	; ScreenItemList::operator[]
PUBLIC	?TopScreenItem@SOL_Plane@@QBEHXZ		; SOL_Plane::TopScreenItem
PUBLIC	?FixedPri@ScreenItem@@QBEHXZ			; ScreenItem::FixedPri
PUBLIC	?Priority@ScreenItem@@QBEHXZ			; ScreenItem::Priority
_TEXT	SEGMENT
_this$ = -20
_thisPri$ = -4
_topPri$ = -12
_length$ = -8
_i$ = -16
?TopScreenItem@SOL_Plane@@QBEHXZ PROC NEAR		; SOL_Plane::TopScreenItem

; 560  : {

  0131f	55		 push	 ebp
  01320	8b ec		 mov	 ebp, esp
  01322	83 ec 14	 sub	 esp, 20			; 00000014H
  01325	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 561  : 	int thisPri;
; 562  : 	int topPri = -100000;

  01328	c7 45 f4 60 79
	fe ff		 mov	 DWORD PTR _topPri$[ebp], -100000 ; fffe7960H

; 563  : 	int length = siArray.Length();

  0132f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01332	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01335	e8 00 00 00 00	 call	 ?Length@ScreenItemList@@QBEHXZ ; ScreenItemList::Length
  0133a	89 45 f8	 mov	 DWORD PTR _length$[ebp], eax

; 564  : 	for (int i = 0;i < length;i++) {

  0133d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  01344	eb 09		 jmp	 SHORT $L61953
$L61954:
  01346	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  01349	83 c0 01	 add	 eax, 1
  0134c	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$L61953:
  0134f	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  01352	3b 4d f8	 cmp	 ecx, DWORD PTR _length$[ebp]
  01355	7d 7e		 jge	 SHORT $L61955

; 565  : 		if (siArray.Exists(i)) {

  01357	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  0135a	52		 push	 edx
  0135b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0135e	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01361	e8 00 00 00 00	 call	 ?Exists@ScreenItemList@@QBEHH@Z ; ScreenItemList::Exists
  01366	85 c0		 test	 eax, eax
  01368	74 66		 je	 SHORT $L61960

; 566  : 			if (siArray[i].FixedPri()) {

  0136a	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0136d	50		 push	 eax
  0136e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01371	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01374	e8 00 00 00 00	 call	 ??AScreenItemList@@QBEABVScreenItem@@H@Z ; ScreenItemList::operator[]
  01379	8b c8		 mov	 ecx, eax
  0137b	e8 00 00 00 00	 call	 ?FixedPri@ScreenItem@@QBEHXZ ; ScreenItem::FixedPri
  01380	85 c0		 test	 eax, eax
  01382	74 29		 je	 SHORT $L61957

; 567  : 				if ((thisPri = siArray[i].Priority()) > topPri)

  01384	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  01387	51		 push	 ecx
  01388	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0138b	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0138e	e8 00 00 00 00	 call	 ??AScreenItemList@@QBEABVScreenItem@@H@Z ; ScreenItemList::operator[]
  01393	8b c8		 mov	 ecx, eax
  01395	e8 00 00 00 00	 call	 ?Priority@ScreenItem@@QBEHXZ ; ScreenItem::Priority
  0139a	89 45 fc	 mov	 DWORD PTR _thisPri$[ebp], eax
  0139d	8b 55 fc	 mov	 edx, DWORD PTR _thisPri$[ebp]
  013a0	3b 55 f4	 cmp	 edx, DWORD PTR _topPri$[ebp]
  013a3	7e 06		 jle	 SHORT $L61958

; 568  : 					topPri = thisPri;

  013a5	8b 45 fc	 mov	 eax, DWORD PTR _thisPri$[ebp]
  013a8	89 45 f4	 mov	 DWORD PTR _topPri$[ebp], eax
$L61958:

; 570  : 			else {

  013ab	eb 23		 jmp	 SHORT $L61960
$L61957:

; 571  : 				if ((thisPri = siArray[i].pos.y) > topPri)

  013ad	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  013b0	51		 push	 ecx
  013b1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  013b4	83 c1 7c	 add	 ecx, 124		; 0000007cH
  013b7	e8 00 00 00 00	 call	 ??AScreenItemList@@QBEABVScreenItem@@H@Z ; ScreenItemList::operator[]
  013bc	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  013bf	89 55 fc	 mov	 DWORD PTR _thisPri$[ebp], edx
  013c2	8b 45 fc	 mov	 eax, DWORD PTR _thisPri$[ebp]
  013c5	3b 45 f4	 cmp	 eax, DWORD PTR _topPri$[ebp]
  013c8	7e 06		 jle	 SHORT $L61960

; 572  : 					topPri = thisPri;

  013ca	8b 4d fc	 mov	 ecx, DWORD PTR _thisPri$[ebp]
  013cd	89 4d f4	 mov	 DWORD PTR _topPri$[ebp], ecx
$L61960:

; 575  : 	}

  013d0	e9 71 ff ff ff	 jmp	 $L61954
$L61955:

; 576  : 	return topPri;

  013d5	8b 45 f4	 mov	 eax, DWORD PTR _topPri$[ebp]

; 577  : }

  013d8	8b e5		 mov	 esp, ebp
  013da	5d		 pop	 ebp
  013db	c3		 ret	 0
?TopScreenItem@SOL_Plane@@QBEHXZ ENDP			; SOL_Plane::TopScreenItem
_TEXT	ENDS
;	COMDAT ?FixedPri@ScreenItem@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?FixedPri@ScreenItem@@QBEHXZ PROC NEAR			; ScreenItem::FixedPri, COMDAT

; 60   : 	Bool			FixedPri() const			{return fixedPriFlag;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 44	 mov	 eax, DWORD PTR [eax+68]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?FixedPri@ScreenItem@@QBEHXZ ENDP			; ScreenItem::FixedPri
_TEXT	ENDS
;	COMDAT ?Priority@ScreenItem@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Priority@ScreenItem@@QBEHXZ PROC NEAR			; ScreenItem::Priority, COMDAT

; 64   : 	int			Priority() const			{return priority;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 40	 mov	 eax, DWORD PTR [eax+64]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Priority@ScreenItem@@QBEHXZ ENDP			; ScreenItem::Priority
_TEXT	ENDS
;	COMDAT ??AScreenItemList@@QBEABVScreenItem@@H@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
??AScreenItemList@@QBEABVScreenItem@@H@Z PROC NEAR	; ScreenItemList::operator[], COMDAT

; 24   : 	const ScreenItem& operator[](int index) const 		{return *siArray[index];}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??AScreenItemList@@QBEABVScreenItem@@H@Z ENDP		; ScreenItemList::operator[]
_TEXT	ENDS
PUBLIC	?NowSeen@SOL_Plane@@QAEHVMemID@@AAVSOL_Rect@@@Z	; SOL_Plane::NowSeen
EXTRN	?NowSeen@ScreenItem@@QAEXABVSOL_Plane@@AAVSOL_Rect@@@Z:NEAR ; ScreenItem::NowSeen
EXTRN	?Search@ScreenItemList@@QBEHJ@Z:NEAR		; ScreenItemList::Search
_TEXT	SEGMENT
_id$ = 8
_nowSeen$ = 12
_this$ = -8
_index$ = -4
?NowSeen@SOL_Plane@@QAEHVMemID@@AAVSOL_Rect@@@Z PROC NEAR ; SOL_Plane::NowSeen

; 581  : {

  013dc	55		 push	 ebp
  013dd	8b ec		 mov	 ebp, esp
  013df	83 ec 08	 sub	 esp, 8
  013e2	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 582  : 	int index = siArray.Search(id);

  013e5	8d 4d 08	 lea	 ecx, DWORD PTR _id$[ebp]
  013e8	e8 00 00 00 00	 call	 ??BMemID@@QBEGXZ	; MemID::operator unsigned short
  013ed	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  013f2	50		 push	 eax
  013f3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  013f6	83 c1 7c	 add	 ecx, 124		; 0000007cH
  013f9	e8 00 00 00 00	 call	 ?Search@ScreenItemList@@QBEHJ@Z ; ScreenItemList::Search
  013fe	89 45 fc	 mov	 DWORD PTR _index$[ebp], eax

; 583  : 	if (index != -1) {

  01401	83 7d fc ff	 cmp	 DWORD PTR _index$[ebp], -1
  01405	74 25		 je	 SHORT $L61967

; 584  : 		siArray[index].NowSeen(*this,nowSeen);

  01407	8b 45 0c	 mov	 eax, DWORD PTR _nowSeen$[ebp]
  0140a	50		 push	 eax
  0140b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0140e	51		 push	 ecx
  0140f	8b 55 fc	 mov	 edx, DWORD PTR _index$[ebp]
  01412	52		 push	 edx
  01413	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01416	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01419	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  0141e	8b c8		 mov	 ecx, eax
  01420	e8 00 00 00 00	 call	 ?NowSeen@ScreenItem@@QAEXABVSOL_Plane@@AAVSOL_Rect@@@Z ; ScreenItem::NowSeen

; 585  : 		return True;

  01425	b8 01 00 00 00	 mov	 eax, 1
  0142a	eb 02		 jmp	 SHORT $L61965
$L61967:

; 587  : 	return False;

  0142c	33 c0		 xor	 eax, eax
$L61965:

; 588  : }

  0142e	8b e5		 mov	 esp, ebp
  01430	5d		 pop	 ebp
  01431	c2 08 00	 ret	 8
?NowSeen@SOL_Plane@@QAEHVMemID@@AAVSOL_Rect@@@Z ENDP	; SOL_Plane::NowSeen
_TEXT	ENDS
PUBLIC	?UpdateCount@ScreenItem@@QBEHXZ			; ScreenItem::UpdateCount
PUBLIC	?DoUpdate@ScreenItem@@QAEXABVSOL_Plane@@@Z	; ScreenItem::DoUpdate
PUBLIC	?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ	; ScreenItem::OnScreen
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
PUBLIC	?Length@RectList@@QBEHXZ			; RectList::Length
PUBLIC	??ARectList@@QAEAAVSOL_Rect@@H@Z		; RectList::operator[]
PUBLIC	?OnScreen@DrawItem@@QAEAAVSOL_Rect@@XZ		; DrawItem::OnScreen
PUBLIC	?SI@DrawItem@@QAEAAVScreenItem@@XZ		; DrawItem::SI
PUBLIC	?Length@DrawList@@QBEHXZ			; DrawList::Length
PUBLIC	?Exists@DrawList@@QBEHH@Z			; DrawList::Exists
PUBLIC	??ADrawList@@QAEAAVDrawItem@@H@Z		; DrawList::operator[]
PUBLIC	?CalcLists@SOL_Plane@@QAEXPAV1@AAVPlaneList@@AAVDrawList@@AAVRectList@@@Z ; SOL_Plane::CalcLists
PUBLIC	?Cel@Bitmap@@QBEHXZ				; Bitmap::Cel
PUBLIC	?SIList@SOL_Plane@@QAEAAVScreenItemList@@XZ	; SOL_Plane::SIList
PUBLIC	?CheckIntegrity@SOL_Plane@@QAEXXZ		; SOL_Plane::CheckIntegrity
PUBLIC	?BreakDrawListByPlanes@SOL_Plane@@IAEXAAVDrawList@@AAVPlaneList@@@Z ; SOL_Plane::BreakDrawListByPlanes
PUBLIC	?BreakEraseListByPlanes@SOL_Plane@@IAEXAAVRectList@@AAVPlaneList@@@Z ; SOL_Plane::BreakEraseListByPlanes
PUBLIC	?DecSIArrayCounts@SOL_Plane@@IAEXPAV1@H@Z	; SOL_Plane::DecSIArrayCounts
PUBLIC	?MergeToRectList@@YAXABVSOL_Rect@@AAVRectList@@@Z ; MergeToRectList
PUBLIC	?IsEmpty@SOL_Rect@@QBEHXZ			; SOL_Rect::IsEmpty
PUBLIC	?Both@SOL_Rect@@QAEXABV1@@Z			; SOL_Rect::Both
PUBLIC	??0SOL_Rect@@QAE@ABV0@@Z			; SOL_Rect::SOL_Rect
PUBLIC	?Id@ScreenItem@@QBEJXZ				; ScreenItem::Id
EXTRN	?Add@RectList@@QAEXABVSOL_Rect@@@Z:NEAR		; RectList::Add
EXTRN	?Sort@ScreenItemList@@QAEXXZ:NEAR		; ScreenItemList::Sort
EXTRN	?Unsort@ScreenItemList@@QAEXXZ:NEAR		; ScreenItemList::Unsort
EXTRN	?remapCount@Remap@@2IA:DWORD			; Remap::remapCount
EXTRN	?Add@DrawList@@QAEHPAVScreenItem@@AAVSOL_Rect@@@Z:NEAR ; DrawList::Add
EXTRN	?Intersect@SOL_Rect@@QBEHABV1@PAV1@@Z:NEAR	; SOL_Rect::Intersect
_TEXT	SEGMENT
$T62712 = -116
$T62713 = -132
_last$ = 8
_nextPlanesList$ = 12
_drawList$ = 16
_eraseList$ = 20
_this$ = -136
_lastList$ = -20
_siArraySize$ = -12
_rects$ = -92
_i$ = -24
_drawListSize$ = -4
_pictureDrawn$ = -28
_screenItemDrawn$ = -8
_eraseListSize$ = -16
_j$62014 = -96
_j$62034 = -100
?CalcLists@SOL_Plane@@QAEXPAV1@AAVPlaneList@@AAVDrawList@@AAVRectList@@@Z PROC NEAR ; SOL_Plane::CalcLists

; 592  : {

  01434	55		 push	 ebp
  01435	8b ec		 mov	 ebp, esp
  01437	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  0143d	56		 push	 esi
  0143e	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 593  : 	//	Create the first entries into the eraseList and drawlist based
; 594  : 	//	upon screenItems that where added, updated or deleted.
; 595  : 
; 596  : 	// Note
; 597  : 	// There is an assumption in this routine that
; 598  : 	// siArray in the next screen is in sync with
; 599  : 	// it's counterpart in the last screen
; 600  : 
; 601  : 	ScreenItemList& lastList = last->SIList();

  01444	8b 4d 08	 mov	 ecx, DWORD PTR _last$[ebp]
  01447	e8 00 00 00 00	 call	 ?SIList@SOL_Plane@@QAEAAVScreenItemList@@XZ ; SOL_Plane::SIList
  0144c	89 45 ec	 mov	 DWORD PTR _lastList$[ebp], eax

; 602  : 
; 603  : 	int siArraySize = siArray.Length();

  0144f	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01455	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01458	e8 00 00 00 00	 call	 ?Length@ScreenItemList@@QBEHXZ ; ScreenItemList::Length
  0145d	89 45 f4	 mov	 DWORD PTR _siArraySize$[ebp], eax

; 604  : 	SOL_Rect rects[4];

  01460	68 00 00 00 00	 push	 OFFSET FLAT:??0SOL_Rect@@QAE@XZ ; SOL_Rect::SOL_Rect
  01465	6a 04		 push	 4
  01467	6a 10		 push	 16			; 00000010H
  01469	8d 45 a4	 lea	 eax, DWORD PTR _rects$[ebp]
  0146c	50		 push	 eax
  0146d	e8 00 00 00 00	 call	 ??_H@YGXPAXIHP6EX0@Z@Z	; `vector constructor iterator'

; 605  : 	int i;
; 606  : 	// Any screenItem marked Deleted add to the eraseList.
; 607  : 	// Any screenItem marked Added add to the drawList.
; 608  : 	// Any screenItem marked Updated add to the eraseList and the drawList.
; 609  : 
; 610  : 	CheckIntegrity();

  01472	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01478	e8 00 00 00 00	 call	 ?CheckIntegrity@SOL_Plane@@QAEXXZ ; SOL_Plane::CheckIntegrity

; 611  : 
; 612  : 	for (i=0;i<siArraySize;++i) {

  0147d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  01484	eb 09		 jmp	 SHORT $L61980
$L61981:
  01486	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  01489	83 c1 01	 add	 ecx, 1
  0148c	89 4d e8	 mov	 DWORD PTR _i$[ebp], ecx
$L61980:
  0148f	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  01492	3b 55 f4	 cmp	 edx, DWORD PTR _siArraySize$[ebp]
  01495	0f 8d b9 04 00
	00		 jge	 $L61982

; 613  : 		if (siArray.Exists(i)) {

  0149b	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  0149e	50		 push	 eax
  0149f	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  014a5	83 c1 7c	 add	 ecx, 124		; 0000007cH
  014a8	e8 00 00 00 00	 call	 ?Exists@ScreenItemList@@QBEHH@Z ; ScreenItemList::Exists
  014ad	85 c0		 test	 eax, eax
  014af	0f 84 9a 04 00
	00		 je	 $L62006

; 614  : 			if (siArray[i].DeleteCount())	{

  014b5	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  014b8	51		 push	 ecx
  014b9	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  014bf	83 c1 7c	 add	 ecx, 124		; 0000007cH
  014c2	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  014c7	8b c8		 mov	 ecx, eax
  014c9	e8 00 00 00 00	 call	 ?DeleteCount@ScreenItem@@QBEHXZ ; ScreenItem::DeleteCount
  014ce	85 c0		 test	 eax, eax
  014d0	74 7a		 je	 SHORT $L61984

; 615  : 				// Add to the eraseList if it was visable in the lastList.
; 616  : 				if (lastList.Exists(i)  &&  !lastList[i].OnScreen().IsEmpty()) {

  014d2	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  014d5	52		 push	 edx
  014d6	8b 4d ec	 mov	 ecx, DWORD PTR _lastList$[ebp]
  014d9	e8 00 00 00 00	 call	 ?Exists@ScreenItemList@@QBEHH@Z ; ScreenItemList::Exists
  014de	85 c0		 test	 eax, eax
  014e0	74 65		 je	 SHORT $L61987
  014e2	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  014e5	50		 push	 eax
  014e6	8b 4d ec	 mov	 ecx, DWORD PTR _lastList$[ebp]
  014e9	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  014ee	8b c8		 mov	 ecx, eax
  014f0	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  014f5	8b c8		 mov	 ecx, eax
  014f7	e8 00 00 00 00	 call	 ?IsEmpty@SOL_Rect@@QBEHXZ ; SOL_Rect::IsEmpty
  014fc	85 c0		 test	 eax, eax
  014fe	75 47		 jne	 SHORT $L61987

; 617  : 					if (Remap::remapCount)

  01500	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?remapCount@Remap@@2IA, 0 ; Remap::remapCount
  01507	74 22		 je	 SHORT $L61986

; 618  : 						MergeToRectList(lastList[i].OnScreen(),eraseList);

  01509	8b 4d 14	 mov	 ecx, DWORD PTR _eraseList$[ebp]
  0150c	51		 push	 ecx
  0150d	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  01510	52		 push	 edx
  01511	8b 4d ec	 mov	 ecx, DWORD PTR _lastList$[ebp]
  01514	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01519	8b c8		 mov	 ecx, eax
  0151b	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  01520	50		 push	 eax
  01521	e8 00 00 00 00	 call	 ?MergeToRectList@@YAXABVSOL_Rect@@AAVRectList@@@Z ; MergeToRectList
  01526	83 c4 08	 add	 esp, 8

; 619  : 					else

  01529	eb 1c		 jmp	 SHORT $L61987
$L61986:

; 620  : 						eraseList.Add(lastList[i].OnScreen());

  0152b	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  0152e	50		 push	 eax
  0152f	8b 4d ec	 mov	 ecx, DWORD PTR _lastList$[ebp]
  01532	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01537	8b c8		 mov	 ecx, eax
  01539	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  0153e	50		 push	 eax
  0153f	8b 4d 14	 mov	 ecx, DWORD PTR _eraseList$[ebp]
  01542	e8 00 00 00 00	 call	 ?Add@RectList@@QAEXABVSOL_Rect@@@Z ; RectList::Add
$L61987:

; 623  : 			else if (siArray[i].AddCount())	{

  01547	e9 03 04 00 00	 jmp	 $L62006
$L61984:
  0154c	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  0154f	51		 push	 ecx
  01550	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01556	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01559	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  0155e	8b c8		 mov	 ecx, eax
  01560	e8 00 00 00 00	 call	 ?AddCount@ScreenItem@@QBEHXZ ; ScreenItem::AddCount
  01565	85 c0		 test	 eax, eax
  01567	0f 84 f1 00 00
	00		 je	 $L61989

; 624  : 				// Update the screenItem
; 625  : 				siArray[i].DoUpdate(*this);

  0156d	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  01573	52		 push	 edx
  01574	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  01577	50		 push	 eax
  01578	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0157e	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01581	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01586	8b c8		 mov	 ecx, eax
  01588	e8 00 00 00 00	 call	 ?DoUpdate@ScreenItem@@QAEXABVSOL_Plane@@@Z ; ScreenItem::DoUpdate

; 626  : 
; 627  : 				// Add to the drawList if visable.
; 628  : 				if (!siArray[i].OnScreen().IsEmpty()) {

  0158d	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  01590	51		 push	 ecx
  01591	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01597	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0159a	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  0159f	8b c8		 mov	 ecx, eax
  015a1	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  015a6	8b c8		 mov	 ecx, eax
  015a8	e8 00 00 00 00	 call	 ?IsEmpty@SOL_Rect@@QBEHXZ ; SOL_Rect::IsEmpty
  015ad	85 c0		 test	 eax, eax
  015af	0f 85 a4 00 00
	00		 jne	 $L61994

; 629  : 					if (Remap::remapCount) {

  015b5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?remapCount@Remap@@2IA, 0 ; Remap::remapCount
  015bc	74 66		 je	 SHORT $L61991

; 630  : 					   drawList.Add(&siArray[i],siArray[i].OnScreen());

  015be	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  015c1	52		 push	 edx
  015c2	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  015c8	83 c1 7c	 add	 ecx, 124		; 0000007cH
  015cb	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  015d0	8b c8		 mov	 ecx, eax
  015d2	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  015d7	50		 push	 eax
  015d8	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  015db	50		 push	 eax
  015dc	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  015e2	83 c1 7c	 add	 ecx, 124		; 0000007cH
  015e5	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  015ea	50		 push	 eax
  015eb	8b 4d 10	 mov	 ecx, DWORD PTR _drawList$[ebp]
  015ee	e8 00 00 00 00	 call	 ?Add@DrawList@@QAEHPAVScreenItem@@AAVSOL_Rect@@@Z ; DrawList::Add

; 631  : 						MergeToRectList((SOL_Rect)(siArray[i].OnScreen()),eraseList);

  015f3	8b 4d 14	 mov	 ecx, DWORD PTR _eraseList$[ebp]
  015f6	51		 push	 ecx
  015f7	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  015fa	52		 push	 edx
  015fb	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01601	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01604	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01609	8b c8		 mov	 ecx, eax
  0160b	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  01610	50		 push	 eax
  01611	8d 4d 8c	 lea	 ecx, DWORD PTR $T62712[ebp]
  01614	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@ABV0@@Z ; SOL_Rect::SOL_Rect
  01619	50		 push	 eax
  0161a	e8 00 00 00 00	 call	 ?MergeToRectList@@YAXABVSOL_Rect@@AAVRectList@@@Z ; MergeToRectList
  0161f	83 c4 08	 add	 esp, 8

; 632  : 					} else

  01622	eb 35		 jmp	 SHORT $L61994
$L61991:

; 633  : 					   drawList.Add(&siArray[i],siArray[i].OnScreen());

  01624	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  01627	50		 push	 eax
  01628	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0162e	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01631	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01636	8b c8		 mov	 ecx, eax
  01638	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  0163d	50		 push	 eax
  0163e	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  01641	51		 push	 ecx
  01642	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01648	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0164b	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01650	50		 push	 eax
  01651	8b 4d 10	 mov	 ecx, DWORD PTR _drawList$[ebp]
  01654	e8 00 00 00 00	 call	 ?Add@DrawList@@QAEHPAVScreenItem@@AAVSOL_Rect@@@Z ; DrawList::Add
$L61994:

; 636  : 			else if (siArray[i].UpdateCount()) {

  01659	e9 f1 02 00 00	 jmp	 $L62006
$L61989:
  0165e	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  01661	52		 push	 edx
  01662	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01668	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0166b	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01670	8b c8		 mov	 ecx, eax
  01672	e8 00 00 00 00	 call	 ?UpdateCount@ScreenItem@@QBEHXZ ; ScreenItem::UpdateCount
  01677	85 c0		 test	 eax, eax
  01679	0f 84 d0 02 00
	00		 je	 $L62006

; 637  : 				// Update the screenItem
; 638  : 				siArray[i].DoUpdate(*this);

  0167f	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01685	50		 push	 eax
  01686	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  01689	51		 push	 ecx
  0168a	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01690	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01693	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01698	8b c8		 mov	 ecx, eax
  0169a	e8 00 00 00 00	 call	 ?DoUpdate@ScreenItem@@QAEXABVSOL_Plane@@@Z ; ScreenItem::DoUpdate

; 639  :             if (Remap::remapCount) {

  0169f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?remapCount@Remap@@2IA, 0 ; Remap::remapCount
  016a6	0f 84 00 02 00
	00		 je	 $L61997

; 641  :                   !lastList[i].OnScreen().IsEmpty() &&
; 642  :                   lastList[i].OnScreen().Intersect(siArray[i].OnScreen())
; 643  :                ) {

  016ac	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  016af	52		 push	 edx
  016b0	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  016b6	83 c1 7c	 add	 ecx, 124		; 0000007cH
  016b9	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  016be	8b c8		 mov	 ecx, eax
  016c0	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  016c5	8b c8		 mov	 ecx, eax
  016c7	e8 00 00 00 00	 call	 ?IsEmpty@SOL_Rect@@QBEHXZ ; SOL_Rect::IsEmpty
  016cc	85 c0		 test	 eax, eax
  016ce	0f 85 fa 00 00
	00		 jne	 $L61998
  016d4	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  016d7	50		 push	 eax
  016d8	8b 4d ec	 mov	 ecx, DWORD PTR _lastList$[ebp]
  016db	e8 00 00 00 00	 call	 ?Exists@ScreenItemList@@QBEHH@Z ; ScreenItemList::Exists
  016e0	85 c0		 test	 eax, eax
  016e2	0f 84 e6 00 00
	00		 je	 $L61998
  016e8	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  016eb	51		 push	 ecx
  016ec	8b 4d ec	 mov	 ecx, DWORD PTR _lastList$[ebp]
  016ef	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  016f4	8b c8		 mov	 ecx, eax
  016f6	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  016fb	8b c8		 mov	 ecx, eax
  016fd	e8 00 00 00 00	 call	 ?IsEmpty@SOL_Rect@@QBEHXZ ; SOL_Rect::IsEmpty
  01702	85 c0		 test	 eax, eax
  01704	0f 85 c4 00 00
	00		 jne	 $L61998
  0170a	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  0170d	52		 push	 edx
  0170e	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01714	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01717	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  0171c	8b c8		 mov	 ecx, eax
  0171e	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  01723	50		 push	 eax
  01724	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  01727	50		 push	 eax
  01728	8b 4d ec	 mov	 ecx, DWORD PTR _lastList$[ebp]
  0172b	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01730	8b c8		 mov	 ecx, eax
  01732	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  01737	8b c8		 mov	 ecx, eax
  01739	e8 00 00 00 00	 call	 ?Intersect@SOL_Rect@@QBEHABV1@@Z ; SOL_Rect::Intersect
  0173e	85 c0		 test	 eax, eax
  01740	0f 84 88 00 00
	00		 je	 $L61998

; 644  :                   rects[0] = lastList[i].OnScreen();

  01746	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  01749	51		 push	 ecx
  0174a	8b 4d ec	 mov	 ecx, DWORD PTR _lastList$[ebp]
  0174d	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01752	8b c8		 mov	 ecx, eax
  01754	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  01759	50		 push	 eax
  0175a	8d 4d a4	 lea	 ecx, DWORD PTR _rects$[ebp]
  0175d	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 645  :                   rects[0].Both(siArray[i].OnScreen());

  01762	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  01765	52		 push	 edx
  01766	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0176c	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0176f	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01774	8b c8		 mov	 ecx, eax
  01776	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  0177b	50		 push	 eax
  0177c	8d 4d a4	 lea	 ecx, DWORD PTR _rects$[ebp]
  0177f	e8 00 00 00 00	 call	 ?Both@SOL_Rect@@QAEXABV1@@Z ; SOL_Rect::Both

; 646  : 					   drawList.Add(&siArray[i],siArray[i].OnScreen());

  01784	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  01787	50		 push	 eax
  01788	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0178e	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01791	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01796	8b c8		 mov	 ecx, eax
  01798	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  0179d	50		 push	 eax
  0179e	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  017a1	51		 push	 ecx
  017a2	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  017a8	83 c1 7c	 add	 ecx, 124		; 0000007cH
  017ab	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  017b0	50		 push	 eax
  017b1	8b 4d 10	 mov	 ecx, DWORD PTR _drawList$[ebp]
  017b4	e8 00 00 00 00	 call	 ?Add@DrawList@@QAEHPAVScreenItem@@AAVSOL_Rect@@@Z ; DrawList::Add

; 647  : 						MergeToRectList(rects[0],eraseList);

  017b9	8b 55 14	 mov	 edx, DWORD PTR _eraseList$[ebp]
  017bc	52		 push	 edx
  017bd	8d 45 a4	 lea	 eax, DWORD PTR _rects$[ebp]
  017c0	50		 push	 eax
  017c1	e8 00 00 00 00	 call	 ?MergeToRectList@@YAXABVSOL_Rect@@AAVRectList@@@Z ; MergeToRectList
  017c6	83 c4 08	 add	 esp, 8

; 648  :                } else {

  017c9	e9 d9 00 00 00	 jmp	 $L62003
$L61998:

; 649  : 
; 650  : 				      if (!siArray[i].OnScreen().IsEmpty()) {

  017ce	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  017d1	51		 push	 ecx
  017d2	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  017d8	83 c1 7c	 add	 ecx, 124		; 0000007cH
  017db	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  017e0	8b c8		 mov	 ecx, eax
  017e2	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  017e7	8b c8		 mov	 ecx, eax
  017e9	e8 00 00 00 00	 call	 ?IsEmpty@SOL_Rect@@QBEHXZ ; SOL_Rect::IsEmpty
  017ee	85 c0		 test	 eax, eax
  017f0	75 67		 jne	 SHORT $L62000

; 651  : 					      drawList.Add(&siArray[i],siArray[i].OnScreen());

  017f2	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  017f5	52		 push	 edx
  017f6	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  017fc	83 c1 7c	 add	 ecx, 124		; 0000007cH
  017ff	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01804	8b c8		 mov	 ecx, eax
  01806	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  0180b	50		 push	 eax
  0180c	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  0180f	50		 push	 eax
  01810	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01816	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01819	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  0181e	50		 push	 eax
  0181f	8b 4d 10	 mov	 ecx, DWORD PTR _drawList$[ebp]
  01822	e8 00 00 00 00	 call	 ?Add@DrawList@@QAEHPAVScreenItem@@AAVSOL_Rect@@@Z ; DrawList::Add

; 652  : 						   MergeToRectList((SOL_Rect)(siArray[i].OnScreen()),eraseList);

  01827	8b 4d 14	 mov	 ecx, DWORD PTR _eraseList$[ebp]
  0182a	51		 push	 ecx
  0182b	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  0182e	52		 push	 edx
  0182f	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01835	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01838	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  0183d	8b c8		 mov	 ecx, eax
  0183f	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  01844	50		 push	 eax
  01845	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T62713[ebp]
  0184b	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@ABV0@@Z ; SOL_Rect::SOL_Rect
  01850	50		 push	 eax
  01851	e8 00 00 00 00	 call	 ?MergeToRectList@@YAXABVSOL_Rect@@AAVRectList@@@Z ; MergeToRectList
  01856	83 c4 08	 add	 esp, 8
$L62000:

; 654  : 
; 655  : 				      if (lastList.Exists(i)  &&  !lastList[i].OnScreen().IsEmpty()) 

  01859	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  0185c	50		 push	 eax
  0185d	8b 4d ec	 mov	 ecx, DWORD PTR _lastList$[ebp]
  01860	e8 00 00 00 00	 call	 ?Exists@ScreenItemList@@QBEHH@Z ; ScreenItemList::Exists
  01865	85 c0		 test	 eax, eax
  01867	74 3e		 je	 SHORT $L62003
  01869	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  0186c	51		 push	 ecx
  0186d	8b 4d ec	 mov	 ecx, DWORD PTR _lastList$[ebp]
  01870	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01875	8b c8		 mov	 ecx, eax
  01877	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  0187c	8b c8		 mov	 ecx, eax
  0187e	e8 00 00 00 00	 call	 ?IsEmpty@SOL_Rect@@QBEHXZ ; SOL_Rect::IsEmpty
  01883	85 c0		 test	 eax, eax
  01885	75 20		 jne	 SHORT $L62003

; 656  : 				         MergeToRectList(lastList[i].OnScreen(),eraseList);

  01887	8b 55 14	 mov	 edx, DWORD PTR _eraseList$[ebp]
  0188a	52		 push	 edx
  0188b	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  0188e	50		 push	 eax
  0188f	8b 4d ec	 mov	 ecx, DWORD PTR _lastList$[ebp]
  01892	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01897	8b c8		 mov	 ecx, eax
  01899	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  0189e	50		 push	 eax
  0189f	e8 00 00 00 00	 call	 ?MergeToRectList@@YAXABVSOL_Rect@@AAVRectList@@@Z ; MergeToRectList
  018a4	83 c4 08	 add	 esp, 8
$L62003:

; 658  :             } else {

  018a7	e9 a3 00 00 00	 jmp	 $L62006
$L61997:

; 659  : 				   // Add to the drawList if visable.
; 660  : 				   if (!siArray[i].OnScreen().IsEmpty()) {

  018ac	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  018af	51		 push	 ecx
  018b0	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  018b6	83 c1 7c	 add	 ecx, 124		; 0000007cH
  018b9	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  018be	8b c8		 mov	 ecx, eax
  018c0	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  018c5	8b c8		 mov	 ecx, eax
  018c7	e8 00 00 00 00	 call	 ?IsEmpty@SOL_Rect@@QBEHXZ ; SOL_Rect::IsEmpty
  018cc	85 c0		 test	 eax, eax
  018ce	75 35		 jne	 SHORT $L62005

; 661  : 					   drawList.Add(&siArray[i],siArray[i].OnScreen());

  018d0	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  018d3	52		 push	 edx
  018d4	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  018da	83 c1 7c	 add	 ecx, 124		; 0000007cH
  018dd	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  018e2	8b c8		 mov	 ecx, eax
  018e4	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  018e9	50		 push	 eax
  018ea	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  018ed	50		 push	 eax
  018ee	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  018f4	83 c1 7c	 add	 ecx, 124		; 0000007cH
  018f7	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  018fc	50		 push	 eax
  018fd	8b 4d 10	 mov	 ecx, DWORD PTR _drawList$[ebp]
  01900	e8 00 00 00 00	 call	 ?Add@DrawList@@QAEHPAVScreenItem@@AAVSOL_Rect@@@Z ; DrawList::Add
$L62005:

; 663  : 
; 664  : 				   // Add to the eraseList if it was visable in the lastList.
; 665  : 				   if (lastList.Exists(i)  &&  !lastList[i].OnScreen().IsEmpty()) {

  01905	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  01908	51		 push	 ecx
  01909	8b 4d ec	 mov	 ecx, DWORD PTR _lastList$[ebp]
  0190c	e8 00 00 00 00	 call	 ?Exists@ScreenItemList@@QBEHH@Z ; ScreenItemList::Exists
  01911	85 c0		 test	 eax, eax
  01913	74 3a		 je	 SHORT $L62006
  01915	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  01918	52		 push	 edx
  01919	8b 4d ec	 mov	 ecx, DWORD PTR _lastList$[ebp]
  0191c	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01921	8b c8		 mov	 ecx, eax
  01923	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  01928	8b c8		 mov	 ecx, eax
  0192a	e8 00 00 00 00	 call	 ?IsEmpty@SOL_Rect@@QBEHXZ ; SOL_Rect::IsEmpty
  0192f	85 c0		 test	 eax, eax
  01931	75 1c		 jne	 SHORT $L62006

; 666  : 						eraseList.Add(lastList[i].OnScreen());

  01933	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  01936	50		 push	 eax
  01937	8b 4d ec	 mov	 ecx, DWORD PTR _lastList$[ebp]
  0193a	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  0193f	8b c8		 mov	 ecx, eax
  01941	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  01946	50		 push	 eax
  01947	8b 4d 14	 mov	 ecx, DWORD PTR _eraseList$[ebp]
  0194a	e8 00 00 00 00	 call	 ?Add@RectList@@QAEXABVSOL_Rect@@@Z ; RectList::Add
$L62006:

; 671  : 	}

  0194f	e9 32 fb ff ff	 jmp	 $L61981
$L61982:

; 672  : 
; 673  : 	// If an erase rect is overlaped by a non transparent plane 
; 674  : 	// of higher priority, delete the overlap from the erase 
; 675  : 	// list for this plane
; 676  : 	BreakEraseListByPlanes(eraseList,nextPlanesList);

  01954	8b 4d 0c	 mov	 ecx, DWORD PTR _nextPlanesList$[ebp]
  01957	51		 push	 ecx
  01958	8b 55 14	 mov	 edx, DWORD PTR _eraseList$[ebp]
  0195b	52		 push	 edx
  0195c	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01962	e8 00 00 00 00	 call	 ?BreakEraseListByPlanes@SOL_Plane@@IAEXAAVRectList@@AAVPlaneList@@@Z ; SOL_Plane::BreakEraseListByPlanes

; 677  : 
; 678  : 	// If a draw rect is overlaped by a plane of higher priority,
; 679  : 	//	delete the overlap from the erase list for this plane
; 680  : 	BreakDrawListByPlanes(drawList,nextPlanesList);

  01967	8b 45 0c	 mov	 eax, DWORD PTR _nextPlanesList$[ebp]
  0196a	50		 push	 eax
  0196b	8b 4d 10	 mov	 ecx, DWORD PTR _drawList$[ebp]
  0196e	51		 push	 ecx
  0196f	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01975	e8 00 00 00 00	 call	 ?BreakDrawListByPlanes@SOL_Plane@@IAEXAAVDrawList@@AAVPlaneList@@@Z ; SOL_Plane::BreakDrawListByPlanes

; 681  : 
; 682  : 	// Don't need to check the drawlist member from the erase rects
; 683  : 	// against non changing member of the siArray
; 684  : 	int drawListSize = drawList.Length();

  0197a	8b 4d 10	 mov	 ecx, DWORD PTR _drawList$[ebp]
  0197d	e8 00 00 00 00	 call	 ?Length@DrawList@@QBEHXZ ; DrawList::Length
  01982	89 45 fc	 mov	 DWORD PTR _drawListSize$[ebp], eax

; 685  : 
; 686  : 	//	Now go through the eraselist looking for anything that
; 687  : 	//	collides	with members of the siArray that are unchanged,
; 688  : 	//	and add them to the drawList.
; 689  : 
; 690  : 	// Sort the siArray by priority
; 691  : 	siArray.Sort();

  01985	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0198b	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0198e	e8 00 00 00 00	 call	 ?Sort@ScreenItemList@@QAEXXZ ; ScreenItemList::Sort

; 692  : 
; 693  : 	int pictureDrawn = 0;

  01993	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _pictureDrawn$[ebp], 0

; 694  : 	int screenItemDrawn = 0;

  0199a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _screenItemDrawn$[ebp], 0

; 695  : 
; 696  : 	int eraseListSize = eraseList.Length();

  019a1	8b 4d 14	 mov	 ecx, DWORD PTR _eraseList$[ebp]
  019a4	e8 00 00 00 00	 call	 ?Length@RectList@@QBEHXZ ; RectList::Length
  019a9	89 45 f0	 mov	 DWORD PTR _eraseListSize$[ebp], eax

; 697  : 
; 698  : 	for (i=0;i<eraseListSize;++i) {

  019ac	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  019b3	eb 09		 jmp	 SHORT $L62011
$L62012:
  019b5	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  019b8	83 c2 01	 add	 edx, 1
  019bb	89 55 e8	 mov	 DWORD PTR _i$[ebp], edx
$L62011:
  019be	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  019c1	3b 45 f0	 cmp	 eax, DWORD PTR _eraseListSize$[ebp]
  019c4	0f 8d f2 01 00
	00		 jge	 $L62013

; 699  : 		for (int j=0;j<siArraySize;++j) {

  019ca	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _j$62014[ebp], 0
  019d1	eb 09		 jmp	 SHORT $L62015
$L62016:
  019d3	8b 4d a0	 mov	 ecx, DWORD PTR _j$62014[ebp]
  019d6	83 c1 01	 add	 ecx, 1
  019d9	89 4d a0	 mov	 DWORD PTR _j$62014[ebp], ecx
$L62015:
  019dc	8b 55 a0	 mov	 edx, DWORD PTR _j$62014[ebp]
  019df	3b 55 f4	 cmp	 edx, DWORD PTR _siArraySize$[ebp]
  019e2	0f 8d cf 01 00
	00		 jge	 $L62017

; 700  : 			if (siArray.Exists(j)) {

  019e8	8b 45 a0	 mov	 eax, DWORD PTR _j$62014[ebp]
  019eb	50		 push	 eax
  019ec	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  019f2	83 c1 7c	 add	 ecx, 124		; 0000007cH
  019f5	e8 00 00 00 00	 call	 ?Exists@ScreenItemList@@QBEHH@Z ; ScreenItemList::Exists
  019fa	85 c0		 test	 eax, eax
  019fc	0f 84 b0 01 00
	00		 je	 $L62029

; 701  : 				if (eraseList[i].Intersect(siArray[j].OnScreen(),rects)) {

  01a02	8d 4d a4	 lea	 ecx, DWORD PTR _rects$[ebp]
  01a05	51		 push	 ecx
  01a06	8b 55 a0	 mov	 edx, DWORD PTR _j$62014[ebp]
  01a09	52		 push	 edx
  01a0a	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01a10	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01a13	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01a18	8b c8		 mov	 ecx, eax
  01a1a	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  01a1f	50		 push	 eax
  01a20	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  01a23	50		 push	 eax
  01a24	8b 4d 14	 mov	 ecx, DWORD PTR _eraseList$[ebp]
  01a27	e8 00 00 00 00	 call	 ??ARectList@@QAEAAVSOL_Rect@@H@Z ; RectList::operator[]
  01a2c	8b c8		 mov	 ecx, eax
  01a2e	e8 00 00 00 00	 call	 ?Intersect@SOL_Rect@@QBEHABV1@PAV1@@Z ; SOL_Rect::Intersect
  01a33	85 c0		 test	 eax, eax
  01a35	0f 84 77 01 00
	00		 je	 $L62029

; 702  : 					// Don't add to the drawList if:
; 703  : 					//		If it's a picture screen Item after the first picture
; 704  : 					//		screenItem encountered and no non-picture screen item
; 705  : 					//		has been encountered and the subsequent picture item is
; 706  : 					// 	completely within the previously drawn screen item then
; 707  : 					//		it doesn't have to be drawn. In other words don't draw 
; 708  : 					//		picture screenItems next to picture screenItems unless 
; 709  : 					//		neccessary.
; 710  : 					// This assumes that each picture screen item contains
; 711  : 					// all the rest of the picture priority from it's priority 
; 712  : 					// and to any higher picture priority and that the lowest
; 713  : 					// priority picture element contains the entire picture.
; 714  : 
; 715  : 					// This version takes a shortcut in that if a non picuture
; 716  : 					// screen item is drawn all the other picture screen items
; 717  : 					// will be drawn.
; 718  : 					if (!siArray[j].DeleteCount()) {

  01a3b	8b 4d a0	 mov	 ecx, DWORD PTR _j$62014[ebp]
  01a3e	51		 push	 ecx
  01a3f	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01a45	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01a48	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01a4d	8b c8		 mov	 ecx, eax
  01a4f	e8 00 00 00 00	 call	 ?DeleteCount@ScreenItem@@QBEHXZ ; ScreenItem::DeleteCount
  01a54	85 c0		 test	 eax, eax
  01a56	0f 85 56 01 00
	00		 jne	 $L62029

; 719  : 						// This item may be added to the drawList
; 720  : 
; 721  : 						if (pictureDrawn)	{

  01a5c	83 7d e4 00	 cmp	 DWORD PTR _pictureDrawn$[ebp], 0
  01a60	0f 84 cc 00 00
	00		 je	 $L62021

; 722  : 							if ((siArray[j].bitmap.IsPic())) {

  01a66	8b 55 a0	 mov	 edx, DWORD PTR _j$62014[ebp]
  01a69	52		 push	 edx
  01a6a	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01a70	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01a73	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01a78	8b c8		 mov	 ecx, eax
  01a7a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01a7d	e8 00 00 00 00	 call	 ?IsPic@Bitmap@@QBEHXZ	; Bitmap::IsPic
  01a82	85 c0		 test	 eax, eax
  01a84	74 47		 je	 SHORT $L62022

; 723  : 								if (screenItemDrawn || (siArray[j].bitmap.Cel() == 0)) {

  01a86	83 7d f8 00	 cmp	 DWORD PTR _screenItemDrawn$[ebp], 0
  01a8a	75 20		 jne	 SHORT $L62024
  01a8c	8b 45 a0	 mov	 eax, DWORD PTR _j$62014[ebp]
  01a8f	50		 push	 eax
  01a90	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01a96	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01a99	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01a9e	8b c8		 mov	 ecx, eax
  01aa0	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01aa3	e8 00 00 00 00	 call	 ?Cel@Bitmap@@QBEHXZ	; Bitmap::Cel
  01aa8	85 c0		 test	 eax, eax
  01aaa	75 1f		 jne	 SHORT $L62023
$L62024:

; 724  : 									// The cel == 0 means it's a lowest 
; 725  : 									// priority picture element
; 726  : 									drawList.Add(&siArray[j],rects[0]);

  01aac	8d 4d a4	 lea	 ecx, DWORD PTR _rects$[ebp]
  01aaf	51		 push	 ecx
  01ab0	8b 55 a0	 mov	 edx, DWORD PTR _j$62014[ebp]
  01ab3	52		 push	 edx
  01ab4	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01aba	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01abd	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01ac2	50		 push	 eax
  01ac3	8b 4d 10	 mov	 ecx, DWORD PTR _drawList$[ebp]
  01ac6	e8 00 00 00 00	 call	 ?Add@DrawList@@QAEHPAVScreenItem@@AAVSOL_Rect@@@Z ; DrawList::Add
$L62023:

; 729  : 							else {

  01acb	eb 60		 jmp	 SHORT $L62025
$L62022:

; 730  : 								// Add to the drawList
; 731  : 								if (!(siArray[j].UpdateCount() || siArray[j].AddCount()))

  01acd	8b 45 a0	 mov	 eax, DWORD PTR _j$62014[ebp]
  01ad0	50		 push	 eax
  01ad1	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01ad7	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01ada	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01adf	8b c8		 mov	 ecx, eax
  01ae1	e8 00 00 00 00	 call	 ?UpdateCount@ScreenItem@@QBEHXZ ; ScreenItem::UpdateCount
  01ae6	85 c0		 test	 eax, eax
  01ae8	75 3c		 jne	 SHORT $L62026
  01aea	8b 4d a0	 mov	 ecx, DWORD PTR _j$62014[ebp]
  01aed	51		 push	 ecx
  01aee	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01af4	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01af7	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01afc	8b c8		 mov	 ecx, eax
  01afe	e8 00 00 00 00	 call	 ?AddCount@ScreenItem@@QBEHXZ ; ScreenItem::AddCount
  01b03	85 c0		 test	 eax, eax
  01b05	75 1f		 jne	 SHORT $L62026

; 732  : 									drawList.Add(&siArray[j],rects[0]);

  01b07	8d 55 a4	 lea	 edx, DWORD PTR _rects$[ebp]
  01b0a	52		 push	 edx
  01b0b	8b 45 a0	 mov	 eax, DWORD PTR _j$62014[ebp]
  01b0e	50		 push	 eax
  01b0f	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01b15	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01b18	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01b1d	50		 push	 eax
  01b1e	8b 4d 10	 mov	 ecx, DWORD PTR _drawList$[ebp]
  01b21	e8 00 00 00 00	 call	 ?Add@DrawList@@QAEHPAVScreenItem@@AAVSOL_Rect@@@Z ; DrawList::Add
$L62026:

; 733  : 								screenItemDrawn = True;

  01b26	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _screenItemDrawn$[ebp], 1
$L62025:

; 736  : 						else {

  01b2d	e9 80 00 00 00	 jmp	 $L62029
$L62021:

; 737  : 							// Add to the drawList
; 738  : 							if (!(siArray[j].UpdateCount() || siArray[j].AddCount()))

  01b32	8b 4d a0	 mov	 ecx, DWORD PTR _j$62014[ebp]
  01b35	51		 push	 ecx
  01b36	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01b3c	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01b3f	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01b44	8b c8		 mov	 ecx, eax
  01b46	e8 00 00 00 00	 call	 ?UpdateCount@ScreenItem@@QBEHXZ ; ScreenItem::UpdateCount
  01b4b	85 c0		 test	 eax, eax
  01b4d	75 3c		 jne	 SHORT $L62028
  01b4f	8b 55 a0	 mov	 edx, DWORD PTR _j$62014[ebp]
  01b52	52		 push	 edx
  01b53	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01b59	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01b5c	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01b61	8b c8		 mov	 ecx, eax
  01b63	e8 00 00 00 00	 call	 ?AddCount@ScreenItem@@QBEHXZ ; ScreenItem::AddCount
  01b68	85 c0		 test	 eax, eax
  01b6a	75 1f		 jne	 SHORT $L62028

; 739  : 								drawList.Add(&siArray[j],rects[0]);

  01b6c	8d 45 a4	 lea	 eax, DWORD PTR _rects$[ebp]
  01b6f	50		 push	 eax
  01b70	8b 4d a0	 mov	 ecx, DWORD PTR _j$62014[ebp]
  01b73	51		 push	 ecx
  01b74	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01b7a	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01b7d	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01b82	50		 push	 eax
  01b83	8b 4d 10	 mov	 ecx, DWORD PTR _drawList$[ebp]
  01b86	e8 00 00 00 00	 call	 ?Add@DrawList@@QAEHPAVScreenItem@@AAVSOL_Rect@@@Z ; DrawList::Add
$L62028:

; 740  : 							if (siArray[j].bitmap.IsPic())

  01b8b	8b 55 a0	 mov	 edx, DWORD PTR _j$62014[ebp]
  01b8e	52		 push	 edx
  01b8f	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01b95	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01b98	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01b9d	8b c8		 mov	 ecx, eax
  01b9f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01ba2	e8 00 00 00 00	 call	 ?IsPic@Bitmap@@QBEHXZ	; Bitmap::IsPic
  01ba7	85 c0		 test	 eax, eax
  01ba9	74 07		 je	 SHORT $L62029

; 741  : 								pictureDrawn = True;

  01bab	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _pictureDrawn$[ebp], 1
$L62029:

; 746  : 		}

  01bb2	e9 1c fe ff ff	 jmp	 $L62016
$L62017:

; 747  : 	}

  01bb7	e9 f9 fd ff ff	 jmp	 $L62012
$L62013:

; 748  : 	// Reset the siArray to it's orginal state
; 749  : 	siArray.Unsort();

  01bbc	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01bc2	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01bc5	e8 00 00 00 00	 call	 ?Unsort@ScreenItemList@@QAEXXZ ; ScreenItemList::Unsort

; 750  : 
; 751  : 	//	Go through the drawList. If a member of the drawList intersects a
; 752  : 	//	member of the siArray that is unchanged and has higher priority,
; 753  : 	//	then add	this member	to the drawList
; 754  : 	if(!Remap::remapCount) {

  01bca	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?remapCount@Remap@@2IA, 0 ; Remap::remapCount
  01bd1	0f 85 e1 01 00
	00		 jne	 $L62033

; 755  :    	for (i=0;i<drawListSize;++i) {	// Don't use dynamic list size!!

  01bd7	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  01bde	eb 09		 jmp	 SHORT $L62031
$L62032:
  01be0	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  01be3	83 c0 01	 add	 eax, 1
  01be6	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax
$L62031:
  01be9	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  01bec	3b 4d fc	 cmp	 ecx, DWORD PTR _drawListSize$[ebp]
  01bef	0f 8d c3 01 00
	00		 jge	 $L62033

; 756  :    		for (int j=0;j<siArraySize;++j) {

  01bf5	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _j$62034[ebp], 0
  01bfc	eb 09		 jmp	 SHORT $L62035
$L62036:
  01bfe	8b 55 9c	 mov	 edx, DWORD PTR _j$62034[ebp]
  01c01	83 c2 01	 add	 edx, 1
  01c04	89 55 9c	 mov	 DWORD PTR _j$62034[ebp], edx
$L62035:
  01c07	8b 45 9c	 mov	 eax, DWORD PTR _j$62034[ebp]
  01c0a	3b 45 f4	 cmp	 eax, DWORD PTR _siArraySize$[ebp]
  01c0d	0f 8d a0 01 00
	00		 jge	 $L62037

; 758  : 					 siArray.Exists(j) && 
; 759  : 					 !(siArray[j].UpdateCount() ||
; 760  : 					   siArray[j].DeleteCount() ||
; 761  : 						siArray[j].AddCount()
; 762  : 					  )
; 763  : 				   ) {

  01c13	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  01c16	51		 push	 ecx
  01c17	8b 4d 10	 mov	 ecx, DWORD PTR _drawList$[ebp]
  01c1a	e8 00 00 00 00	 call	 ?Exists@DrawList@@QBEHH@Z ; DrawList::Exists
  01c1f	85 c0		 test	 eax, eax
  01c21	0f 84 87 01 00
	00		 je	 $L62041
  01c27	8b 55 9c	 mov	 edx, DWORD PTR _j$62034[ebp]
  01c2a	52		 push	 edx
  01c2b	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01c31	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01c34	e8 00 00 00 00	 call	 ?Exists@ScreenItemList@@QBEHH@Z ; ScreenItemList::Exists
  01c39	85 c0		 test	 eax, eax
  01c3b	0f 84 6d 01 00
	00		 je	 $L62041
  01c41	8b 45 9c	 mov	 eax, DWORD PTR _j$62034[ebp]
  01c44	50		 push	 eax
  01c45	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01c4b	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01c4e	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01c53	8b c8		 mov	 ecx, eax
  01c55	e8 00 00 00 00	 call	 ?UpdateCount@ScreenItem@@QBEHXZ ; ScreenItem::UpdateCount
  01c5a	85 c0		 test	 eax, eax
  01c5c	0f 85 4c 01 00
	00		 jne	 $L62041
  01c62	8b 4d 9c	 mov	 ecx, DWORD PTR _j$62034[ebp]
  01c65	51		 push	 ecx
  01c66	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01c6c	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01c6f	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01c74	8b c8		 mov	 ecx, eax
  01c76	e8 00 00 00 00	 call	 ?DeleteCount@ScreenItem@@QBEHXZ ; ScreenItem::DeleteCount
  01c7b	85 c0		 test	 eax, eax
  01c7d	0f 85 2b 01 00
	00		 jne	 $L62041
  01c83	8b 55 9c	 mov	 edx, DWORD PTR _j$62034[ebp]
  01c86	52		 push	 edx
  01c87	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01c8d	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01c90	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01c95	8b c8		 mov	 ecx, eax
  01c97	e8 00 00 00 00	 call	 ?AddCount@ScreenItem@@QBEHXZ ; ScreenItem::AddCount
  01c9c	85 c0		 test	 eax, eax
  01c9e	0f 85 0a 01 00
	00		 jne	 $L62041

; 765  : 					   (siArray[j].Priority() > drawList[i].SI().Priority()) ||
; 766  : 					   (
; 767  : 					   (siArray[j].Priority() == drawList[i].SI().Priority()) &&
; 768  : 					   (siArray[j].Id() > drawList[i].SI().Id())
; 769  : 					   )
; 770  : 					   ) {

  01ca4	8b 45 9c	 mov	 eax, DWORD PTR _j$62034[ebp]
  01ca7	50		 push	 eax
  01ca8	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01cae	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01cb1	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01cb6	8b c8		 mov	 ecx, eax
  01cb8	e8 00 00 00 00	 call	 ?Priority@ScreenItem@@QBEHXZ ; ScreenItem::Priority
  01cbd	8b f0		 mov	 esi, eax
  01cbf	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  01cc2	51		 push	 ecx
  01cc3	8b 4d 10	 mov	 ecx, DWORD PTR _drawList$[ebp]
  01cc6	e8 00 00 00 00	 call	 ??ADrawList@@QAEAAVDrawItem@@H@Z ; DrawList::operator[]
  01ccb	8b c8		 mov	 ecx, eax
  01ccd	e8 00 00 00 00	 call	 ?SI@DrawItem@@QAEAAVScreenItem@@XZ ; DrawItem::SI
  01cd2	8b c8		 mov	 ecx, eax
  01cd4	e8 00 00 00 00	 call	 ?Priority@ScreenItem@@QBEHXZ ; ScreenItem::Priority
  01cd9	3b f0		 cmp	 esi, eax
  01cdb	7f 76		 jg	 SHORT $L62040
  01cdd	8b 55 9c	 mov	 edx, DWORD PTR _j$62034[ebp]
  01ce0	52		 push	 edx
  01ce1	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01ce7	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01cea	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01cef	8b c8		 mov	 ecx, eax
  01cf1	e8 00 00 00 00	 call	 ?Priority@ScreenItem@@QBEHXZ ; ScreenItem::Priority
  01cf6	8b f0		 mov	 esi, eax
  01cf8	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  01cfb	50		 push	 eax
  01cfc	8b 4d 10	 mov	 ecx, DWORD PTR _drawList$[ebp]
  01cff	e8 00 00 00 00	 call	 ??ADrawList@@QAEAAVDrawItem@@H@Z ; DrawList::operator[]
  01d04	8b c8		 mov	 ecx, eax
  01d06	e8 00 00 00 00	 call	 ?SI@DrawItem@@QAEAAVScreenItem@@XZ ; DrawItem::SI
  01d0b	8b c8		 mov	 ecx, eax
  01d0d	e8 00 00 00 00	 call	 ?Priority@ScreenItem@@QBEHXZ ; ScreenItem::Priority
  01d12	3b f0		 cmp	 esi, eax
  01d14	0f 85 94 00 00
	00		 jne	 $L62041
  01d1a	8b 4d 9c	 mov	 ecx, DWORD PTR _j$62034[ebp]
  01d1d	51		 push	 ecx
  01d1e	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01d24	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01d27	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01d2c	8b c8		 mov	 ecx, eax
  01d2e	e8 00 00 00 00	 call	 ?Id@ScreenItem@@QBEJXZ	; ScreenItem::Id
  01d33	8b f0		 mov	 esi, eax
  01d35	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  01d38	52		 push	 edx
  01d39	8b 4d 10	 mov	 ecx, DWORD PTR _drawList$[ebp]
  01d3c	e8 00 00 00 00	 call	 ??ADrawList@@QAEAAVDrawItem@@H@Z ; DrawList::operator[]
  01d41	8b c8		 mov	 ecx, eax
  01d43	e8 00 00 00 00	 call	 ?SI@DrawItem@@QAEAAVScreenItem@@XZ ; DrawItem::SI
  01d48	8b c8		 mov	 ecx, eax
  01d4a	e8 00 00 00 00	 call	 ?Id@ScreenItem@@QBEJXZ	; ScreenItem::Id
  01d4f	3b f0		 cmp	 esi, eax
  01d51	7e 5b		 jle	 SHORT $L62041
$L62040:

; 771  : 					   if (drawList[i].OnScreen().Intersect(siArray[j].OnScreen(),rects)) {

  01d53	8d 45 a4	 lea	 eax, DWORD PTR _rects$[ebp]
  01d56	50		 push	 eax
  01d57	8b 4d 9c	 mov	 ecx, DWORD PTR _j$62034[ebp]
  01d5a	51		 push	 ecx
  01d5b	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01d61	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01d64	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01d69	8b c8		 mov	 ecx, eax
  01d6b	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  01d70	50		 push	 eax
  01d71	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  01d74	52		 push	 edx
  01d75	8b 4d 10	 mov	 ecx, DWORD PTR _drawList$[ebp]
  01d78	e8 00 00 00 00	 call	 ??ADrawList@@QAEAAVDrawItem@@H@Z ; DrawList::operator[]
  01d7d	8b c8		 mov	 ecx, eax
  01d7f	e8 00 00 00 00	 call	 ?OnScreen@DrawItem@@QAEAAVSOL_Rect@@XZ ; DrawItem::OnScreen
  01d84	8b c8		 mov	 ecx, eax
  01d86	e8 00 00 00 00	 call	 ?Intersect@SOL_Rect@@QBEHABV1@PAV1@@Z ; SOL_Rect::Intersect
  01d8b	85 c0		 test	 eax, eax
  01d8d	74 1f		 je	 SHORT $L62041

; 772  : 						   // Add to the drawList
; 773  : 							drawList.Add(&siArray[j],rects[0]);

  01d8f	8d 45 a4	 lea	 eax, DWORD PTR _rects$[ebp]
  01d92	50		 push	 eax
  01d93	8b 4d 9c	 mov	 ecx, DWORD PTR _j$62034[ebp]
  01d96	51		 push	 ecx
  01d97	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01d9d	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01da0	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01da5	50		 push	 eax
  01da6	8b 4d 10	 mov	 ecx, DWORD PTR _drawList$[ebp]
  01da9	e8 00 00 00 00	 call	 ?Add@DrawList@@QAEHPAVScreenItem@@AAVSOL_Rect@@@Z ; DrawList::Add
$L62041:

; 777  : 		   }

  01dae	e9 4b fe ff ff	 jmp	 $L62036
$L62037:

; 778  :       }

  01db3	e9 28 fe ff ff	 jmp	 $L62032
$L62033:

; 780  : 
; 781  : //	if ( drawList.Length() )
; 782  : //		msgMgr->Mono ( "DrawList size = %d\n", drawList.Length() );
; 783  : 
; 784  : 	DecSIArrayCounts(last);

  01db8	6a 00		 push	 0
  01dba	8b 55 08	 mov	 edx, DWORD PTR _last$[ebp]
  01dbd	52		 push	 edx
  01dbe	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01dc4	e8 00 00 00 00	 call	 ?DecSIArrayCounts@SOL_Plane@@IAEXPAV1@H@Z ; SOL_Plane::DecSIArrayCounts

; 785  : 	siArray.Pack();

  01dc9	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01dcf	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01dd2	e8 00 00 00 00	 call	 ?Pack@ScreenItemList@@QAEXXZ ; ScreenItemList::Pack

; 786  : 	lastList.Pack();

  01dd7	8b 4d ec	 mov	 ecx, DWORD PTR _lastList$[ebp]
  01dda	e8 00 00 00 00	 call	 ?Pack@ScreenItemList@@QAEXXZ ; ScreenItemList::Pack

; 787  : }

  01ddf	5e		 pop	 esi
  01de0	8b e5		 mov	 esp, ebp
  01de2	5d		 pop	 ebp
  01de3	c2 10 00	 ret	 16			; 00000010H
?CalcLists@SOL_Plane@@QAEXPAV1@AAVPlaneList@@AAVDrawList@@AAVRectList@@@Z ENDP ; SOL_Plane::CalcLists
_TEXT	ENDS
;	COMDAT ?IsEmpty@SOL_Rect@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsEmpty@SOL_Rect@@QBEHXZ PROC NEAR			; SOL_Rect::IsEmpty, COMDAT

; 116  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 117  : 	if (B.x < A.x  ||  B.y < A.y)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00010	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00012	7c 0e		 jl	 SHORT $L868
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0001d	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00020	7d 07		 jge	 SHORT $L867
$L868:

; 118  : 		return True;

  00022	b8 01 00 00 00	 mov	 eax, 1
  00027	eb 02		 jmp	 SHORT $L866
$L867:

; 119  : 	return False;

  00029	33 c0		 xor	 eax, eax
$L866:

; 120  : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?IsEmpty@SOL_Rect@@QBEHXZ ENDP				; SOL_Rect::IsEmpty
_TEXT	ENDS
;	COMDAT ?Both@SOL_Rect@@QAEXABV1@@Z
_TEXT	SEGMENT
_r$ = 8
_this$ = -4
?Both@SOL_Rect@@QAEXABV1@@Z PROC NEAR			; SOL_Rect::Both, COMDAT

; 244  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 245  : 	if (A.x > r.A.x)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  0000d	8b 10		 mov	 edx, DWORD PTR [eax]
  0000f	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00011	7e 0a		 jle	 SHORT $L931

; 246  : 		A.x = r.A.x;

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00019	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001b	89 10		 mov	 DWORD PTR [eax], edx
$L931:

; 247  : 	if (A.y > r.A.y)

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00023	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00026	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00029	7e 0c		 jle	 SHORT $L932

; 248  : 		A.y = r.A.y;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00031	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00034	89 50 04	 mov	 DWORD PTR [eax+4], edx
$L932:

; 249  : 	if (B.x < r.B.x)

  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  0003d	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00040	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00043	7d 0c		 jge	 SHORT $L933

; 250  : 		B.x = r.B.x;

  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  0004b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0004e	89 50 08	 mov	 DWORD PTR [eax+8], edx
$L933:

; 251  : 	if (B.y < r.B.y)

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00057	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0005a	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  0005d	7d 0c		 jge	 SHORT $L934

; 252  : 		B.y = r.B.y;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00065	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00068	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$L934:

; 253  : }

  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 04 00	 ret	 4
?Both@SOL_Rect@@QAEXABV1@@Z ENDP			; SOL_Rect::Both
_TEXT	ENDS
;	COMDAT ?Cel@Bitmap@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Cel@Bitmap@@QBEHXZ PROC NEAR				; Bitmap::Cel, COMDAT

; 139  : 	int	Cel() const				{return cel;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Cel@Bitmap@@QBEHXZ ENDP				; Bitmap::Cel
_TEXT	ENDS
;	COMDAT ?Id@ScreenItem@@QBEJXZ
_TEXT	SEGMENT
_this$ = -4
?Id@ScreenItem@@QBEJXZ PROC NEAR			; ScreenItem::Id, COMDAT

; 61   : 	long			Id() const					{return id;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Id@ScreenItem@@QBEJXZ ENDP				; ScreenItem::Id
_TEXT	ENDS
;	COMDAT ?UpdateCount@ScreenItem@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?UpdateCount@ScreenItem@@QBEHXZ PROC NEAR		; ScreenItem::UpdateCount, COMDAT

; 70   : 	int			UpdateCount() const		{return updateCount;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 48	 mov	 eax, DWORD PTR [eax+72]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?UpdateCount@ScreenItem@@QBEHXZ ENDP			; ScreenItem::UpdateCount
_TEXT	ENDS
EXTRN	?GetCelObj@ScreenItem@@QAEXXZ:NEAR		; ScreenItem::GetCelObj
EXTRN	?Update@ScreenItem@@IAEXABVSOL_Plane@@@Z:NEAR	; ScreenItem::Update
;	COMDAT ?DoUpdate@ScreenItem@@QAEXABVSOL_Plane@@@Z
_TEXT	SEGMENT
_plane$ = 8
_this$ = -4
?DoUpdate@ScreenItem@@QAEXABVSOL_Plane@@@Z PROC NEAR	; ScreenItem::DoUpdate, COMDAT

; 85   : 	void 			DoUpdate(const SOL_Plane& plane)	{GetCelObj();Update(plane);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetCelObj@ScreenItem@@QAEXXZ ; ScreenItem::GetCelObj
  0000f	8b 45 08	 mov	 eax, DWORD PTR _plane$[ebp]
  00012	50		 push	 eax
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?Update@ScreenItem@@IAEXABVSOL_Plane@@@Z ; ScreenItem::Update
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?DoUpdate@ScreenItem@@QAEXABVSOL_Plane@@@Z ENDP		; ScreenItem::DoUpdate
_TEXT	ENDS
;	COMDAT ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ
_TEXT	SEGMENT
_this$ = -4
?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ PROC NEAR	; ScreenItem::OnScreen, COMDAT

; 89   : 	SOL_Rect& 	OnScreen() 					{return onScreen;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 68	 add	 eax, 104		; 00000068H
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ENDP		; ScreenItem::OnScreen
_TEXT	ENDS
;	COMDAT ?OnScreen@DrawItem@@QAEAAVSOL_Rect@@XZ
_TEXT	SEGMENT
_this$ = -4
?OnScreen@DrawItem@@QAEAAVSOL_Rect@@XZ PROC NEAR	; DrawItem::OnScreen, COMDAT

; 17   : 	SOL_Rect&	OnScreen()				{return onScreen;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?OnScreen@DrawItem@@QAEAAVSOL_Rect@@XZ ENDP		; DrawItem::OnScreen
_TEXT	ENDS
;	COMDAT ?SI@DrawItem@@QAEAAVScreenItem@@XZ
_TEXT	SEGMENT
_this$ = -4
?SI@DrawItem@@QAEAAVScreenItem@@XZ PROC NEAR		; DrawItem::SI, COMDAT

; 18   : 	ScreenItem&	SI()						{return *si;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?SI@DrawItem@@QAEAAVScreenItem@@XZ ENDP			; DrawItem::SI
_TEXT	ENDS
;	COMDAT ?Length@DrawList@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Length@DrawList@@QBEHXZ PROC NEAR			; DrawList::Length, COMDAT

; 36   : 	int	Length() const							{return length;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?Length@DrawList@@QBEHXZ ENDP				; DrawList::Length
_TEXT	ENDS
;	COMDAT ?Exists@DrawList@@QBEHH@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
?Exists@DrawList@@QBEHH@Z PROC NEAR			; DrawList::Exists, COMDAT

; 37   : 	Bool	Exists(int index) const				{return (index < length) && (drawArray[index] != NULL);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  0000f	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00011	7d 16		 jge	 SHORT $L62725
  00013	8b 55 08	 mov	 edx, DWORD PTR _index$[ebp]
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	83 7c 90 04 00	 cmp	 DWORD PTR [eax+edx*4+4], 0
  0001e	74 09		 je	 SHORT $L62725
  00020	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR -8+[ebp], 1
  00027	eb 07		 jmp	 SHORT $L62726
$L62725:
  00029	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR -8+[ebp], 0
$L62726:
  00030	8b 45 f8	 mov	 eax, DWORD PTR -8+[ebp]
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
?Exists@DrawList@@QBEHH@Z ENDP				; DrawList::Exists
_TEXT	ENDS
;	COMDAT ??ADrawList@@QAEAAVDrawItem@@H@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
??ADrawList@@QAEAAVDrawItem@@H@Z PROC NEAR		; DrawList::operator[], COMDAT

; 40   : 	DrawItem& operator[](int index) 			{return *drawArray[index];}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 44 81 04	 mov	 eax, DWORD PTR [ecx+eax*4+4]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
??ADrawList@@QAEAAVDrawItem@@H@Z ENDP			; DrawList::operator[]
_TEXT	ENDS
;	COMDAT ?SIList@SOL_Plane@@QAEAAVScreenItemList@@XZ
_TEXT	SEGMENT
_this$ = -4
?SIList@SOL_Plane@@QAEAAVScreenItemList@@XZ PROC NEAR	; SOL_Plane::SIList, COMDAT

; 125  : 						SIList()						{return siArray;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 7c	 add	 eax, 124		; 0000007cH
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?SIList@SOL_Plane@@QAEAAVScreenItemList@@XZ ENDP	; SOL_Plane::SIList
_TEXT	ENDS
;	COMDAT ?Length@RectList@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Length@RectList@@QBEHXZ PROC NEAR			; RectList::Length, COMDAT

; 45   : 	int	Length() const									{return length;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 80 a0 0f 00
	00		 mov	 eax, DWORD PTR [eax+4000]
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?Length@RectList@@QBEHXZ ENDP				; RectList::Length
_TEXT	ENDS
;	COMDAT ??ARectList@@QAEAAVSOL_Rect@@H@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
??ARectList@@QAEAAVSOL_Rect@@H@Z PROC NEAR		; RectList::operator[], COMDAT

; 48   : 	SOL_Rect&	operator[](int index)				{return *rectArray[index];}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??ARectList@@QAEAAVSOL_Rect@@H@Z ENDP			; RectList::operator[]
_TEXT	ENDS
;	COMDAT ??0SOL_Rect@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0SOL_Rect@@QAE@ABV0@@Z PROC NEAR			; SOL_Rect::SOL_Rect, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  00013	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00016	83 c1 08	 add	 ecx, 8
  00019	51		 push	 ecx
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 08	 add	 ecx, 8
  00020	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??0SOL_Rect@@QAE@ABV0@@Z ENDP				; SOL_Rect::SOL_Rect
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$L62050:
  00003	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00006	83 e8 01	 sub	 eax, 1
  00009	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  0000c	83 7d 10 00	 cmp	 DWORD PTR ___n$[ebp], 0
  00010	7c 11		 jl	 SHORT $L62051
  00012	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00015	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001b	03 4d 0c	 add	 ecx, DWORD PTR ___s$[ebp]
  0001e	89 4d 08	 mov	 DWORD PTR ___t$[ebp], ecx
  00021	eb e0		 jmp	 SHORT $L62050
$L62051:
  00023	5d		 pop	 ebp
  00024	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?RedrawAll@SOL_Plane@@QAEXPAV1@AAVPlaneList@@AAVDrawList@@AAVRectList@@@Z ; SOL_Plane::RedrawAll
EXTRN	?Clear@RectList@@QAEXXZ:NEAR			; RectList::Clear
_TEXT	SEGMENT
_last$ = 8
_nextPlanesList$ = 12
_drawList$ = 16
_eraseList$ = 20
_this$ = -16
_siArraySize$ = -4
_i$ = -8
_lastList$62069 = -12
?RedrawAll@SOL_Plane@@QAEXPAV1@AAVPlaneList@@AAVDrawList@@AAVRectList@@@Z PROC NEAR ; SOL_Plane::RedrawAll

; 792  : {

  01de6	55		 push	 ebp
  01de7	8b ec		 mov	 ebp, esp
  01de9	83 ec 10	 sub	 esp, 16			; 00000010H
  01dec	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 793  : 	// Note
; 794  : 	// There is an assumption in this routine that
; 795  : 	// siArray in the next screen is in sync with
; 796  : 	// it's counterpart in the last screen
; 797  : 
; 798  : 	int siArraySize = siArray.Length();

  01def	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01df2	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01df5	e8 00 00 00 00	 call	 ?Length@ScreenItemList@@QBEHXZ ; ScreenItemList::Length
  01dfa	89 45 fc	 mov	 DWORD PTR _siArraySize$[ebp], eax

; 799  : 
; 800  : 	// All screenItems get added to the drawList if visable and not deleted.
; 801  : 	for (int i=0;i<siArraySize;++i) {

  01dfd	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  01e04	eb 09		 jmp	 SHORT $L62062
$L62063:
  01e06	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01e09	83 c0 01	 add	 eax, 1
  01e0c	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L62062:
  01e0f	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  01e12	3b 4d fc	 cmp	 ecx, DWORD PTR _siArraySize$[ebp]
  01e15	0f 8d a0 00 00
	00		 jge	 $L62064

; 802  : 		if ((siArray.Exists(i) && !siArray[i].DeleteCount())) {

  01e1b	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  01e1e	52		 push	 edx
  01e1f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01e22	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01e25	e8 00 00 00 00	 call	 ?Exists@ScreenItemList@@QBEHH@Z ; ScreenItemList::Exists
  01e2a	85 c0		 test	 eax, eax
  01e2c	0f 84 84 00 00
	00		 je	 $L62066
  01e32	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01e35	50		 push	 eax
  01e36	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01e39	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01e3c	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01e41	8b c8		 mov	 ecx, eax
  01e43	e8 00 00 00 00	 call	 ?DeleteCount@ScreenItem@@QBEHXZ ; ScreenItem::DeleteCount
  01e48	85 c0		 test	 eax, eax
  01e4a	75 6a		 jne	 SHORT $L62066

; 803  : 			// Update the screenItem
; 804  : 			siArray[i].DoUpdate(*this);

  01e4c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01e4f	51		 push	 ecx
  01e50	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  01e53	52		 push	 edx
  01e54	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01e57	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01e5a	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01e5f	8b c8		 mov	 ecx, eax
  01e61	e8 00 00 00 00	 call	 ?DoUpdate@ScreenItem@@QAEXABVSOL_Plane@@@Z ; ScreenItem::DoUpdate

; 805  : 			// Add to the drawList if visable.
; 806  : 			if (!siArray[i].OnScreen().IsEmpty()) {

  01e66	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01e69	50		 push	 eax
  01e6a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01e6d	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01e70	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01e75	8b c8		 mov	 ecx, eax
  01e77	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  01e7c	8b c8		 mov	 ecx, eax
  01e7e	e8 00 00 00 00	 call	 ?IsEmpty@SOL_Rect@@QBEHXZ ; SOL_Rect::IsEmpty
  01e83	85 c0		 test	 eax, eax
  01e85	75 2f		 jne	 SHORT $L62066

; 807  : 				drawList.Add(&siArray[i],siArray[i].OnScreen());

  01e87	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  01e8a	51		 push	 ecx
  01e8b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01e8e	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01e91	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01e96	8b c8		 mov	 ecx, eax
  01e98	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  01e9d	50		 push	 eax
  01e9e	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  01ea1	52		 push	 edx
  01ea2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01ea5	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01ea8	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01ead	50		 push	 eax
  01eae	8b 4d 10	 mov	 ecx, DWORD PTR _drawList$[ebp]
  01eb1	e8 00 00 00 00	 call	 ?Add@DrawList@@QAEHPAVScreenItem@@AAVSOL_Rect@@@Z ; DrawList::Add
$L62066:

; 810  : 	}

  01eb6	e9 4b ff ff ff	 jmp	 $L62063
$L62064:

; 811  : 
; 812  : 	// Clear eraseList (it may have erases from other planes).
; 813  : 	eraseList.Clear();

  01ebb	8b 4d 14	 mov	 ecx, DWORD PTR _eraseList$[ebp]
  01ebe	e8 00 00 00 00	 call	 ?Clear@RectList@@QAEXXZ	; RectList::Clear

; 817  : 		 (type != picturePlane) 	&&
; 818  : 		 (type != opaquePlane))

  01ec3	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01ec6	83 c1 4c	 add	 ecx, 76			; 0000004cH
  01ec9	e8 00 00 00 00	 call	 ?IsEmpty@SOL_Rect@@QBEHXZ ; SOL_Rect::IsEmpty
  01ece	85 c0		 test	 eax, eax
  01ed0	75 21		 jne	 SHORT $L62067
  01ed2	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  01ed5	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  01ed9	74 18		 je	 SHORT $L62067
  01edb	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01ede	83 79 04 03	 cmp	 DWORD PTR [ecx+4], 3
  01ee2	74 0f		 je	 SHORT $L62067

; 819  : 		eraseList.Add(onScreen);

  01ee4	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  01ee7	83 c2 4c	 add	 edx, 76			; 0000004cH
  01eea	52		 push	 edx
  01eeb	8b 4d 14	 mov	 ecx, DWORD PTR _eraseList$[ebp]
  01eee	e8 00 00 00 00	 call	 ?Add@RectList@@QAEXABVSOL_Rect@@@Z ; RectList::Add
$L62067:

; 820  : 
; 821  : 	// If an erase rect is overlaped by a non transparent plane 
; 822  : 	// of higher priority, delete the overlap from the erase 
; 823  : 	// list for this plane
; 824  : 	BreakEraseListByPlanes(eraseList,nextPlanesList);

  01ef3	8b 45 0c	 mov	 eax, DWORD PTR _nextPlanesList$[ebp]
  01ef6	50		 push	 eax
  01ef7	8b 4d 14	 mov	 ecx, DWORD PTR _eraseList$[ebp]
  01efa	51		 push	 ecx
  01efb	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01efe	e8 00 00 00 00	 call	 ?BreakEraseListByPlanes@SOL_Plane@@IAEXAAVRectList@@AAVPlaneList@@@Z ; SOL_Plane::BreakEraseListByPlanes

; 825  : 
; 826  : 	// If a draw rect is overlaped by a non transparent plane 
; 827  : 	// of higher priority, delete the overlap from the erase 
; 828  : 	// list for this plane
; 829  : 	BreakDrawListByPlanes(drawList,nextPlanesList);

  01f03	8b 55 0c	 mov	 edx, DWORD PTR _nextPlanesList$[ebp]
  01f06	52		 push	 edx
  01f07	8b 45 10	 mov	 eax, DWORD PTR _drawList$[ebp]
  01f0a	50		 push	 eax
  01f0b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01f0e	e8 00 00 00 00	 call	 ?BreakDrawListByPlanes@SOL_Plane@@IAEXAAVDrawList@@AAVPlaneList@@@Z ; SOL_Plane::BreakDrawListByPlanes

; 830  : 	redrawAllCount--;

  01f13	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01f16	8b 51 78	 mov	 edx, DWORD PTR [ecx+120]
  01f19	83 ea 01	 sub	 edx, 1
  01f1c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  01f1f	89 50 78	 mov	 DWORD PTR [eax+120], edx

; 831  : 	DecSIArrayCounts(last,True);

  01f22	6a 01		 push	 1
  01f24	8b 4d 08	 mov	 ecx, DWORD PTR _last$[ebp]
  01f27	51		 push	 ecx
  01f28	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01f2b	e8 00 00 00 00	 call	 ?DecSIArrayCounts@SOL_Plane@@IAEXPAV1@H@Z ; SOL_Plane::DecSIArrayCounts

; 832  : 	siArray.Pack();

  01f30	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01f33	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01f36	e8 00 00 00 00	 call	 ?Pack@ScreenItemList@@QAEXXZ ; ScreenItemList::Pack

; 833  :    if (last != NULL) {

  01f3b	83 7d 08 00	 cmp	 DWORD PTR _last$[ebp], 0
  01f3f	74 13		 je	 SHORT $L62068

; 834  : 	   ScreenItemList& lastList = last->SIList();

  01f41	8b 4d 08	 mov	 ecx, DWORD PTR _last$[ebp]
  01f44	e8 00 00 00 00	 call	 ?SIList@SOL_Plane@@QAEAAVScreenItemList@@XZ ; SOL_Plane::SIList
  01f49	89 45 f4	 mov	 DWORD PTR _lastList$62069[ebp], eax

; 835  : 	   lastList.Pack();

  01f4c	8b 4d f4	 mov	 ecx, DWORD PTR _lastList$62069[ebp]
  01f4f	e8 00 00 00 00	 call	 ?Pack@ScreenItemList@@QAEXXZ ; ScreenItemList::Pack
$L62068:

; 837  : }

  01f54	8b e5		 mov	 esp, ebp
  01f56	5d		 pop	 ebp
  01f57	c2 10 00	 ret	 16			; 00000010H
?RedrawAll@SOL_Plane@@QAEXPAV1@AAVPlaneList@@AAVDrawList@@AAVRectList@@@Z ENDP ; SOL_Plane::RedrawAll
_TEXT	ENDS
PUBLIC	?RemapState@ScreenItem@@QAEHXZ			; ScreenItem::RemapState
PUBLIC	?RemapMarkRedraw@SOL_Plane@@QAEXXZ		; SOL_Plane::RemapMarkRedraw
_TEXT	SEGMENT
_this$ = -12
_count$ = -4
_i$ = -8
?RemapMarkRedraw@SOL_Plane@@QAEXXZ PROC NEAR		; SOL_Plane::RemapMarkRedraw

; 841  : {

  01f5a	55		 push	 ebp
  01f5b	8b ec		 mov	 ebp, esp
  01f5d	83 ec 0c	 sub	 esp, 12			; 0000000cH
  01f60	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 842  :    int count = siArray.Length();

  01f63	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  01f66	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01f69	e8 00 00 00 00	 call	 ?Length@ScreenItemList@@QBEHXZ ; ScreenItemList::Length
  01f6e	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 843  : 	for (int i = 0; i < count; i++) {

  01f71	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  01f78	eb 09		 jmp	 SHORT $L62075
$L62076:
  01f7a	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01f7d	83 c0 01	 add	 eax, 1
  01f80	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L62075:
  01f83	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  01f86	3b 4d fc	 cmp	 ecx, DWORD PTR _count$[ebp]
  01f89	0f 8d 8e 00 00
	00		 jge	 $L62077

; 845  : 			 !siArray[i].DeleteCount()					&&
; 846  : 			 !siArray[i].AddCount() 					&&	
; 847  : 			 (siArray[i].RemapState() == RemapInCel)) {

  01f8f	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  01f92	52		 push	 edx
  01f93	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  01f96	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01f99	e8 00 00 00 00	 call	 ?Exists@ScreenItemList@@QBEHH@Z ; ScreenItemList::Exists
  01f9e	85 c0		 test	 eax, eax
  01fa0	74 76		 je	 SHORT $L62078
  01fa2	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01fa5	50		 push	 eax
  01fa6	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  01fa9	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01fac	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01fb1	8b c8		 mov	 ecx, eax
  01fb3	e8 00 00 00 00	 call	 ?DeleteCount@ScreenItem@@QBEHXZ ; ScreenItem::DeleteCount
  01fb8	85 c0		 test	 eax, eax
  01fba	75 5c		 jne	 SHORT $L62078
  01fbc	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  01fbf	51		 push	 ecx
  01fc0	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  01fc3	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01fc6	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01fcb	8b c8		 mov	 ecx, eax
  01fcd	e8 00 00 00 00	 call	 ?AddCount@ScreenItem@@QBEHXZ ; ScreenItem::AddCount
  01fd2	85 c0		 test	 eax, eax
  01fd4	75 42		 jne	 SHORT $L62078
  01fd6	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  01fd9	52		 push	 edx
  01fda	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  01fdd	83 c1 7c	 add	 ecx, 124		; 0000007cH
  01fe0	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  01fe5	8b c8		 mov	 ecx, eax
  01fe7	e8 00 00 00 00	 call	 ?RemapState@ScreenItem@@QAEHXZ ; ScreenItem::RemapState
  01fec	83 f8 01	 cmp	 eax, 1
  01fef	75 27		 jne	 SHORT $L62078

; 848  :  
; 849  : 	      siArray[i].SetUpdateCount(graphMgr->ScreenCount());

  01ff1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  01ff6	8b 10		 mov	 edx, DWORD PTR [eax]
  01ff8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  01ffe	ff 52 04	 call	 DWORD PTR [edx+4]
  02001	50		 push	 eax
  02002	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  02005	50		 push	 eax
  02006	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  02009	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0200c	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  02011	8b c8		 mov	 ecx, eax
  02013	e8 00 00 00 00	 call	 ?SetUpdateCount@ScreenItem@@QAEXH@Z ; ScreenItem::SetUpdateCount
$L62078:

; 851  : 	}

  02018	e9 5d ff ff ff	 jmp	 $L62076
$L62077:

; 852  : }

  0201d	8b e5		 mov	 esp, ebp
  0201f	5d		 pop	 ebp
  02020	c3		 ret	 0
?RemapMarkRedraw@SOL_Plane@@QAEXXZ ENDP			; SOL_Plane::RemapMarkRedraw
_TEXT	ENDS
PUBLIC	?RemapState@CelObj@@QBEHXZ			; CelObj::RemapState
;	COMDAT ?RemapState@ScreenItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?RemapState@ScreenItem@@QAEHXZ PROC NEAR		; ScreenItem::RemapState, COMDAT

; 92   : 	int			RemapState()  				{GetCelObj(); return cel->RemapState();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetCelObj@ScreenItem@@QAEXXZ ; ScreenItem::GetCelObj
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00015	e8 00 00 00 00	 call	 ?RemapState@CelObj@@QBEHXZ ; CelObj::RemapState
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?RemapState@ScreenItem@@QAEHXZ ENDP			; ScreenItem::RemapState
_TEXT	ENDS
;	COMDAT ?RemapState@CelObj@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?RemapState@CelObj@@QBEHXZ PROC NEAR			; CelObj::RemapState, COMDAT

; 186  : 	int	RemapState() const	{return remapState;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 44	 mov	 eax, DWORD PTR [eax+68]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?RemapState@CelObj@@QBEHXZ ENDP				; CelObj::RemapState
_TEXT	ENDS
PUBLIC	?Length@PlaneList@@QBEHXZ			; PlaneList::Length
PUBLIC	??APlaneList@@QAEAAVSOL_Plane@@H@Z		; PlaneList::operator[]
PUBLIC	?IsTransparent@SOL_Plane@@QBEHXZ		; SOL_Plane::IsTransparent
PUBLIC	?IsPictureSkip@SOL_Plane@@QBEHXZ		; SOL_Plane::IsPictureSkip
PUBLIC	?OnScreen@SOL_Plane@@QAEAAVSOL_Rect@@XZ		; SOL_Plane::OnScreen
EXTRN	?Search@PlaneList@@QBEHI@Z:NEAR			; PlaneList::Search
EXTRN	?Delete@DrawList@@QAEXH@Z:NEAR			; DrawList::Delete
EXTRN	?Pack@DrawList@@QAEXXZ:NEAR			; DrawList::Pack
EXTRN	?Split@SOL_Rect@@QAEHAAV1@PAV1@@Z:NEAR		; SOL_Rect::Split
_TEXT	SEGMENT
_drawList$ = 8
_nextPlanesList$ = 12
_this$ = -88
_rects$ = -72
_nextPlanesListSize$ = -4
_nextHigherPlane$ = -76
_i$ = -8
_j$62092 = -80
_newRects$62097 = -84
?BreakDrawListByPlanes@SOL_Plane@@IAEXAAVDrawList@@AAVPlaneList@@@Z PROC NEAR ; SOL_Plane::BreakDrawListByPlanes

; 856  : {

  02021	55		 push	 ebp
  02022	8b ec		 mov	 ebp, esp
  02024	83 ec 58	 sub	 esp, 88			; 00000058H
  02027	89 4d a8	 mov	 DWORD PTR _this$[ebp], ecx

; 857  : 	//	Go through the drawList and break apart members intersecting
; 858  : 	//	higher priority planes in the PlaneList.
; 859  : 
; 860  : 	SOL_Rect rects[4];

  0202a	68 00 00 00 00	 push	 OFFSET FLAT:??0SOL_Rect@@QAE@XZ ; SOL_Rect::SOL_Rect
  0202f	6a 04		 push	 4
  02031	6a 10		 push	 16			; 00000010H
  02033	8d 45 b8	 lea	 eax, DWORD PTR _rects$[ebp]
  02036	50		 push	 eax
  02037	e8 00 00 00 00	 call	 ??_H@YGXPAXIHP6EX0@Z@Z	; `vector constructor iterator'

; 861  : 
; 862  : 	int nextPlanesListSize = nextPlanesList.Length();

  0203c	8b 4d 0c	 mov	 ecx, DWORD PTR _nextPlanesList$[ebp]
  0203f	e8 00 00 00 00	 call	 ?Length@PlaneList@@QBEHXZ ; PlaneList::Length
  02044	89 45 fc	 mov	 DWORD PTR _nextPlanesListSize$[ebp], eax

; 863  : 
; 864  : 	// Start from the next higher plane
; 865  : 	int nextHigherPlane = nextPlanesList.Search(planeId) + 1;

  02047	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  0204a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0204c	52		 push	 edx
  0204d	8b 4d 0c	 mov	 ecx, DWORD PTR _nextPlanesList$[ebp]
  02050	e8 00 00 00 00	 call	 ?Search@PlaneList@@QBEHI@Z ; PlaneList::Search
  02055	83 c0 01	 add	 eax, 1
  02058	89 45 b4	 mov	 DWORD PTR _nextHigherPlane$[ebp], eax

; 866  : 
; 867  : 	for (int i=0;i< drawList.Length(); ++i) {

  0205b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  02062	eb 09		 jmp	 SHORT $L62089
$L62090:
  02064	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  02067	83 c0 01	 add	 eax, 1
  0206a	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L62089:
  0206d	8b 4d 08	 mov	 ecx, DWORD PTR _drawList$[ebp]
  02070	e8 00 00 00 00	 call	 ?Length@DrawList@@QBEHXZ ; DrawList::Length
  02075	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  02078	0f 8d df 00 00
	00		 jge	 $L62091

; 868  : 		// See if intersected by a plane of higher priority
; 869  : 		for (int j=nextHigherPlane;j<nextPlanesListSize;++j) {

  0207e	8b 4d b4	 mov	 ecx, DWORD PTR _nextHigherPlane$[ebp]
  02081	89 4d b0	 mov	 DWORD PTR _j$62092[ebp], ecx
  02084	eb 09		 jmp	 SHORT $L62093
$L62094:
  02086	8b 55 b0	 mov	 edx, DWORD PTR _j$62092[ebp]
  02089	83 c2 01	 add	 edx, 1
  0208c	89 55 b0	 mov	 DWORD PTR _j$62092[ebp], edx
$L62093:
  0208f	8b 45 b0	 mov	 eax, DWORD PTR _j$62092[ebp]
  02092	3b 45 fc	 cmp	 eax, DWORD PTR _nextPlanesListSize$[ebp]
  02095	0f 8d bd 00 00
	00		 jge	 $L62095

; 871  : 				 !nextPlanesList[j].IsPictureSkip()) {

  0209b	8b 4d b0	 mov	 ecx, DWORD PTR _j$62092[ebp]
  0209e	51		 push	 ecx
  0209f	8b 4d 0c	 mov	 ecx, DWORD PTR _nextPlanesList$[ebp]
  020a2	e8 00 00 00 00	 call	 ??APlaneList@@QAEAAVSOL_Plane@@H@Z ; PlaneList::operator[]
  020a7	8b c8		 mov	 ecx, eax
  020a9	e8 00 00 00 00	 call	 ?IsTransparent@SOL_Plane@@QBEHXZ ; SOL_Plane::IsTransparent
  020ae	85 c0		 test	 eax, eax
  020b0	0f 85 9d 00 00
	00		 jne	 $L62098
  020b6	8b 55 b0	 mov	 edx, DWORD PTR _j$62092[ebp]
  020b9	52		 push	 edx
  020ba	8b 4d 0c	 mov	 ecx, DWORD PTR _nextPlanesList$[ebp]
  020bd	e8 00 00 00 00	 call	 ??APlaneList@@QAEAAVSOL_Plane@@H@Z ; PlaneList::operator[]
  020c2	8b c8		 mov	 ecx, eax
  020c4	e8 00 00 00 00	 call	 ?IsPictureSkip@SOL_Plane@@QBEHXZ ; SOL_Plane::IsPictureSkip
  020c9	85 c0		 test	 eax, eax
  020cb	0f 85 82 00 00
	00		 jne	 $L62098

; 872  : 				int newRects = drawList[i].OnScreen().Split
; 873  : 					(
; 874  : 					nextPlanesList[j].OnScreen(),
; 875  : 					rects
; 876  : 					);

  020d1	8d 45 b8	 lea	 eax, DWORD PTR _rects$[ebp]
  020d4	50		 push	 eax
  020d5	8b 4d b0	 mov	 ecx, DWORD PTR _j$62092[ebp]
  020d8	51		 push	 ecx
  020d9	8b 4d 0c	 mov	 ecx, DWORD PTR _nextPlanesList$[ebp]
  020dc	e8 00 00 00 00	 call	 ??APlaneList@@QAEAAVSOL_Plane@@H@Z ; PlaneList::operator[]
  020e1	8b c8		 mov	 ecx, eax
  020e3	e8 00 00 00 00	 call	 ?OnScreen@SOL_Plane@@QAEAAVSOL_Rect@@XZ ; SOL_Plane::OnScreen
  020e8	50		 push	 eax
  020e9	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  020ec	52		 push	 edx
  020ed	8b 4d 08	 mov	 ecx, DWORD PTR _drawList$[ebp]
  020f0	e8 00 00 00 00	 call	 ??ADrawList@@QAEAAVDrawItem@@H@Z ; DrawList::operator[]
  020f5	8b c8		 mov	 ecx, eax
  020f7	e8 00 00 00 00	 call	 ?OnScreen@DrawItem@@QAEAAVSOL_Rect@@XZ ; DrawItem::OnScreen
  020fc	8b c8		 mov	 ecx, eax
  020fe	e8 00 00 00 00	 call	 ?Split@SOL_Rect@@QAEHAAV1@PAV1@@Z ; SOL_Rect::Split
  02103	89 45 ac	 mov	 DWORD PTR _newRects$62097[ebp], eax

; 877  : 				if (newRects != -1) {

  02106	83 7d ac ff	 cmp	 DWORD PTR _newRects$62097[ebp], -1
  0210a	74 47		 je	 SHORT $L62098
$L62100:

; 878  : 					// Eliminate this screenItem and add newRects new ones
; 879  : 					while (newRects--) {

  0210c	8b 45 ac	 mov	 eax, DWORD PTR _newRects$62097[ebp]
  0210f	8b 4d ac	 mov	 ecx, DWORD PTR _newRects$62097[ebp]
  02112	83 e9 01	 sub	 ecx, 1
  02115	89 4d ac	 mov	 DWORD PTR _newRects$62097[ebp], ecx
  02118	85 c0		 test	 eax, eax
  0211a	74 29		 je	 SHORT $L62101

; 880  : 						// Add to the drawList
; 881  : 						drawList.Add(&drawList[i].SI(),rects[newRects]);

  0211c	8b 55 ac	 mov	 edx, DWORD PTR _newRects$62097[ebp]
  0211f	c1 e2 04	 shl	 edx, 4
  02122	8d 44 15 b8	 lea	 eax, DWORD PTR _rects$[ebp+edx]
  02126	50		 push	 eax
  02127	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0212a	51		 push	 ecx
  0212b	8b 4d 08	 mov	 ecx, DWORD PTR _drawList$[ebp]
  0212e	e8 00 00 00 00	 call	 ??ADrawList@@QAEAAVDrawItem@@H@Z ; DrawList::operator[]
  02133	8b c8		 mov	 ecx, eax
  02135	e8 00 00 00 00	 call	 ?SI@DrawItem@@QAEAAVScreenItem@@XZ ; DrawItem::SI
  0213a	50		 push	 eax
  0213b	8b 4d 08	 mov	 ecx, DWORD PTR _drawList$[ebp]
  0213e	e8 00 00 00 00	 call	 ?Add@DrawList@@QAEHPAVScreenItem@@AAVSOL_Rect@@@Z ; DrawList::Add

; 882  : 					}

  02143	eb c7		 jmp	 SHORT $L62100
$L62101:

; 883  : 					drawList.Delete(i);

  02145	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  02148	52		 push	 edx
  02149	8b 4d 08	 mov	 ecx, DWORD PTR _drawList$[ebp]
  0214c	e8 00 00 00 00	 call	 ?Delete@DrawList@@QAEXH@Z ; DrawList::Delete

; 884  : 					break;

  02151	eb 05		 jmp	 SHORT $L62095
$L62098:

; 887  : 		}

  02153	e9 2e ff ff ff	 jmp	 $L62094
$L62095:

; 888  : 	}

  02158	e9 07 ff ff ff	 jmp	 $L62090
$L62091:

; 889  : 
; 890  : 	// Pack the drawList to get rid of deleted screenItems.
; 891  : 	drawList.Pack();

  0215d	8b 4d 08	 mov	 ecx, DWORD PTR _drawList$[ebp]
  02160	e8 00 00 00 00	 call	 ?Pack@DrawList@@QAEXXZ	; DrawList::Pack

; 892  : }

  02165	8b e5		 mov	 esp, ebp
  02167	5d		 pop	 ebp
  02168	c2 08 00	 ret	 8
?BreakDrawListByPlanes@SOL_Plane@@IAEXAAVDrawList@@AAVPlaneList@@@Z ENDP ; SOL_Plane::BreakDrawListByPlanes
_TEXT	ENDS
;	COMDAT ?IsTransparent@SOL_Plane@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsTransparent@SOL_Plane@@QBEHXZ PROC NEAR		; SOL_Plane::IsTransparent, COMDAT

; 73   : 	Bool				IsTransparent() const	{return (type == transparentPlane);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	83 78 04 02	 cmp	 DWORD PTR [eax+4], 2
  00010	0f 94 c1	 sete	 cl
  00013	8b c1		 mov	 eax, ecx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?IsTransparent@SOL_Plane@@QBEHXZ ENDP			; SOL_Plane::IsTransparent
_TEXT	ENDS
;	COMDAT ?IsPictureSkip@SOL_Plane@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPictureSkip@SOL_Plane@@QBEHXZ PROC NEAR		; SOL_Plane::IsPictureSkip, COMDAT

; 74   : 	Bool				IsPictureSkip() const	{return (type == pictureSkipPlane);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	83 78 04 04	 cmp	 DWORD PTR [eax+4], 4
  00010	0f 94 c1	 sete	 cl
  00013	8b c1		 mov	 eax, ecx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?IsPictureSkip@SOL_Plane@@QBEHXZ ENDP			; SOL_Plane::IsPictureSkip
_TEXT	ENDS
;	COMDAT ?OnScreen@SOL_Plane@@QAEAAVSOL_Rect@@XZ
_TEXT	SEGMENT
_this$ = -4
?OnScreen@SOL_Plane@@QAEAAVSOL_Rect@@XZ PROC NEAR	; SOL_Plane::OnScreen, COMDAT

; 80   : 	SOL_Rect&		OnScreen()					{return onScreen;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 4c	 add	 eax, 76			; 0000004cH
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?OnScreen@SOL_Plane@@QAEAAVSOL_Rect@@XZ ENDP		; SOL_Plane::OnScreen
_TEXT	ENDS
;	COMDAT ?Length@PlaneList@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Length@PlaneList@@QBEHXZ PROC NEAR			; PlaneList::Length, COMDAT

; 22   : 	int	Length() const								{return length;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 80 90 01 00
	00		 mov	 eax, DWORD PTR [eax+400]
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?Length@PlaneList@@QBEHXZ ENDP				; PlaneList::Length
_TEXT	ENDS
;	COMDAT ??APlaneList@@QAEAAVSOL_Plane@@H@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
??APlaneList@@QAEAAVSOL_Plane@@H@Z PROC NEAR		; PlaneList::operator[], COMDAT

; 29   : 	SOL_Plane& operator[](int index) 					{return *planeArray[index];}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??APlaneList@@QAEAAVSOL_Plane@@H@Z ENDP			; PlaneList::operator[]
_TEXT	ENDS
EXTRN	?Delete@RectList@@QAEXH@Z:NEAR			; RectList::Delete
EXTRN	?Pack@RectList@@QAEHXZ:NEAR			; RectList::Pack
_TEXT	SEGMENT
_eraseList$ = 8
_nextPlanesList$ = 12
_this$ = -88
_rects$ = -72
_nextPlanesListSize$ = -4
_nextHigherPlane$ = -76
_i$ = -8
_j$62115 = -80
_newRects$62120 = -84
?BreakEraseListByPlanes@SOL_Plane@@IAEXAAVRectList@@AAVPlaneList@@@Z PROC NEAR ; SOL_Plane::BreakEraseListByPlanes

; 896  : {

  0216b	55		 push	 ebp
  0216c	8b ec		 mov	 ebp, esp
  0216e	83 ec 58	 sub	 esp, 88			; 00000058H
  02171	89 4d a8	 mov	 DWORD PTR _this$[ebp], ecx

; 897  : 	//	Go through the eraseList and break apart members intersecting
; 898  : 	//	higher priority planes in the PlaneList.
; 899  : 
; 900  : 	SOL_Rect rects[4];

  02174	68 00 00 00 00	 push	 OFFSET FLAT:??0SOL_Rect@@QAE@XZ ; SOL_Rect::SOL_Rect
  02179	6a 04		 push	 4
  0217b	6a 10		 push	 16			; 00000010H
  0217d	8d 45 b8	 lea	 eax, DWORD PTR _rects$[ebp]
  02180	50		 push	 eax
  02181	e8 00 00 00 00	 call	 ??_H@YGXPAXIHP6EX0@Z@Z	; `vector constructor iterator'

; 901  : 	int nextPlanesListSize = nextPlanesList.Length();

  02186	8b 4d 0c	 mov	 ecx, DWORD PTR _nextPlanesList$[ebp]
  02189	e8 00 00 00 00	 call	 ?Length@PlaneList@@QBEHXZ ; PlaneList::Length
  0218e	89 45 fc	 mov	 DWORD PTR _nextPlanesListSize$[ebp], eax

; 902  : 
; 903  : 	// Start from the next higher plane
; 904  : 	int nextHigherPlane = nextPlanesList.Search(planeId) + 1;

  02191	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  02194	8b 11		 mov	 edx, DWORD PTR [ecx]
  02196	52		 push	 edx
  02197	8b 4d 0c	 mov	 ecx, DWORD PTR _nextPlanesList$[ebp]
  0219a	e8 00 00 00 00	 call	 ?Search@PlaneList@@QBEHI@Z ; PlaneList::Search
  0219f	83 c0 01	 add	 eax, 1
  021a2	89 45 b4	 mov	 DWORD PTR _nextHigherPlane$[ebp], eax

; 905  : 
; 906  : 	for (int i=0;i< eraseList.Length();++i) {

  021a5	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  021ac	eb 09		 jmp	 SHORT $L62112
$L62113:
  021ae	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  021b1	83 c0 01	 add	 eax, 1
  021b4	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L62112:
  021b7	8b 4d 08	 mov	 ecx, DWORD PTR _eraseList$[ebp]
  021ba	e8 00 00 00 00	 call	 ?Length@RectList@@QBEHXZ ; RectList::Length
  021bf	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  021c2	0f 8d bc 00 00
	00		 jge	 $L62114

; 907  : 		// See if intersected by a plane of higher priority
; 908  : 		for (int j=nextHigherPlane;j<nextPlanesListSize;++j) {

  021c8	8b 4d b4	 mov	 ecx, DWORD PTR _nextHigherPlane$[ebp]
  021cb	89 4d b0	 mov	 DWORD PTR _j$62115[ebp], ecx
  021ce	eb 09		 jmp	 SHORT $L62116
$L62117:
  021d0	8b 55 b0	 mov	 edx, DWORD PTR _j$62115[ebp]
  021d3	83 c2 01	 add	 edx, 1
  021d6	89 55 b0	 mov	 DWORD PTR _j$62115[ebp], edx
$L62116:
  021d9	8b 45 b0	 mov	 eax, DWORD PTR _j$62115[ebp]
  021dc	3b 45 fc	 cmp	 eax, DWORD PTR _nextPlanesListSize$[ebp]
  021df	0f 8d 9a 00 00
	00		 jge	 $L62118

; 910  : 				 !nextPlanesList[j].IsPictureSkip()) {

  021e5	8b 4d b0	 mov	 ecx, DWORD PTR _j$62115[ebp]
  021e8	51		 push	 ecx
  021e9	8b 4d 0c	 mov	 ecx, DWORD PTR _nextPlanesList$[ebp]
  021ec	e8 00 00 00 00	 call	 ??APlaneList@@QAEAAVSOL_Plane@@H@Z ; PlaneList::operator[]
  021f1	8b c8		 mov	 ecx, eax
  021f3	e8 00 00 00 00	 call	 ?IsTransparent@SOL_Plane@@QBEHXZ ; SOL_Plane::IsTransparent
  021f8	85 c0		 test	 eax, eax
  021fa	75 7e		 jne	 SHORT $L62121
  021fc	8b 55 b0	 mov	 edx, DWORD PTR _j$62115[ebp]
  021ff	52		 push	 edx
  02200	8b 4d 0c	 mov	 ecx, DWORD PTR _nextPlanesList$[ebp]
  02203	e8 00 00 00 00	 call	 ??APlaneList@@QAEAAVSOL_Plane@@H@Z ; PlaneList::operator[]
  02208	8b c8		 mov	 ecx, eax
  0220a	e8 00 00 00 00	 call	 ?IsPictureSkip@SOL_Plane@@QBEHXZ ; SOL_Plane::IsPictureSkip
  0220f	85 c0		 test	 eax, eax
  02211	75 67		 jne	 SHORT $L62121

; 911  : 				int newRects = eraseList[i].Split
; 912  : 					(
; 913  : 					nextPlanesList[j].OnScreen(),
; 914  : 					rects
; 915  : 					);

  02213	8d 45 b8	 lea	 eax, DWORD PTR _rects$[ebp]
  02216	50		 push	 eax
  02217	8b 4d b0	 mov	 ecx, DWORD PTR _j$62115[ebp]
  0221a	51		 push	 ecx
  0221b	8b 4d 0c	 mov	 ecx, DWORD PTR _nextPlanesList$[ebp]
  0221e	e8 00 00 00 00	 call	 ??APlaneList@@QAEAAVSOL_Plane@@H@Z ; PlaneList::operator[]
  02223	8b c8		 mov	 ecx, eax
  02225	e8 00 00 00 00	 call	 ?OnScreen@SOL_Plane@@QAEAAVSOL_Rect@@XZ ; SOL_Plane::OnScreen
  0222a	50		 push	 eax
  0222b	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0222e	52		 push	 edx
  0222f	8b 4d 08	 mov	 ecx, DWORD PTR _eraseList$[ebp]
  02232	e8 00 00 00 00	 call	 ??ARectList@@QAEAAVSOL_Rect@@H@Z ; RectList::operator[]
  02237	8b c8		 mov	 ecx, eax
  02239	e8 00 00 00 00	 call	 ?Split@SOL_Rect@@QAEHAAV1@PAV1@@Z ; SOL_Rect::Split
  0223e	89 45 ac	 mov	 DWORD PTR _newRects$62120[ebp], eax

; 916  : 				if (newRects != -1) {

  02241	83 7d ac ff	 cmp	 DWORD PTR _newRects$62120[ebp], -1
  02245	74 33		 je	 SHORT $L62121
$L62123:

; 917  : 					// Eliminate this screenItem and add newRects new ones
; 918  : 					while (newRects--) {

  02247	8b 45 ac	 mov	 eax, DWORD PTR _newRects$62120[ebp]
  0224a	8b 4d ac	 mov	 ecx, DWORD PTR _newRects$62120[ebp]
  0224d	83 e9 01	 sub	 ecx, 1
  02250	89 4d ac	 mov	 DWORD PTR _newRects$62120[ebp], ecx
  02253	85 c0		 test	 eax, eax
  02255	74 15		 je	 SHORT $L62124

; 919  : 						// Add to the eraseList
; 920  : 						eraseList.Add(rects[newRects]);

  02257	8b 55 ac	 mov	 edx, DWORD PTR _newRects$62120[ebp]
  0225a	c1 e2 04	 shl	 edx, 4
  0225d	8d 44 15 b8	 lea	 eax, DWORD PTR _rects$[ebp+edx]
  02261	50		 push	 eax
  02262	8b 4d 08	 mov	 ecx, DWORD PTR _eraseList$[ebp]
  02265	e8 00 00 00 00	 call	 ?Add@RectList@@QAEXABVSOL_Rect@@@Z ; RectList::Add

; 921  : 					}

  0226a	eb db		 jmp	 SHORT $L62123
$L62124:

; 922  : 					eraseList.Delete(i);

  0226c	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0226f	51		 push	 ecx
  02270	8b 4d 08	 mov	 ecx, DWORD PTR _eraseList$[ebp]
  02273	e8 00 00 00 00	 call	 ?Delete@RectList@@QAEXH@Z ; RectList::Delete

; 923  : 					break;

  02278	eb 05		 jmp	 SHORT $L62118
$L62121:

; 926  : 		}

  0227a	e9 51 ff ff ff	 jmp	 $L62117
$L62118:

; 927  : 	}

  0227f	e9 2a ff ff ff	 jmp	 $L62113
$L62114:

; 928  : 	// Pack the eraseList to get rid of deleted rectangles.
; 929  : 	eraseList.Pack();

  02284	8b 4d 08	 mov	 ecx, DWORD PTR _eraseList$[ebp]
  02287	e8 00 00 00 00	 call	 ?Pack@RectList@@QAEHXZ	; RectList::Pack

; 930  : }

  0228c	8b e5		 mov	 esp, ebp
  0228e	5d		 pop	 ebp
  0228f	c2 08 00	 ret	 8
?BreakEraseListByPlanes@SOL_Plane@@IAEXAAVRectList@@AAVPlaneList@@@Z ENDP ; SOL_Plane::BreakEraseListByPlanes
_TEXT	ENDS
PUBLIC	?DecUpdateCount@ScreenItem@@QAEXXZ		; ScreenItem::DecUpdateCount
PUBLIC	?DecAddCount@ScreenItem@@QAEXXZ			; ScreenItem::DecAddCount
PUBLIC	?DecDeleteCount@ScreenItem@@QAEXXZ		; ScreenItem::DecDeleteCount
EXTRN	?Search@ScreenItemList@@QBEHPBVScreenItem@@@Z:NEAR ; ScreenItemList::Search
EXTRN	?Delete@ScreenItemList@@QAEXH@Z:NEAR		; ScreenItemList::Delete
EXTRN	??0ScreenItem@@QAE@PBV0@@Z:NEAR			; ScreenItem::ScreenItem
EXTRN	??4ScreenItem@@QAEAAV0@ABV0@@Z:NEAR		; ScreenItem::operator=
xdata$x	SEGMENT
$T62751	DD	019930520H
	DD	01H
	DD	FLAT:$T62753
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T62753	DD	0ffffffffH
	DD	FLAT:$L62749
xdata$x	ENDS
_TEXT	SEGMENT
$T62745 = -32
$T62746 = -36
__$EHRec$ = -12
_last$ = 8
_forceUpdate$ = 12
_this$ = -40
_lastList$ = -20
_siArraySize$ = -16
_i$ = -24
_siCopy$62142 = -28
?DecSIArrayCounts@SOL_Plane@@IAEXPAV1@H@Z PROC NEAR	; SOL_Plane::DecSIArrayCounts

; 935  : {

  02292	55		 push	 ebp
  02293	8b ec		 mov	 ebp, esp
  02295	6a ff		 push	 -1
  02297	68 00 00 00 00	 push	 $L62752
  0229c	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  022a2	50		 push	 eax
  022a3	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  022aa	83 ec 20	 sub	 esp, 32			; 00000020H
  022ad	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx

; 936  : 	//  Decrement counts if needed to reflect processed
; 937  : 	//  Also updates the siArray lists for the last screen
; 938  : 
; 939  : 	ScreenItemList& lastList = last->SIList();

  022b0	8b 4d 08	 mov	 ecx, DWORD PTR _last$[ebp]
  022b3	e8 00 00 00 00	 call	 ?SIList@SOL_Plane@@QAEAAVScreenItemList@@XZ ; SOL_Plane::SIList
  022b8	89 45 ec	 mov	 DWORD PTR _lastList$[ebp], eax

; 940  : 
; 941  : 	int siArraySize = siArray.Length();

  022bb	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  022be	83 c1 7c	 add	 ecx, 124		; 0000007cH
  022c1	e8 00 00 00 00	 call	 ?Length@ScreenItemList@@QBEHXZ ; ScreenItemList::Length
  022c6	89 45 f0	 mov	 DWORD PTR _siArraySize$[ebp], eax

; 942  : 	for (int i = 0; i < siArraySize; ++i) {

  022c9	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  022d0	eb 09		 jmp	 SHORT $L62133
$L62134:
  022d2	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  022d5	83 c0 01	 add	 eax, 1
  022d8	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax
$L62133:
  022db	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  022de	3b 4d f0	 cmp	 ecx, DWORD PTR _siArraySize$[ebp]
  022e1	0f 8d ca 01 00
	00		 jge	 $L62135

; 943  : 		if (siArray.Exists(i))  {

  022e7	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  022ea	52		 push	 edx
  022eb	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  022ee	83 c1 7c	 add	 ecx, 124		; 0000007cH
  022f1	e8 00 00 00 00	 call	 ?Exists@ScreenItemList@@QBEHH@Z ; ScreenItemList::Exists
  022f6	85 c0		 test	 eax, eax
  022f8	0f 84 ae 01 00
	00		 je	 $L62148

; 945  : 				 (
; 946  : 				 forceUpdate 											&& 
; 947  : 				 (last != NULL) 										&&
; 948  : 				 (last->SIList().Search(&siArray[i]) != -1)
; 949  : 				 )) {

  022fe	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  02301	50		 push	 eax
  02302	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  02305	83 c1 7c	 add	 ecx, 124		; 0000007cH
  02308	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  0230d	8b c8		 mov	 ecx, eax
  0230f	e8 00 00 00 00	 call	 ?UpdateCount@ScreenItem@@QBEHXZ ; ScreenItem::UpdateCount
  02314	85 c0		 test	 eax, eax
  02316	75 30		 jne	 SHORT $L62138
  02318	83 7d 0c 00	 cmp	 DWORD PTR _forceUpdate$[ebp], 0
  0231c	74 4d		 je	 SHORT $L62137
  0231e	83 7d 08 00	 cmp	 DWORD PTR _last$[ebp], 0
  02322	74 47		 je	 SHORT $L62137
  02324	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  02327	51		 push	 ecx
  02328	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0232b	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0232e	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  02333	50		 push	 eax
  02334	8b 4d 08	 mov	 ecx, DWORD PTR _last$[ebp]
  02337	e8 00 00 00 00	 call	 ?SIList@SOL_Plane@@QAEAAVScreenItemList@@XZ ; SOL_Plane::SIList
  0233c	8b c8		 mov	 ecx, eax
  0233e	e8 00 00 00 00	 call	 ?Search@ScreenItemList@@QBEHPBVScreenItem@@@Z ; ScreenItemList::Search
  02343	83 f8 ff	 cmp	 eax, -1
  02346	74 23		 je	 SHORT $L62137
$L62138:

; 950  : 			
; 951  : 				// The assigment operator is designed
; 952  : 				// for specifically to update the 
; 953  : 				// screenitems data in the previous
; 954  : 				// screen
; 955  : 				lastList[i] = siArray[i];

  02348	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  0234b	52		 push	 edx
  0234c	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0234f	83 c1 7c	 add	 ecx, 124		; 0000007cH
  02352	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  02357	50		 push	 eax
  02358	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  0235b	50		 push	 eax
  0235c	8b 4d ec	 mov	 ecx, DWORD PTR _lastList$[ebp]
  0235f	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  02364	8b c8		 mov	 ecx, eax
  02366	e8 00 00 00 00	 call	 ??4ScreenItem@@QAEAAV0@ABV0@@Z ; ScreenItem::operator=
$L62137:

; 957  : 
; 958  : 			if (siArray[i].UpdateCount()) {

  0236b	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  0236e	51		 push	 ecx
  0236f	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  02372	83 c1 7c	 add	 ecx, 124		; 0000007cH
  02375	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  0237a	8b c8		 mov	 ecx, eax
  0237c	e8 00 00 00 00	 call	 ?UpdateCount@ScreenItem@@QBEHXZ ; ScreenItem::UpdateCount
  02381	85 c0		 test	 eax, eax
  02383	74 16		 je	 SHORT $L62139

; 959  : 				siArray[i].DecUpdateCount();

  02385	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  02388	52		 push	 edx
  02389	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0238c	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0238f	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  02394	8b c8		 mov	 ecx, eax
  02396	e8 00 00 00 00	 call	 ?DecUpdateCount@ScreenItem@@QAEXXZ ; ScreenItem::DecUpdateCount
$L62139:

; 961  : 
; 962  : 			if (siArray[i].AddCount()) {

  0239b	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  0239e	50		 push	 eax
  0239f	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  023a2	83 c1 7c	 add	 ecx, 124		; 0000007cH
  023a5	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  023aa	8b c8		 mov	 ecx, eax
  023ac	e8 00 00 00 00	 call	 ?AddCount@ScreenItem@@QBEHXZ ; ScreenItem::AddCount
  023b1	85 c0		 test	 eax, eax
  023b3	74 7c		 je	 SHORT $L62141

; 963  : 				siArray[i].DecAddCount();

  023b5	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  023b8	51		 push	 ecx
  023b9	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  023bc	83 c1 7c	 add	 ecx, 124		; 0000007cH
  023bf	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  023c4	8b c8		 mov	 ecx, eax
  023c6	e8 00 00 00 00	 call	 ?DecAddCount@ScreenItem@@QAEXXZ ; ScreenItem::DecAddCount

; 964  : 				// Add the screen item in last screen.
; 965  : 				// The constructor of a screen item from a screen
; 966  : 				// item is designed to put a copy of a screen item
; 967  : 				// into the last screen.
; 968  : 				if (last != NULL) {

  023cb	83 7d 08 00	 cmp	 DWORD PTR _last$[ebp], 0
  023cf	74 60		 je	 SHORT $L62141

; 969  : 					// If the last plane does not yet exist all
; 970  : 					// of the screen items will be copied to
; 971  : 					// the created last plane in Screen::CalcLists()
; 972  : 					ScreenItem* siCopy = New ScreenItem(&siArray[i]);

  023d1	68 98 00 00 00	 push	 152			; 00000098H
  023d6	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  023db	83 c4 04	 add	 esp, 4
  023de	89 45 dc	 mov	 DWORD PTR $T62746[ebp], eax
  023e1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  023e8	83 7d dc 00	 cmp	 DWORD PTR $T62746[ebp], 0
  023ec	74 1d		 je	 SHORT $L62747
  023ee	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  023f1	52		 push	 edx
  023f2	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  023f5	83 c1 7c	 add	 ecx, 124		; 0000007cH
  023f8	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  023fd	50		 push	 eax
  023fe	8b 4d dc	 mov	 ecx, DWORD PTR $T62746[ebp]
  02401	e8 00 00 00 00	 call	 ??0ScreenItem@@QAE@PBV0@@Z ; ScreenItem::ScreenItem
  02406	89 45 d4	 mov	 DWORD PTR -44+[ebp], eax
  02409	eb 07		 jmp	 SHORT $L62748
$L62747:
  0240b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR -44+[ebp], 0
$L62748:
  02412	8b 45 d4	 mov	 eax, DWORD PTR -44+[ebp]
  02415	89 45 e0	 mov	 DWORD PTR $T62745[ebp], eax
  02418	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0241f	8b 4d e0	 mov	 ecx, DWORD PTR $T62745[ebp]
  02422	89 4d e4	 mov	 DWORD PTR _siCopy$62142[ebp], ecx

; 973  : 					lastList.Add(siCopy);

  02425	8b 55 e4	 mov	 edx, DWORD PTR _siCopy$62142[ebp]
  02428	52		 push	 edx
  02429	8b 4d ec	 mov	 ecx, DWORD PTR _lastList$[ebp]
  0242c	e8 00 00 00 00	 call	 ?Add@ScreenItemList@@QAEHPAVScreenItem@@@Z ; ScreenItemList::Add
$L62141:

; 976  : 
; 977  : 			//  Decrement delete count, if it hits zero, remove it from list
; 978  : 			if (siArray[i].DeleteCount())  {

  02431	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  02434	50		 push	 eax
  02435	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  02438	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0243b	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  02440	8b c8		 mov	 ecx, eax
  02442	e8 00 00 00 00	 call	 ?DeleteCount@ScreenItem@@QBEHXZ ; ScreenItem::DeleteCount
  02447	85 c0		 test	 eax, eax
  02449	74 61		 je	 SHORT $L62148

; 979  : 				siArray[i].DecDeleteCount();

  0244b	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  0244e	51		 push	 ecx
  0244f	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  02452	83 c1 7c	 add	 ecx, 124		; 0000007cH
  02455	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  0245a	8b c8		 mov	 ecx, eax
  0245c	e8 00 00 00 00	 call	 ?DecDeleteCount@ScreenItem@@QAEXXZ ; ScreenItem::DecDeleteCount

; 980  : 				if (!siArray[i].DeleteCount()) {

  02461	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  02464	52		 push	 edx
  02465	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  02468	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0246b	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  02470	8b c8		 mov	 ecx, eax
  02472	e8 00 00 00 00	 call	 ?DeleteCount@ScreenItem@@QBEHXZ ; ScreenItem::DeleteCount
  02477	85 c0		 test	 eax, eax
  02479	75 31		 jne	 SHORT $L62148

; 981  : 					// Delete the screen item in last screen
; 982  : 					if ((last != NULL) && lastList.Exists(i))

  0247b	83 7d 08 00	 cmp	 DWORD PTR _last$[ebp], 0
  0247f	74 1c		 je	 SHORT $L62149
  02481	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  02484	50		 push	 eax
  02485	8b 4d ec	 mov	 ecx, DWORD PTR _lastList$[ebp]
  02488	e8 00 00 00 00	 call	 ?Exists@ScreenItemList@@QBEHH@Z ; ScreenItemList::Exists
  0248d	85 c0		 test	 eax, eax
  0248f	74 0c		 je	 SHORT $L62149

; 983  : 						lastList.Delete(i);

  02491	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  02494	51		 push	 ecx
  02495	8b 4d ec	 mov	 ecx, DWORD PTR _lastList$[ebp]
  02498	e8 00 00 00 00	 call	 ?Delete@ScreenItemList@@QAEXH@Z ; ScreenItemList::Delete
$L62149:

; 984  : 					// Delete the screen item in next screen
; 985  : 					siArray.Delete(i);

  0249d	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  024a0	52		 push	 edx
  024a1	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  024a4	83 c1 7c	 add	 ecx, 124		; 0000007cH
  024a7	e8 00 00 00 00	 call	 ?Delete@ScreenItemList@@QAEXH@Z ; ScreenItemList::Delete
$L62148:

; 989  : 	}

  024ac	e9 21 fe ff ff	 jmp	 $L62134
$L62135:

; 990  : }

  024b1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  024b4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  024bb	8b e5		 mov	 esp, ebp
  024bd	5d		 pop	 ebp
  024be	c2 08 00	 ret	 8
_TEXT	ENDS
text$x	SEGMENT
$L62749:
  00082	8b 45 dc	 mov	 eax, DWORD PTR $T62746[ebp]
  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008b	59		 pop	 ecx
  0008c	c3		 ret	 0
$L62752:
  0008d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T62751
  00092	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?DecSIArrayCounts@SOL_Plane@@IAEXPAV1@H@Z ENDP		; SOL_Plane::DecSIArrayCounts
;	COMDAT ?DecUpdateCount@ScreenItem@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?DecUpdateCount@ScreenItem@@QAEXXZ PROC NEAR		; ScreenItem::DecUpdateCount, COMDAT

; 80   : 	void			DecUpdateCount()			{updateCount--;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0000d	83 e9 01	 sub	 ecx, 1
  00010	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00013	89 4a 48	 mov	 DWORD PTR [edx+72], ecx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?DecUpdateCount@ScreenItem@@QAEXXZ ENDP			; ScreenItem::DecUpdateCount
_TEXT	ENDS
;	COMDAT ?DecAddCount@ScreenItem@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?DecAddCount@ScreenItem@@QAEXXZ PROC NEAR		; ScreenItem::DecAddCount, COMDAT

; 81   : 	void			DecAddCount()				{addCount--;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  0000d	83 e9 01	 sub	 ecx, 1
  00010	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00013	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?DecAddCount@ScreenItem@@QAEXXZ ENDP			; ScreenItem::DecAddCount
_TEXT	ENDS
;	COMDAT ?DecDeleteCount@ScreenItem@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?DecDeleteCount@ScreenItem@@QAEXXZ PROC NEAR		; ScreenItem::DecDeleteCount, COMDAT

; 82   : 	void			DecDeleteCount()			{deleteCount--;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  0000d	83 e9 01	 sub	 ecx, 1
  00010	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00013	89 4a 50	 mov	 DWORD PTR [edx+80], ecx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?DecDeleteCount@ScreenItem@@QAEXXZ ENDP			; ScreenItem::DecDeleteCount
_TEXT	ENDS
PUBLIC	?GlobalToLocalGame@@YAHHAAVSOL_Point@@@Z	; GlobalToLocalGame
PUBLIC	?KGlobalToLocal@@YAXPAF@Z			; KGlobalToLocal
PUBLIC	??0ObjectID@@QAE@G@Z				; ObjectID::ObjectID
PUBLIC	?GetIndexedProperty@ObjectID@@QBEFH@Z		; ObjectID::GetIndexedProperty
PUBLIC	?SetIndexedProperty@ObjectID@@QBEXHF@Z		; ObjectID::SetIndexedProperty
EXTRN	?pm@@3VPMachine@@A:BYTE				; pm
_TEXT	SEGMENT
_args$ = 8
_point$ = -12
_evt$ = -4
?KGlobalToLocal@@YAXPAF@Z PROC NEAR			; KGlobalToLocal

; 994  : {

  024c1	55		 push	 ebp
  024c2	8b ec		 mov	 ebp, esp
  024c4	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 995  : 	// Given an SCI plane object, convert the event to local coordinates
; 996  : 	// arg(1) = event
; 997  : 	//	arg(2) = plane
; 998  : 
; 999  :    SOL_Point point(0,0);

  024c7	6a 00		 push	 0
  024c9	6a 00		 push	 0
  024cb	8d 4d f4	 lea	 ecx, DWORD PTR _point$[ebp]
  024ce	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@HH@Z	; SOL_Point::SOL_Point

; 1000 : 
; 1001 :    pm.acc = GlobalToLocalGame((int)(unsigned short)arg(2),point);

  024d3	8d 45 f4	 lea	 eax, DWORD PTR _point$[ebp]
  024d6	50		 push	 eax
  024d7	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  024da	33 d2		 xor	 edx, edx
  024dc	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  024e0	52		 push	 edx
  024e1	e8 00 00 00 00	 call	 ?GlobalToLocalGame@@YAHHAAVSOL_Point@@@Z ; GlobalToLocalGame
  024e6	83 c4 08	 add	 esp, 8
  024e9	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 1002 : 
; 1003 : 	// The point comes back as negative offsets
; 1004 : 	ObjectID evt = arg(1);

  024ee	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  024f1	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  024f5	51		 push	 ecx
  024f6	8d 4d fc	 lea	 ecx, DWORD PTR _evt$[ebp]
  024f9	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID

; 1005 : 	evt.SetIndexedProperty(evX,evt.GetIndexedProperty(evX) + point.x);

  024fe	6a 2f		 push	 47			; 0000002fH
  02500	8d 4d fc	 lea	 ecx, DWORD PTR _evt$[ebp]
  02503	e8 00 00 00 00	 call	 ?GetIndexedProperty@ObjectID@@QBEFH@Z ; ObjectID::GetIndexedProperty
  02508	0f bf d0	 movsx	 edx, ax
  0250b	03 55 f4	 add	 edx, DWORD PTR _point$[ebp]
  0250e	52		 push	 edx
  0250f	6a 2f		 push	 47			; 0000002fH
  02511	8d 4d fc	 lea	 ecx, DWORD PTR _evt$[ebp]
  02514	e8 00 00 00 00	 call	 ?SetIndexedProperty@ObjectID@@QBEXHF@Z ; ObjectID::SetIndexedProperty

; 1006 : 	evt.SetIndexedProperty(evY,evt.GetIndexedProperty(evY) + point.y);

  02519	6a 30		 push	 48			; 00000030H
  0251b	8d 4d fc	 lea	 ecx, DWORD PTR _evt$[ebp]
  0251e	e8 00 00 00 00	 call	 ?GetIndexedProperty@ObjectID@@QBEFH@Z ; ObjectID::GetIndexedProperty
  02523	0f bf c0	 movsx	 eax, ax
  02526	03 45 f8	 add	 eax, DWORD PTR _point$[ebp+4]
  02529	50		 push	 eax
  0252a	6a 30		 push	 48			; 00000030H
  0252c	8d 4d fc	 lea	 ecx, DWORD PTR _evt$[ebp]
  0252f	e8 00 00 00 00	 call	 ?SetIndexedProperty@ObjectID@@QBEXHF@Z ; ObjectID::SetIndexedProperty

; 1007 : }

  02534	8b e5		 mov	 esp, ebp
  02536	5d		 pop	 ebp
  02537	c3		 ret	 0
?KGlobalToLocal@@YAXPAF@Z ENDP				; KGlobalToLocal
_TEXT	ENDS
PUBLIC	??0FakeObjectID@@QAE@G@Z			; FakeObjectID::FakeObjectID
;	COMDAT ??0ObjectID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0ObjectID@@QAE@G@Z PROC NEAR				; ObjectID::ObjectID, COMDAT

; 230  : 	ObjectID(SOL_Handle h) : FakeObjectID(h) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	66 8b 45 08	 mov	 ax, WORD PTR _h$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0FakeObjectID@@QAE@G@Z ; FakeObjectID::FakeObjectID
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0ObjectID@@QAE@G@Z ENDP				; ObjectID::ObjectID
_TEXT	ENDS
PUBLIC	??0MemID@@QAE@G@Z				; MemID::MemID
;	COMDAT ??0FakeObjectID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0FakeObjectID@@QAE@G@Z PROC NEAR			; FakeObjectID::FakeObjectID, COMDAT

; 224  : FakeTemplateID(FakeObjectID, Object, MemObject)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	66 8b 45 08	 mov	 ax, WORD PTR _h$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0MemID@@QAE@G@Z	; MemID::MemID
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0FakeObjectID@@QAE@G@Z ENDP				; FakeObjectID::FakeObjectID
_TEXT	ENDS
;	COMDAT ??0MemID@@QAE@G@Z
_TEXT	SEGMENT
_h$ = 8
_this$ = -4
??0MemID@@QAE@G@Z PROC NEAR				; MemID::MemID, COMDAT

; 23   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 4d 08	 mov	 cx, WORD PTR _h$[ebp]
  0000e	66 89 08	 mov	 WORD PTR [eax], cx

; 24   : 	}

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??0MemID@@QAE@G@Z ENDP					; MemID::MemID
_TEXT	ENDS
PUBLIC	?GetIndexedProperty@Object@@QAEFH@Z		; Object::GetIndexedProperty
;	COMDAT ?GetIndexedProperty@ObjectID@@QBEFH@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
?GetIndexedProperty@ObjectID@@QBEFH@Z PROC NEAR		; ObjectID::GetIndexedProperty, COMDAT

; 266  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 267  : 		//	get a property given an index in the property offsets table
; 268  : 		AssureValid();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?AssureValid@ObjectID@@QBEXXZ ; ObjectID::AssureValid

; 269  : 		return (*this)->GetIndexedProperty(index);

  0000f	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00012	50		 push	 eax
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  0001b	8b c8		 mov	 ecx, eax
  0001d	e8 00 00 00 00	 call	 ?GetIndexedProperty@Object@@QAEFH@Z ; Object::GetIndexedProperty

; 270  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?GetIndexedProperty@ObjectID@@QBEFH@Z ENDP		; ObjectID::GetIndexedProperty
_TEXT	ENDS
PUBLIC	?GetIndexedPropAddr@Object@@QAEPBFH@Z		; Object::GetIndexedPropAddr
;	COMDAT ?GetIndexedProperty@Object@@QAEFH@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
?GetIndexedProperty@Object@@QAEFH@Z PROC NEAR		; Object::GetIndexedProperty, COMDAT

; 146  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 147  : 		//	get a property given an index in the property offsets table
; 148  : 		return *GetIndexedPropAddr(index);

  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?GetIndexedPropAddr@Object@@QAEPBFH@Z ; Object::GetIndexedPropAddr
  00013	66 8b 00	 mov	 ax, WORD PTR [eax]

; 149  : 	}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?GetIndexedProperty@Object@@QAEFH@Z ENDP		; Object::GetIndexedProperty
_TEXT	ENDS
EXTRN	?indexedPropertyOffsets@@3PAIA:BYTE		; indexedPropertyOffsets
;	COMDAT ?GetIndexedPropAddr@Object@@QAEPBFH@Z
_TEXT	SEGMENT
_index$ = 8
_this$ = -4
?GetIndexedPropAddr@Object@@QAEPBFH@Z PROC NEAR		; Object::GetIndexedPropAddr, COMDAT

; 138  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 139  : 		//	get a property address given an index into the property offsets table
; 140  : 		extern size_t indexedPropertyOffsets[];
; 141  : 		return &(*this)[indexedPropertyOffsets[index]];

  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?indexedPropertyOffsets@@3PAIA[eax*4]
  00011	51		 push	 ecx
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??AObject@@QAEAAFH@Z	; Object::operator[]

; 142  : 	}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?GetIndexedPropAddr@Object@@QAEPBFH@Z ENDP		; Object::GetIndexedPropAddr
_TEXT	ENDS
PUBLIC	?SetIndexedProperty@Object@@QAEXHF@Z		; Object::SetIndexedProperty
;	COMDAT ?SetIndexedProperty@ObjectID@@QBEXHF@Z
_TEXT	SEGMENT
_index$ = 8
_property$ = 12
_this$ = -4
?SetIndexedProperty@ObjectID@@QBEXHF@Z PROC NEAR	; ObjectID::SetIndexedProperty, COMDAT

; 324  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 325  : 		//	set a property given an index into property offsets table
; 326  : 		AssureValid();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?AssureValid@ObjectID@@QBEXXZ ; ObjectID::AssureValid

; 327  : 		(*this)->SetIndexedProperty(index, property);

  0000f	66 8b 45 0c	 mov	 ax, WORD PTR _property$[ebp]
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  00017	51		 push	 ecx
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??CFakeObjectID@@QBEPAUObject@@XZ ; FakeObjectID::operator->
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 ?SetIndexedProperty@Object@@QAEXHF@Z ; Object::SetIndexedProperty

; 328  : 	}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
?SetIndexedProperty@ObjectID@@QBEXHF@Z ENDP		; ObjectID::SetIndexedProperty
_TEXT	ENDS
PUBLIC	?SetPropAtOffset@Object@@QAEAAFI@Z		; Object::SetPropAtOffset
EXTRN	?indexedPropertyOffsets@@3PAIA:BYTE		; indexedPropertyOffsets
;	COMDAT ?SetIndexedProperty@Object@@QAEXHF@Z
_TEXT	SEGMENT
_index$ = 8
_property$ = 12
_this$ = -4
?SetIndexedProperty@Object@@QAEXHF@Z PROC NEAR		; Object::SetIndexedProperty, COMDAT

; 188  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 189  : 		//	set a property given an index into property offsets table
; 190  : 		extern size_t indexedPropertyOffsets[];
; 191  : 		SetPropAtOffset(indexedPropertyOffsets[index] * sizeof(Property)) =
; 192  : 			property;

  00007	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?indexedPropertyOffsets@@3PAIA[eax*4]
  00011	d1 e1		 shl	 ecx, 1
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?SetPropAtOffset@Object@@QAEAAFI@Z ; Object::SetPropAtOffset
  0001c	66 8b 55 0c	 mov	 dx, WORD PTR _property$[ebp]
  00020	66 89 10	 mov	 WORD PTR [eax], dx

; 193  : 	}

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
?SetIndexedProperty@Object@@QAEXHF@Z ENDP		; Object::SetIndexedProperty
_TEXT	ENDS
PUBLIC	?SetGraphicsUpdate@Object@@QAEXXZ		; Object::SetGraphicsUpdate
PUBLIC	?GetPropAtOffset@Object@@QAEAAFI@Z		; Object::GetPropAtOffset
;	COMDAT ?SetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT
_offset$ = 8
_this$ = -4
?SetPropAtOffset@Object@@QAEAAFI@Z PROC NEAR		; Object::SetPropAtOffset, COMDAT

; 197  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 198  : 		//	return reference to property that is about to be changed
; 199  : 		if (offset <= MaxGraphUpdateOffset && offset >= MinGraphUpdateOffset)

  00007	83 7d 08 56	 cmp	 DWORD PTR _offset$[ebp], 86 ; 00000056H
  0000b	77 0e		 ja	 SHORT $L61136
  0000d	83 7d 08 30	 cmp	 DWORD PTR _offset$[ebp], 48 ; 00000030H
  00011	72 08		 jb	 SHORT $L61136

; 200  : 			SetGraphicsUpdate();

  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?SetGraphicsUpdate@Object@@QAEXXZ ; Object::SetGraphicsUpdate
$L61136:

; 201  : 		return GetPropAtOffset(offset);

  0001b	8b 45 08	 mov	 eax, DWORD PTR _offset$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?GetPropAtOffset@Object@@QAEAAFI@Z ; Object::GetPropAtOffset

; 202  : 	}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?SetPropAtOffset@Object@@QAEAAFI@Z ENDP			; Object::SetPropAtOffset
_TEXT	ENDS
;	COMDAT ?SetGraphicsUpdate@Object@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?SetGraphicsUpdate@Object@@QAEXXZ PROC NEAR		; Object::SetGraphicsUpdate, COMDAT

; 97   : 	void		SetGraphicsUpdate()		{ info |= GRAPH_UPD; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 48 0e	 mov	 cx, WORD PTR [eax+14]
  0000e	80 c9 08	 or	 cl, 8
  00011	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00014	66 89 4a 0e	 mov	 WORD PTR [edx+14], cx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?SetGraphicsUpdate@Object@@QAEXXZ ENDP			; Object::SetGraphicsUpdate
_TEXT	ENDS
;	COMDAT ?GetPropAtOffset@Object@@QAEAAFI@Z
_TEXT	SEGMENT
_offset$ = 8
_this$ = -4
?GetPropAtOffset@Object@@QAEAAFI@Z PROC NEAR		; Object::GetPropAtOffset, COMDAT

; 163  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 164  : 		//	get a property given an offset into the object
; 165  : 		return (Property&) ((char*) this)[offset];

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	03 45 08	 add	 eax, DWORD PTR _offset$[ebp]

; 166  : 	}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?GetPropAtOffset@Object@@QAEAAFI@Z ENDP			; Object::GetPropAtOffset
_TEXT	ENDS
PUBLIC	?Planes@Screen@@QAEAAVPlaneList@@XZ		; Screen::Planes
PUBLIC	?GameRect@SOL_Plane@@QBEABVSOL_Rect@@XZ		; SOL_Plane::GameRect
EXTRN	?Fatal@MsgMgr@@QAAXDPADHHZZ:NEAR		; MsgMgr::Fatal
_DATA	SEGMENT
	ORG $+1
$SG62168 DB	'C:\Documents and Settings\don\Desktop\sciw\Interp\Plane.'
	DB	'cpp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_planeID$ = 8
_point$ = 12
_exitBool$ = -24
_r$ = -16
_last$ = -20
_index$ = -28
_next$62166 = -32
?GlobalToLocalGame@@YAHHAAVSOL_Point@@@Z PROC NEAR	; GlobalToLocalGame

; 1011 : {

  02538	55		 push	 ebp
  02539	8b ec		 mov	 ebp, esp
  0253b	83 ec 20	 sub	 esp, 32			; 00000020H

; 1012 : 	Bool		exitBool = True;

  0253e	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _exitBool$[ebp], 1

; 1013 : 	SOL_Rect r;

  02545	8d 4d f0	 lea	 ecx, DWORD PTR _r$[ebp]
  02548	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@XZ	; SOL_Rect::SOL_Rect

; 1014 : 	Screen& 	last =	graphMgr->VisibleScreen();

  0254d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  02552	8b 10		 mov	 edx, DWORD PTR [eax]
  02554	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  0255a	ff 52 44	 call	 DWORD PTR [edx+68]
  0255d	89 45 ec	 mov	 DWORD PTR _last$[ebp], eax

; 1015 : 
; 1016 : 	// Given a plane def, convert the point to local game coordinates
; 1017 : 	int index = last.Planes().Search(planeID);

  02560	8b 45 08	 mov	 eax, DWORD PTR _planeID$[ebp]
  02563	50		 push	 eax
  02564	8b 4d ec	 mov	 ecx, DWORD PTR _last$[ebp]
  02567	e8 00 00 00 00	 call	 ?Planes@Screen@@QAEAAVPlaneList@@XZ ; Screen::Planes
  0256c	8b c8		 mov	 ecx, eax
  0256e	e8 00 00 00 00	 call	 ?Search@PlaneList@@QBEHI@Z ; PlaneList::Search
  02573	89 45 e4	 mov	 DWORD PTR _index$[ebp], eax

; 1018 : 	if (index == -1) {

  02576	83 7d e4 ff	 cmp	 DWORD PTR _index$[ebp], -1
  0257a	75 76		 jne	 SHORT $L62165

; 1019 : 		// Must be only in the next screen's planes list
; 1020 : 		Screen* next = graphMgr->NextScreen();

  0257c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  02582	e8 00 00 00 00	 call	 ?NextScreen@GraphicsMgr@@QAEPAVScreen@@XZ ; GraphicsMgr::NextScreen
  02587	89 45 e0	 mov	 DWORD PTR _next$62166[ebp], eax

; 1021 : 		index = next->Planes().Search(planeID);

  0258a	8b 4d 08	 mov	 ecx, DWORD PTR _planeID$[ebp]
  0258d	51		 push	 ecx
  0258e	8b 4d e0	 mov	 ecx, DWORD PTR _next$62166[ebp]
  02591	e8 00 00 00 00	 call	 ?Planes@Screen@@QAEAAVPlaneList@@XZ ; Screen::Planes
  02596	8b c8		 mov	 ecx, eax
  02598	e8 00 00 00 00	 call	 ?Search@PlaneList@@QBEHI@Z ; PlaneList::Search
  0259d	89 45 e4	 mov	 DWORD PTR _index$[ebp], eax

; 1022 : 		if (index == -1)

  025a0	83 7d e4 ff	 cmp	 DWORD PTR _index$[ebp], -1
  025a4	75 20		 jne	 SHORT $L62167

; 1023 : 			msgMgr->Fatal(SrcLoc,Msg_PlaneNotFound,planeID);

  025a6	8b 55 08	 mov	 edx, DWORD PTR _planeID$[ebp]
  025a9	52		 push	 edx
  025aa	6a 6b		 push	 107			; 0000006bH
  025ac	68 ff 03 00 00	 push	 1023			; 000003ffH
  025b1	68 00 00 00 00	 push	 OFFSET FLAT:$SG62168
  025b6	6a 61		 push	 97			; 00000061H
  025b8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  025bd	50		 push	 eax
  025be	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXDPADHHZZ ; MsgMgr::Fatal
  025c3	83 c4 18	 add	 esp, 24			; 00000018H
$L62167:

; 1024 : 		r = next->Planes()[index].GameRect();

  025c6	8b 4d e4	 mov	 ecx, DWORD PTR _index$[ebp]
  025c9	51		 push	 ecx
  025ca	8b 4d e0	 mov	 ecx, DWORD PTR _next$62166[ebp]
  025cd	e8 00 00 00 00	 call	 ?Planes@Screen@@QAEAAVPlaneList@@XZ ; Screen::Planes
  025d2	8b c8		 mov	 ecx, eax
  025d4	e8 00 00 00 00	 call	 ??APlaneList@@QAEAAVSOL_Plane@@H@Z ; PlaneList::operator[]
  025d9	8b c8		 mov	 ecx, eax
  025db	e8 00 00 00 00	 call	 ?GameRect@SOL_Plane@@QBEABVSOL_Rect@@XZ ; SOL_Plane::GameRect
  025e0	50		 push	 eax
  025e1	8d 4d f0	 lea	 ecx, DWORD PTR _r$[ebp]
  025e4	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 1025 : 		exitBool = False;

  025e9	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _exitBool$[ebp], 0

; 1027 : 	else

  025f0	eb 23		 jmp	 SHORT $L62169
$L62165:

; 1028 : 		r = last.Planes()[index].GameRect();

  025f2	8b 55 e4	 mov	 edx, DWORD PTR _index$[ebp]
  025f5	52		 push	 edx
  025f6	8b 4d ec	 mov	 ecx, DWORD PTR _last$[ebp]
  025f9	e8 00 00 00 00	 call	 ?Planes@Screen@@QAEAAVPlaneList@@XZ ; Screen::Planes
  025fe	8b c8		 mov	 ecx, eax
  02600	e8 00 00 00 00	 call	 ??APlaneList@@QAEAAVSOL_Plane@@H@Z ; PlaneList::operator[]
  02605	8b c8		 mov	 ecx, eax
  02607	e8 00 00 00 00	 call	 ?GameRect@SOL_Plane@@QBEABVSOL_Rect@@XZ ; SOL_Plane::GameRect
  0260c	50		 push	 eax
  0260d	8d 4d f0	 lea	 ecx, DWORD PTR _r$[ebp]
  02610	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=
$L62169:

; 1029 : 	point.x -= r.A.x;

  02615	8b 45 0c	 mov	 eax, DWORD PTR _point$[ebp]
  02618	8b 08		 mov	 ecx, DWORD PTR [eax]
  0261a	2b 4d f0	 sub	 ecx, DWORD PTR _r$[ebp]
  0261d	8b 55 0c	 mov	 edx, DWORD PTR _point$[ebp]
  02620	89 0a		 mov	 DWORD PTR [edx], ecx

; 1030 : 	point.y -= r.A.y;

  02622	8b 45 0c	 mov	 eax, DWORD PTR _point$[ebp]
  02625	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  02628	2b 4d f4	 sub	 ecx, DWORD PTR _r$[ebp+4]
  0262b	8b 55 0c	 mov	 edx, DWORD PTR _point$[ebp]
  0262e	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1031 : 	return exitBool;

  02631	8b 45 e8	 mov	 eax, DWORD PTR _exitBool$[ebp]

; 1032 : }

  02634	8b e5		 mov	 esp, ebp
  02636	5d		 pop	 ebp
  02637	c3		 ret	 0
?GlobalToLocalGame@@YAHHAAVSOL_Point@@@Z ENDP		; GlobalToLocalGame
_TEXT	ENDS
;	COMDAT ?GameRect@SOL_Plane@@QBEABVSOL_Rect@@XZ
_TEXT	SEGMENT
_this$ = -4
?GameRect@SOL_Plane@@QBEABVSOL_Rect@@XZ PROC NEAR	; SOL_Plane::GameRect, COMDAT

; 62   : 						GameRect() const			{return gameRect;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 0c	 add	 eax, 12			; 0000000cH
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GameRect@SOL_Plane@@QBEABVSOL_Rect@@XZ ENDP		; SOL_Plane::GameRect
_TEXT	ENDS
;	COMDAT ?Planes@Screen@@QAEAAVPlaneList@@XZ
_TEXT	SEGMENT
_this$ = -4
?Planes@Screen@@QAEAAVPlaneList@@XZ PROC NEAR		; Screen::Planes, COMDAT

; 37   : 	PlaneList& Planes() 						{return planes;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Planes@Screen@@QAEAAVPlaneList@@XZ ENDP		; Screen::Planes
_TEXT	ENDS
PUBLIC	?LocalGameToGlobal@@YAHHAAVSOL_Point@@@Z	; LocalGameToGlobal
PUBLIC	?KLocalToGlobal@@YAXPAF@Z			; KLocalToGlobal
_TEXT	SEGMENT
_args$ = 8
_point$ = -12
_evt$ = -4
?KLocalToGlobal@@YAXPAF@Z PROC NEAR			; KLocalToGlobal

; 1053 : {

  02638	55		 push	 ebp
  02639	8b ec		 mov	 ebp, esp
  0263b	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1054 : 	// Given an SCI plane object, convert the event to global (screen) coordinates
; 1055 : 	// arg(1) = event
; 1056 : 	//	arg(2) = plane
; 1057 :    SOL_Point point(0,0);

  0263e	6a 00		 push	 0
  02640	6a 00		 push	 0
  02642	8d 4d f4	 lea	 ecx, DWORD PTR _point$[ebp]
  02645	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@HH@Z	; SOL_Point::SOL_Point

; 1058 : 
; 1059 :    pm.acc = LocalGameToGlobal((int)(unsigned short)arg(2),point);

  0264a	8d 45 f4	 lea	 eax, DWORD PTR _point$[ebp]
  0264d	50		 push	 eax
  0264e	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  02651	33 d2		 xor	 edx, edx
  02653	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  02657	52		 push	 edx
  02658	e8 00 00 00 00	 call	 ?LocalGameToGlobal@@YAHHAAVSOL_Point@@@Z ; LocalGameToGlobal
  0265d	83 c4 08	 add	 esp, 8
  02660	a3 04 00 00 00	 mov	 DWORD PTR ?pm@@3VPMachine@@A+4, eax

; 1060 : 
; 1061 : 	// The point comes back as positive offsets
; 1062 : 	ObjectID evt = arg(1);

  02665	8b 45 08	 mov	 eax, DWORD PTR _args$[ebp]
  02668	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  0266c	51		 push	 ecx
  0266d	8d 4d fc	 lea	 ecx, DWORD PTR _evt$[ebp]
  02670	e8 00 00 00 00	 call	 ??0ObjectID@@QAE@G@Z	; ObjectID::ObjectID

; 1063 : 	evt.SetIndexedProperty(evX,evt.GetIndexedProperty(evX) + point.x);

  02675	6a 2f		 push	 47			; 0000002fH
  02677	8d 4d fc	 lea	 ecx, DWORD PTR _evt$[ebp]
  0267a	e8 00 00 00 00	 call	 ?GetIndexedProperty@ObjectID@@QBEFH@Z ; ObjectID::GetIndexedProperty
  0267f	0f bf d0	 movsx	 edx, ax
  02682	03 55 f4	 add	 edx, DWORD PTR _point$[ebp]
  02685	52		 push	 edx
  02686	6a 2f		 push	 47			; 0000002fH
  02688	8d 4d fc	 lea	 ecx, DWORD PTR _evt$[ebp]
  0268b	e8 00 00 00 00	 call	 ?SetIndexedProperty@ObjectID@@QBEXHF@Z ; ObjectID::SetIndexedProperty

; 1064 : 	evt.SetIndexedProperty(evY,evt.GetIndexedProperty(evY) + point.y);

  02690	6a 30		 push	 48			; 00000030H
  02692	8d 4d fc	 lea	 ecx, DWORD PTR _evt$[ebp]
  02695	e8 00 00 00 00	 call	 ?GetIndexedProperty@ObjectID@@QBEFH@Z ; ObjectID::GetIndexedProperty
  0269a	0f bf c0	 movsx	 eax, ax
  0269d	03 45 f8	 add	 eax, DWORD PTR _point$[ebp+4]
  026a0	50		 push	 eax
  026a1	6a 30		 push	 48			; 00000030H
  026a3	8d 4d fc	 lea	 ecx, DWORD PTR _evt$[ebp]
  026a6	e8 00 00 00 00	 call	 ?SetIndexedProperty@ObjectID@@QBEXHF@Z ; ObjectID::SetIndexedProperty

; 1065 : }

  026ab	8b e5		 mov	 esp, ebp
  026ad	5d		 pop	 ebp
  026ae	c3		 ret	 0
?KLocalToGlobal@@YAXPAF@Z ENDP				; KLocalToGlobal
_TEXT	ENDS
_DATA	SEGMENT
$SG62188 DB	'C:\Documents and Settings\don\Desktop\sciw\Interp\Plane.'
	DB	'cpp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_planeID$ = 8
_point$ = 12
_exitBool$ = -24
_r$ = -16
_last$ = -20
_index$ = -28
_next$62186 = -32
?LocalGameToGlobal@@YAHHAAVSOL_Point@@@Z PROC NEAR	; LocalGameToGlobal

; 1069 : {

  026af	55		 push	 ebp
  026b0	8b ec		 mov	 ebp, esp
  026b2	83 ec 20	 sub	 esp, 32			; 00000020H

; 1070 : 
; 1071 : 	Bool		exitBool = True;

  026b5	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _exitBool$[ebp], 1

; 1072 : 	SOL_Rect r;

  026bc	8d 4d f0	 lea	 ecx, DWORD PTR _r$[ebp]
  026bf	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@XZ	; SOL_Rect::SOL_Rect

; 1073 : 	Screen& 	last =	graphMgr->VisibleScreen();

  026c4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  026c9	8b 10		 mov	 edx, DWORD PTR [eax]
  026cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  026d1	ff 52 44	 call	 DWORD PTR [edx+68]
  026d4	89 45 ec	 mov	 DWORD PTR _last$[ebp], eax

; 1074 : 
; 1075 : 	// Given a plane def, convert the point to global game coordinates
; 1076 : 	int index = last.Planes().Search(planeID);

  026d7	8b 45 08	 mov	 eax, DWORD PTR _planeID$[ebp]
  026da	50		 push	 eax
  026db	8b 4d ec	 mov	 ecx, DWORD PTR _last$[ebp]
  026de	e8 00 00 00 00	 call	 ?Planes@Screen@@QAEAAVPlaneList@@XZ ; Screen::Planes
  026e3	8b c8		 mov	 ecx, eax
  026e5	e8 00 00 00 00	 call	 ?Search@PlaneList@@QBEHI@Z ; PlaneList::Search
  026ea	89 45 e4	 mov	 DWORD PTR _index$[ebp], eax

; 1077 : 	if (index == -1) {

  026ed	83 7d e4 ff	 cmp	 DWORD PTR _index$[ebp], -1
  026f1	75 76		 jne	 SHORT $L62185

; 1078 : 		// Must be only in the next screen's planes list
; 1079 : 		Screen* next = graphMgr->NextScreen();

  026f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?graphMgr@@3PAVGraphicsMgr@@A ; graphMgr
  026f9	e8 00 00 00 00	 call	 ?NextScreen@GraphicsMgr@@QAEPAVScreen@@XZ ; GraphicsMgr::NextScreen
  026fe	89 45 e0	 mov	 DWORD PTR _next$62186[ebp], eax

; 1080 : 		index = next->Planes().Search(planeID);

  02701	8b 4d 08	 mov	 ecx, DWORD PTR _planeID$[ebp]
  02704	51		 push	 ecx
  02705	8b 4d e0	 mov	 ecx, DWORD PTR _next$62186[ebp]
  02708	e8 00 00 00 00	 call	 ?Planes@Screen@@QAEAAVPlaneList@@XZ ; Screen::Planes
  0270d	8b c8		 mov	 ecx, eax
  0270f	e8 00 00 00 00	 call	 ?Search@PlaneList@@QBEHI@Z ; PlaneList::Search
  02714	89 45 e4	 mov	 DWORD PTR _index$[ebp], eax

; 1081 : 		if (index == -1)

  02717	83 7d e4 ff	 cmp	 DWORD PTR _index$[ebp], -1
  0271b	75 20		 jne	 SHORT $L62187

; 1082 : 			msgMgr->Fatal(SrcLoc,Msg_PlaneNotFound,planeID);

  0271d	8b 55 08	 mov	 edx, DWORD PTR _planeID$[ebp]
  02720	52		 push	 edx
  02721	6a 6b		 push	 107			; 0000006bH
  02723	68 3a 04 00 00	 push	 1082			; 0000043aH
  02728	68 00 00 00 00	 push	 OFFSET FLAT:$SG62188
  0272d	6a 61		 push	 97			; 00000061H
  0272f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  02734	50		 push	 eax
  02735	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXDPADHHZZ ; MsgMgr::Fatal
  0273a	83 c4 18	 add	 esp, 24			; 00000018H
$L62187:

; 1083 : 		r = next->Planes()[index].GameRect();

  0273d	8b 4d e4	 mov	 ecx, DWORD PTR _index$[ebp]
  02740	51		 push	 ecx
  02741	8b 4d e0	 mov	 ecx, DWORD PTR _next$62186[ebp]
  02744	e8 00 00 00 00	 call	 ?Planes@Screen@@QAEAAVPlaneList@@XZ ; Screen::Planes
  02749	8b c8		 mov	 ecx, eax
  0274b	e8 00 00 00 00	 call	 ??APlaneList@@QAEAAVSOL_Plane@@H@Z ; PlaneList::operator[]
  02750	8b c8		 mov	 ecx, eax
  02752	e8 00 00 00 00	 call	 ?GameRect@SOL_Plane@@QBEABVSOL_Rect@@XZ ; SOL_Plane::GameRect
  02757	50		 push	 eax
  02758	8d 4d f0	 lea	 ecx, DWORD PTR _r$[ebp]
  0275b	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 1084 : 		exitBool = False;

  02760	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _exitBool$[ebp], 0

; 1086 : 	else

  02767	eb 23		 jmp	 SHORT $L62189
$L62185:

; 1087 : 		r = last.Planes()[index].GameRect();

  02769	8b 55 e4	 mov	 edx, DWORD PTR _index$[ebp]
  0276c	52		 push	 edx
  0276d	8b 4d ec	 mov	 ecx, DWORD PTR _last$[ebp]
  02770	e8 00 00 00 00	 call	 ?Planes@Screen@@QAEAAVPlaneList@@XZ ; Screen::Planes
  02775	8b c8		 mov	 ecx, eax
  02777	e8 00 00 00 00	 call	 ??APlaneList@@QAEAAVSOL_Plane@@H@Z ; PlaneList::operator[]
  0277c	8b c8		 mov	 ecx, eax
  0277e	e8 00 00 00 00	 call	 ?GameRect@SOL_Plane@@QBEABVSOL_Rect@@XZ ; SOL_Plane::GameRect
  02783	50		 push	 eax
  02784	8d 4d f0	 lea	 ecx, DWORD PTR _r$[ebp]
  02787	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=
$L62189:

; 1088 : 	point.x += r.A.x;

  0278c	8b 45 0c	 mov	 eax, DWORD PTR _point$[ebp]
  0278f	8b 08		 mov	 ecx, DWORD PTR [eax]
  02791	03 4d f0	 add	 ecx, DWORD PTR _r$[ebp]
  02794	8b 55 0c	 mov	 edx, DWORD PTR _point$[ebp]
  02797	89 0a		 mov	 DWORD PTR [edx], ecx

; 1089 : 	point.y += r.A.y;

  02799	8b 45 0c	 mov	 eax, DWORD PTR _point$[ebp]
  0279c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0279f	03 4d f4	 add	 ecx, DWORD PTR _r$[ebp+4]
  027a2	8b 55 0c	 mov	 edx, DWORD PTR _point$[ebp]
  027a5	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1090 : 	return exitBool;

  027a8	8b 45 e8	 mov	 eax, DWORD PTR _exitBool$[ebp]

; 1091 : }

  027ab	8b e5		 mov	 esp, ebp
  027ad	5d		 pop	 ebp
  027ae	c3		 ret	 0
?LocalGameToGlobal@@YAHHAAVSOL_Point@@@Z ENDP		; LocalGameToGlobal
_TEXT	ENDS
PUBLIC	?FilterUpEraseRects@SOL_Plane@@QAEXAAVDrawList@@AAVRectList@@@Z ; SOL_Plane::FilterUpEraseRects
PUBLIC	?MergeToDrawList@SOL_Plane@@IAEXHAAVSOL_Rect@@AAVDrawList@@@Z ; SOL_Plane::MergeToDrawList
_TEXT	SEGMENT
_myDrawList$ = 8
_theirEraseList$ = 12
_this$ = -36
_theirCount$ = -4
_i$ = -8
_r$62200 = -24
_myCount$62201 = -32
_j$62202 = -28
?FilterUpEraseRects@SOL_Plane@@QAEXAAVDrawList@@AAVRectList@@@Z PROC NEAR ; SOL_Plane::FilterUpEraseRects

; 1112 : {

  027af	55		 push	 ebp
  027b0	8b ec		 mov	 ebp, esp
  027b2	83 ec 24	 sub	 esp, 36			; 00000024H
  027b5	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 1113 : 	// If a rectangle in theirEraseList intersects my plane, then any	screen
; 1114 : 	// item in my plane that intersects the rectangle must be redrawn. My
; 1115 : 	// plane is transparent. The rectangle will be passed up to higher
; 1116 : 	// transparent priority planes by screen.
; 1117 : 
; 1118 : 	int theirCount = theirEraseList.Length();

  027b8	8b 4d 0c	 mov	 ecx, DWORD PTR _theirEraseList$[ebp]
  027bb	e8 00 00 00 00	 call	 ?Length@RectList@@QBEHXZ ; RectList::Length
  027c0	89 45 fc	 mov	 DWORD PTR _theirCount$[ebp], eax

; 1119 : 	for (int i = 0;i < theirCount;++i) {

  027c3	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  027ca	eb 09		 jmp	 SHORT $L62197
$L62198:
  027cc	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  027cf	83 c0 01	 add	 eax, 1
  027d2	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L62197:
  027d5	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  027d8	3b 4d fc	 cmp	 ecx, DWORD PTR _theirCount$[ebp]
  027db	0f 8d 8e 00 00
	00		 jge	 $L62199

; 1120 : 		SOL_Rect r = theirEraseList[i];

  027e1	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  027e4	52		 push	 edx
  027e5	8b 4d 0c	 mov	 ecx, DWORD PTR _theirEraseList$[ebp]
  027e8	e8 00 00 00 00	 call	 ??ARectList@@QAEAAVSOL_Rect@@H@Z ; RectList::operator[]
  027ed	50		 push	 eax
  027ee	8d 4d e8	 lea	 ecx, DWORD PTR _r$62200[ebp]
  027f1	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@ABV0@@Z ; SOL_Rect::SOL_Rect

; 1121 : 		int myCount = siArray.Length();

  027f6	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  027f9	83 c1 7c	 add	 ecx, 124		; 0000007cH
  027fc	e8 00 00 00 00	 call	 ?Length@ScreenItemList@@QBEHXZ ; ScreenItemList::Length
  02801	89 45 e0	 mov	 DWORD PTR _myCount$62201[ebp], eax

; 1122 : 		for (int j = 0;j < myCount;j++) {

  02804	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _j$62202[ebp], 0
  0280b	eb 09		 jmp	 SHORT $L62203
$L62204:
  0280d	8b 45 e4	 mov	 eax, DWORD PTR _j$62202[ebp]
  02810	83 c0 01	 add	 eax, 1
  02813	89 45 e4	 mov	 DWORD PTR _j$62202[ebp], eax
$L62203:
  02816	8b 4d e4	 mov	 ecx, DWORD PTR _j$62202[ebp]
  02819	3b 4d e0	 cmp	 ecx, DWORD PTR _myCount$62201[ebp]
  0281c	7d 4c		 jge	 SHORT $L62205

; 1123 : 			if (siArray.Exists(j))  {

  0281e	8b 55 e4	 mov	 edx, DWORD PTR _j$62202[ebp]
  02821	52		 push	 edx
  02822	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  02825	83 c1 7c	 add	 ecx, 124		; 0000007cH
  02828	e8 00 00 00 00	 call	 ?Exists@ScreenItemList@@QBEHH@Z ; ScreenItemList::Exists
  0282d	85 c0		 test	 eax, eax
  0282f	74 37		 je	 SHORT $L62207

; 1124 : 				if (r.Intersect(siArray[j].OnScreen()))

  02831	8b 45 e4	 mov	 eax, DWORD PTR _j$62202[ebp]
  02834	50		 push	 eax
  02835	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  02838	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0283b	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  02840	8b c8		 mov	 ecx, eax
  02842	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  02847	50		 push	 eax
  02848	8d 4d e8	 lea	 ecx, DWORD PTR _r$62200[ebp]
  0284b	e8 00 00 00 00	 call	 ?Intersect@SOL_Rect@@QBEHABV1@@Z ; SOL_Rect::Intersect
  02850	85 c0		 test	 eax, eax
  02852	74 14		 je	 SHORT $L62207

; 1125 : 					MergeToDrawList(j,r,myDrawList);

  02854	8b 4d 08	 mov	 ecx, DWORD PTR _myDrawList$[ebp]
  02857	51		 push	 ecx
  02858	8d 55 e8	 lea	 edx, DWORD PTR _r$62200[ebp]
  0285b	52		 push	 edx
  0285c	8b 45 e4	 mov	 eax, DWORD PTR _j$62202[ebp]
  0285f	50		 push	 eax
  02860	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  02863	e8 00 00 00 00	 call	 ?MergeToDrawList@SOL_Plane@@IAEXHAAVSOL_Rect@@AAVDrawList@@@Z ; SOL_Plane::MergeToDrawList
$L62207:

; 1127 : 		}

  02868	eb a3		 jmp	 SHORT $L62204
$L62205:

; 1128 : 	}

  0286a	e9 5d ff ff ff	 jmp	 $L62198
$L62199:

; 1129 : }

  0286f	8b e5		 mov	 esp, ebp
  02871	5d		 pop	 ebp
  02872	c2 08 00	 ret	 8
?FilterUpEraseRects@SOL_Plane@@QAEXAAVDrawList@@AAVRectList@@@Z ENDP ; SOL_Plane::FilterUpEraseRects
_TEXT	ENDS
PUBLIC	?FilterDownEraseRects@SOL_Plane@@QAEXAAVDrawList@@AAVRectList@@1@Z ; SOL_Plane::FilterDownEraseRects
PUBLIC	?UpdateTheirEraseList@SOL_Plane@@IAEXAAVSOL_Rect@@HAAVRectList@@@Z ; SOL_Plane::UpdateTheirEraseList
_TEXT	SEGMENT
_myDrawList$ = 8
_myEraseList$ = 12
_theirEraseList$ = 16
_this$ = -68
_theirCount$62216 = -4
_i$62217 = -8
_r$62221 = -24
_myCount$62222 = -32
_j$62223 = -28
_theirCount$62230 = -36
_i$62231 = -40
_r$62235 = -56
_myCount$62237 = -64
_j$62238 = -60
?FilterDownEraseRects@SOL_Plane@@QAEXAAVDrawList@@AAVRectList@@1@Z PROC NEAR ; SOL_Plane::FilterDownEraseRects

; 1133 : {

  02875	55		 push	 ebp
  02876	8b ec		 mov	 ebp, esp
  02878	83 ec 44	 sub	 esp, 68			; 00000044H
  0287b	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx

; 1134 : 	// If a rectangle in theirEraseList intersects my plane, then any	screen
; 1135 : 	// item in my plane that intersects the rectangle must be redrawn. If my
; 1136 : 	// plane is transparent, the rectangle will be passed down to lower
; 1137 : 	// priority planes. If my plane is opaque then the part of the rectangle
; 1138 : 	// that intersects my plane will	not be passed on.
; 1139 : 
; 1140 : 	if (IsTransparent() || IsPictureSkip()) {

  0287e	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  02881	e8 00 00 00 00	 call	 ?IsTransparent@SOL_Plane@@QBEHXZ ; SOL_Plane::IsTransparent
  02886	85 c0		 test	 eax, eax
  02888	75 10		 jne	 SHORT $L62215
  0288a	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0288d	e8 00 00 00 00	 call	 ?IsPictureSkip@SOL_Plane@@QBEHXZ ; SOL_Plane::IsPictureSkip
  02892	85 c0		 test	 eax, eax
  02894	0f 84 bc 00 00
	00		 je	 $L62214
$L62215:

; 1141 : 		// I'm transparent
; 1142 : 		int theirCount = theirEraseList.Length();

  0289a	8b 4d 10	 mov	 ecx, DWORD PTR _theirEraseList$[ebp]
  0289d	e8 00 00 00 00	 call	 ?Length@RectList@@QBEHXZ ; RectList::Length
  028a2	89 45 fc	 mov	 DWORD PTR _theirCount$62216[ebp], eax

; 1143 : 		for (int i = 0;i < theirCount;++i) {

  028a5	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$62217[ebp], 0
  028ac	eb 09		 jmp	 SHORT $L62218
$L62219:
  028ae	8b 45 f8	 mov	 eax, DWORD PTR _i$62217[ebp]
  028b1	83 c0 01	 add	 eax, 1
  028b4	89 45 f8	 mov	 DWORD PTR _i$62217[ebp], eax
$L62218:
  028b7	8b 4d f8	 mov	 ecx, DWORD PTR _i$62217[ebp]
  028ba	3b 4d fc	 cmp	 ecx, DWORD PTR _theirCount$62216[ebp]
  028bd	0f 8d 8e 00 00
	00		 jge	 $L62220

; 1144 : 			SOL_Rect r = theirEraseList[i];

  028c3	8b 55 f8	 mov	 edx, DWORD PTR _i$62217[ebp]
  028c6	52		 push	 edx
  028c7	8b 4d 10	 mov	 ecx, DWORD PTR _theirEraseList$[ebp]
  028ca	e8 00 00 00 00	 call	 ??ARectList@@QAEAAVSOL_Rect@@H@Z ; RectList::operator[]
  028cf	50		 push	 eax
  028d0	8d 4d e8	 lea	 ecx, DWORD PTR _r$62221[ebp]
  028d3	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@ABV0@@Z ; SOL_Rect::SOL_Rect

; 1145 : 			int myCount = siArray.Length();

  028d8	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  028db	83 c1 7c	 add	 ecx, 124		; 0000007cH
  028de	e8 00 00 00 00	 call	 ?Length@ScreenItemList@@QBEHXZ ; ScreenItemList::Length
  028e3	89 45 e0	 mov	 DWORD PTR _myCount$62222[ebp], eax

; 1146 : 			for (int j = 0;j < myCount;j++) {

  028e6	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _j$62223[ebp], 0
  028ed	eb 09		 jmp	 SHORT $L62224
$L62225:
  028ef	8b 45 e4	 mov	 eax, DWORD PTR _j$62223[ebp]
  028f2	83 c0 01	 add	 eax, 1
  028f5	89 45 e4	 mov	 DWORD PTR _j$62223[ebp], eax
$L62224:
  028f8	8b 4d e4	 mov	 ecx, DWORD PTR _j$62223[ebp]
  028fb	3b 4d e0	 cmp	 ecx, DWORD PTR _myCount$62222[ebp]
  028fe	7d 4c		 jge	 SHORT $L62226

; 1147 : 				if (siArray.Exists(j))  {

  02900	8b 55 e4	 mov	 edx, DWORD PTR _j$62223[ebp]
  02903	52		 push	 edx
  02904	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  02907	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0290a	e8 00 00 00 00	 call	 ?Exists@ScreenItemList@@QBEHH@Z ; ScreenItemList::Exists
  0290f	85 c0		 test	 eax, eax
  02911	74 37		 je	 SHORT $L62228

; 1148 : 					if (r.Intersect(siArray[j].OnScreen()))

  02913	8b 45 e4	 mov	 eax, DWORD PTR _j$62223[ebp]
  02916	50		 push	 eax
  02917	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0291a	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0291d	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  02922	8b c8		 mov	 ecx, eax
  02924	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  02929	50		 push	 eax
  0292a	8d 4d e8	 lea	 ecx, DWORD PTR _r$62221[ebp]
  0292d	e8 00 00 00 00	 call	 ?Intersect@SOL_Rect@@QBEHABV1@@Z ; SOL_Rect::Intersect
  02932	85 c0		 test	 eax, eax
  02934	74 14		 je	 SHORT $L62228

; 1149 : 						MergeToDrawList(j,r,myDrawList);

  02936	8b 4d 08	 mov	 ecx, DWORD PTR _myDrawList$[ebp]
  02939	51		 push	 ecx
  0293a	8d 55 e8	 lea	 edx, DWORD PTR _r$62221[ebp]
  0293d	52		 push	 edx
  0293e	8b 45 e4	 mov	 eax, DWORD PTR _j$62223[ebp]
  02941	50		 push	 eax
  02942	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  02945	e8 00 00 00 00	 call	 ?MergeToDrawList@SOL_Plane@@IAEXHAAVSOL_Rect@@AAVDrawList@@@Z ; SOL_Plane::MergeToDrawList
$L62228:

; 1151 : 			}

  0294a	eb a3		 jmp	 SHORT $L62225
$L62226:

; 1152 : 		}

  0294c	e9 5d ff ff ff	 jmp	 $L62219
$L62220:

; 1154 : 	else {

  02951	e9 0d 01 00 00	 jmp	 $L62229
$L62214:

; 1155 : 		// I'm not transparent
; 1156 : 		int theirCount = theirEraseList.Length();

  02956	8b 4d 10	 mov	 ecx, DWORD PTR _theirEraseList$[ebp]
  02959	e8 00 00 00 00	 call	 ?Length@RectList@@QBEHXZ ; RectList::Length
  0295e	89 45 dc	 mov	 DWORD PTR _theirCount$62230[ebp], eax

; 1157 : 		for (int i = 0;i < theirCount;++i) {

  02961	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _i$62231[ebp], 0
  02968	eb 09		 jmp	 SHORT $L62232
$L62233:
  0296a	8b 4d d8	 mov	 ecx, DWORD PTR _i$62231[ebp]
  0296d	83 c1 01	 add	 ecx, 1
  02970	89 4d d8	 mov	 DWORD PTR _i$62231[ebp], ecx
$L62232:
  02973	8b 55 d8	 mov	 edx, DWORD PTR _i$62231[ebp]
  02976	3b 55 dc	 cmp	 edx, DWORD PTR _theirCount$62230[ebp]
  02979	0f 8d dc 00 00
	00		 jge	 $L62234

; 1158 : 			SOL_Rect r = theirEraseList[i];

  0297f	8b 45 d8	 mov	 eax, DWORD PTR _i$62231[ebp]
  02982	50		 push	 eax
  02983	8b 4d 10	 mov	 ecx, DWORD PTR _theirEraseList$[ebp]
  02986	e8 00 00 00 00	 call	 ??ARectList@@QAEAAVSOL_Rect@@H@Z ; RectList::operator[]
  0298b	50		 push	 eax
  0298c	8d 4d c8	 lea	 ecx, DWORD PTR _r$62235[ebp]
  0298f	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@ABV0@@Z ; SOL_Rect::SOL_Rect

; 1159 : 			if (r.Intersect(OnScreen())) {

  02994	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  02997	e8 00 00 00 00	 call	 ?OnScreen@SOL_Plane@@QAEAAVSOL_Rect@@XZ ; SOL_Plane::OnScreen
  0299c	50		 push	 eax
  0299d	8d 4d c8	 lea	 ecx, DWORD PTR _r$62235[ebp]
  029a0	e8 00 00 00 00	 call	 ?Intersect@SOL_Rect@@QBEHABV1@@Z ; SOL_Rect::Intersect
  029a5	85 c0		 test	 eax, eax
  029a7	0f 84 a9 00 00
	00		 je	 $L62236

; 1160 : 				r.Clip(OnScreen());

  029ad	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  029b0	e8 00 00 00 00	 call	 ?OnScreen@SOL_Plane@@QAEAAVSOL_Rect@@XZ ; SOL_Plane::OnScreen
  029b5	50		 push	 eax
  029b6	8d 4d c8	 lea	 ecx, DWORD PTR _r$62235[ebp]
  029b9	e8 00 00 00 00	 call	 ?Clip@SOL_Rect@@QAEXABV1@@Z ; SOL_Rect::Clip

; 1161 : 				MergeToRectList(r,myEraseList);

  029be	8b 4d 0c	 mov	 ecx, DWORD PTR _myEraseList$[ebp]
  029c1	51		 push	 ecx
  029c2	8d 55 c8	 lea	 edx, DWORD PTR _r$62235[ebp]
  029c5	52		 push	 edx
  029c6	e8 00 00 00 00	 call	 ?MergeToRectList@@YAXABVSOL_Rect@@AAVRectList@@@Z ; MergeToRectList
  029cb	83 c4 08	 add	 esp, 8

; 1162 : 				int myCount = siArray.Length();

  029ce	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  029d1	83 c1 7c	 add	 ecx, 124		; 0000007cH
  029d4	e8 00 00 00 00	 call	 ?Length@ScreenItemList@@QBEHXZ ; ScreenItemList::Length
  029d9	89 45 c0	 mov	 DWORD PTR _myCount$62237[ebp], eax

; 1163 : 				for (int j = 0;j < myCount;j++) {

  029dc	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _j$62238[ebp], 0
  029e3	eb 09		 jmp	 SHORT $L62239
$L62240:
  029e5	8b 45 c4	 mov	 eax, DWORD PTR _j$62238[ebp]
  029e8	83 c0 01	 add	 eax, 1
  029eb	89 45 c4	 mov	 DWORD PTR _j$62238[ebp], eax
$L62239:
  029ee	8b 4d c4	 mov	 ecx, DWORD PTR _j$62238[ebp]
  029f1	3b 4d c0	 cmp	 ecx, DWORD PTR _myCount$62237[ebp]
  029f4	7d 4c		 jge	 SHORT $L62241

; 1164 : 					if (siArray.Exists(j))  {

  029f6	8b 55 c4	 mov	 edx, DWORD PTR _j$62238[ebp]
  029f9	52		 push	 edx
  029fa	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  029fd	83 c1 7c	 add	 ecx, 124		; 0000007cH
  02a00	e8 00 00 00 00	 call	 ?Exists@ScreenItemList@@QBEHH@Z ; ScreenItemList::Exists
  02a05	85 c0		 test	 eax, eax
  02a07	74 37		 je	 SHORT $L62243

; 1165 : 						if (r.Intersect(siArray[j].OnScreen()))

  02a09	8b 45 c4	 mov	 eax, DWORD PTR _j$62238[ebp]
  02a0c	50		 push	 eax
  02a0d	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  02a10	83 c1 7c	 add	 ecx, 124		; 0000007cH
  02a13	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  02a18	8b c8		 mov	 ecx, eax
  02a1a	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  02a1f	50		 push	 eax
  02a20	8d 4d c8	 lea	 ecx, DWORD PTR _r$62235[ebp]
  02a23	e8 00 00 00 00	 call	 ?Intersect@SOL_Rect@@QBEHABV1@@Z ; SOL_Rect::Intersect
  02a28	85 c0		 test	 eax, eax
  02a2a	74 14		 je	 SHORT $L62243

; 1166 : 							MergeToDrawList(j,r,myDrawList);

  02a2c	8b 4d 08	 mov	 ecx, DWORD PTR _myDrawList$[ebp]
  02a2f	51		 push	 ecx
  02a30	8d 55 c8	 lea	 edx, DWORD PTR _r$62235[ebp]
  02a33	52		 push	 edx
  02a34	8b 45 c4	 mov	 eax, DWORD PTR _j$62238[ebp]
  02a37	50		 push	 eax
  02a38	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  02a3b	e8 00 00 00 00	 call	 ?MergeToDrawList@SOL_Plane@@IAEXHAAVSOL_Rect@@AAVDrawList@@@Z ; SOL_Plane::MergeToDrawList
$L62243:

; 1168 : 				}

  02a40	eb a3		 jmp	 SHORT $L62240
$L62241:

; 1169 : 				UpdateTheirEraseList(r,i,theirEraseList);

  02a42	8b 4d 10	 mov	 ecx, DWORD PTR _theirEraseList$[ebp]
  02a45	51		 push	 ecx
  02a46	8b 55 d8	 mov	 edx, DWORD PTR _i$62231[ebp]
  02a49	52		 push	 edx
  02a4a	8d 45 c8	 lea	 eax, DWORD PTR _r$62235[ebp]
  02a4d	50		 push	 eax
  02a4e	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  02a51	e8 00 00 00 00	 call	 ?UpdateTheirEraseList@SOL_Plane@@IAEXAAVSOL_Rect@@HAAVRectList@@@Z ; SOL_Plane::UpdateTheirEraseList
$L62236:

; 1171 : 		}

  02a56	e9 0f ff ff ff	 jmp	 $L62233
$L62234:

; 1172 : 		theirEraseList.Pack();

  02a5b	8b 4d 10	 mov	 ecx, DWORD PTR _theirEraseList$[ebp]
  02a5e	e8 00 00 00 00	 call	 ?Pack@RectList@@QAEHXZ	; RectList::Pack
$L62229:

; 1174 : }

  02a63	8b e5		 mov	 esp, ebp
  02a65	5d		 pop	 ebp
  02a66	c2 0c 00	 ret	 12			; 0000000cH
?FilterDownEraseRects@SOL_Plane@@QAEXAAVDrawList@@AAVRectList@@1@Z ENDP ; SOL_Plane::FilterDownEraseRects
_TEXT	ENDS
PUBLIC	?FilterUpDrawRects@SOL_Plane@@QAEXAAVDrawList@@0@Z ; SOL_Plane::FilterUpDrawRects
_TEXT	SEGMENT
_myDrawList$ = 8
_theirDrawList$ = 12
_this$ = -36
_theirCount$ = -4
_i$ = -8
_r$62254 = -24
_myCount$62255 = -32
_j$62256 = -28
?FilterUpDrawRects@SOL_Plane@@QAEXAAVDrawList@@0@Z PROC NEAR ; SOL_Plane::FilterUpDrawRects

; 1178 : {

  02a69	55		 push	 ebp
  02a6a	8b ec		 mov	 ebp, esp
  02a6c	83 ec 24	 sub	 esp, 36			; 00000024H
  02a6f	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 1179 : 	// If a rectangle in theirDrawList intersects my plane, then any
; 1180 : 	// screen item in my plane that intersects the rectangle must be
; 1181 : 	// redrawn. My plane is transparent. The rectangle will be passed
; 1182 : 	// up to higher priority transparent planes.
; 1183 : 
; 1184 : 
; 1185 : 	int theirCount = theirDrawList.Length();

  02a72	8b 4d 0c	 mov	 ecx, DWORD PTR _theirDrawList$[ebp]
  02a75	e8 00 00 00 00	 call	 ?Length@DrawList@@QBEHXZ ; DrawList::Length
  02a7a	89 45 fc	 mov	 DWORD PTR _theirCount$[ebp], eax

; 1186 : 	for (int i = 0;i < theirCount;++i) {

  02a7d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  02a84	eb 09		 jmp	 SHORT $L62251
$L62252:
  02a86	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  02a89	83 c0 01	 add	 eax, 1
  02a8c	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$L62251:
  02a8f	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  02a92	3b 4d fc	 cmp	 ecx, DWORD PTR _theirCount$[ebp]
  02a95	0f 8d 95 00 00
	00		 jge	 $L62253

; 1187 : 		SOL_Rect r = theirDrawList[i].OnScreen();

  02a9b	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  02a9e	52		 push	 edx
  02a9f	8b 4d 0c	 mov	 ecx, DWORD PTR _theirDrawList$[ebp]
  02aa2	e8 00 00 00 00	 call	 ??ADrawList@@QAEAAVDrawItem@@H@Z ; DrawList::operator[]
  02aa7	8b c8		 mov	 ecx, eax
  02aa9	e8 00 00 00 00	 call	 ?OnScreen@DrawItem@@QAEAAVSOL_Rect@@XZ ; DrawItem::OnScreen
  02aae	50		 push	 eax
  02aaf	8d 4d e8	 lea	 ecx, DWORD PTR _r$62254[ebp]
  02ab2	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@ABV0@@Z ; SOL_Rect::SOL_Rect

; 1188 : 		int myCount = siArray.Length();

  02ab7	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  02aba	83 c1 7c	 add	 ecx, 124		; 0000007cH
  02abd	e8 00 00 00 00	 call	 ?Length@ScreenItemList@@QBEHXZ ; ScreenItemList::Length
  02ac2	89 45 e0	 mov	 DWORD PTR _myCount$62255[ebp], eax

; 1189 : 		for (int j = 0;j < myCount;j++) {

  02ac5	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _j$62256[ebp], 0
  02acc	eb 09		 jmp	 SHORT $L62257
$L62258:
  02ace	8b 45 e4	 mov	 eax, DWORD PTR _j$62256[ebp]
  02ad1	83 c0 01	 add	 eax, 1
  02ad4	89 45 e4	 mov	 DWORD PTR _j$62256[ebp], eax
$L62257:
  02ad7	8b 4d e4	 mov	 ecx, DWORD PTR _j$62256[ebp]
  02ada	3b 4d e0	 cmp	 ecx, DWORD PTR _myCount$62255[ebp]
  02add	7d 4c		 jge	 SHORT $L62259

; 1190 : 			if (siArray.Exists(j))  {

  02adf	8b 55 e4	 mov	 edx, DWORD PTR _j$62256[ebp]
  02ae2	52		 push	 edx
  02ae3	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  02ae6	83 c1 7c	 add	 ecx, 124		; 0000007cH
  02ae9	e8 00 00 00 00	 call	 ?Exists@ScreenItemList@@QBEHH@Z ; ScreenItemList::Exists
  02aee	85 c0		 test	 eax, eax
  02af0	74 37		 je	 SHORT $L62261

; 1191 : 				if (r.Intersect(siArray[j].OnScreen()))

  02af2	8b 45 e4	 mov	 eax, DWORD PTR _j$62256[ebp]
  02af5	50		 push	 eax
  02af6	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  02af9	83 c1 7c	 add	 ecx, 124		; 0000007cH
  02afc	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  02b01	8b c8		 mov	 ecx, eax
  02b03	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  02b08	50		 push	 eax
  02b09	8d 4d e8	 lea	 ecx, DWORD PTR _r$62254[ebp]
  02b0c	e8 00 00 00 00	 call	 ?Intersect@SOL_Rect@@QBEHABV1@@Z ; SOL_Rect::Intersect
  02b11	85 c0		 test	 eax, eax
  02b13	74 14		 je	 SHORT $L62261

; 1192 : 					MergeToDrawList(j,r,myDrawList);

  02b15	8b 4d 08	 mov	 ecx, DWORD PTR _myDrawList$[ebp]
  02b18	51		 push	 ecx
  02b19	8d 55 e8	 lea	 edx, DWORD PTR _r$62254[ebp]
  02b1c	52		 push	 edx
  02b1d	8b 45 e4	 mov	 eax, DWORD PTR _j$62256[ebp]
  02b20	50		 push	 eax
  02b21	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  02b24	e8 00 00 00 00	 call	 ?MergeToDrawList@SOL_Plane@@IAEXHAAVSOL_Rect@@AAVDrawList@@@Z ; SOL_Plane::MergeToDrawList
$L62261:

; 1194 : 		}

  02b29	eb a3		 jmp	 SHORT $L62258
$L62259:

; 1195 : 	}

  02b2b	e9 56 ff ff ff	 jmp	 $L62252
$L62253:

; 1196 : }

  02b30	8b e5		 mov	 esp, ebp
  02b32	5d		 pop	 ebp
  02b33	c2 08 00	 ret	 8
?FilterUpDrawRects@SOL_Plane@@QAEXAAVDrawList@@0@Z ENDP	; SOL_Plane::FilterUpDrawRects
_TEXT	ENDS
PUBLIC	?Includes@SOL_Rect@@QAEHABV1@@Z			; SOL_Rect::Includes
EXTRN	??0RectList@@QAE@XZ:NEAR			; RectList::RectList
EXTRN	??1RectList@@QAE@XZ:NEAR			; RectList::~RectList
EXTRN	__chkstk:NEAR
xdata$x	SEGMENT
$T62780	DD	019930520H
	DD	01H
	DD	FLAT:$T62783
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T62783	DD	0ffffffffH
	DD	FLAT:$L62778
xdata$x	ENDS
_TEXT	SEGMENT
__$EHRec$ = -12
_i$ = 8
_r$ = 12
_myDrawList$ = 16
_this$ = -4132
_mergeRect$ = -4040
_mergeList$ = -4016
_j$ = -4020
_k$ = -4024
_myCount$62275 = -4044
_drawRect$62280 = -4060
_rects$62283 = -4128
_newRects$62285 = -4064
?MergeToDrawList@SOL_Plane@@IAEXHAAVSOL_Rect@@AAVDrawList@@@Z PROC NEAR ; SOL_Plane::MergeToDrawList

; 1200 : {

  02b36	55		 push	 ebp
  02b37	8b ec		 mov	 ebp, esp
  02b39	6a ff		 push	 -1
  02b3b	68 00 00 00 00	 push	 $L62781
  02b40	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  02b46	50		 push	 eax
  02b47	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  02b4e	b8 18 10 00 00	 mov	 eax, 4120		; 00001018H
  02b53	e8 00 00 00 00	 call	 __chkstk
  02b58	56		 push	 esi
  02b59	89 8d dc ef ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 1201 : 	// If the screen item siArray[i] is already in myDrawList
; 1202 : 	// and either r is enclosed by siArray[i].OnScreen() or
; 1203 : 	//	siArray[i].OnScreen() is enclosed by r then change the
; 1204 : 	// drawlist entry. Else add a new draw list entry.
; 1205 : 
; 1206 : 	SOL_Rect mergeRect = siArray[i].OnScreen();

  02b5f	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  02b62	50		 push	 eax
  02b63	8b 8d dc ef ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  02b69	83 c1 7c	 add	 ecx, 124		; 0000007cH
  02b6c	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  02b71	8b c8		 mov	 ecx, eax
  02b73	e8 00 00 00 00	 call	 ?OnScreen@ScreenItem@@QAEAAVSOL_Rect@@XZ ; ScreenItem::OnScreen
  02b78	50		 push	 eax
  02b79	8d 8d 38 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeRect$[ebp]
  02b7f	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@ABV0@@Z ; SOL_Rect::SOL_Rect

; 1207 : 	mergeRect.Clip(r);

  02b84	8b 4d 0c	 mov	 ecx, DWORD PTR _r$[ebp]
  02b87	51		 push	 ecx
  02b88	8d 8d 38 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeRect$[ebp]
  02b8e	e8 00 00 00 00	 call	 ?Clip@SOL_Rect@@QAEXABV1@@Z ; SOL_Rect::Clip

; 1208 : 
; 1209 : 	RectList mergeList;

  02b93	8d 8d 50 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeList$[ebp]
  02b99	e8 00 00 00 00	 call	 ??0RectList@@QAE@XZ	; RectList::RectList
  02b9e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1210 : 	mergeList.Add(mergeRect);

  02ba5	8d 95 38 f0 ff
	ff		 lea	 edx, DWORD PTR _mergeRect$[ebp]
  02bab	52		 push	 edx
  02bac	8d 8d 50 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeList$[ebp]
  02bb2	e8 00 00 00 00	 call	 ?Add@RectList@@QAEXABVSOL_Rect@@@Z ; RectList::Add

; 1211 : 	int j, k;
; 1212 : 	for (j = 0;j < mergeList.Length();++j) {

  02bb7	c7 85 4c f0 ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$[ebp], 0
  02bc1	eb 0f		 jmp	 SHORT $L62272
$L62273:
  02bc3	8b 85 4c f0 ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  02bc9	83 c0 01	 add	 eax, 1
  02bcc	89 85 4c f0 ff
	ff		 mov	 DWORD PTR _j$[ebp], eax
$L62272:
  02bd2	8d 8d 50 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeList$[ebp]
  02bd8	e8 00 00 00 00	 call	 ?Length@RectList@@QBEHXZ ; RectList::Length
  02bdd	39 85 4c f0 ff
	ff		 cmp	 DWORD PTR _j$[ebp], eax
  02be3	0f 8d a5 01 00
	00		 jge	 $L62274

; 1213 : 		mergeRect = mergeList[j];

  02be9	8b 8d 4c f0 ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  02bef	51		 push	 ecx
  02bf0	8d 8d 50 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeList$[ebp]
  02bf6	e8 00 00 00 00	 call	 ??ARectList@@QAEAAVSOL_Rect@@H@Z ; RectList::operator[]
  02bfb	50		 push	 eax
  02bfc	8d 8d 38 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeRect$[ebp]
  02c02	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 1214 : 
; 1215 : 		int myCount = myDrawList.Length();

  02c07	8b 4d 10	 mov	 ecx, DWORD PTR _myDrawList$[ebp]
  02c0a	e8 00 00 00 00	 call	 ?Length@DrawList@@QBEHXZ ; DrawList::Length
  02c0f	89 85 34 f0 ff
	ff		 mov	 DWORD PTR _myCount$62275[ebp], eax

; 1216 : 		for (k = 0;k < myCount;++k) {

  02c15	c7 85 48 f0 ff
	ff 00 00 00 00	 mov	 DWORD PTR _k$[ebp], 0
  02c1f	eb 0f		 jmp	 SHORT $L62276
$L62277:
  02c21	8b 95 48 f0 ff
	ff		 mov	 edx, DWORD PTR _k$[ebp]
  02c27	83 c2 01	 add	 edx, 1
  02c2a	89 95 48 f0 ff
	ff		 mov	 DWORD PTR _k$[ebp], edx
$L62276:
  02c30	8b 85 48 f0 ff
	ff		 mov	 eax, DWORD PTR _k$[ebp]
  02c36	3b 85 34 f0 ff
	ff		 cmp	 eax, DWORD PTR _myCount$62275[ebp]
  02c3c	0f 8d 47 01 00
	00		 jge	 $L62278

; 1217 : 			if (siArray[i].Id() == myDrawList[k].SI().Id()) {

  02c42	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  02c45	51		 push	 ecx
  02c46	8b 8d dc ef ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  02c4c	83 c1 7c	 add	 ecx, 124		; 0000007cH
  02c4f	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  02c54	8b c8		 mov	 ecx, eax
  02c56	e8 00 00 00 00	 call	 ?Id@ScreenItem@@QBEJXZ	; ScreenItem::Id
  02c5b	8b f0		 mov	 esi, eax
  02c5d	8b 95 48 f0 ff
	ff		 mov	 edx, DWORD PTR _k$[ebp]
  02c63	52		 push	 edx
  02c64	8b 4d 10	 mov	 ecx, DWORD PTR _myDrawList$[ebp]
  02c67	e8 00 00 00 00	 call	 ??ADrawList@@QAEAAVDrawItem@@H@Z ; DrawList::operator[]
  02c6c	8b c8		 mov	 ecx, eax
  02c6e	e8 00 00 00 00	 call	 ?SI@DrawItem@@QAEAAVScreenItem@@XZ ; DrawItem::SI
  02c73	8b c8		 mov	 ecx, eax
  02c75	e8 00 00 00 00	 call	 ?Id@ScreenItem@@QBEJXZ	; ScreenItem::Id
  02c7a	3b f0		 cmp	 esi, eax
  02c7c	0f 85 02 01 00
	00		 jne	 $L62286

; 1218 : 				SOL_Rect drawRect = myDrawList[k].OnScreen();

  02c82	8b 85 48 f0 ff
	ff		 mov	 eax, DWORD PTR _k$[ebp]
  02c88	50		 push	 eax
  02c89	8b 4d 10	 mov	 ecx, DWORD PTR _myDrawList$[ebp]
  02c8c	e8 00 00 00 00	 call	 ??ADrawList@@QAEAAVDrawItem@@H@Z ; DrawList::operator[]
  02c91	8b c8		 mov	 ecx, eax
  02c93	e8 00 00 00 00	 call	 ?OnScreen@DrawItem@@QAEAAVSOL_Rect@@XZ ; DrawItem::OnScreen
  02c98	50		 push	 eax
  02c99	8d 8d 24 f0 ff
	ff		 lea	 ecx, DWORD PTR _drawRect$62280[ebp]
  02c9f	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@ABV0@@Z ; SOL_Rect::SOL_Rect

; 1219 : 				if (drawRect.Includes(mergeRect)) {

  02ca4	8d 8d 38 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeRect$[ebp]
  02caa	51		 push	 ecx
  02cab	8d 8d 24 f0 ff
	ff		 lea	 ecx, DWORD PTR _drawRect$62280[ebp]
  02cb1	e8 00 00 00 00	 call	 ?Includes@SOL_Rect@@QAEHABV1@@Z ; SOL_Rect::Includes
  02cb6	85 c0		 test	 eax, eax
  02cb8	74 17		 je	 SHORT $L62281

; 1220 : 					// Already being complety drawn
; 1221 : 					mergeList.Delete(j);

  02cba	8b 95 4c f0 ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  02cc0	52		 push	 edx
  02cc1	8d 8d 50 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeList$[ebp]
  02cc7	e8 00 00 00 00	 call	 ?Delete@RectList@@QAEXH@Z ; RectList::Delete

; 1222 : 					break;

  02ccc	e9 b8 00 00 00	 jmp	 $L62278
$L62281:

; 1225 : 					// Check for being partly drawn
; 1226 : 					SOL_Rect rects[4];

  02cd1	68 00 00 00 00	 push	 OFFSET FLAT:??0SOL_Rect@@QAE@XZ ; SOL_Rect::SOL_Rect
  02cd6	6a 04		 push	 4
  02cd8	6a 10		 push	 16			; 00000010H
  02cda	8d 85 e0 ef ff
	ff		 lea	 eax, DWORD PTR _rects$62283[ebp]
  02ce0	50		 push	 eax
  02ce1	e8 00 00 00 00	 call	 ??_H@YGXPAXIHP6EX0@Z@Z	; `vector constructor iterator'

; 1227 : 					int newRects = mergeRect.Split(drawRect,rects);

  02ce6	8d 8d e0 ef ff
	ff		 lea	 ecx, DWORD PTR _rects$62283[ebp]
  02cec	51		 push	 ecx
  02ced	8d 95 24 f0 ff
	ff		 lea	 edx, DWORD PTR _drawRect$62280[ebp]
  02cf3	52		 push	 edx
  02cf4	8d 8d 38 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeRect$[ebp]
  02cfa	e8 00 00 00 00	 call	 ?Split@SOL_Rect@@QAEHAAV1@PAV1@@Z ; SOL_Rect::Split
  02cff	89 85 20 f0 ff
	ff		 mov	 DWORD PTR _newRects$62285[ebp], eax

; 1228 : 					if (newRects != -1) {

  02d05	83 bd 20 f0 ff
	ff ff		 cmp	 DWORD PTR _newRects$62285[ebp], -1
  02d0c	74 76		 je	 SHORT $L62286
$L62288:

; 1229 : 						// Eliminate the merege rect and add new ones
; 1230 : 						while (newRects--) {

  02d0e	8b 85 20 f0 ff
	ff		 mov	 eax, DWORD PTR _newRects$62285[ebp]
  02d14	8b 8d 20 f0 ff
	ff		 mov	 ecx, DWORD PTR _newRects$62285[ebp]
  02d1a	83 e9 01	 sub	 ecx, 1
  02d1d	89 8d 20 f0 ff
	ff		 mov	 DWORD PTR _newRects$62285[ebp], ecx
  02d23	85 c0		 test	 eax, eax
  02d25	74 1e		 je	 SHORT $L62289

; 1231 : 							mergeList.Add(rects[newRects]);

  02d27	8b 95 20 f0 ff
	ff		 mov	 edx, DWORD PTR _newRects$62285[ebp]
  02d2d	c1 e2 04	 shl	 edx, 4
  02d30	8d 84 15 e0 ef
	ff ff		 lea	 eax, DWORD PTR _rects$62283[ebp+edx]
  02d37	50		 push	 eax
  02d38	8d 8d 50 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeList$[ebp]
  02d3e	e8 00 00 00 00	 call	 ?Add@RectList@@QAEXABVSOL_Rect@@@Z ; RectList::Add

; 1232 : 						}

  02d43	eb c9		 jmp	 SHORT $L62288
$L62289:

; 1233 : 						mergeList.Delete(j);

  02d45	8b 8d 4c f0 ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  02d4b	51		 push	 ecx
  02d4c	8d 8d 50 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeList$[ebp]
  02d52	e8 00 00 00 00	 call	 ?Delete@RectList@@QAEXH@Z ; RectList::Delete

; 1234 : 						mergeRect = mergeList[++j];

  02d57	8b 95 4c f0 ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  02d5d	83 c2 01	 add	 edx, 1
  02d60	89 95 4c f0 ff
	ff		 mov	 DWORD PTR _j$[ebp], edx
  02d66	8b 85 4c f0 ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  02d6c	50		 push	 eax
  02d6d	8d 8d 50 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeList$[ebp]
  02d73	e8 00 00 00 00	 call	 ??ARectList@@QAEAAVSOL_Rect@@H@Z ; RectList::operator[]
  02d78	50		 push	 eax
  02d79	8d 8d 38 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeRect$[ebp]
  02d7f	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=
$L62286:

; 1238 : 		}

  02d84	e9 98 fe ff ff	 jmp	 $L62277
$L62278:

; 1239 : 	}

  02d89	e9 35 fe ff ff	 jmp	 $L62273
$L62274:

; 1240 : 	// Now add any thing left in the mergeList
; 1241 : 	mergeList.Pack();

  02d8e	8d 8d 50 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeList$[ebp]
  02d94	e8 00 00 00 00	 call	 ?Pack@RectList@@QAEHXZ	; RectList::Pack

; 1242 : 	for (j = 0;j < mergeList.Length();++j) {

  02d99	c7 85 4c f0 ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$[ebp], 0
  02da3	eb 0f		 jmp	 SHORT $L62290
$L62291:
  02da5	8b 8d 4c f0 ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  02dab	83 c1 01	 add	 ecx, 1
  02dae	89 8d 4c f0 ff
	ff		 mov	 DWORD PTR _j$[ebp], ecx
$L62290:
  02db4	8d 8d 50 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeList$[ebp]
  02dba	e8 00 00 00 00	 call	 ?Length@RectList@@QBEHXZ ; RectList::Length
  02dbf	39 85 4c f0 ff
	ff		 cmp	 DWORD PTR _j$[ebp], eax
  02dc5	7d 30		 jge	 SHORT $L62292

; 1243 : 		myDrawList.Add(&siArray[i],mergeList[j]);

  02dc7	8b 95 4c f0 ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  02dcd	52		 push	 edx
  02dce	8d 8d 50 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeList$[ebp]
  02dd4	e8 00 00 00 00	 call	 ??ARectList@@QAEAAVSOL_Rect@@H@Z ; RectList::operator[]
  02dd9	50		 push	 eax
  02dda	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  02ddd	50		 push	 eax
  02dde	8b 8d dc ef ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  02de4	83 c1 7c	 add	 ecx, 124		; 0000007cH
  02de7	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  02dec	50		 push	 eax
  02ded	8b 4d 10	 mov	 ecx, DWORD PTR _myDrawList$[ebp]
  02df0	e8 00 00 00 00	 call	 ?Add@DrawList@@QAEHPAVScreenItem@@AAVSOL_Rect@@@Z ; DrawList::Add

; 1244 : 	}

  02df5	eb ae		 jmp	 SHORT $L62291
$L62292:

; 1245 : }

  02df7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  02dfe	8d 8d 50 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeList$[ebp]
  02e04	e8 00 00 00 00	 call	 ??1RectList@@QAE@XZ	; RectList::~RectList
  02e09	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  02e0c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  02e13	5e		 pop	 esi
  02e14	8b e5		 mov	 esp, ebp
  02e16	5d		 pop	 ebp
  02e17	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
$L62778:
  00097	8d 8d 50 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeList$[ebp]
  0009d	e8 00 00 00 00	 call	 ??1RectList@@QAE@XZ	; RectList::~RectList
  000a2	c3		 ret	 0
$L62781:
  000a3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T62780
  000a8	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?MergeToDrawList@SOL_Plane@@IAEXHAAVSOL_Rect@@AAVDrawList@@@Z ENDP ; SOL_Plane::MergeToDrawList
PUBLIC	?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z		; SOL_Rect::Intersect
;	COMDAT ?Includes@SOL_Rect@@QAEHABV1@@Z
_TEXT	SEGMENT
_r$ = 8
_this$ = -12
?Includes@SOL_Rect@@QAEHABV1@@Z PROC NEAR		; SOL_Rect::Includes, COMDAT

; 276  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 277  : 	return  (Intersect(r.A) && Intersect(r.B));

  00009	83 ec 08	 sub	 esp, 8
  0000c	8b cc		 mov	 ecx, esp
  0000e	8b 45 08	 mov	 eax, DWORD PTR _r$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  00017	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z ; SOL_Rect::Intersect
  0001f	85 c0		 test	 eax, eax
  00021	74 28		 je	 SHORT $L62787
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00026	83 c1 08	 add	 ecx, 8
  00029	83 ec 08	 sub	 esp, 8
  0002c	8b d4		 mov	 edx, esp
  0002e	51		 push	 ecx
  0002f	8b ca		 mov	 ecx, edx
  00031	e8 00 00 00 00	 call	 ??0SOL_Point@@QAE@ABV0@@Z ; SOL_Point::SOL_Point
  00036	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z ; SOL_Rect::Intersect
  0003e	85 c0		 test	 eax, eax
  00040	74 09		 je	 SHORT $L62787
  00042	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR -16+[ebp], 1
  00049	eb 07		 jmp	 SHORT $L62788
$L62787:
  0004b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR -16+[ebp], 0
$L62788:
  00052	8b 45 f0	 mov	 eax, DWORD PTR -16+[ebp]

; 278  : }

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
?Includes@SOL_Rect@@QAEHABV1@@Z ENDP			; SOL_Rect::Includes
_TEXT	ENDS
;	COMDAT ?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z
_TEXT	SEGMENT
_P$ = 8
_this$ = -4
?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z PROC NEAR	; SOL_Rect::Intersect, COMDAT

; 177  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 178  : 	if (P.x < A.x  ||  P.x > B.x)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _P$[ebp]
  0000d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000f	7c 0b		 jl	 SHORT $L897
  00011	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00014	8b 45 08	 mov	 eax, DWORD PTR _P$[ebp]
  00017	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  0001a	7e 04		 jle	 SHORT $L896
$L897:

; 179  : 		return False;

  0001c	33 c0		 xor	 eax, eax
  0001e	eb 1f		 jmp	 SHORT $L895
$L896:

; 180  : 	if (P.y < A.y  ||  P.y > B.y)

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 55 0c	 mov	 edx, DWORD PTR _P$[ebp+4]
  00026	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00029	7c 0b		 jl	 SHORT $L899
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _P$[ebp+4]
  00031	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00034	7e 04		 jle	 SHORT $L898
$L899:

; 181  : 		return False;

  00036	33 c0		 xor	 eax, eax
  00038	eb 05		 jmp	 SHORT $L895
$L898:

; 182  : 	return True;

  0003a	b8 01 00 00 00	 mov	 eax, 1
$L895:

; 183  : }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
?Intersect@SOL_Rect@@QBEHVSOL_Point@@@Z ENDP		; SOL_Rect::Intersect
_TEXT	ENDS
_TEXT	SEGMENT
_r$ = 8
_i$ = 12
_theirEraseList$ = 16
_this$ = -88
_rects$ = -84
_bigRect$ = -20
_newRects$ = -4
?UpdateTheirEraseList@SOL_Plane@@IAEXAAVSOL_Rect@@HAAVRectList@@@Z PROC NEAR ; SOL_Plane::UpdateTheirEraseList

; 1249 : {

  02e1a	55		 push	 ebp
  02e1b	8b ec		 mov	 ebp, esp
  02e1d	83 ec 58	 sub	 esp, 88			; 00000058H
  02e20	89 4d a8	 mov	 DWORD PTR _this$[ebp], ecx

; 1250 : 	// theirEraseList[i] will be removed from theirEraseList and whats 
; 1251 : 	// left of theirEraseList[i] after subtracting r will be added to 
; 1252 : 	// their erase list
; 1253 : 
; 1254 : 	SOL_Rect	rects[4];

  02e23	68 00 00 00 00	 push	 OFFSET FLAT:??0SOL_Rect@@QAE@XZ ; SOL_Rect::SOL_Rect
  02e28	6a 04		 push	 4
  02e2a	6a 10		 push	 16			; 00000010H
  02e2c	8d 45 ac	 lea	 eax, DWORD PTR _rects$[ebp]
  02e2f	50		 push	 eax
  02e30	e8 00 00 00 00	 call	 ??_H@YGXPAXIHP6EX0@Z@Z	; `vector constructor iterator'

; 1255 : 
; 1256 : 	SOL_Rect bigRect = theirEraseList[i];

  02e35	8b 4d 0c	 mov	 ecx, DWORD PTR _i$[ebp]
  02e38	51		 push	 ecx
  02e39	8b 4d 10	 mov	 ecx, DWORD PTR _theirEraseList$[ebp]
  02e3c	e8 00 00 00 00	 call	 ??ARectList@@QAEAAVSOL_Rect@@H@Z ; RectList::operator[]
  02e41	50		 push	 eax
  02e42	8d 4d ec	 lea	 ecx, DWORD PTR _bigRect$[ebp]
  02e45	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@ABV0@@Z ; SOL_Rect::SOL_Rect

; 1257 : 	int newRects = bigRect.Split(r,rects);

  02e4a	8d 55 ac	 lea	 edx, DWORD PTR _rects$[ebp]
  02e4d	52		 push	 edx
  02e4e	8b 45 08	 mov	 eax, DWORD PTR _r$[ebp]
  02e51	50		 push	 eax
  02e52	8d 4d ec	 lea	 ecx, DWORD PTR _bigRect$[ebp]
  02e55	e8 00 00 00 00	 call	 ?Split@SOL_Rect@@QAEHAAV1@PAV1@@Z ; SOL_Rect::Split
  02e5a	89 45 fc	 mov	 DWORD PTR _newRects$[ebp], eax
$L62304:

; 1258 : 	while (newRects--) {

  02e5d	8b 4d fc	 mov	 ecx, DWORD PTR _newRects$[ebp]
  02e60	8b 55 fc	 mov	 edx, DWORD PTR _newRects$[ebp]
  02e63	83 ea 01	 sub	 edx, 1
  02e66	89 55 fc	 mov	 DWORD PTR _newRects$[ebp], edx
  02e69	85 c9		 test	 ecx, ecx
  02e6b	74 15		 je	 SHORT $L62305

; 1259 : 		// Add to the theirEraseList
; 1260 : 		theirEraseList.Add(rects[newRects]);

  02e6d	8b 45 fc	 mov	 eax, DWORD PTR _newRects$[ebp]
  02e70	c1 e0 04	 shl	 eax, 4
  02e73	8d 4c 05 ac	 lea	 ecx, DWORD PTR _rects$[ebp+eax]
  02e77	51		 push	 ecx
  02e78	8b 4d 10	 mov	 ecx, DWORD PTR _theirEraseList$[ebp]
  02e7b	e8 00 00 00 00	 call	 ?Add@RectList@@QAEXABVSOL_Rect@@@Z ; RectList::Add

; 1261 : 	}

  02e80	eb db		 jmp	 SHORT $L62304
$L62305:

; 1262 : 	theirEraseList.Delete(i);

  02e82	8b 55 0c	 mov	 edx, DWORD PTR _i$[ebp]
  02e85	52		 push	 edx
  02e86	8b 4d 10	 mov	 ecx, DWORD PTR _theirEraseList$[ebp]
  02e89	e8 00 00 00 00	 call	 ?Delete@RectList@@QAEXH@Z ; RectList::Delete

; 1263 : }

  02e8e	8b e5		 mov	 esp, ebp
  02e90	5d		 pop	 ebp
  02e91	c2 0c 00	 ret	 12			; 0000000cH
?UpdateTheirEraseList@SOL_Plane@@IAEXAAVSOL_Rect@@HAAVRectList@@@Z ENDP ; SOL_Plane::UpdateTheirEraseList
_TEXT	ENDS
PUBLIC	?Type@Bitmap@@QBEHXZ				; Bitmap::Type
EXTRN	?Fatal@MsgMgr@@QAAXPADZZ:NEAR			; MsgMgr::Fatal
_DATA	SEGMENT
$SG62320 DB	'Picture screen item has been lost.  (%s)', 00H
_DATA	ENDS
_TEXT	SEGMENT
_this$ = -16
_siArraySize$62312 = -4
_picSI$62313 = -8
_i$62314 = -12
?CheckIntegrity@SOL_Plane@@QAEXXZ PROC NEAR		; SOL_Plane::CheckIntegrity

; 1266 : {

  02e94	55		 push	 ebp
  02e95	8b ec		 mov	 ebp, esp
  02e97	83 ec 10	 sub	 esp, 16			; 00000010H
  02e9a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1267 : 	if ( type == picturePlane || type == pictureSkipPlane )	{

  02e9d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  02ea0	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  02ea4	74 09		 je	 SHORT $L62311
  02ea6	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  02ea9	83 79 04 04	 cmp	 DWORD PTR [ecx+4], 4
  02ead	75 7e		 jne	 SHORT $L62310
$L62311:

; 1268 : 		int siArraySize = siArray.Length(), picSI = 0;

  02eaf	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  02eb2	83 c1 7c	 add	 ecx, 124		; 0000007cH
  02eb5	e8 00 00 00 00	 call	 ?Length@ScreenItemList@@QBEHXZ ; ScreenItemList::Length
  02eba	89 45 fc	 mov	 DWORD PTR _siArraySize$62312[ebp], eax
  02ebd	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _picSI$62313[ebp], 0

; 1269 : 
; 1270 : 		for (int i=0;i<siArraySize;++i) {

  02ec4	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$62314[ebp], 0
  02ecb	eb 09		 jmp	 SHORT $L62315
$L62316:
  02ecd	8b 55 f4	 mov	 edx, DWORD PTR _i$62314[ebp]
  02ed0	83 c2 01	 add	 edx, 1
  02ed3	89 55 f4	 mov	 DWORD PTR _i$62314[ebp], edx
$L62315:
  02ed6	8b 45 f4	 mov	 eax, DWORD PTR _i$62314[ebp]
  02ed9	3b 45 fc	 cmp	 eax, DWORD PTR _siArraySize$62312[ebp]
  02edc	7d 35		 jge	 SHORT $L62317

; 1271 : 			if (siArray.Exists(i)) {

  02ede	8b 4d f4	 mov	 ecx, DWORD PTR _i$62314[ebp]
  02ee1	51		 push	 ecx
  02ee2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  02ee5	83 c1 7c	 add	 ecx, 124		; 0000007cH
  02ee8	e8 00 00 00 00	 call	 ?Exists@ScreenItemList@@QBEHH@Z ; ScreenItemList::Exists
  02eed	85 c0		 test	 eax, eax
  02eef	74 20		 je	 SHORT $L62319

; 1272 : 				if ( siArray[i].bitmap.Type() == 1 )

  02ef1	8b 55 f4	 mov	 edx, DWORD PTR _i$62314[ebp]
  02ef4	52		 push	 edx
  02ef5	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  02ef8	83 c1 7c	 add	 ecx, 124		; 0000007cH
  02efb	e8 00 00 00 00	 call	 ??AScreenItemList@@QAEAAVScreenItem@@H@Z ; ScreenItemList::operator[]
  02f00	8b c8		 mov	 ecx, eax
  02f02	83 c1 0c	 add	 ecx, 12			; 0000000cH
  02f05	e8 00 00 00 00	 call	 ?Type@Bitmap@@QBEHXZ	; Bitmap::Type
  02f0a	83 f8 01	 cmp	 eax, 1
  02f0d	75 02		 jne	 SHORT $L62319

; 1273 : 					return;

  02f0f	eb 1c		 jmp	 SHORT $L62309
$L62319:

; 1275 : 		}

  02f11	eb ba		 jmp	 SHORT $L62316
$L62317:

; 1276 : 
; 1277 : 		msgMgr->Fatal ( "Picture screen item has been lost.  (%s)", gPlaneFatalStr );

  02f13	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gPlaneFatalStr@@3PADA ; gPlaneFatalStr
  02f18	50		 push	 eax
  02f19	68 00 00 00 00	 push	 OFFSET FLAT:$SG62320
  02f1e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?msgMgr@@3PAVMsgMgr@@A ; msgMgr
  02f24	51		 push	 ecx
  02f25	e8 00 00 00 00	 call	 ?Fatal@MsgMgr@@QAAXPADZZ ; MsgMgr::Fatal
  02f2a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L62310:
$L62309:

; 1279 : }

  02f2d	8b e5		 mov	 esp, ebp
  02f2f	5d		 pop	 ebp
  02f30	c3		 ret	 0
?CheckIntegrity@SOL_Plane@@QAEXXZ ENDP			; SOL_Plane::CheckIntegrity
_TEXT	ENDS
;	COMDAT ?Type@Bitmap@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Type@Bitmap@@QBEHXZ PROC NEAR				; Bitmap::Type, COMDAT

; 132  : 	int	Type() const			{return type;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?Type@Bitmap@@QBEHXZ ENDP				; Bitmap::Type
_TEXT	ENDS
xdata$x	SEGMENT
$T62796	DD	019930520H
	DD	01H
	DD	FLAT:$T62798
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T62798	DD	0ffffffffH
	DD	FLAT:$L62794
xdata$x	ENDS
_TEXT	SEGMENT
__$EHRec$ = -12
_r$ = 8
_myEraseList$ = 12
_j$ = -4020
_mergeRect$ = -4036
_mergeList$ = -4016
_myCount$62331 = -4044
_k$62332 = -4040
_eraseRect$62336 = -4060
_rects$62339 = -4128
_newRects$62341 = -4064
?MergeToRectList@@YAXABVSOL_Rect@@AAVRectList@@@Z PROC NEAR ; MergeToRectList

; 1283 : {

  02f31	55		 push	 ebp
  02f32	8b ec		 mov	 ebp, esp
  02f34	6a ff		 push	 -1
  02f36	68 00 00 00 00	 push	 $L62797
  02f3b	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  02f41	50		 push	 eax
  02f42	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  02f49	b8 14 10 00 00	 mov	 eax, 4116		; 00001014H
  02f4e	e8 00 00 00 00	 call	 __chkstk

; 1284 : 	int j;
; 1285 : 	SOL_Rect mergeRect = r;

  02f53	8b 45 08	 mov	 eax, DWORD PTR _r$[ebp]
  02f56	50		 push	 eax
  02f57	8d 8d 3c f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeRect$[ebp]
  02f5d	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@ABV0@@Z ; SOL_Rect::SOL_Rect

; 1286 : 	RectList mergeList;

  02f62	8d 8d 50 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeList$[ebp]
  02f68	e8 00 00 00 00	 call	 ??0RectList@@QAE@XZ	; RectList::RectList
  02f6d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1287 : 	mergeList.Add(mergeRect);

  02f74	8d 8d 3c f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeRect$[ebp]
  02f7a	51		 push	 ecx
  02f7b	8d 8d 50 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeList$[ebp]
  02f81	e8 00 00 00 00	 call	 ?Add@RectList@@QAEXABVSOL_Rect@@@Z ; RectList::Add

; 1288 : 	for (j = 0;j < mergeList.Length();++j) {

  02f86	c7 85 4c f0 ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$[ebp], 0
  02f90	eb 0f		 jmp	 SHORT $L62328
$L62329:
  02f92	8b 95 4c f0 ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  02f98	83 c2 01	 add	 edx, 1
  02f9b	89 95 4c f0 ff
	ff		 mov	 DWORD PTR _j$[ebp], edx
$L62328:
  02fa1	8d 8d 50 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeList$[ebp]
  02fa7	e8 00 00 00 00	 call	 ?Length@RectList@@QBEHXZ ; RectList::Length
  02fac	39 85 4c f0 ff
	ff		 cmp	 DWORD PTR _j$[ebp], eax
  02fb2	0f 8d 5e 01 00
	00		 jge	 $L62330

; 1289 : 		mergeRect = mergeList[j];

  02fb8	8b 85 4c f0 ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  02fbe	50		 push	 eax
  02fbf	8d 8d 50 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeList$[ebp]
  02fc5	e8 00 00 00 00	 call	 ??ARectList@@QAEAAVSOL_Rect@@H@Z ; RectList::operator[]
  02fca	50		 push	 eax
  02fcb	8d 8d 3c f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeRect$[ebp]
  02fd1	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=

; 1290 : 
; 1291 : 		int myCount = myEraseList.Length();

  02fd6	8b 4d 0c	 mov	 ecx, DWORD PTR _myEraseList$[ebp]
  02fd9	e8 00 00 00 00	 call	 ?Length@RectList@@QBEHXZ ; RectList::Length
  02fde	89 85 34 f0 ff
	ff		 mov	 DWORD PTR _myCount$62331[ebp], eax

; 1292 : 		for (int k = 0;k < myCount;++k) {

  02fe4	c7 85 38 f0 ff
	ff 00 00 00 00	 mov	 DWORD PTR _k$62332[ebp], 0
  02fee	eb 0f		 jmp	 SHORT $L62333
$L62334:
  02ff0	8b 8d 38 f0 ff
	ff		 mov	 ecx, DWORD PTR _k$62332[ebp]
  02ff6	83 c1 01	 add	 ecx, 1
  02ff9	89 8d 38 f0 ff
	ff		 mov	 DWORD PTR _k$62332[ebp], ecx
$L62333:
  02fff	8b 95 38 f0 ff
	ff		 mov	 edx, DWORD PTR _k$62332[ebp]
  03005	3b 95 34 f0 ff
	ff		 cmp	 edx, DWORD PTR _myCount$62331[ebp]
  0300b	0f 8d 00 01 00
	00		 jge	 $L62335

; 1293 : 			SOL_Rect eraseRect = myEraseList[k];

  03011	8b 85 38 f0 ff
	ff		 mov	 eax, DWORD PTR _k$62332[ebp]
  03017	50		 push	 eax
  03018	8b 4d 0c	 mov	 ecx, DWORD PTR _myEraseList$[ebp]
  0301b	e8 00 00 00 00	 call	 ??ARectList@@QAEAAVSOL_Rect@@H@Z ; RectList::operator[]
  03020	50		 push	 eax
  03021	8d 8d 24 f0 ff
	ff		 lea	 ecx, DWORD PTR _eraseRect$62336[ebp]
  03027	e8 00 00 00 00	 call	 ??0SOL_Rect@@QAE@ABV0@@Z ; SOL_Rect::SOL_Rect

; 1294 : 			if (eraseRect.Includes(mergeRect)) {

  0302c	8d 8d 3c f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeRect$[ebp]
  03032	51		 push	 ecx
  03033	8d 8d 24 f0 ff
	ff		 lea	 ecx, DWORD PTR _eraseRect$62336[ebp]
  03039	e8 00 00 00 00	 call	 ?Includes@SOL_Rect@@QAEHABV1@@Z ; SOL_Rect::Includes
  0303e	85 c0		 test	 eax, eax
  03040	74 17		 je	 SHORT $L62337

; 1295 : 				// Already being complety erased
; 1296 : 				mergeList.Delete(j);

  03042	8b 95 4c f0 ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  03048	52		 push	 edx
  03049	8d 8d 50 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeList$[ebp]
  0304f	e8 00 00 00 00	 call	 ?Delete@RectList@@QAEXH@Z ; RectList::Delete

; 1297 : 				break;

  03054	e9 b8 00 00 00	 jmp	 $L62335
$L62337:

; 1300 : 				// Check for being partly drawn
; 1301 : 				SOL_Rect rects[4];

  03059	68 00 00 00 00	 push	 OFFSET FLAT:??0SOL_Rect@@QAE@XZ ; SOL_Rect::SOL_Rect
  0305e	6a 04		 push	 4
  03060	6a 10		 push	 16			; 00000010H
  03062	8d 85 e0 ef ff
	ff		 lea	 eax, DWORD PTR _rects$62339[ebp]
  03068	50		 push	 eax
  03069	e8 00 00 00 00	 call	 ??_H@YGXPAXIHP6EX0@Z@Z	; `vector constructor iterator'

; 1302 : 				int newRects = mergeRect.Split(eraseRect,rects);

  0306e	8d 8d e0 ef ff
	ff		 lea	 ecx, DWORD PTR _rects$62339[ebp]
  03074	51		 push	 ecx
  03075	8d 95 24 f0 ff
	ff		 lea	 edx, DWORD PTR _eraseRect$62336[ebp]
  0307b	52		 push	 edx
  0307c	8d 8d 3c f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeRect$[ebp]
  03082	e8 00 00 00 00	 call	 ?Split@SOL_Rect@@QAEHAAV1@PAV1@@Z ; SOL_Rect::Split
  03087	89 85 20 f0 ff
	ff		 mov	 DWORD PTR _newRects$62341[ebp], eax

; 1303 : 				if (newRects != -1) {

  0308d	83 bd 20 f0 ff
	ff ff		 cmp	 DWORD PTR _newRects$62341[ebp], -1
  03094	74 76		 je	 SHORT $L62342
$L62344:

; 1304 : 					// Eliminate the merege rect and add new ones
; 1305 : 					while (newRects--) {

  03096	8b 85 20 f0 ff
	ff		 mov	 eax, DWORD PTR _newRects$62341[ebp]
  0309c	8b 8d 20 f0 ff
	ff		 mov	 ecx, DWORD PTR _newRects$62341[ebp]
  030a2	83 e9 01	 sub	 ecx, 1
  030a5	89 8d 20 f0 ff
	ff		 mov	 DWORD PTR _newRects$62341[ebp], ecx
  030ab	85 c0		 test	 eax, eax
  030ad	74 1e		 je	 SHORT $L62345

; 1306 : 						mergeList.Add(rects[newRects]);

  030af	8b 95 20 f0 ff
	ff		 mov	 edx, DWORD PTR _newRects$62341[ebp]
  030b5	c1 e2 04	 shl	 edx, 4
  030b8	8d 84 15 e0 ef
	ff ff		 lea	 eax, DWORD PTR _rects$62339[ebp+edx]
  030bf	50		 push	 eax
  030c0	8d 8d 50 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeList$[ebp]
  030c6	e8 00 00 00 00	 call	 ?Add@RectList@@QAEXABVSOL_Rect@@@Z ; RectList::Add

; 1307 : 					}

  030cb	eb c9		 jmp	 SHORT $L62344
$L62345:

; 1308 : 					mergeList.Delete(j);

  030cd	8b 8d 4c f0 ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  030d3	51		 push	 ecx
  030d4	8d 8d 50 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeList$[ebp]
  030da	e8 00 00 00 00	 call	 ?Delete@RectList@@QAEXH@Z ; RectList::Delete

; 1309 : 					mergeRect = mergeList[++j];

  030df	8b 95 4c f0 ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  030e5	83 c2 01	 add	 edx, 1
  030e8	89 95 4c f0 ff
	ff		 mov	 DWORD PTR _j$[ebp], edx
  030ee	8b 85 4c f0 ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  030f4	50		 push	 eax
  030f5	8d 8d 50 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeList$[ebp]
  030fb	e8 00 00 00 00	 call	 ??ARectList@@QAEAAVSOL_Rect@@H@Z ; RectList::operator[]
  03100	50		 push	 eax
  03101	8d 8d 3c f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeRect$[ebp]
  03107	e8 00 00 00 00	 call	 ??4SOL_Rect@@QAEAAV0@ABV0@@Z ; SOL_Rect::operator=
$L62342:

; 1312 : 		}

  0310c	e9 df fe ff ff	 jmp	 $L62334
$L62335:

; 1313 : 	}

  03111	e9 7c fe ff ff	 jmp	 $L62329
$L62330:

; 1314 : 	// Now add any thing left in the mergeList
; 1315 : 	mergeList.Pack();

  03116	8d 8d 50 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeList$[ebp]
  0311c	e8 00 00 00 00	 call	 ?Pack@RectList@@QAEHXZ	; RectList::Pack

; 1316 : 	for (j = 0;j < mergeList.Length();++j) {

  03121	c7 85 4c f0 ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$[ebp], 0
  0312b	eb 0f		 jmp	 SHORT $L62346
$L62347:
  0312d	8b 8d 4c f0 ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  03133	83 c1 01	 add	 ecx, 1
  03136	89 8d 4c f0 ff
	ff		 mov	 DWORD PTR _j$[ebp], ecx
$L62346:
  0313c	8d 8d 50 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeList$[ebp]
  03142	e8 00 00 00 00	 call	 ?Length@RectList@@QBEHXZ ; RectList::Length
  03147	39 85 4c f0 ff
	ff		 cmp	 DWORD PTR _j$[ebp], eax
  0314d	7d 1d		 jge	 SHORT $L62348

; 1317 : 		myEraseList.Add(mergeList[j]);

  0314f	8b 95 4c f0 ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  03155	52		 push	 edx
  03156	8d 8d 50 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeList$[ebp]
  0315c	e8 00 00 00 00	 call	 ??ARectList@@QAEAAVSOL_Rect@@H@Z ; RectList::operator[]
  03161	50		 push	 eax
  03162	8b 4d 0c	 mov	 ecx, DWORD PTR _myEraseList$[ebp]
  03165	e8 00 00 00 00	 call	 ?Add@RectList@@QAEXABVSOL_Rect@@@Z ; RectList::Add

; 1318 : 	}

  0316a	eb c1		 jmp	 SHORT $L62347
$L62348:

; 1319 : }

  0316c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  03173	8d 8d 50 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeList$[ebp]
  03179	e8 00 00 00 00	 call	 ??1RectList@@QAE@XZ	; RectList::~RectList
  0317e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  03181	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  03188	8b e5		 mov	 esp, ebp
  0318a	5d		 pop	 ebp
  0318b	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L62794:
  000ad	8d 8d 50 f0 ff
	ff		 lea	 ecx, DWORD PTR _mergeList$[ebp]
  000b3	e8 00 00 00 00	 call	 ??1RectList@@QAE@XZ	; RectList::~RectList
  000b8	c3		 ret	 0
$L62797:
  000b9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T62796
  000be	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?MergeToRectList@@YAXABVSOL_Rect@@AAVRectList@@@Z ENDP	; MergeToRectList
END
